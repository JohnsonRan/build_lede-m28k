diff --git a/feeds.conf.default b/feeds.conf.default
index 98dcb2aa..d3869573 100644
--- a/feeds.conf.default
+++ b/feeds.conf.default
@@ -1,8 +1,8 @@
-src-git packages https://github.com/coolsnowwolf/packages
+src-git packages https://github.com/openwrt/packages;openwrt-24.10
 #src-git luci https://github.com/coolsnowwolf/luci
 src-git luci https://github.com/coolsnowwolf/luci.git;openwrt-23.05
-src-git routing https://github.com/coolsnowwolf/routing
-src-git telephony https://github.com/coolsnowwolf/telephony.git
+src-git routing https://github.com/openwrt/routing;openwrt-24.10
+src-git telephony https://github.com/openwrt/telephony.git;openwrt-24.10
 #src-git helloworld https://github.com/fw876/helloworld.git
 #src-git oui https://github.com/zhaojh329/oui.git
 #src-git video https://github.com/openwrt/video.git
diff --git a/include/target.mk b/include/target.mk
index 64d0f394..660be3d2 100644
--- a/include/target.mk
+++ b/include/target.mk
@@ -267,6 +267,10 @@ ifeq ($(DUMP),1)
     CPU_CFLAGS := -O2 -pipe
     CPU_CFLAGS_generic:=-march=loongarch64
   endif
+  ifeq ($(BOARD),rockchip)
+    CPU_CFLAGS = -O3 -Wl,--gc-sections -pipe
+    CPU_CFLAGS_generic = -march=armv8-a+crc+crypto
+  endif
   ifneq ($(CPU_TYPE),)
     ifndef CPU_CFLAGS_$(CPU_TYPE)
       $(warning CPU_TYPE "$(CPU_TYPE)" doesn't correspond to a known type)
diff --git a/package/base-files/files/bin/config_generate b/package/base-files/files/bin/config_generate
index 52fd105f..da58ce63 100755
--- a/package/base-files/files/bin/config_generate
+++ b/package/base-files/files/bin/config_generate
@@ -147,7 +147,7 @@ generate_network() {
 		static)
 			local ipad
 			case "$1" in
-				lan) ipad=${ipaddr:-"192.168.1.1"} ;;
+				lan) ipad=${ipaddr:-"172.20.10.1"} ;;
 				*) ipad=${ipaddr:-"192.168.$((addr_offset++)).1"} ;;
 			esac
 
diff --git a/package/kernel/mac80211/Makefile b/package/kernel/mac80211/Makefile
index e2d4aeff..f924d346 100644
--- a/package/kernel/mac80211/Makefile
+++ b/package/kernel/mac80211/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright (C) 2007-2023 OpenWrt.org
+# Copyright (C) 2007-2015 OpenWrt.org
 #
 # This is free software, licensed under the GNU General Public License v2.
 # See /LICENSE for more information.
@@ -10,14 +10,16 @@ include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=mac80211
 
-PKG_VERSION:=6.1.24
-PKG_RELEASE:=3
-# PKG_SOURCE_URL:=@KERNEL/linux/kernel/projects/backports/stable/v5.15.58/
+PKG_VERSION:=6.12.6
+PKG_RELEASE:=1
+PKG_LICENSE:=GPL-2.0-only
+PKG_LICENSE_FILES:=COPYING
+
 PKG_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-PKG_HASH:=5d39aca7e34c33cb9b3e366117b2e86841b7bdd37933679d6b1e61be6b150648
+PKG_HASH:=28ec39425a1b3270e1422d92a8131a6a3d8919cc13e8ee250c315e55d922ba68
 
 PKG_SOURCE:=backports-$(PKG_VERSION).tar.xz
-PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/backports-$(PKG_VERSION)
+PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(if $(BUILD_VARIANT),$(PKG_NAME)-$(BUILD_VARIANT)/)backports-$(PKG_VERSION)
 PKG_BUILD_PARALLEL:=1
 
 PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
@@ -48,7 +50,13 @@ define KernelPackage/mac80211/Default
   MAINTAINER:=Felix Fietkau <nbd@nbd.name>
 endef
 
-config_package=$(if $(CONFIG_PACKAGE_kmod-$(1)),m)
+# config_pacakge:
+# 1 = OpenWrt KernelPackage name
+# 2 = Optional list of variants for which the module may be selected:
+#     If empty, the module is only selected with the first variant
+#     Use $(ALL_VARIANTS) to allow module selection in all variants
+config_package=$(if $(and $(CONFIG_PACKAGE_kmod-$(1)),$(call mac80211_variant_check,$(2))),m)
+mac80211_variant_check=$(if $(ALL_VARIANTS),$(filter $(BUILD_VARIANT),$(if $(1),$(1),$(firstword $(ALL_VARIANTS)))),y)
 
 config-y:= \
 	WLAN \
@@ -73,10 +81,10 @@ config-y:= \
 	WLAN_VENDOR_TI \
 	WLAN_VENDOR_ZYDAS \
 
-config-$(call config_package,cfg80211) += CFG80211
+config-$(call config_package,cfg80211,$(ALL_VARIANTS)) += CFG80211
 config-$(CONFIG_PACKAGE_CFG80211_TESTMODE) += NL80211_TESTMODE
 
-config-$(call config_package,mac80211) += MAC80211
+config-$(call config_package,mac80211,$(ALL_VARIANTS)) += MAC80211
 config-$(CONFIG_PACKAGE_MAC80211_MESH) += MAC80211_MESH
 
 include ath.mk
@@ -92,7 +100,7 @@ PKG_CONFIG_DEPENDS += \
 define KernelPackage/cfg80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=cfg80211 - wireless configuration API
-  DEPENDS+= +iw +iwinfo +wireless-regdb +USE_RFKILL:kmod-rfkill
+  DEPENDS+= +iw +iwinfo +wifi-scripts +wireless-regdb +USE_RFKILL:kmod-rfkill
   ABI_VERSION:=$(PKG_VERSION)-$(PKG_RELEASE)
   FILES:= \
 	$(PKG_BUILD_DIR)/compat/compat.ko \
@@ -163,8 +171,8 @@ endef
 define KernelPackage/mac80211-hwsim
   $(call KernelPackage/mac80211/Default)
   TITLE:=mac80211 HW simulation device
-  DEPENDS+= +kmod-mac80211 +@DRIVER_11AX_SUPPORT +@DRIVER_11AC_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mac80211_hwsim.ko
+  DEPENDS+= +kmod-mac80211 +@DRIVER_11BE_SUPPORT +@DRIVER_11AX_SUPPORT +@DRIVER_11AC_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/virtual/mac80211_hwsim.ko
   AUTOLOAD:=$(call AutoProbe,mac80211_hwsim)
 endef
 
@@ -180,7 +188,7 @@ endef
 define KernelPackage/rsi91x
   $(call KernelPackage/mac80211/Default)
   TITLE:=Redpine Signals Inc 91x WLAN driver support
-  DEPENDS+= +kmod-mac80211 +rs9113-firmware +@DRIVER_11N_SUPPORT
+  DEPENDS+= +kmod-mac80211 +rs9113-firmware
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rsi/rsi_91x.ko
 endef
 
@@ -204,7 +212,7 @@ endef
 define KernelPackage/wlcore
   $(call KernelPackage/mac80211/Default)
   TITLE:=TI common driver part
-  DEPENDS+= +kmod-mmc +kmod-mac80211 +@DRIVER_11N_SUPPORT
+  DEPENDS+= +kmod-mmc +kmod-mac80211
   FILES:= \
 	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore.ko \
 	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore_sdio.ko
@@ -325,7 +333,6 @@ endif
 ifeq ($(strip $(CONFIG_EXTERNAL_KERNEL_TREE)),"")
   ifeq ($(strip $(CONFIG_KERNEL_GIT_CLONE_URI)),"")
     define Build/Configure
-	  cmp $(PKG_BUILD_DIR)/include/linux/ath9k_platform.h $(LINUX_DIR)/include/linux/ath9k_platform.h
 	  cmp $(PKG_BUILD_DIR)/include/linux/ath5k_platform.h $(LINUX_DIR)/include/linux/ath5k_platform.h
 	  cmp $(PKG_BUILD_DIR)/include/linux/rt2x00_platform.h $(LINUX_DIR)/include/linux/rt2x00_platform.h
     endef
@@ -341,6 +348,7 @@ define Build/Patch
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath9k,ath9k/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath10k,ath10k/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath11k,ath11k/)
+	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath12k,ath12k/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/rt2x00,rt2x00/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/mt7601u,mt7601u/)
 	$(call PatchDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/mwl,mwl/)
@@ -357,6 +365,7 @@ define Quilt/Refresh/Package
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath9k,ath9k/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath10k,ath10k/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath11k,ath11k/)
+	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/ath12k,ath12k/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/rt2x00,rt2x00/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/mt7601u,mt7601u/)
 	$(call Quilt/RefreshDir,$(PKG_BUILD_DIR),$(PATCH_DIR)/mwl,mwl/)
@@ -384,14 +393,6 @@ define Build/InstallDev
 endef
 
 
-define KernelPackage/cfg80211/install
-	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless
-	$(INSTALL_DATA) ./files/lib/wifi/mac80211.sh $(1)/lib/wifi
-	$(INSTALL_BIN) ./files/lib/netifd/wireless/mac80211.sh $(1)/lib/netifd/wireless
-	$(INSTALL_DIR) $(1)/etc/hotplug.d/ieee80211
-	$(INSTALL_DATA) ./files/mac80211.hotplug $(1)/etc/hotplug.d/ieee80211/10-wifi-detect
-endef
-
 $(eval $(foreach drv,$(PKG_DRIVERS),$(call KernelPackage,$(drv))))
 $(eval $(call KernelPackage,cfg80211))
 $(eval $(call KernelPackage,mac80211))
diff --git a/package/kernel/mac80211/ath.mk b/package/kernel/mac80211/ath.mk
index f0229696..5b13b6aa 100644
--- a/package/kernel/mac80211/ath.mk
+++ b/package/kernel/mac80211/ath.mk
@@ -1,7 +1,6 @@
 PKG_DRIVERS += \
-	ath ath5k ath6kl ath6kl-sdio ath6kl-usb ath9k ath9k-common ath9k-htc \
-	ath10k ath10k-pci ath10k-sdio ath10k-smallbuffers ath11k ath11k-ahb \
-	ath11k-pci ar5523 carl9170 owl-loader wil6210 qcom-qmi-helpers
+	ath ath5k ath6kl ath6kl-sdio ath6kl-usb ath9k ath9k-common ath9k-htc ath10k ath10k-smallbuffers \
+	ath11k ath11k-ahb ath11k-pci ath12k carl9170 owl-loader ar5523 wil6210 qcom-qmi-helpers
 
 PKG_CONFIG_DEPENDS += \
 	CONFIG_PACKAGE_ATH_DEBUG \
@@ -22,6 +21,7 @@ ifdef CONFIG_PACKAGE_MAC80211_DEBUGFS
 	ATH9K_HTC_DEBUGFS \
 	ATH10K_DEBUGFS \
 	ATH11K_DEBUGFS \
+	ATH12K_DEBUGFS \
 	CARL9170_DEBUGFS \
 	ATH5K_DEBUG \
 	ATH6KL_DEBUG \
@@ -32,6 +32,7 @@ ifdef CONFIG_PACKAGE_MAC80211_TRACING
   config-y += \
 	ATH10K_TRACING \
 	ATH11K_TRACING \
+	ATH12K_TRACING \
 	ATH6KL_TRACING \
 	ATH_TRACEPOINTS \
 	ATH5K_TRACER \
@@ -39,8 +40,8 @@ ifdef CONFIG_PACKAGE_MAC80211_TRACING
 endif
 
 config-$(call config_package,qcom-qmi-helpers) += QCOM_QMI_HELPERS
-config-$(call config_package,ath) += ATH_CARDS ATH_COMMON
-config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG ATH10K_DEBUG ATH11K_DEBUG ATH9K_STATION_STATISTICS
+config-$(call config_package,ath,regular smallbuffers) += ATH_CARDS ATH_COMMON
+config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG ATH10K_DEBUG ATH11K_DEBUG ATH12K_DEBUG ATH9K_STATION_STATISTICS
 config-$(CONFIG_PACKAGE_ATH_DFS) += ATH9K_DFS_CERTIFIED ATH10K_DFS_CERTIFIED
 config-$(CONFIG_PACKAGE_ATH_SPECTRAL) += ATH9K_COMMON_SPECTRAL ATH10K_SPECTRAL ATH11K_SPECTRAL
 config-$(CONFIG_PACKAGE_ATH_DYNACK) += ATH9K_DYNACK
@@ -60,21 +61,14 @@ config-$(CONFIG_ATH10K_THERMAL) += ATH10K_THERMAL
 config-$(CONFIG_ATH11K_THERMAL) += ATH11K_THERMAL
 
 config-$(call config_package,ath9k-htc) += ATH9K_HTC
-config-$(call config_package,ath10k) += ATH10K
-config-$(call config_package,ath10k-pci) += ATH10K_PCI
-config-$(call config_package,ath10k-sdio) += ATH10K_SDIO
-config-$(call config_package,ath10k-smallbuffers) += ATH10K ATH10K_PCI ATH10K_SMALLBUFFERS
-
+config-$(call config_package,ath10k,regular) += ATH10K ATH10K_PCI
+config-$(call config_package,ath10k-smallbuffers,smallbuffers) += ATH10K ATH10K_PCI ATH10K_SMALLBUFFERS
 config-$(call config_package,ath11k) += ATH11K
 config-$(call config_package,ath11k-ahb) += ATH11K_AHB
 config-$(call config_package,ath11k-pci) += ATH11K_PCI
+config-$(call config_package,ath12k) += ATH12K
 
-config-$(call config_package,ath5k) += ATH5K
-ifdef CONFIG_TARGET_ath25
-  config-y += ATH5K_AHB
-else
-  config-y += ATH5K_PCI
-endif
+config-$(call config_package,ath5k) += ATH5K ATH5K_PCI
 
 config-$(call config_package,ath6kl) += ATH6KL
 config-$(call config_package,ath6kl-sdio) += ATH6KL_SDIO
@@ -85,14 +79,6 @@ config-$(call config_package,ar5523) += AR5523
 
 config-$(call config_package,wil6210) += WIL6210
 
-define KernelPackage/qcom-qmi-helpers
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Qualcomm QMI backports helpers
-  HIDDEN:=1
-  FILES:=$(PKG_BUILD_DIR)/drivers/soc/qcom/qmi_helpers.ko
-  AUTOLOAD:=$(call AutoProbe,qmi_helpers)
-endef
-
 define KernelPackage/ath/config
   if PACKAGE_kmod-ath
 	config ATH_USER_REGD
@@ -143,10 +129,18 @@ define KernelPackage/ath/config
   endif
 endef
 
+define KernelPackage/qcom-qmi-helpers
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Qualcomm QMI backports helpers
+  HIDDEN:=1
+  FILES:=$(PKG_BUILD_DIR)/drivers/soc/qcom/qmi_helpers.ko
+  AUTOLOAD:=$(call AutoProbe,qmi_helpers)
+endef
+
 define KernelPackage/ath
   $(call KernelPackage/mac80211/Default)
   TITLE:=Atheros common driver part
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ath79||TARGET_ath25 +kmod-mac80211
+  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ath79 +kmod-mac80211
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath.ko
   MENU:=1
 endef
@@ -159,7 +153,7 @@ define KernelPackage/ath5k
   $(call KernelPackage/mac80211/Default)
   TITLE:=Atheros 5xxx wireless cards support
   URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath5k
-  DEPENDS+= @(PCI_SUPPORT||TARGET_ath25) +kmod-ath
+  DEPENDS+= @PCI_SUPPORT +kmod-ath
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath5k/ath5k.ko
   AUTOLOAD:=$(call AutoProbe,ath5k)
 endef
@@ -174,7 +168,7 @@ define KernelPackage/ath6kl
   TITLE:=Atheros FullMAC wireless devices (common code for ath6kl_sdio and ath6kl_usb)
   URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath6kl
   HIDDEN:=1
-  DEPENDS+= +kmod-ath +@DRIVER_11N_SUPPORT
+  DEPENDS+= +kmod-ath
   FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath6kl/ath6kl_core.ko
 endef
 
@@ -275,17 +269,20 @@ define KernelPackage/ath10k
   $(call KernelPackage/mac80211/Default)
   TITLE:=Atheros 802.11ac wireless cards support
   URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath10k
-  DEPENDS+= +kmod-ath +@DRIVER_11N_SUPPORT +@DRIVER_11AC_SUPPORT \
+  DEPENDS+= @PCI_SUPPORT +kmod-ath +@DRIVER_11AC_SUPPORT \
 	+ATH10K_THERMAL:kmod-hwmon-core +ATH10K_THERMAL:kmod-thermal
   FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_core.ko
-  AUTOLOAD:=$(call AutoProbe,ath10k_core)
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_core.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_pci.ko
+  AUTOLOAD:=$(call AutoProbe,ath10k_core ath10k_pci)
   MODPARAMS.ath10k_core:=frame_mode=2
+  VARIANT:=regular
 endef
 
 define KernelPackage/ath10k/description
 This module adds support for wireless adapters based on
-Atheros IEEE 802.11ac family of chipsets.
+Atheros IEEE 802.11ac family of chipsets. For now only
+PCI is supported.
 endef
 
 define KernelPackage/ath10k/config
@@ -297,42 +294,12 @@ define KernelPackage/ath10k/config
 
        config ATH10K_THERMAL
                bool "Enable thermal sensors and throttling support"
-               default y
                depends on PACKAGE_kmod-ath10k || PACKAGE_kmod-ath10k-smallbuffers
 
 endef
 
-define KernelPackage/ath10k-pci
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11ac PCIE wireless cards support
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath10k
-  DEPENDS+= @PCI_SUPPORT kmod-ath10k
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_pci.ko
-  AUTOLOAD:=$(call AutoProbe,ath10k_pci)
-  VARIANT:=regular
-endef
-
-define KernelPackage/ath10k-pci/description
-This module adds support for wireless adapters based on
-Atheros IEEE 802.11ac family of chipsets with PCIE bus.
-endef
-
-define KernelPackage/ath10k-sdio
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11ac SDIO wireless cards support
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath10k
-  DEPENDS+= kmod-ath10k +kmod-mmc
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_sdio.ko
-  AUTOLOAD:=$(call AutoProbe,ath10k_sdio)
-endef
-
-define KernelPackage/ath10k-sdio/description
-This module adds support for wireless adapters based on
-Atheros IEEE 802.11ac family of chipsets with SDIO bus.
-endef
-
 define KernelPackage/ath10k-smallbuffers
-  $(call KernelPackage/ath10k-pci)
+  $(call KernelPackage/ath10k)
   TITLE+= (small buffers for low-RAM devices)
   VARIANT:=smallbuffers
 endef
@@ -345,7 +312,6 @@ define KernelPackage/ath11k
   +kmod-crypto-michael-mic +ATH11K_THERMAL:kmod-hwmon-core \
   +ATH11K_THERMAL:kmod-thermal +kmod-qcom-qmi-helpers
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath11k/ath11k.ko
-  MODPARAMS.ath11k:=frame_mode=2
 endef
 
 define KernelPackage/ath11k/description
@@ -390,6 +356,22 @@ This module adds support for Qualcomm Technologies 802.11ax family of
 chipsets with PCI bus.
 endef
 
+define KernelPackage/ath12k
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Qualcomm 802.11be wireless chipset support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath12k
+  DEPENDS+= @PCI_SUPPORT +kmod-ath +@DRIVER_11AC_SUPPORT +@DRIVER_11AX_SUPPORT \
+  +kmod-crypto-michael-mic +kmod-qrtr-mhi \
+  +kmod-qcom-qmi-helpers +@DRIVER_11BE_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath12k/ath12k.ko
+  AUTOLOAD:=$(call AutoProbe,ath12k)
+endef
+
+define KernelPackage/ath12k/description
+This module adds support for Qualcomm Technologies 802.11be family of
+chipsets with PCI bus.
+endef
+
 define KernelPackage/carl9170
   $(call KernelPackage/mac80211/Default)
   TITLE:=Driver for Atheros AR9170 USB sticks
diff --git a/package/kernel/mac80211/broadcom.mk b/package/kernel/mac80211/broadcom.mk
index a36f9247..444d705a 100644
--- a/package/kernel/mac80211/broadcom.mk
+++ b/package/kernel/mac80211/broadcom.mk
@@ -245,11 +245,11 @@ config PACKAGE_B43_USE_BCMA
 		  This allows choosing buses that b43 should support.
 
 	config PACKAGE_B43_BUSES_BCMA_AND_SSB
-		depends on !TARGET_bcm47xx_legacy && !TARGET_bcm47xx_mips74k && !TARGET_bcm53xx
+		depends on !TARGET_bcm47xx_legacy && !TARGET_bcm47xx_mips74k && !TARGET_bcm53xx && !TARGET_bmips
 		bool "BCMA and SSB"
 
 	config PACKAGE_B43_BUSES_BCMA
-		depends on !TARGET_bcm47xx_legacy
+		depends on !TARGET_bcm47xx_legacy && !TARGET_bmips_bcm6358 && !TARGET_bmips_bcm6368
 		bool "BCMA only"
 
 	config PACKAGE_B43_BUSES_SSB
@@ -416,7 +416,10 @@ define KernelPackage/brcmfmac
   DEPENDS+= @USB_SUPPORT +kmod-cfg80211 +@DRIVER_11AC_SUPPORT \
   	+kmod-brcmutil +BRCMFMAC_SDIO:kmod-mmc @!TARGET_uml \
 	+BRCMFMAC_USB:kmod-usb-core +BRCMFMAC_USB:brcmfmac-firmware-usb
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/brcm80211/brcmfmac/brcmfmac.ko
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/brcm80211/brcmfmac/brcmfmac.ko \
+	$(foreach type,bca cyw wcc, \
+		$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/brcm80211/brcmfmac/$(type)/brcmfmac-$(type).ko)
   AUTOLOAD:=$(call AutoProbe,brcmfmac)
 endef
 
@@ -430,9 +433,11 @@ define KernelPackage/brcmfmac/config
 	config BRCMFMAC_SDIO
 		bool "Enable SDIO bus interface support"
 		default y if TARGET_bcm27xx
-		default y if TARGET_sunxi
+		default y if TARGET_imx_cortexa7
+		default y if TARGET_starfive
 		default y if TARGET_rockchip
-		default y if TARGET_amlogic
+		default y if TARGET_sunxi
+		default y if TARGET_stm32
 		default n
 		help
 		  Enable support for cards attached to an SDIO bus.
diff --git a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
deleted file mode 100644
index 469d4264..00000000
--- a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
+++ /dev/null
@@ -1,1244 +0,0 @@
-#!/bin/sh
-. /lib/netifd/netifd-wireless.sh
-. /lib/netifd/hostapd.sh
-. /lib/functions/system.sh
-
-init_wireless_driver "$@"
-
-MP_CONFIG_INT="mesh_retry_timeout mesh_confirm_timeout mesh_holding_timeout mesh_max_peer_links
-	       mesh_max_retries mesh_ttl mesh_element_ttl mesh_hwmp_max_preq_retries
-	       mesh_path_refresh_time mesh_min_discovery_timeout mesh_hwmp_active_path_timeout
-	       mesh_hwmp_preq_min_interval mesh_hwmp_net_diameter_traversal_time mesh_hwmp_rootmode
-	       mesh_hwmp_rann_interval mesh_gate_announcements mesh_sync_offset_max_neighor
-	       mesh_rssi_threshold mesh_hwmp_active_path_to_root_timeout mesh_hwmp_root_interval
-	       mesh_hwmp_confirmation_interval mesh_awake_window mesh_plink_timeout"
-MP_CONFIG_BOOL="mesh_auto_open_plinks mesh_fwding"
-MP_CONFIG_STRING="mesh_power_mode"
-
-NEWAPLIST=
-OLDAPLIST=
-NEWSPLIST=
-OLDSPLIST=
-NEWUMLIST=
-OLDUMLIST=
-
-drv_mac80211_init_device_config() {
-	hostapd_common_add_device_config
-
-	config_add_string path phy 'macaddr:macaddr'
-	config_add_string tx_burst
-	config_add_string distance
-	config_add_int beacon_int chanbw frag rts
-	config_add_int rxantenna txantenna antenna_gain txpower min_tx_power
-	config_add_boolean noscan ht_coex acs_exclude_dfs background_radar
-	config_add_array ht_capab
-	config_add_array channels
-	config_add_array scan_list
-	config_add_boolean \
-		rxldpc \
-		short_gi_80 \
-		short_gi_160 \
-		tx_stbc_2by1 \
-		su_beamformer \
-		su_beamformee \
-		mu_beamformer \
-		mu_beamformee \
-		he_su_beamformer \
-		he_su_beamformee \
-		he_mu_beamformer \
-		vht_txop_ps \
-		htc_vht \
-		rx_antenna_pattern \
-		tx_antenna_pattern \
-		he_spr_sr_control \
-		he_spr_psr_enabled \
-		he_bss_color_enabled \
-		he_twt_required
-	config_add_int \
-		beamformer_antennas \
-		beamformee_antennas \
-		vht_max_a_mpdu_len_exp \
-		vht_max_mpdu \
-		vht_link_adapt \
-		vht160 \
-		rx_stbc \
-		tx_stbc \
-		he_bss_color \
-		he_spr_non_srg_obss_pd_max_offset
-	config_add_boolean \
-		ldpc \
-		greenfield \
-		short_gi_20 \
-		short_gi_40 \
-		max_amsdu \
-		dsss_cck_40
-}
-
-drv_mac80211_init_iface_config() {
-	hostapd_common_add_bss_config
-
-	config_add_string 'macaddr:macaddr' ifname
-
-	config_add_boolean wds powersave enable
-	config_add_string wds_bridge
-	config_add_int maxassoc
-	config_add_int max_listen_int
-	config_add_int dtim_period
-	config_add_int start_disabled
-
-	# mesh
-	config_add_string mesh_id
-	config_add_int $MP_CONFIG_INT
-	config_add_boolean $MP_CONFIG_BOOL
-	config_add_string $MP_CONFIG_STRING
-}
-
-mac80211_add_capabilities() {
-	local __var="$1"; shift
-	local __mask="$1"; shift
-	local __out= oifs
-
-	oifs="$IFS"
-	IFS=:
-	for capab in "$@"; do
-		set -- $capab
-
-		[ "$(($4))" -gt 0 ] || continue
-		[ "$(($__mask & $2))" -eq "$((${3:-$2}))" ] || continue
-		__out="$__out[$1]"
-	done
-	IFS="$oifs"
-
-	export -n -- "$__var=$__out"
-}
-
-mac80211_add_he_capabilities() {
-	local __out= oifs
-
-	oifs="$IFS"
-	IFS=:
-	for capab in "$@"; do
-		set -- $capab
-		[ "$(($4))" -gt 0 ] || continue
-		[ "$(((0x$2) & $3))" -gt 0 ] || {
-			eval "$1=0"
-			continue
-		}
-		append base_cfg "$1=1" "$N"
-	done
-	IFS="$oifs"
-}
-
-mac80211_hostapd_setup_base() {
-	local phy="$1"
-
-	json_select config
-
-	[ "$auto_channel" -gt 0 ] && channel=acs_survey
-
-	[ "$auto_channel" -gt 0 ] && json_get_vars acs_exclude_dfs
-	[ -n "$acs_exclude_dfs" ] && [ "$acs_exclude_dfs" -gt 0 ] &&
-		append base_cfg "acs_exclude_dfs=1" "$N"
-
-	json_get_vars noscan ht_coex vendor_vht min_tx_power:0
-	json_get_values ht_capab_list ht_capab tx_burst
-	json_get_values channel_list channels
-
-	[ "$auto_channel" = 0 ] && [ -z "$channel_list" ] && \
-		channel_list="$channel"
-
-	[ "$min_tx_power" -gt 0 ] && append base_cfg "min_tx_power=$min_tx_power"
-
-	set_default noscan 0
-
-	[ "$noscan" -gt 0 ] && hostapd_noscan=1
-	[ "$tx_burst" = 0 ] && tx_burst=
-
-	chan_ofs=0
-	[ "$band" = "6g" ] && chan_ofs=1
-
-	ieee80211n=1
-	ht_capab=
-	case "$htmode" in
-		VHT20|HT20|HE20) ;;
-		HT40*|VHT40|VHT80|VHT160|HE40|HE80|HE160)
-			case "$hwmode" in
-				a)
-					case "$(( (($channel / 4) + $chan_ofs) % 2 ))" in
-						1) ht_capab="[HT40+]";;
-						0) ht_capab="[HT40-]";;
-					esac
-				;;
-				*)
-					case "$htmode" in
-						HT40+) ht_capab="[HT40+]";;
-						HT40-) ht_capab="[HT40-]";;
-						*)
-							if [ "$channel" -lt 7 ]; then
-								ht_capab="[HT40+]"
-							else
-								ht_capab="[HT40-]"
-							fi
-						;;
-					esac
-				;;
-			esac
-			[ "$auto_channel" -gt 0 ] && ht_capab="[HT40+]"
-		;;
-		*) ieee80211n= ;;
-	esac
-
-	[ -n "$ieee80211n" ] && {
-		append base_cfg "ieee80211n=1" "$N"
-
-		set_default ht_coex 0
-		append base_cfg "ht_coex=$ht_coex" "$N"
-
-		json_get_vars \
-			ldpc:1 \
-			greenfield:0 \
-			short_gi_20:1 \
-			short_gi_40:1 \
-			tx_stbc:1 \
-			rx_stbc:3 \
-			max_amsdu:1 \
-			dsss_cck_40:1
-
-		ht_cap_mask=0
-		for cap in $(iw phy "$phy" info | grep 'Capabilities:' | cut -d: -f2); do
-			ht_cap_mask="$(($ht_cap_mask | $cap))"
-		done
-
-		cap_rx_stbc=$((($ht_cap_mask >> 8) & 3))
-		[ "$rx_stbc" -lt "$cap_rx_stbc" ] && cap_rx_stbc="$rx_stbc"
-		ht_cap_mask="$(( ($ht_cap_mask & ~(0x300)) | ($cap_rx_stbc << 8) ))"
-
-		mac80211_add_capabilities ht_capab_flags $ht_cap_mask \
-			LDPC:0x1::$ldpc \
-			GF:0x10::$greenfield \
-			SHORT-GI-20:0x20::$short_gi_20 \
-			SHORT-GI-40:0x40::$short_gi_40 \
-			TX-STBC:0x80::$tx_stbc \
-			RX-STBC1:0x300:0x100:1 \
-			RX-STBC12:0x300:0x200:1 \
-			RX-STBC123:0x300:0x300:1 \
-			MAX-AMSDU-7935:0x800::$max_amsdu \
-			DSSS_CCK-40:0x1000::$dsss_cck_40
-
-		ht_capab="$ht_capab$ht_capab_flags"
-		[ -n "$ht_capab" ] && append base_cfg "ht_capab=$ht_capab" "$N"
-	}
-
-	# 802.11ac
-	enable_ac=0
-	vht_oper_chwidth=0
-	vht_center_seg0=
-
-	idx="$channel"
-	case "$htmode" in
-		VHT20|HE20) enable_ac=1;;
-		VHT40|HE40)
-			case "$(( (($channel / 4) + $chan_ofs) % 2 ))" in
-				1) idx=$(($channel + 2));;
-				0) idx=$(($channel - 2));;
-			esac
-			enable_ac=1
-			vht_center_seg0=$idx
-		;;
-		VHT80|HE80)
-			case "$(( (($channel / 4) + $chan_ofs) % 4 ))" in
-				1) idx=$(($channel + 6));;
-				2) idx=$(($channel + 2));;
-				3) idx=$(($channel - 2));;
-				0) idx=$(($channel - 6));;
-			esac
-			enable_ac=1
-			vht_oper_chwidth=1
-			vht_center_seg0=$idx
-		;;
-		VHT160|HE160)
-			if [ "$band" = "6g" ]; then
-				case "$channel" in
-					1|5|9|13|17|21|25|29) idx=15;;
-					33|37|41|45|49|53|57|61) idx=47;;
-					65|69|73|77|81|85|89|93) idx=79;;
-					97|101|105|109|113|117|121|125) idx=111;;
-					129|133|137|141|145|149|153|157) idx=143;;
-					161|165|169|173|177|181|185|189) idx=175;;
-					193|197|201|205|209|213|217|221) idx=207;;
-				esac
-			else
-				case "$channel" in
-					36|40|44|48|52|56|60|64) idx=50;;
-					100|104|108|112|116|120|124|128) idx=114;;
-				esac
-			fi
-			enable_ac=1
-			vht_oper_chwidth=2
-			vht_center_seg0=$idx
-		;;
-	esac
-	[ "$band" = "5g" ] && {
-		json_get_vars background_radar:0
-
-		[ "$background_radar" -eq 1 ] && append base_cfg "enable_background_radar=1" "$N"
-	}
-	[ "$band" = "6g" ] && {
-		op_class=
-		case "$htmode" in
-			HE20) op_class=131;;
-			HE*) op_class=$((132 + $vht_oper_chwidth))
-		esac
-		[ -n "$op_class" ] && append base_cfg "op_class=$op_class" "$N"
-	}
-	[ "$hwmode" = "a" ] || enable_ac=0
-
-	if [ "$enable_ac" != "0" -o "$vendor_vht" = "1" ]; then
-		json_get_vars \
-			rxldpc:1 \
-			short_gi_80:1 \
-			short_gi_160:1 \
-			tx_stbc_2by1:1 \
-			su_beamformer:1 \
-			su_beamformee:1 \
-			mu_beamformer:1 \
-			mu_beamformee:1 \
-			vht_txop_ps:1 \
-			htc_vht:1 \
-			beamformee_antennas:4 \
-			beamformer_antennas:4 \
-			rx_antenna_pattern:1 \
-			tx_antenna_pattern:1 \
-			vht_max_a_mpdu_len_exp:7 \
-			vht_max_mpdu:11454 \
-			rx_stbc:4 \
-			vht_link_adapt:3 \
-			vht160:2
-
-		set_default tx_burst 2.0
-		append base_cfg "ieee80211ac=1" "$N"
-		vht_cap=0
-		for cap in $(iw phy "$phy" info | awk -F "[()]" '/VHT Capabilities/ { print $2 }'); do
-			vht_cap="$(($vht_cap | $cap))"
-		done
-
-		append base_cfg "vht_oper_chwidth=$vht_oper_chwidth" "$N"
-		append base_cfg "vht_oper_centr_freq_seg0_idx=$vht_center_seg0" "$N"
-
-		cap_rx_stbc=$((($vht_cap >> 8) & 7))
-		[ "$rx_stbc" -lt "$cap_rx_stbc" ] && cap_rx_stbc="$rx_stbc"
-		vht_cap="$(( ($vht_cap & ~(0x700)) | ($cap_rx_stbc << 8) ))"
-
-		mac80211_add_capabilities vht_capab $vht_cap \
-			RXLDPC:0x10::$rxldpc \
-			SHORT-GI-80:0x20::$short_gi_80 \
-			SHORT-GI-160:0x40::$short_gi_160 \
-			TX-STBC-2BY1:0x80::$tx_stbc_2by1 \
-			SU-BEAMFORMER:0x800::$su_beamformer \
-			SU-BEAMFORMEE:0x1000::$su_beamformee \
-			MU-BEAMFORMER:0x80000::$mu_beamformer \
-			MU-BEAMFORMEE:0x100000::$mu_beamformee \
-			VHT-TXOP-PS:0x200000::$vht_txop_ps \
-			HTC-VHT:0x400000::$htc_vht \
-			RX-ANTENNA-PATTERN:0x10000000::$rx_antenna_pattern \
-			TX-ANTENNA-PATTERN:0x20000000::$tx_antenna_pattern \
-			RX-STBC-1:0x700:0x100:1 \
-			RX-STBC-12:0x700:0x200:1 \
-			RX-STBC-123:0x700:0x300:1 \
-			RX-STBC-1234:0x700:0x400:1 \
-
-		[ "$(($vht_cap & 0x800))" -gt 0 -a "$su_beamformer" -gt 0 ] && {
-			cap_ant="$(( ( ($vht_cap >> 16) & 3 ) + 1 ))"
-			[ "$cap_ant" -gt "$beamformer_antennas" ] && cap_ant="$beamformer_antennas"
-			[ "$cap_ant" -gt 1 ] && vht_capab="$vht_capab[SOUNDING-DIMENSION-$cap_ant]"
-		}
-
-		[ "$(($vht_cap & 0x1000))" -gt 0 -a "$su_beamformee" -gt 0 ] && {
-			cap_ant="$(( ( ($vht_cap >> 13) & 3 ) + 1 ))"
-			[ "$cap_ant" -gt "$beamformee_antennas" ] && cap_ant="$beamformee_antennas"
-			[ "$cap_ant" -gt 1 ] && vht_capab="$vht_capab[BF-ANTENNA-$cap_ant]"
-		}
-
-		# supported Channel widths
-		vht160_hw=0
-		[ "$(($vht_cap & 12))" -eq 4 -a 1 -le "$vht160" ] && \
-			vht160_hw=1
-		[ "$(($vht_cap & 12))" -eq 8 -a 2 -le "$vht160" ] && \
-			vht160_hw=2
-		[ "$vht160_hw" = 1 ] && vht_capab="$vht_capab[VHT160]"
-		[ "$vht160_hw" = 2 ] && vht_capab="$vht_capab[VHT160-80PLUS80]"
-
-		# maximum MPDU length
-		vht_max_mpdu_hw=3895
-		[ "$(($vht_cap & 3))" -ge 1 -a 7991 -le "$vht_max_mpdu" ] && \
-			vht_max_mpdu_hw=7991
-		[ "$(($vht_cap & 3))" -ge 2 -a 11454 -le "$vht_max_mpdu" ] && \
-			vht_max_mpdu_hw=11454
-		[ "$vht_max_mpdu_hw" != 3895 ] && \
-			vht_capab="$vht_capab[MAX-MPDU-$vht_max_mpdu_hw]"
-
-		# maximum A-MPDU length exponent
-		vht_max_a_mpdu_len_exp_hw=0
-		[ "$(($vht_cap & 58720256))" -ge 8388608 -a 1 -le "$vht_max_a_mpdu_len_exp" ] && \
-			vht_max_a_mpdu_len_exp_hw=1
-		[ "$(($vht_cap & 58720256))" -ge 16777216 -a 2 -le "$vht_max_a_mpdu_len_exp" ] && \
-			vht_max_a_mpdu_len_exp_hw=2
-		[ "$(($vht_cap & 58720256))" -ge 25165824 -a 3 -le "$vht_max_a_mpdu_len_exp" ] && \
-			vht_max_a_mpdu_len_exp_hw=3
-		[ "$(($vht_cap & 58720256))" -ge 33554432 -a 4 -le "$vht_max_a_mpdu_len_exp" ] && \
-			vht_max_a_mpdu_len_exp_hw=4
-		[ "$(($vht_cap & 58720256))" -ge 41943040 -a 5 -le "$vht_max_a_mpdu_len_exp" ] && \
-			vht_max_a_mpdu_len_exp_hw=5
-		[ "$(($vht_cap & 58720256))" -ge 50331648 -a 6 -le "$vht_max_a_mpdu_len_exp" ] && \
-			vht_max_a_mpdu_len_exp_hw=6
-		[ "$(($vht_cap & 58720256))" -ge 58720256 -a 7 -le "$vht_max_a_mpdu_len_exp" ] && \
-			vht_max_a_mpdu_len_exp_hw=7
-		vht_capab="$vht_capab[MAX-A-MPDU-LEN-EXP$vht_max_a_mpdu_len_exp_hw]"
-
-		# whether or not the STA supports link adaptation using VHT variant
-		vht_link_adapt_hw=0
-		[ "$(($vht_cap & 201326592))" -ge 134217728 -a 2 -le "$vht_link_adapt" ] && \
-			vht_link_adapt_hw=2
-		[ "$(($vht_cap & 201326592))" -ge 201326592 -a 3 -le "$vht_link_adapt" ] && \
-			vht_link_adapt_hw=3
-		[ "$vht_link_adapt_hw" != 0 ] && \
-			vht_capab="$vht_capab[VHT-LINK-ADAPT-$vht_link_adapt_hw]"
-
-		[ -n "$vht_capab" ] && append base_cfg "vht_capab=$vht_capab" "$N"
-	fi
-
-	# 802.11ax
-	enable_ax=0
-	case "$htmode" in
-		HE*) enable_ax=1 ;;
-	esac
-
-	if [ "$enable_ax" != "0" ]; then
-		json_get_vars \
-			he_su_beamformer:1 \
-			he_su_beamformee:1 \
-			he_mu_beamformer:1 \
-			he_twt_required:0 \
-			he_spr_sr_control:3 \
-			he_spr_psr_enabled:0 \
-			he_spr_non_srg_obss_pd_max_offset:0 \
-			he_bss_color:128 \
-			he_bss_color_enabled:1
-
-		he_phy_cap=$(iw phy "$phy" info | sed -n '/HE Iftypes: AP/,$p' | awk -F "[()]" '/HE PHY Capabilities/ { print $2 }' | head -1)
-		he_phy_cap=${he_phy_cap:2}
-		he_mac_cap=$(iw phy "$phy" info | sed -n '/HE Iftypes: AP/,$p' | awk -F "[()]" '/HE MAC Capabilities/ { print $2 }' | head -1)
-		he_mac_cap=${he_mac_cap:2}
-
-		append base_cfg "ieee80211ax=1" "$N"
-		[ "$hwmode" = "a" ] && {
-			append base_cfg "he_oper_chwidth=$vht_oper_chwidth" "$N"
-			append base_cfg "he_oper_centr_freq_seg0_idx=$vht_center_seg0" "$N"
-		}
-
-		mac80211_add_he_capabilities \
-			he_su_beamformer:${he_phy_cap:6:2}:0x80:$he_su_beamformer \
-			he_su_beamformee:${he_phy_cap:8:2}:0x1:$he_su_beamformee \
-			he_mu_beamformer:${he_phy_cap:8:2}:0x2:$he_mu_beamformer \
-			he_spr_psr_enabled:${he_phy_cap:14:2}:0x1:$he_spr_psr_enabled \
-			he_twt_required:${he_mac_cap:0:2}:0x6:$he_twt_required
-
-		if [ "$he_bss_color_enabled" -gt 0 ]; then
-			append base_cfg "he_bss_color=$he_bss_color" "$N"
-			[ "$he_spr_non_srg_obss_pd_max_offset" -gt 0 ] && { \
-				append base_cfg "he_spr_non_srg_obss_pd_max_offset=$he_spr_non_srg_obss_pd_max_offset" "$N"
-				he_spr_sr_control=$((he_spr_sr_control | (1 << 2)))
-			}
-			[ "$he_spr_psr_enabled" -gt 0 ] || he_spr_sr_control=$((he_spr_sr_control | (1 << 0)))
-			append base_cfg "he_spr_sr_control=$he_spr_sr_control" "$N"
-		else
-			append base_cfg "he_bss_color_disabled=1" "$N"
-		fi
-
-
-		append base_cfg "he_default_pe_duration=4" "$N"
-		append base_cfg "he_rts_threshold=1023" "$N"
-		append base_cfg "he_mu_edca_qos_info_param_count=0" "$N"
-		append base_cfg "he_mu_edca_qos_info_q_ack=0" "$N"
-		append base_cfg "he_mu_edca_qos_info_queue_request=0" "$N"
-		append base_cfg "he_mu_edca_qos_info_txop_request=0" "$N"
-		append base_cfg "he_mu_edca_ac_be_aifsn=8" "$N"
-		append base_cfg "he_mu_edca_ac_be_aci=0" "$N"
-		append base_cfg "he_mu_edca_ac_be_ecwmin=9" "$N"
-		append base_cfg "he_mu_edca_ac_be_ecwmax=10" "$N"
-		append base_cfg "he_mu_edca_ac_be_timer=255" "$N"
-		append base_cfg "he_mu_edca_ac_bk_aifsn=15" "$N"
-		append base_cfg "he_mu_edca_ac_bk_aci=1" "$N"
-		append base_cfg "he_mu_edca_ac_bk_ecwmin=9" "$N"
-		append base_cfg "he_mu_edca_ac_bk_ecwmax=10" "$N"
-		append base_cfg "he_mu_edca_ac_bk_timer=255" "$N"
-		append base_cfg "he_mu_edca_ac_vi_ecwmin=5" "$N"
-		append base_cfg "he_mu_edca_ac_vi_ecwmax=7" "$N"
-		append base_cfg "he_mu_edca_ac_vi_aifsn=5" "$N"
-		append base_cfg "he_mu_edca_ac_vi_aci=2" "$N"
-		append base_cfg "he_mu_edca_ac_vi_timer=255" "$N"
-		append base_cfg "he_mu_edca_ac_vo_aifsn=5" "$N"
-		append base_cfg "he_mu_edca_ac_vo_aci=3" "$N"
-		append base_cfg "he_mu_edca_ac_vo_ecwmin=5" "$N"
-		append base_cfg "he_mu_edca_ac_vo_ecwmax=7" "$N"
-		append base_cfg "he_mu_edca_ac_vo_timer=255" "$N"
-	fi
-
-	hostapd_prepare_device_config "$hostapd_conf_file" nl80211
-	cat >> "$hostapd_conf_file" <<EOF
-${channel:+channel=$channel}
-${channel_list:+chanlist=$channel_list}
-${hostapd_noscan:+noscan=1}
-${tx_burst:+tx_queue_data2_burst=$tx_burst}
-$base_cfg
-
-EOF
-	json_select ..
-	radio_md5sum=$(md5sum $hostapd_conf_file | cut -d" " -f1)
-	echo "radio_config_id=${radio_md5sum}" >> $hostapd_conf_file
-}
-
-mac80211_hostapd_setup_bss() {
-	local phy="$1"
-	local ifname="$2"
-	local macaddr="$3"
-	local type="$4"
-
-	hostapd_cfg=
-	append hostapd_cfg "$type=$ifname" "$N"
-
-	hostapd_set_bss_options hostapd_cfg "$phy" "$vif" || return 1
-	json_get_vars wds wds_bridge dtim_period max_listen_int start_disabled
-
-	set_default wds 0
-	set_default start_disabled 0
-
-	[ "$wds" -gt 0 ] && {
-		append hostapd_cfg "wds_sta=1" "$N"
-		[ -n "$wds_bridge" ] && append hostapd_cfg "wds_bridge=$wds_bridge" "$N"
-	}
-	[ "$staidx" -gt 0 -o "$start_disabled" -eq 1 ] && append hostapd_cfg "start_disabled=1" "$N"
-
-	cat >> /var/run/hostapd-$phy.conf <<EOF
-$hostapd_cfg
-bssid=$macaddr
-${dtim_period:+dtim_period=$dtim_period}
-${max_listen_int:+max_listen_interval=$max_listen_int}
-EOF
-}
-
-mac80211_get_addr() {
-	local phy="$1"
-	local idx="$(($2 + 1))"
-
-	head -n $idx /sys/class/ieee80211/${phy}/addresses | tail -n1
-}
-
-mac80211_generate_mac() {
-	local phy="$1"
-	local id="${macidx:-0}"
-
-	local ref="$(cat /sys/class/ieee80211/${phy}/macaddress)"
-	local mask="$(cat /sys/class/ieee80211/${phy}/address_mask)"
-
-	[ "$mask" = "00:00:00:00:00:00" ] && {
-		mask="ff:ff:ff:ff:ff:ff";
-
-		[ "$(wc -l < /sys/class/ieee80211/${phy}/addresses)" -gt $id ] && {
-			addr="$(mac80211_get_addr "$phy" "$id")"
-			[ -n "$addr" ] && {
-				echo "$addr"
-				return
-			}
-		}
-	}
-
-	local oIFS="$IFS"; IFS=":"; set -- $mask; IFS="$oIFS"
-
-	local mask1=$1
-	local mask6=$6
-
-	local oIFS="$IFS"; IFS=":"; set -- $ref; IFS="$oIFS"
-
-	macidx=$(($id + 1))
-	[ "$((0x$mask1))" -gt 0 ] && {
-		b1="0x$1"
-		[ "$id" -gt 0 ] && \
-			b1=$(($b1 ^ ((($id - !($b1 & 2)) << 2)) | 0x2))
-		printf "%02x:%s:%s:%s:%s:%s" $b1 $2 $3 $4 $5 $6
-		return
-	}
-
-	[ "$((0x$mask6))" -lt 255 ] && {
-		printf "%s:%s:%s:%s:%s:%02x" $1 $2 $3 $4 $5 $(( 0x$6 ^ $id ))
-		return
-	}
-
-	off2=$(( (0x$6 + $id) / 0x100 ))
-	printf "%s:%s:%s:%s:%02x:%02x" \
-		$1 $2 $3 $4 \
-		$(( (0x$5 + $off2) % 0x100 )) \
-		$(( (0x$6 + $id) % 0x100 ))
-}
-
-find_phy() {
-	[ -n "$phy" -a -d /sys/class/ieee80211/$phy ] && return 0
-	[ -n "$path" ] && {
-		phy="$(iwinfo nl80211 phyname "path=$path")"
-		[ -n "$phy" ] && return 0
-	}
-	[ -n "$macaddr" ] && {
-		for phy in $(ls /sys/class/ieee80211 2>/dev/null); do
-			grep -i -q "$macaddr" "/sys/class/ieee80211/${phy}/macaddress" && return 0
-		done
-	}
-	return 1
-}
-
-mac80211_check_ap() {
-	has_ap=1
-}
-
-mac80211_iw_interface_add() {
-	local phy="$1"
-	local ifname="$2"
-	local type="$3"
-	local wdsflag="$4"
-	local rc
-	local oldifname
-
-	iw phy "$phy" interface add "$ifname" type "$type" $wdsflag >/dev/null 2>&1
-	rc="$?"
-
-	[ "$rc" = 233 ] && {
-		# Device might have just been deleted, give the kernel some time to finish cleaning it up
-		sleep 1
-
-		iw phy "$phy" interface add "$ifname" type "$type" $wdsflag >/dev/null 2>&1
-		rc="$?"
-	}
-
-	[ "$rc" = 233 ] && {
-		# Keep matching pre-existing interface
-		[ -d "/sys/class/ieee80211/${phy}/device/net/${ifname}" ] && \
-		case "$(iw dev $ifname info | grep "^\ttype" | cut -d' ' -f2- 2>/dev/null)" in
-			"AP")
-				[ "$type" = "__ap" ] && rc=0
-				;;
-			"IBSS")
-				[ "$type" = "adhoc" ] && rc=0
-				;;
-			"managed")
-				[ "$type" = "managed" ] && rc=0
-				;;
-			"mesh point")
-				[ "$type" = "mp" ] && rc=0
-				;;
-			"monitor")
-				[ "$type" = "monitor" ] && rc=0
-				;;
-		esac
-	}
-
-	[ "$rc" = 233 ] && {
-		iw dev "$ifname" del >/dev/null 2>&1
-		[ "$?" = 0 ] && {
-			sleep 1
-
-			iw phy "$phy" interface add "$ifname" type "$type" $wdsflag >/dev/null 2>&1
-			rc="$?"
-		}
-	}
-
-	[ "$rc" != 0 ] && {
-		# Device might not support virtual interfaces, so the interface never got deleted in the first place.
-		# Check if the interface already exists, and avoid failing in this case.
-		[ -d "/sys/class/ieee80211/${phy}/device/net/${ifname}" ] && rc=0
-	}
-
-	[ "$rc" != 0 ] && {
-		# Device doesn't support virtual interfaces and may have existing interface other than ifname.
-		oldifname="$(basename "/sys/class/ieee80211/${phy}/device/net"/* 2>/dev/null)"
-		[ "$oldifname" ] && ip link set "$oldifname" name "$ifname" 1>/dev/null 2>&1
-		rc="$?"
-	}
-
-	[ "$rc" != 0 ] && echo "Failed to create interface $ifname"
-	return $rc
-}
-
-mac80211_prepare_vif() {
-	json_select config
-
-	json_get_vars ifname mode ssid wds powersave macaddr enable wpa_psk_file vlan_file
-
-	[ -n "$ifname" ] || ifname="wlan${phy#phy}${if_idx:+-$if_idx}"
-	if_idx=$((${if_idx:-0} + 1))
-
-	set_default wds 0
-	set_default powersave 0
-
-	json_select ..
-
-	if [ -z "$macaddr" ]; then
-		macaddr="$(mac80211_generate_mac $phy)"
-		macidx="$(($macidx + 1))"
-	elif [ "$macaddr" = 'random' ]; then
-		macaddr="$(macaddr_random)"
-	fi
-
-	json_add_object data
-	json_add_string ifname "$ifname"
-	json_close_object
-
-	[ "$mode" == "ap" ] && {
-		[ -z "$wpa_psk_file" ] && hostapd_set_psk "$ifname"
-		[ -z "$vlan_file" ] && hostapd_set_vlan "$ifname"
-	}
-
-	json_select config
-
-	# It is far easier to delete and create the desired interface
-	case "$mode" in
-		adhoc)
-			mac80211_iw_interface_add "$phy" "$ifname" adhoc || return
-		;;
-		ap)
-			# Hostapd will handle recreating the interface and
-			# subsequent virtual APs belonging to the same PHY
-			if [ -n "$hostapd_ctrl" ]; then
-				type=bss
-			else
-				type=interface
-			fi
-
-			mac80211_hostapd_setup_bss "$phy" "$ifname" "$macaddr" "$type" || return
-
-			NEWAPLIST="${NEWAPLIST}$ifname "
-			[ -n "$hostapd_ctrl" ] || {
-				ap_ifname="${ifname}"
-				hostapd_ctrl="${hostapd_ctrl:-/var/run/hostapd/$ifname}"
-			}
-		;;
-		mesh)
-			mac80211_iw_interface_add "$phy" "$ifname" mp || return
-		;;
-		monitor)
-			mac80211_iw_interface_add "$phy" "$ifname" monitor || return
-		;;
-		sta)
-			local wdsflag=
-			[ "$enable" = 0 ] || staidx="$(($staidx + 1))"
-			[ "$wds" -gt 0 ] && wdsflag="4addr on"
-			mac80211_iw_interface_add "$phy" "$ifname" managed "$wdsflag" || return
-			if [ "$wds" -gt 0 ]; then
-				iw "$ifname" set 4addr on
-			else
-				iw "$ifname" set 4addr off
-			fi
-			[ "$powersave" -gt 0 ] && powersave="on" || powersave="off"
-			iw "$ifname" set power_save "$powersave"
-		;;
-	esac
-
-	case "$mode" in
-		monitor|mesh)
-			[ "$auto_channel" -gt 0 ] || iw dev "$ifname" set channel "$channel" $iw_htmode
-		;;
-	esac
-
-	if [ "$mode" != "ap" ]; then
-		# ALL ap functionality will be passed to hostapd
-		# All interfaces must have unique mac addresses
-		# which can either be explicitly set in the device
-		# section, or automatically generated
-		ip link set dev "$ifname" address "$macaddr"
-	fi
-
-	json_select ..
-}
-
-mac80211_setup_supplicant() {
-	local enable=$1
-	local add_sp=0
-	local spobj="$(ubus -S list | grep wpa_supplicant.${ifname})"
-
-	[ "$enable" = 0 ] && {
-		ubus call wpa_supplicant.${phy} config_remove "{\"iface\":\"$ifname\"}"
-		ip link set dev "$ifname" down
-		iw dev "$ifname" del
-		return 0
-	}
-
-	wpa_supplicant_prepare_interface "$ifname" nl80211 || {
-		iw dev "$ifname" del
-		return 1
-	}
-	if [ "$mode" = "sta" ]; then
-		wpa_supplicant_add_network "$ifname"
-	else
-		wpa_supplicant_add_network "$ifname" "$freq" "$htmode" "$noscan"
-	fi
-
-	NEWSPLIST="${NEWSPLIST}$ifname "
-
-	if [ "${NEWAPLIST%% *}" != "${OLDAPLIST%% *}" ]; then
-		[ "$spobj" ] && ubus call wpa_supplicant config_remove "{\"iface\":\"$ifname\"}"
-		add_sp=1
-	fi
-	[ -z "$spobj" ] && add_sp=1
-
-	NEW_MD5_SP=$(test -e "${_config}" && md5sum ${_config})
-	OLD_MD5_SP=$(uci -q -P /var/state get wireless._${phy}.md5_${ifname})
-	if [ "$add_sp" = "1" ]; then
-		wpa_supplicant_run "$ifname" "$hostapd_ctrl"
-	else
-		[ "${NEW_MD5_SP}" == "${OLD_MD5_SP}" ] || ubus call $spobj reload
-	fi
-	uci -q -P /var/state set wireless._${phy}.md5_${ifname}="${NEW_MD5_SP}"
-	return 0
-}
-
-mac80211_setup_supplicant_noctl() {
-	local enable=$1
-	local spobj="$(ubus -S list | grep wpa_supplicant.${ifname})"
-	wpa_supplicant_prepare_interface "$ifname" nl80211 || {
-		iw dev "$ifname" del
-		return 1
-	}
-
-	wpa_supplicant_add_network "$ifname" "$freq" "$htmode" "$noscan"
-
-	NEWSPLIST="${NEWSPLIST}$ifname "
-	[ "$enable" = 0 ] && {
-		ubus call wpa_supplicant config_remove "{\"iface\":\"$ifname\"}"
-		ip link set dev "$ifname" down
-		return 0
-	}
-	if [ -z "$spobj" ]; then
-		wpa_supplicant_run "$ifname"
-	else
-		ubus call $spobj reload
-	fi
-}
-
-mac80211_prepare_iw_htmode() {
-	case "$htmode" in
-		VHT20|HT20|HE20) iw_htmode=HT20;;
-		HT40*|VHT40|VHT160|HE40)
-			case "$band" in
-				2g)
-					case "$htmode" in
-						HT40+) iw_htmode="HT40+";;
-						HT40-) iw_htmode="HT40-";;
-						*)
-							if [ "$channel" -lt 7 ]; then
-								iw_htmode="HT40+"
-							else
-								iw_htmode="HT40-"
-							fi
-						;;
-					esac
-				;;
-				*)
-					case "$(( ($channel / 4) % 2 ))" in
-						1) iw_htmode="HT40+" ;;
-						0) iw_htmode="HT40-";;
-					esac
-				;;
-			esac
-			[ "$auto_channel" -gt 0 ] && iw_htmode="HT40+"
-		;;
-		VHT80|HE80)
-			iw_htmode="80MHZ"
-		;;
-		NONE|NOHT)
-			iw_htmode="NOHT"
-		;;
-		*) iw_htmode="" ;;
-	esac
-}
-
-mac80211_setup_adhoc() {
-	local enable=$1
-	json_get_vars bssid ssid key mcast_rate
-
-	NEWUMLIST="${NEWUMLIST}$ifname "
-
-	[ "$enable" = 0 ] && {
-		ip link set dev "$ifname" down
-		return 0
-	}
-
-	keyspec=
-	[ "$auth_type" = "wep" ] && {
-		set_default key 1
-		case "$key" in
-			[1234])
-				local idx
-				for idx in 1 2 3 4; do
-					json_get_var ikey "key$idx"
-
-					[ -n "$ikey" ] && {
-						ikey="$(($idx - 1)):$(prepare_key_wep "$ikey")"
-						[ $idx -eq $key ] && ikey="d:$ikey"
-						append keyspec "$ikey"
-					}
-				done
-			;;
-			*)
-				append keyspec "d:0:$(prepare_key_wep "$key")"
-			;;
-		esac
-	}
-
-	brstr=
-	for br in $basic_rate_list; do
-		wpa_supplicant_add_rate brstr "$br"
-	done
-
-	mcval=
-	[ -n "$mcast_rate" ] && wpa_supplicant_add_rate mcval "$mcast_rate"
-
-	iw dev "$ifname" set type ibss
-	iw dev "$ifname" ibss join "$ssid" $freq $iw_htmode fixed-freq $bssid \
-		beacon-interval $beacon_int \
-		${brstr:+basic-rates $brstr} \
-		${mcval:+mcast-rate $mcval} \
-		${keyspec:+keys $keyspec}
-}
-
-mac80211_setup_mesh() {
-	local enable=$1
-	json_get_vars ssid mesh_id mcast_rate
-
-	NEWUMLIST="${NEWUMLIST}$ifname "
-
-	[ "$enable" = 0 ] && {
-		ip link set dev "$ifname" down
-		return 0
-	}
-
-	mcval=
-	[ -n "$mcast_rate" ] && wpa_supplicant_add_rate mcval "$mcast_rate"
-	[ -n "$mesh_id" ] && ssid="$mesh_id"
-
-	iw dev "$ifname" mesh join "$ssid" freq $freq $iw_htmode \
-		${mcval:+mcast-rate $mcval} \
-		beacon-interval $beacon_int
-}
-
-mac80211_setup_vif() {
-	local name="$1"
-	local failed
-	local action=up
-
-	json_select data
-	json_get_vars ifname
-	json_select ..
-
-	json_select config
-	json_get_vars mode
-	json_get_var vif_txpower
-	json_get_var vif_enable enable 1
-
-	[ "$vif_enable" = 1 ] || action=down
-	if [ "$mode" != "ap" ] || [ "$ifname" = "$ap_ifname" ]; then
-		ip link set dev "$ifname" "$action" || {
-			wireless_setup_vif_failed IFUP_ERROR
-			json_select ..
-			return
-		}
-		[ -z "$vif_txpower" ] || iw dev "$ifname" set txpower fixed "${vif_txpower%%.*}00"
-	fi
-
-	case "$mode" in
-		mesh)
-			wireless_vif_parse_encryption
-			[ -z "$htmode" ] && htmode="NOHT";
-			if [ "$wpa" -gt 0 -o "$auto_channel" -gt 0 ] || chan_is_dfs "$phy" "$channel"; then
-				mac80211_setup_supplicant $vif_enable || failed=1
-			else
-				mac80211_setup_mesh $vif_enable
-			fi
-			for var in $MP_CONFIG_INT $MP_CONFIG_BOOL $MP_CONFIG_STRING; do
-				json_get_var mp_val "$var"
-				[ -n "$mp_val" ] && iw dev "$ifname" set mesh_param "$var" "$mp_val"
-			done
-		;;
-		adhoc)
-			wireless_vif_parse_encryption
-			if [ "$wpa" -gt 0 -o "$auto_channel" -gt 0 ]; then
-				mac80211_setup_supplicant_noctl $vif_enable || failed=1
-			else
-				mac80211_setup_adhoc $vif_enable
-			fi
-		;;
-		sta)
-			mac80211_setup_supplicant $vif_enable || failed=1
-		;;
-	esac
-
-	json_select ..
-	[ -n "$failed" ] || wireless_add_vif "$name" "$ifname"
-}
-
-get_freq() {
-	local phy="$1"
-	local channel="$2"
-	local band="$3"
-
-	case "$band" in
-		2g) band="1:";;
-		5g) band="2:";;
-		60g) band="3:";;
-		6g) band="4:";;
-	esac
-
-	iw "$phy" info | awk -v band="$band" -v channel="[$channel]" '
-
-$1 ~ /Band/ {
-	band_match = band == $2
-}
-
-band_match && $3 == "MHz" && $4 == channel {
-	print $2
-	exit
-}
-'
-}
-
-
-chan_is_dfs() {
-	local phy="$1"
-	local chan="$2"
-	iw "$phy" info | grep -E -m1 "(\* ${chan:-....} MHz${chan:+|\\[$chan\\]})" | grep -q "MHz.*radar detection"
-	return $!
-}
-
-mac80211_vap_cleanup() {
-	local service="$1"
-	local vaps="$2"
-
-	for wdev in $vaps; do
-		[ "$service" != "none" ] && ubus call ${service} config_remove "{\"iface\":\"$wdev\"}"
-		ip link set dev "$wdev" down 2>/dev/null
-		iw dev "$wdev" del
-	done
-}
-
-mac80211_interface_cleanup() {
-	local phy="$1"
-	local primary_ap=$(uci -q -P /var/state get wireless._${phy}.aplist)
-	primary_ap=${primary_ap%% *}
-
-	mac80211_vap_cleanup hostapd "${primary_ap}"
-	mac80211_vap_cleanup wpa_supplicant "$(uci -q -P /var/state get wireless._${phy}.splist)"
-	mac80211_vap_cleanup none "$(uci -q -P /var/state get wireless._${phy}.umlist)"
-}
-
-mac80211_set_noscan() {
-	hostapd_noscan=1
-}
-
-drv_mac80211_cleanup() {
-	hostapd_common_cleanup
-}
-
-drv_mac80211_setup() {
-	json_select config
-	json_get_vars \
-		phy macaddr path \
-		country chanbw distance \
-		txpower antenna_gain \
-		rxantenna txantenna \
-		frag rts beacon_int:100 htmode
-	json_get_values basic_rate_list basic_rate
-	json_get_values scan_list scan_list
-	json_select ..
-
-	find_phy || {
-		echo "Could not find PHY for device '$1'"
-		wireless_set_retry 0
-		return 1
-	}
-
-	wireless_set_data phy="$phy"
-	[ -z "$(uci -q -P /var/state show wireless._${phy})" ] && uci -q -P /var/state set wireless._${phy}=phy
-
-	OLDAPLIST=$(uci -q -P /var/state get wireless._${phy}.aplist)
-	OLDSPLIST=$(uci -q -P /var/state get wireless._${phy}.splist)
-	OLDUMLIST=$(uci -q -P /var/state get wireless._${phy}.umlist)
-
-	local wdev
-	local cwdev
-	local found
-
-	for wdev in $(list_phy_interfaces "$phy"); do
-		found=0
-		for cwdev in $OLDAPLIST $OLDSPLIST $OLDUMLIST; do
-			if [ "$wdev" = "$cwdev" ]; then
-				found=1
-				break
-			fi
-		done
-		if [ "$found" = "0" ]; then
-			ip link set dev "$wdev" down
-			iw dev "$wdev" del
-		fi
-	done
-
-	# convert channel to frequency
-	[ "$auto_channel" -gt 0 ] || freq="$(get_freq "$phy" "$channel" "$band")"
-
-	[ -n "$country" ] && {
-		iw reg get | grep -q "^country $country:" || {
-			iw reg set "$country"
-			sleep 1
-		}
-	}
-
-	hostapd_conf_file="/var/run/hostapd-$phy.conf"
-
-	no_ap=1
-	macidx=0
-	staidx=0
-
-	[ -n "$chanbw" ] && {
-		for file in /sys/kernel/debug/ieee80211/$phy/ath9k*/chanbw /sys/kernel/debug/ieee80211/$phy/ath5k/bwmode; do
-			[ -f "$file" ] && echo "$chanbw" > "$file"
-		done
-	}
-
-	set_default rxantenna 0xffffffff
-	set_default txantenna 0xffffffff
-	set_default distance 0
-	set_default antenna_gain 0
-
-	[ "$txantenna" = "all" ] && txantenna=0xffffffff
-	[ "$rxantenna" = "all" ] && rxantenna=0xffffffff
-
-	iw phy "$phy" set antenna $txantenna $rxantenna >/dev/null 2>&1
-	iw phy "$phy" set antenna_gain $antenna_gain >/dev/null 2>&1
-	iw phy "$phy" set distance "$distance" >/dev/null 2>&1
-
-	if [ -n "$txpower" ]; then
-		iw phy "$phy" set txpower fixed "${txpower%%.*}00"
-	else
-		iw phy "$phy" set txpower auto
-	fi
-
-	[ -n "$frag" ] && iw phy "$phy" set frag "${frag%%.*}"
-	[ -n "$rts" ] && iw phy "$phy" set rts "${rts%%.*}"
-
-	has_ap=
-	hostapd_ctrl=
-	ap_ifname=
-	hostapd_noscan=
-	for_each_interface "ap" mac80211_check_ap
-
-	rm -f "$hostapd_conf_file"
-
-	for_each_interface "sta adhoc mesh" mac80211_set_noscan
-	[ -n "$has_ap" ] && mac80211_hostapd_setup_base "$phy"
-
-	mac80211_prepare_iw_htmode
-	for_each_interface "sta adhoc mesh monitor" mac80211_prepare_vif
-	NEWAPLIST=
-	for_each_interface "ap" mac80211_prepare_vif
-	NEW_MD5=$(test -e "${hostapd_conf_file}" && md5sum ${hostapd_conf_file})
-	OLD_MD5=$(uci -q -P /var/state get wireless._${phy}.md5)
-	if [ "${NEWAPLIST}" != "${OLDAPLIST}" ]; then
-		mac80211_vap_cleanup hostapd "${OLDAPLIST}"
-	fi
-	[ -n "${NEWAPLIST}" ] && mac80211_iw_interface_add "$phy" "${NEWAPLIST%% *}" __ap
-	local add_ap=0
-	local primary_ap=${NEWAPLIST%% *}
-	[ -n "$hostapd_ctrl" ] && {
-		local no_reload=1
-		if [ -n "$(ubus list | grep hostapd.$primary_ap)" ]; then
-			no_reload=0
-			[ "${NEW_MD5}" = "${OLD_MD5}" ] || {
-				ubus call hostapd.$primary_ap reload
-				no_reload=$?
-				if [ "$no_reload" != "0" ]; then
-					mac80211_vap_cleanup hostapd "${OLDAPLIST}"
-					mac80211_vap_cleanup wpa_supplicant "$(uci -q -P /var/state get wireless._${phy}.splist)"
-					mac80211_vap_cleanup none "$(uci -q -P /var/state get wireless._${phy}.umlist)"
-					sleep 2
-					mac80211_iw_interface_add "$phy" "${NEWAPLIST%% *}" __ap
-					for_each_interface "sta adhoc mesh monitor" mac80211_prepare_vif
-				fi
-			}
-		fi
-		if [ "$no_reload" != "0" ]; then
-			add_ap=1
-			ubus wait_for hostapd
-			local hostapd_res="$(ubus call hostapd config_add "{\"iface\":\"$primary_ap\", \"config\":\"${hostapd_conf_file}\"}")"
-			ret="$?"
-			[ "$ret" != 0 -o -z "$hostapd_res" ] && {
-				wireless_setup_failed HOSTAPD_START_FAILED
-				return
-			}
-			wireless_add_process "$(jsonfilter -s "$hostapd_res" -l 1 -e @.pid)" "/usr/sbin/hostapd" 1 1
-		fi
-	}
-	uci -q -P /var/state set wireless._${phy}.aplist="${NEWAPLIST}"
-	uci -q -P /var/state set wireless._${phy}.md5="${NEW_MD5}"
-
-	[ "${add_ap}" = 1 ] && sleep 1
-	for_each_interface "ap" mac80211_setup_vif
-
-	NEWSPLIST=
-	NEWUMLIST=
-
-	for_each_interface "sta adhoc mesh monitor" mac80211_setup_vif
-
-	uci -q -P /var/state set wireless._${phy}.splist="${NEWSPLIST}"
-	uci -q -P /var/state set wireless._${phy}.umlist="${NEWUMLIST}"
-
-	local foundvap
-	local dropvap=""
-	for oldvap in $OLDSPLIST; do
-		foundvap=0
-		for newvap in $NEWSPLIST; do
-			[ "$oldvap" = "$newvap" ] && foundvap=1
-		done
-		[ "$foundvap" = "0" ] && dropvap="$dropvap $oldvap"
-	done
-	[ -n "$dropvap" ] && mac80211_vap_cleanup wpa_supplicant "$dropvap"
-	wireless_set_up
-}
-
-_list_phy_interfaces() {
-	local phy="$1"
-	if [ -d "/sys/class/ieee80211/${phy}/device/net" ]; then
-		ls "/sys/class/ieee80211/${phy}/device/net" 2>/dev/null;
-	else
-		ls "/sys/class/ieee80211/${phy}/device" 2>/dev/null | grep net: | sed -e 's,net:,,g'
-	fi
-}
-
-list_phy_interfaces() {
-	local phy="$1"
-
-	for dev in $(_list_phy_interfaces "$phy"); do
-		readlink "/sys/class/net/${dev}/phy80211" | grep -q "/${phy}\$" || continue
-		echo "$dev"
-	done
-}
-
-drv_mac80211_teardown() {
-	json_select data
-	json_get_vars phy
-	json_select ..
-	[ -n "$phy" ] || {
-		echo "Bug: PHY is undefined for device '$1'"
-		return 1
-	}
-
-	mac80211_interface_cleanup "$phy"
-	uci -q -P /var/state revert wireless._${phy}
-}
-
-add_driver mac80211
diff --git a/package/kernel/mac80211/files/lib/wifi/mac80211.sh b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
deleted file mode 100644
index 46ff38f2..00000000
--- a/package/kernel/mac80211/files/lib/wifi/mac80211.sh
+++ /dev/null
@@ -1,191 +0,0 @@
-#!/bin/sh
-
-append DRIVERS "mac80211"
-
-lookup_phy() {
-	[ -n "$phy" ] && {
-		[ -d /sys/class/ieee80211/$phy ] && return
-	}
-
-	local devpath
-	config_get devpath "$device" path
-	[ -n "$devpath" ] && {
-		phy="$(iwinfo nl80211 phyname "path=$devpath")"
-		[ -n "$phy" ] && return
-	}
-
-	local macaddr="$(config_get "$device" macaddr | tr 'A-Z' 'a-z')"
-	[ -n "$macaddr" ] && {
-		for _phy in /sys/class/ieee80211/*; do
-			[ -e "$_phy" ] || continue
-
-			[ "$macaddr" = "$(cat ${_phy}/macaddress)" ] || continue
-			phy="${_phy##*/}"
-			return
-		done
-	}
-	phy=
-	return
-}
-
-find_mac80211_phy() {
-	local device="$1"
-
-	config_get phy "$device" phy
-	lookup_phy
-	[ -n "$phy" -a -d "/sys/class/ieee80211/$phy" ] || {
-		echo "PHY for wifi device $1 not found"
-		return 1
-	}
-	config_set "$device" phy "$phy"
-
-	config_get macaddr "$device" macaddr
-	[ -z "$macaddr" ] && {
-		config_set "$device" macaddr "$(cat /sys/class/ieee80211/${phy}/macaddress)"
-	}
-
-	return 0
-}
-
-check_mac80211_device() {
-	config_get phy "$1" phy
-	[ -z "$phy" ] && {
-		find_mac80211_phy "$1" >/dev/null || return 0
-		config_get phy "$1" phy
-	}
-	[ "$phy" = "$dev" ] && found=1
-}
-
-
-__get_band_defaults() {
-	local phy="$1"
-
-	( iw phy "$phy" info; echo ) | awk '
-BEGIN {
-        bands = ""
-}
-
-($1 == "Band" || $1 == "") && band {
-        if (channel) {
-		mode="NOHT"
-		if (ht) mode="HT20"
-		if (vht && band != "1:") mode="VHT80"
-		if (he) mode="HE80"
-		if (he && band == "1:") mode="HE20"
-                sub("\\[", "", channel)
-                sub("\\]", "", channel)
-                bands = bands band channel ":" mode " "
-        }
-        band=""
-}
-
-$1 == "Band" {
-        band = $2
-        channel = ""
-	vht = ""
-	ht = ""
-	he = ""
-}
-
-$0 ~ "Capabilities:" {
-	ht=1
-}
-
-$0 ~ "VHT Capabilities" {
-	vht=1
-}
-
-$0 ~ "HE Iftypes" {
-	he=1
-}
-
-$1 == "*" && $3 == "MHz" && $0 !~ /disabled/ && band && !channel {
-        channel = $4
-}
-
-END {
-        print bands
-}'
-}
-
-get_band_defaults() {
-	local phy="$1"
-
-	for c in $(__get_band_defaults "$phy"); do
-		local band="${c%%:*}"
-		c="${c#*:}"
-		local chan="${c%%:*}"
-		c="${c#*:}"
-		local mode="${c%%:*}"
-
-		case "$band" in
-			1) band=2g;;
-			2) band=5g;;
-			3) band=60g;;
-			4) band=6g;;
-			*) band="";;
-		esac
-
-		[ -n "$band" ] || continue
-		[ -n "$mode_band" -a "$band" = "6g" ] && return
-
-		mode_band="$band"
-		channel="$chan"
-		htmode="$mode"
-	done
-}
-
-detect_mac80211() {
-	devidx=0
-	config_load wireless
-	while :; do
-		config_get type "radio$devidx" type
-		[ -n "$type" ] || break
-		devidx=$(($devidx + 1))
-	done
-
-	for _dev in /sys/class/ieee80211/*; do
-		[ -e "$_dev" ] || continue
-
-		dev="${_dev##*/}"
-
-		found=0
-		config_foreach check_mac80211_device wifi-device
-		[ "$found" -gt 0 ] && continue
-
-		mode_band=""
-		channel=""
-		htmode=""
-		ht_capab=""
-
-		get_band_defaults "$dev"
-
-		path="$(iwinfo nl80211 path "$dev")"
-		if [ -n "$path" ]; then
-			dev_id="set wireless.radio${devidx}.path='$path'"
-		else
-			dev_id="set wireless.radio${devidx}.macaddr=$(cat /sys/class/ieee80211/${dev}/macaddress)"
-		fi
-
-		uci -q batch <<-EOF
-			set wireless.radio${devidx}=wifi-device
-			set wireless.radio${devidx}.type=mac80211
-			${dev_id}
-			set wireless.radio${devidx}.channel=${channel}
-			set wireless.radio${devidx}.band=${mode_band}
-			set wireless.radio${devidx}.htmode=$htmode
-			set wireless.radio${devidx}.disabled=0
-			set wireless.radio${devidx}.country=US
-
-			set wireless.default_radio${devidx}=wifi-iface
-			set wireless.default_radio${devidx}.device=radio${devidx}
-			set wireless.default_radio${devidx}.network=lan
-			set wireless.default_radio${devidx}.mode=ap
-			set wireless.default_radio${devidx}.ssid=LEDE
-			set wireless.default_radio${devidx}.encryption=none
-EOF
-		uci -q commit wireless
-
-		devidx=$(($devidx + 1))
-	done
-}
diff --git a/package/kernel/mac80211/files/mac80211.hotplug b/package/kernel/mac80211/files/mac80211.hotplug
deleted file mode 100644
index b8655526..00000000
--- a/package/kernel/mac80211/files/mac80211.hotplug
+++ /dev/null
@@ -1,5 +0,0 @@
-#!/bin/sh
-
-[ "${ACTION}" = "add" ] && {
-	/sbin/wifi config
-}
diff --git a/package/kernel/mac80211/intel.mk b/package/kernel/mac80211/intel.mk
index 8d374d73..f2aceb96 100644
--- a/package/kernel/mac80211/intel.mk
+++ b/package/kernel/mac80211/intel.mk
@@ -6,7 +6,7 @@ config-$(CONFIG_PACKAGE_IWLWIFI_DEBUGFS)+= IWLWIFI_DEBUGFS
 
 define KernelPackage/iwlwifi
   $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 @PCI_SUPPORT +@DRIVER_11AC_SUPPORT +@DRIVER_11AX_SUPPORT
+  DEPENDS:= +kmod-mac80211 +kmod-ptp @PCI_SUPPORT +@DRIVER_11AC_SUPPORT +@DRIVER_11AX_SUPPORT
   TITLE:=Intel AGN Wireless support
   FILES:= \
 	$(PKG_BUILD_DIR)/drivers/net/wireless/intel/iwlwifi/iwlwifi.ko \
diff --git a/package/kernel/mac80211/patches/ath/400-ath_move_debug_code.patch b/package/kernel/mac80211/patches/ath/400-ath_move_debug_code.patch
index eacc7277..23b7340e 100644
--- a/package/kernel/mac80211/patches/ath/400-ath_move_debug_code.patch
+++ b/package/kernel/mac80211/patches/ath/400-ath_move_debug_code.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/Makefile
 +++ b/drivers/net/wireless/ath/Makefile
-@@ -15,10 +15,10 @@ ath-objs :=	main.o \
+@@ -16,10 +16,10 @@ ath-objs :=	main.o \
  		regd.o \
  		hw.o \
  		key.o \
@@ -14,7 +14,7 @@
  CFLAGS_trace.o := -I$(src)
 --- a/drivers/net/wireless/ath/ath.h
 +++ b/drivers/net/wireless/ath/ath.h
-@@ -317,14 +317,7 @@ void _ath_dbg(struct ath_common *common,
+@@ -321,14 +321,7 @@ void _ath_dbg(struct ath_common *common,
  #endif /* CPTCFG_ATH_DEBUG */
  
  /** Returns string describing opmode, or NULL if unknown mode. */
diff --git a/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch b/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch
index fd5493de..5f5ac20d 100644
--- a/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch
+++ b/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch
@@ -82,7 +82,7 @@
  	help
 --- a/local-symbols
 +++ b/local-symbols
-@@ -102,6 +102,7 @@ ADM8211=
+@@ -96,6 +96,7 @@ ADM8211=
  ATH_COMMON=
  WLAN_VENDOR_ATH=
  ATH_DEBUG=
diff --git a/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch b/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch
index 8d83921a..895e2ff8 100644
--- a/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch
+++ b/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch
@@ -1,6 +1,6 @@
 --- a/net/wireless/reg.c
 +++ b/net/wireless/reg.c
-@@ -3370,6 +3370,8 @@ void regulatory_hint_country_ie(struct w
+@@ -3364,6 +3364,8 @@ void regulatory_hint_country_ie(struct w
  	enum environment_cap env = ENVIRON_ANY;
  	struct regulatory_request *request = NULL, *lr;
  
@@ -9,7 +9,7 @@
  	/* IE len must be evenly divisible by 2 */
  	if (country_ie_len & 0x01)
  		return;
-@@ -3621,6 +3623,7 @@ static bool is_wiphy_all_set_reg_flag(en
+@@ -3615,6 +3617,7 @@ static bool is_wiphy_all_set_reg_flag(en
  
  void regulatory_hint_disconnect(void)
  {
diff --git a/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch b/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch
index 136be198..abadadf8 100644
--- a/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch
+++ b/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch
@@ -8,7 +8,7 @@
  #include "../ath.h"
  #include "ath5k.h"
  #include "debug.h"
-@@ -71,7 +72,7 @@ static void ath5k_pci_read_cachesize(str
+@@ -73,7 +74,7 @@ static void ath5k_pci_read_cachesize(str
  }
  
  /*
@@ -17,8 +17,8 @@
   */
  static bool
  ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
-@@ -79,6 +80,19 @@ ath5k_pci_eeprom_read(struct ath_common
- 	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
+@@ -81,6 +82,19 @@ ath5k_pci_eeprom_read(struct ath_common
+ 	struct ath5k_hw *ah = common->ah;
  	u32 status, timeout;
  
 +	struct ath5k_platform_data *pdata = NULL;
@@ -37,7 +37,7 @@
  	/*
  	 * Initialize EEPROM access
  	 */
-@@ -122,6 +136,16 @@ static int ath5k_pci_eeprom_read_mac(str
+@@ -124,6 +138,16 @@ static int ath5k_pci_eeprom_read_mac(str
  	u16 data;
  	int octet;
  
diff --git a/package/kernel/mac80211/patches/ath10k/080-ath10k_thermal_config.patch b/package/kernel/mac80211/patches/ath10k/080-ath10k_thermal_config.patch
index 41ad6006..10d95d36 100644
--- a/package/kernel/mac80211/patches/ath10k/080-ath10k_thermal_config.patch
+++ b/package/kernel/mac80211/patches/ath10k/080-ath10k_thermal_config.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/Kconfig
 +++ b/drivers/net/wireless/ath/ath10k/Kconfig
-@@ -86,6 +86,12 @@ config ATH10K_TRACING
+@@ -94,6 +94,12 @@ config ATH10K_TRACING
  	help
  	  Select this to ath10k use tracing infrastructure.
  
@@ -21,9 +21,9 @@
  ath10k_core-$(CPTCFG_ATH10K_TRACING) += trace.o
 -ath10k_core-$(CONFIG_THERMAL) += thermal.o
 +ath10k_core-$(CPTCFG_ATH10K_THERMAL) += thermal.o
+ ath10k_core-$(CPTCFG_ATH10K_LEDS) += leds.o
  ath10k_core-$(CPTCFG_MAC80211_DEBUGFS) += debugfs_sta.o
  ath10k_core-$(CONFIG_PM) += wow.o
- ath10k_core-$(CONFIG_DEV_COREDUMP) += coredump.o
 --- a/drivers/net/wireless/ath/ath10k/thermal.h
 +++ b/drivers/net/wireless/ath/ath10k/thermal.h
 @@ -25,7 +25,7 @@ struct ath10k_thermal {
@@ -37,9 +37,9 @@
  void ath10k_thermal_event_temperature(struct ath10k *ar, int temperature);
 --- a/local-symbols
 +++ b/local-symbols
-@@ -161,6 +161,7 @@ ATH10K_SNOC=
- ATH10K_DEBUG=
+@@ -156,6 +156,7 @@ ATH10K_DEBUG=
  ATH10K_DEBUGFS=
+ ATH10K_LEDS=
  ATH10K_SPECTRAL=
 +ATH10K_THERMAL=
  ATH10K_TRACING=
diff --git a/package/kernel/mac80211/patches/ath10k/911-ath10k-disable-caldata-prefetch-for-sdio-bus.patch b/package/kernel/mac80211/patches/ath10k/911-ath10k-disable-caldata-prefetch-for-sdio-bus.patch
deleted file mode 100644
index 8ca8f3b5..00000000
--- a/package/kernel/mac80211/patches/ath10k/911-ath10k-disable-caldata-prefetch-for-sdio-bus.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/drivers/net/wireless/ath/ath10k/debug.c
-+++ b/drivers/net/wireless/ath/ath10k/debug.c
-@@ -1260,6 +1260,9 @@ static int ath10k_debug_cal_data_fetch(s
- 	if (ar->hw_params.cal_data_len == 0)
- 		return -EOPNOTSUPP;
- 
-+	if (ar->hif.bus == ATH10K_BUS_SDIO)
-+		return -EINVAL;
-+
- 	hi_addr = host_interest_item_address(HI_ITEM(hi_board_data));
- 
- 	ret = ath10k_hif_diag_read(ar, hi_addr, &addr, sizeof(addr));
diff --git a/package/kernel/mac80211/patches/ath10k/921-ath10k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/ath10k/921-ath10k_init_devices_synchronously.patch
index f5e70219..a7e11679 100644
--- a/package/kernel/mac80211/patches/ath10k/921-ath10k_init_devices_synchronously.patch
+++ b/package/kernel/mac80211/patches/ath10k/921-ath10k_init_devices_synchronously.patch
@@ -14,7 +14,7 @@ Signed-off-by: Sven Eckelmann <sven@open-mesh.com>
 
 --- a/drivers/net/wireless/ath/ath10k/core.c
 +++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -3516,6 +3516,17 @@ int ath10k_core_register(struct ath10k *
+@@ -3539,6 +3539,16 @@ int ath10k_core_register(struct ath10k *
  
  	queue_work(ar->workqueue, &ar->register_work);
  
@@ -26,8 +26,7 @@ Signed-off-by: Sven Eckelmann <sven@open-mesh.com>
 +	 * Forcing the work to be done immediately works around this problem
 +	 * but may also delay the boot when firmware images cannot be found.
 +	 */
-+	if (ar->hif.bus != ATH10K_BUS_SDIO)
-+		flush_workqueue(ar->workqueue);
++	flush_workqueue(ar->workqueue);
 +
  	return 0;
  }
diff --git a/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch b/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
index e8beed17..b13bc334 100644
--- a/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
+++ b/package/kernel/mac80211/patches/ath10k/930-ath10k_add_tpt_led_trigger.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -9909,6 +9909,21 @@ static int ath10k_mac_init_rd(struct ath
+@@ -9919,6 +9919,21 @@ static int ath10k_mac_init_rd(struct ath
  	return 0;
  }
  
@@ -22,7 +22,7 @@
  int ath10k_mac_register(struct ath10k *ar)
  {
  	static const u32 cipher_suites[] = {
-@@ -10267,6 +10282,12 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10281,6 +10296,12 @@ int ath10k_mac_register(struct ath10k *a
  
  	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
  
diff --git a/package/kernel/mac80211/patches/ath10k/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch b/package/kernel/mac80211/patches/ath10k/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
deleted file mode 100644
index fd5b4481..00000000
--- a/package/kernel/mac80211/patches/ath10k/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
+++ /dev/null
@@ -1,609 +0,0 @@
-From: Sebastian Gottschall <s.gottschall@newmedia-net.de>
-
-Adds LED and GPIO Control support for 988x, 9887, 9888, 99x0, 9984 based
-chipsets with on chipset connected led's using WMI Firmware API.  The LED
-device will get available named as "ath10k-phyX" at sysfs and can be controlled
-with various triggers.  adds also debugfs interface for gpio control.
-
-This patch is specific for OpenWRt base, as is use old backported package
-with old wireless source. Support for QCA9984 is removed and a simbol
-is added to local-simbol file to export the actually compile the code 
-with the ATH10K_LEDS simbol.
-
-
-Signed-off-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
-Reviewed-by: Steve deRosier <derosier@cal-sierra.com>
-[kvalo: major reorg and cleanup]
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
-Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
----
-
-v13:
-
-* only compile tested!
-
-* fix all checkpatch warnings
-
-* fix commit log
-
-* sizeof(struct ath10k_gpiocontrol) -> sizeof(*gpio)
-
-* unsigned -> unsigned int
-
-* remove GPIOLIB code, that should be added in a separate patch
-
-* rename gpio.c to leds.c
-
-* add leds.h
-
-* rename some functions:
-
-  ath10k_attach_led() -> ath10k_leds_register()
-  ath10k_unregister_led() -> ath10k_leds_unregister()
-  ath10k_reset_led_pin() -> ath10k_leds_start()
-
-* call ath10k_leds_unregister() before ath10k_thermal_unregister() to preserve ordering
-
-* call ath10k_leds_start() only from ath10k_core_start() and not from mac.c
-
-* rename struct ath10k_gpiocontrol as anonymous function under struct
-  ath10k::leds, no need for memory allocation
-
-* merge ath10k_add_led() to ath10k_attach_led(), which is it's only caller
-
-* remove #if IS_ENABLED() checks from most of places, memory savings from those were not worth it
-
-* Kconfig help text improvement and move it lower in the menu, also don't enable it by default
-
-* switch to set_brightness_blocking() so that the callback can sleep,
-  then no need to use ath10k_wmi_cmd_send_nowait() and can take mutex
-  to access ar->state
-
-* don't touch ath10k_wmi_pdev_get_temperature()
-
-* as QCA6174/QCA9377 are not (yet) supported don't add the command to WMI-TLV interface
-
-* remove debugfs interface, that should be added in another patch
-
-* cleanup includes
-
-
- drivers/net/wireless/ath/ath10k/Kconfig   |  10 +++
- drivers/net/wireless/ath/ath10k/Makefile  |   1 +
- drivers/net/wireless/ath/ath10k/core.c    |  22 +++++++
- drivers/net/wireless/ath/ath10k/core.h    |   9 ++-
- drivers/net/wireless/ath/ath10k/hw.h      |   1 +
- drivers/net/wireless/ath/ath10k/leds.c    | 103 ++++++++++++++++++++++++++++++
- drivers/net/wireless/ath/ath10k/leds.h    |  45 +++++++++++++
- drivers/net/wireless/ath/ath10k/mac.c     |   1 +
- drivers/net/wireless/ath/ath10k/wmi-ops.h |  32 ++++++++++
- drivers/net/wireless/ath/ath10k/wmi-tlv.c |   2 +
- drivers/net/wireless/ath/ath10k/wmi.c     |  54 ++++++++++++++++
- drivers/net/wireless/ath/ath10k/wmi.h     |  35 ++++++++++
- 12 files changed, 314 insertions(+), 1 deletion(-)
- create mode 100644 drivers/net/wireless/ath/ath10k/leds.c
- create mode 100644 drivers/net/wireless/ath/ath10k/leds.h
---- a/drivers/net/wireless/ath/ath10k/Kconfig
-+++ b/drivers/net/wireless/ath/ath10k/Kconfig
-@@ -71,6 +71,16 @@ config ATH10K_DEBUGFS
- 
- 	  If unsure, say Y to make it easier to debug problems.
- 
-+config ATH10K_LEDS
-+	bool "Atheros ath10k LED support"
-+	depends on ATH10K
-+	select MAC80211_LEDS
-+	select LEDS_CLASS
-+	select NEW_LEDS
-+	default y
-+	---help---
-+	  This option is necessary, if you want LED support for chipset connected led pins. If unsure, say N.
-+
- config ATH10K_SPECTRAL
- 	bool "Atheros ath10k spectral scan support"
- 	depends on ATH10K_DEBUGFS
---- a/drivers/net/wireless/ath/ath10k/Makefile
-+++ b/drivers/net/wireless/ath/ath10k/Makefile
-@@ -19,6 +19,7 @@ ath10k_core-$(CPTCFG_ATH10K_SPECTRAL) +=
- ath10k_core-$(CPTCFG_NL80211_TESTMODE) += testmode.o
- ath10k_core-$(CPTCFG_ATH10K_TRACING) += trace.o
- ath10k_core-$(CPTCFG_ATH10K_THERMAL) += thermal.o
-+ath10k_core-$(CPTCFG_ATH10K_LEDS) += leds.o
- ath10k_core-$(CPTCFG_MAC80211_DEBUGFS) += debugfs_sta.o
- ath10k_core-$(CONFIG_PM) += wow.o
- ath10k_core-$(CONFIG_DEV_COREDUMP) += coredump.o
---- a/local-symbols
-+++ b/local-symbols
-@@ -162,6 +162,7 @@ ATH10K_DEBUG=
- ATH10K_DEBUGFS=
- ATH10K_SPECTRAL=
- ATH10K_THERMAL=
-+ATH10K_LEDS=
- ATH10K_TRACING=
- ATH10K_DFS_CERTIFIED=
- WCN36XX=
---- a/drivers/net/wireless/ath/ath10k/core.c
-+++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -26,6 +26,7 @@
- #include "testmode.h"
- #include "wmi-ops.h"
- #include "coredump.h"
-+#include "leds.h"
- 
- unsigned int ath10k_debug_mask;
- EXPORT_SYMBOL(ath10k_debug_mask);
-@@ -65,6 +66,7 @@ static const struct ath10k_hw_params ath
- 		.dev_id = QCA988X_2_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
- 		.name = "qca988x hw2.0",
-+		.led_pin = 1,
- 		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
-@@ -146,6 +148,7 @@ static const struct ath10k_hw_params ath
- 		.dev_id = QCA9887_1_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
- 		.name = "qca9887 hw1.0",
-+		.led_pin = 1,
- 		.patch_load_addr = QCA9887_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
-@@ -387,6 +390,7 @@ static const struct ath10k_hw_params ath
- 		.dev_id = QCA99X0_2_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
- 		.name = "qca99x0 hw2.0",
-+		.led_pin = 17,
- 		.patch_load_addr = QCA99X0_HW_2_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
- 		.otp_exe_param = 0x00000700,
-@@ -433,6 +437,7 @@ static const struct ath10k_hw_params ath
- 		.dev_id = QCA9984_1_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
- 		.name = "qca9984/qca9994 hw1.0",
-+		.led_pin = 17,
- 		.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
-@@ -486,6 +491,7 @@ static const struct ath10k_hw_params ath
- 		.dev_id = QCA9888_2_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
- 		.name = "qca9888 hw2.0",
-+		.led_pin = 17,
- 		.patch_load_addr = QCA9888_HW_2_0_PATCH_LOAD_ADDR,
- 		.uart_pin = 7,
- 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
-@@ -3231,6 +3237,10 @@ int ath10k_core_start(struct ath10k *ar,
- 		goto err_hif_stop;
- 	}
- 
-+	status = ath10k_leds_start(ar);
-+	if (status)
-+		goto err_hif_stop;
-+
- 	return 0;
- 
- err_hif_stop:
-@@ -3489,9 +3499,18 @@ static void ath10k_core_register_work(st
- 		goto err_spectral_destroy;
- 	}
- 
-+	status = ath10k_leds_register(ar);
-+	if (status) {
-+		ath10k_err(ar, "could not register leds: %d\n",
-+			   status);
-+		goto err_thermal_unregister;
-+	}
-+
- 	set_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags);
- 	return;
- 
-+err_thermal_unregister:
-+	ath10k_thermal_unregister(ar);
- err_spectral_destroy:
- 	ath10k_spectral_destroy(ar);
- err_debug_destroy:
-@@ -3538,6 +3557,8 @@ void ath10k_core_unregister(struct ath10
- 	if (!test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))
- 		return;
- 
-+	ath10k_leds_unregister(ar);
-+
- 	ath10k_thermal_unregister(ar);
- 	/* Stop spectral before unregistering from mac80211 to remove the
- 	 * relayfs debugfs file cleanly. Otherwise the parent debugfs tree
---- a/drivers/net/wireless/ath/ath10k/core.h
-+++ b/drivers/net/wireless/ath/ath10k/core.h
-@@ -14,6 +14,7 @@
- #include <linux/pci.h>
- #include <linux/uuid.h>
- #include <linux/time.h>
-+#include <linux/leds.h>
- 
- #include "htt.h"
- #include "htc.h"
-@@ -1253,6 +1254,13 @@ struct ath10k {
- 	} testmode;
- 
- 	struct {
-+		struct gpio_led wifi_led;
-+		struct led_classdev cdev;
-+		char label[48];
-+		u32 gpio_state_pin;
-+	} leds;
-+
-+	struct {
- 		/* protected by data_lock */
- 		u32 rx_crc_err_drop;
- 		u32 fw_crash_counter;
---- a/drivers/net/wireless/ath/ath10k/hw.h
-+++ b/drivers/net/wireless/ath/ath10k/hw.h
-@@ -519,6 +519,7 @@ struct ath10k_hw_params {
- 	const char *name;
- 	u32 patch_load_addr;
- 	int uart_pin;
-+	int led_pin;
- 	u32 otp_exe_param;
- 
- 	/* Type of hw cycle counter wraparound logic, for more info
---- /dev/null
-+++ b/drivers/net/wireless/ath/ath10k/leds.c
-@@ -0,0 +1,103 @@
-+/*
-+ * Copyright (c) 2005-2011 Atheros Communications Inc.
-+ * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
-+ * Copyright (c) 2018 Sebastian Gottschall <s.gottschall@dd-wrt.com>
-+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
-+ *
-+ * Permission to use, copy, modify, and/or distribute this software for any
-+ * purpose with or without fee is hereby granted, provided that the above
-+ * copyright notice and this permission notice appear in all copies.
-+ *
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ */
-+
-+#include <linux/leds.h>
-+
-+#include "core.h"
-+#include "wmi.h"
-+#include "wmi-ops.h"
-+
-+#include "leds.h"
-+
-+static int ath10k_leds_set_brightness_blocking(struct led_classdev *led_cdev,
-+					       enum led_brightness brightness)
-+{
-+	struct ath10k *ar = container_of(led_cdev, struct ath10k,
-+					 leds.cdev);
-+	struct gpio_led *led = &ar->leds.wifi_led;
-+
-+	mutex_lock(&ar->conf_mutex);
-+
-+	if (ar->state != ATH10K_STATE_ON)
-+		goto out;
-+
-+	ar->leds.gpio_state_pin = (brightness != LED_OFF) ^ led->active_low;
-+	ath10k_wmi_gpio_output(ar, led->gpio, ar->leds.gpio_state_pin);
-+
-+out:
-+	mutex_unlock(&ar->conf_mutex);
-+
-+	return 0;
-+}
-+
-+int ath10k_leds_start(struct ath10k *ar)
-+{
-+	if (ar->hw_params.led_pin == 0)
-+		/* leds not supported */
-+		return 0;
-+
-+	/* under some circumstances, the gpio pin gets reconfigured
-+	 * to default state by the firmware, so we need to
-+	 * reconfigure it this behaviour has only ben seen on
-+	 * QCA9984 and QCA99XX devices so far
-+	 */
-+	ath10k_wmi_gpio_config(ar, ar->hw_params.led_pin, 0,
-+			       WMI_GPIO_PULL_NONE, WMI_GPIO_INTTYPE_DISABLE);
-+	ath10k_wmi_gpio_output(ar, ar->hw_params.led_pin, 1);
-+
-+	return 0;
-+}
-+
-+int ath10k_leds_register(struct ath10k *ar)
-+{
-+	int ret;
-+
-+	if (ar->hw_params.led_pin == 0)
-+		/* leds not supported */
-+		return 0;
-+
-+	snprintf(ar->leds.label, sizeof(ar->leds.label), "ath10k-%s",
-+		 wiphy_name(ar->hw->wiphy));
-+	ar->leds.wifi_led.active_low = 1;
-+	ar->leds.wifi_led.gpio = ar->hw_params.led_pin;
-+	ar->leds.wifi_led.name = ar->leds.label;
-+	ar->leds.wifi_led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
-+
-+	ar->leds.cdev.name = ar->leds.label;
-+	ar->leds.cdev.brightness_set_blocking = ath10k_leds_set_brightness_blocking;
-+
-+	/* FIXME: this assignment doesn't make sense as it's NULL, remove it? */
-+	ar->leds.cdev.default_trigger = ar->leds.wifi_led.default_trigger;
-+
-+	ret = led_classdev_register(wiphy_dev(ar->hw->wiphy), &ar->leds.cdev);
-+	if (ret)
-+		return ret;
-+
-+	return 0;
-+}
-+
-+void ath10k_leds_unregister(struct ath10k *ar)
-+{
-+	if (ar->hw_params.led_pin == 0)
-+		/* leds not supported */
-+		return;
-+
-+	led_classdev_unregister(&ar->leds.cdev);
-+}
-+
---- /dev/null
-+++ b/drivers/net/wireless/ath/ath10k/leds.h
-@@ -0,0 +1,41 @@
-+/*
-+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
-+ *
-+ * Permission to use, copy, modify, and/or distribute this software for any
-+ * purpose with or without fee is hereby granted, provided that the above
-+ * copyright notice and this permission notice appear in all copies.
-+ *
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ */
-+#ifndef _LEDS_H_
-+#define _LEDS_H_
-+
-+#include "core.h"
-+
-+#ifdef CPTCFG_ATH10K_LEDS
-+void ath10k_leds_unregister(struct ath10k *ar);
-+int ath10k_leds_start(struct ath10k *ar);
-+int ath10k_leds_register(struct ath10k *ar);
-+#else
-+static inline void ath10k_leds_unregister(struct ath10k *ar)
-+{
-+}
-+
-+static inline int ath10k_leds_start(struct ath10k *ar)
-+{
-+	return 0;
-+}
-+
-+static inline int ath10k_leds_register(struct ath10k *ar)
-+{
-+	return 0;
-+}
-+
-+#endif
-+#endif /* _LEDS_H_ */
---- a/drivers/net/wireless/ath/ath10k/mac.c
-+++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -24,6 +24,7 @@
- #include "wmi-tlv.h"
- #include "wmi-ops.h"
- #include "wow.h"
-+#include "leds.h"
- 
- /*********/
- /* Rates */
---- a/drivers/net/wireless/ath/ath10k/wmi-ops.h
-+++ b/drivers/net/wireless/ath/ath10k/wmi-ops.h
-@@ -226,7 +226,10 @@ struct wmi_ops {
- 			 const struct wmi_bb_timing_cfg_arg *arg);
- 	struct sk_buff *(*gen_per_peer_per_tid_cfg)(struct ath10k *ar,
- 						    const struct wmi_per_peer_per_tid_cfg_arg *arg);
-+	struct sk_buff *(*gen_gpio_config)(struct ath10k *ar, u32 gpio_num,
-+					   u32 input, u32 pull_type, u32 intr_mode);
- 
-+	struct sk_buff *(*gen_gpio_output)(struct ath10k *ar, u32 gpio_num, u32 set);
- };
- 
- int ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id);
-@@ -1122,6 +1125,35 @@ ath10k_wmi_force_fw_hang(struct ath10k *
- 	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->force_fw_hang_cmdid);
- }
- 
-+static inline int ath10k_wmi_gpio_config(struct ath10k *ar, u32 gpio_num,
-+					 u32 input, u32 pull_type, u32 intr_mode)
-+{
-+	struct sk_buff *skb;
-+
-+	if (!ar->wmi.ops->gen_gpio_config)
-+		return -EOPNOTSUPP;
-+
-+	skb = ar->wmi.ops->gen_gpio_config(ar, gpio_num, input, pull_type, intr_mode);
-+	if (IS_ERR(skb))
-+		return PTR_ERR(skb);
-+
-+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_config_cmdid);
-+}
-+
-+static inline int ath10k_wmi_gpio_output(struct ath10k *ar, u32 gpio_num, u32 set)
-+{
-+	struct sk_buff *skb;
-+
-+	if (!ar->wmi.ops->gen_gpio_config)
-+		return -EOPNOTSUPP;
-+
-+	skb = ar->wmi.ops->gen_gpio_output(ar, gpio_num, set);
-+	if (IS_ERR(skb))
-+		return PTR_ERR(skb);
-+
-+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_output_cmdid);
-+}
-+
- static inline int
- ath10k_wmi_dbglog_cfg(struct ath10k *ar, u64 module_enable, u32 log_level)
- {
---- a/drivers/net/wireless/ath/ath10k/wmi-tlv.c
-+++ b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
-@@ -4594,6 +4594,8 @@ static const struct wmi_ops wmi_tlv_ops
- 	.gen_echo = ath10k_wmi_tlv_op_gen_echo,
- 	.gen_vdev_spectral_conf = ath10k_wmi_tlv_op_gen_vdev_spectral_conf,
- 	.gen_vdev_spectral_enable = ath10k_wmi_tlv_op_gen_vdev_spectral_enable,
-+	/* .gen_gpio_config not implemented */
-+	/* .gen_gpio_output not implemented */
- };
- 
- static const struct wmi_peer_flags_map wmi_tlv_peer_flags_map = {
---- a/drivers/net/wireless/ath/ath10k/wmi.c
-+++ b/drivers/net/wireless/ath/ath10k/wmi.c
-@@ -7472,6 +7472,49 @@ ath10k_wmi_op_gen_peer_set_param(struct
- 	return skb;
- }
- 
-+static struct sk_buff *ath10k_wmi_op_gen_gpio_config(struct ath10k *ar,
-+						     u32 gpio_num, u32 input,
-+						     u32 pull_type, u32 intr_mode)
-+{
-+	struct wmi_gpio_config_cmd *cmd;
-+	struct sk_buff *skb;
-+
-+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
-+	if (!skb)
-+		return ERR_PTR(-ENOMEM);
-+
-+	cmd = (struct wmi_gpio_config_cmd *)skb->data;
-+	cmd->pull_type = __cpu_to_le32(pull_type);
-+	cmd->gpio_num = __cpu_to_le32(gpio_num);
-+	cmd->input = __cpu_to_le32(input);
-+	cmd->intr_mode = __cpu_to_le32(intr_mode);
-+
-+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_config gpio_num 0x%08x input 0x%08x pull_type 0x%08x intr_mode 0x%08x\n",
-+		   gpio_num, input, pull_type, intr_mode);
-+
-+	return skb;
-+}
-+
-+static struct sk_buff *ath10k_wmi_op_gen_gpio_output(struct ath10k *ar,
-+						     u32 gpio_num, u32 set)
-+{
-+	struct wmi_gpio_output_cmd *cmd;
-+	struct sk_buff *skb;
-+
-+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
-+	if (!skb)
-+		return ERR_PTR(-ENOMEM);
-+
-+	cmd = (struct wmi_gpio_output_cmd *)skb->data;
-+	cmd->gpio_num = __cpu_to_le32(gpio_num);
-+	cmd->set = __cpu_to_le32(set);
-+
-+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_output gpio_num 0x%08x set 0x%08x\n",
-+		   gpio_num, set);
-+
-+	return skb;
-+}
-+
- static struct sk_buff *
- ath10k_wmi_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,
- 			     enum wmi_sta_ps_mode psmode)
-@@ -9160,6 +9203,9 @@ static const struct wmi_ops wmi_ops = {
- 	.fw_stats_fill = ath10k_wmi_main_op_fw_stats_fill,
- 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
- 	.gen_echo = ath10k_wmi_op_gen_echo,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
-+
- 	/* .gen_bcn_tmpl not implemented */
- 	/* .gen_prb_tmpl not implemented */
- 	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -9230,6 +9276,8 @@ static const struct wmi_ops wmi_10_1_ops
- 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
- 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
- 	.gen_echo = ath10k_wmi_op_gen_echo,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- 	/* .gen_bcn_tmpl not implemented */
- 	/* .gen_prb_tmpl not implemented */
- 	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -9302,6 +9350,8 @@ static const struct wmi_ops wmi_10_2_ops
- 	.gen_delba_send = ath10k_wmi_op_gen_delba_send,
- 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
- 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- 	/* .gen_pdev_enable_adaptive_cca not implemented */
- };
- 
-@@ -9373,6 +9423,8 @@ static const struct wmi_ops wmi_10_2_4_o
- 		ath10k_wmi_op_gen_pdev_enable_adaptive_cca,
- 	.get_vdev_subtype = ath10k_wmi_10_2_4_op_get_vdev_subtype,
- 	.gen_bb_timing = ath10k_wmi_10_2_4_op_gen_bb_timing,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- 	/* .gen_bcn_tmpl not implemented */
- 	/* .gen_prb_tmpl not implemented */
- 	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -9454,6 +9506,8 @@ static const struct wmi_ops wmi_10_4_ops
- 	.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,
- 	.gen_echo = ath10k_wmi_op_gen_echo,
- 	.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,
-+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
-+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
- };
- 
- int ath10k_wmi_attach(struct ath10k *ar)
---- a/drivers/net/wireless/ath/ath10k/wmi.h
-+++ b/drivers/net/wireless/ath/ath10k/wmi.h
-@@ -3030,6 +3030,41 @@ enum wmi_10_4_feature_mask {
- 
- };
- 
-+/* WMI_GPIO_CONFIG_CMDID */
-+enum {
-+	WMI_GPIO_PULL_NONE,
-+	WMI_GPIO_PULL_UP,
-+	WMI_GPIO_PULL_DOWN,
-+};
-+
-+enum {
-+	WMI_GPIO_INTTYPE_DISABLE,
-+	WMI_GPIO_INTTYPE_RISING_EDGE,
-+	WMI_GPIO_INTTYPE_FALLING_EDGE,
-+	WMI_GPIO_INTTYPE_BOTH_EDGE,
-+	WMI_GPIO_INTTYPE_LEVEL_LOW,
-+	WMI_GPIO_INTTYPE_LEVEL_HIGH
-+};
-+
-+/* WMI_GPIO_CONFIG_CMDID */
-+struct wmi_gpio_config_cmd {
-+	__le32 gpio_num;             /* GPIO number to be setup */
-+	__le32 input;                /* 0 - Output/ 1 - Input */
-+	__le32 pull_type;            /* Pull type defined above */
-+	__le32 intr_mode;            /* Interrupt mode defined above (Input) */
-+} __packed;
-+
-+/* WMI_GPIO_OUTPUT_CMDID */
-+struct wmi_gpio_output_cmd {
-+	__le32 gpio_num;    /* GPIO number to be setup */
-+	__le32 set;         /* Set the GPIO pin*/
-+} __packed;
-+
-+/* WMI_GPIO_INPUT_EVENTID */
-+struct wmi_gpio_input_event {
-+	__le32 gpio_num;    /* GPIO number which changed state */
-+} __packed;
-+
- struct wmi_ext_resource_config_10_4_cmd {
- 	/* contains enum wmi_host_platform_type */
- 	__le32 host_platform_config;
diff --git a/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch b/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
index 4c1f9aa8..fc41f5f1 100644
--- a/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
+++ b/package/kernel/mac80211/patches/ath10k/975-ath10k-use-tpt-trigger-by-default.patch
@@ -16,7 +16,7 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
 
 --- a/drivers/net/wireless/ath/ath10k/core.h
 +++ b/drivers/net/wireless/ath/ath10k/core.h
-@@ -1309,6 +1309,10 @@ struct ath10k {
+@@ -1315,6 +1315,10 @@ struct ath10k {
  	s32 tx_power_2g_limit;
  	s32 tx_power_5g_limit;
  
@@ -29,12 +29,10 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
  };
 --- a/drivers/net/wireless/ath/ath10k/leds.c
 +++ b/drivers/net/wireless/ath/ath10k/leds.c
-@@ -81,9 +81,7 @@ int ath10k_leds_register(struct ath10k *
+@@ -70,7 +70,7 @@ int ath10k_leds_register(struct ath10k *
  
  	ar->leds.cdev.name = ar->leds.label;
  	ar->leds.cdev.brightness_set_blocking = ath10k_leds_set_brightness_blocking;
--
--	/* FIXME: this assignment doesn't make sense as it's NULL, remove it? */
 -	ar->leds.cdev.default_trigger = ar->leds.wifi_led.default_trigger;
 +	ar->leds.cdev.default_trigger = ar->led_default_trigger;
  
@@ -42,7 +40,7 @@ Signed-off-by: Mathias Kresin <dev@kresin.me>
  	if (ret)
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -10284,7 +10284,7 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10297,7 +10297,7 @@ int ath10k_mac_register(struct ath10k *a
  	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
  
  #ifdef CPTCFG_MAC80211_LEDS
diff --git a/package/kernel/mac80211/patches/ath10k/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch b/package/kernel/mac80211/patches/ath10k/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
index 3626debf..f1770cfb 100644
--- a/package/kernel/mac80211/patches/ath10k/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
+++ b/package/kernel/mac80211/patches/ath10k/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
@@ -28,7 +28,7 @@ Forwarded: no
 
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -1028,6 +1028,40 @@ static inline int ath10k_vdev_setup_sync
+@@ -1022,6 +1022,40 @@ static inline int ath10k_vdev_setup_sync
  	return ar->last_wmi_vdev_start_status;
  }
  
@@ -69,7 +69,7 @@ Forwarded: no
  static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
  {
  	struct cfg80211_chan_def *chandef = NULL;
-@@ -1060,7 +1094,8 @@ static int ath10k_monitor_vdev_start(str
+@@ -1054,7 +1088,8 @@ static int ath10k_monitor_vdev_start(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = channel->max_power * 2;
  	arg.channel.max_reg_power = channel->max_reg_power * 2;
@@ -79,7 +79,7 @@ Forwarded: no
  
  	reinit_completion(&ar->vdev_setup_done);
  	reinit_completion(&ar->vdev_delete_done);
-@@ -1506,7 +1541,8 @@ static int ath10k_vdev_start_restart(str
+@@ -1500,7 +1535,8 @@ static int ath10k_vdev_start_restart(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = chandef->chan->max_power * 2;
  	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
@@ -89,7 +89,7 @@ Forwarded: no
  
  	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
  		arg.ssid = arvif->u.ap.ssid;
-@@ -3437,7 +3473,8 @@ static int ath10k_update_channel_list(st
+@@ -3431,7 +3467,8 @@ static int ath10k_update_channel_list(st
  			ch->min_power = 0;
  			ch->max_power = channel->max_power * 2;
  			ch->max_reg_power = channel->max_reg_power * 2;
diff --git a/package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch b/package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch
index 084e28a2..beec6a95 100644
--- a/package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch
+++ b/package/kernel/mac80211/patches/ath10k/984-ath10k-Try-to-get-mac-address-from-dts.patch
@@ -18,7 +18,7 @@ Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
 
 --- a/drivers/net/wireless/ath/ath10k/core.c
 +++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -8,6 +8,7 @@
+@@ -9,6 +9,7 @@
  #include <linux/module.h>
  #include <linux/firmware.h>
  #include <linux/of.h>
@@ -26,7 +26,7 @@ Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
  #include <linux/property.h>
  #include <linux/dmi.h>
  #include <linux/ctype.h>
-@@ -3407,6 +3408,8 @@ static int ath10k_core_probe_fw(struct a
+@@ -3411,6 +3412,8 @@ static int ath10k_core_probe_fw(struct a
  
  	device_get_mac_address(ar->dev, ar->mac_addr);
  
diff --git a/package/kernel/mac80211/patches/ath10k/985-ath10k-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/ath10k/985-ath10k-allow-vht-on-2g.patch
deleted file mode 100644
index 3fb26bff..00000000
--- a/package/kernel/mac80211/patches/ath10k/985-ath10k-allow-vht-on-2g.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/ath/ath10k/mac.c
-+++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -5034,6 +5034,7 @@ static void ath10k_mac_setup_ht_vht_cap(
- 	if (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {
- 		band = &ar->mac.sbands[NL80211_BAND_2GHZ];
- 		band->ht_cap = ht_cap;
-+		band->vht_cap = vht_cap;
- 	}
- 	if (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {
- 		band = &ar->mac.sbands[NL80211_BAND_5GHZ];
diff --git a/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch b/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch
index f4b1ded1..b9cdae7e 100644
--- a/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch
+++ b/package/kernel/mac80211/patches/ath10k/988-ath10k-always-use-mac80211-loss-detection.patch
@@ -18,7 +18,7 @@ Signed-off-by: David Bauer <mail@david-bauer.net>
 
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -10081,7 +10081,6 @@ int ath10k_mac_register(struct ath10k *a
+@@ -10089,7 +10089,6 @@ int ath10k_mac_register(struct ath10k *a
  	ieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);
  	ieee80211_hw_set(ar->hw, QUEUE_CONTROL);
  	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
diff --git a/package/kernel/mac80211/patches/ath10k/990-ath10k-small-buffers.patch b/package/kernel/mac80211/patches/ath10k/990-ath10k-small-buffers.patch
index 2f560c70..755982a7 100644
--- a/package/kernel/mac80211/patches/ath10k/990-ath10k-small-buffers.patch
+++ b/package/kernel/mac80211/patches/ath10k/990-ath10k-small-buffers.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/htt.h
 +++ b/drivers/net/wireless/ath/ath10k/htt.h
-@@ -235,7 +235,11 @@ enum htt_rx_ring_flags {
+@@ -236,7 +236,11 @@ enum htt_rx_ring_flags {
  };
  
  #define HTT_RX_RING_SIZE_MIN 128
@@ -14,7 +14,7 @@
  #define HTT_RX_RING_FILL_LEVEL_DUAL_MAC (HTT_RX_RING_SIZE - 1)
 --- a/drivers/net/wireless/ath/ath10k/pci.c
 +++ b/drivers/net/wireless/ath/ath10k/pci.c
-@@ -131,7 +131,11 @@ static const struct ce_attr pci_host_ce_
+@@ -132,7 +132,11 @@ static const struct ce_attr pci_host_ce_
  		.flags = CE_ATTR_FLAGS,
  		.src_nentries = 0,
  		.src_sz_max = 2048,
@@ -26,7 +26,7 @@
  		.recv_cb = ath10k_pci_htt_htc_rx_cb,
  	},
  
-@@ -140,7 +144,11 @@ static const struct ce_attr pci_host_ce_
+@@ -141,7 +145,11 @@ static const struct ce_attr pci_host_ce_
  		.flags = CE_ATTR_FLAGS,
  		.src_nentries = 0,
  		.src_sz_max = 2048,
@@ -38,7 +38,7 @@
  		.recv_cb = ath10k_pci_htc_rx_cb,
  	},
  
-@@ -167,7 +175,11 @@ static const struct ce_attr pci_host_ce_
+@@ -168,7 +176,11 @@ static const struct ce_attr pci_host_ce_
  		.flags = CE_ATTR_FLAGS,
  		.src_nentries = 0,
  		.src_sz_max = 512,
@@ -50,7 +50,7 @@
  		.recv_cb = ath10k_pci_htt_rx_cb,
  	},
  
-@@ -192,7 +204,11 @@ static const struct ce_attr pci_host_ce_
+@@ -193,7 +205,11 @@ static const struct ce_attr pci_host_ce_
  		.flags = CE_ATTR_FLAGS,
  		.src_nentries = 0,
  		.src_sz_max = 2048,
diff --git a/package/kernel/mac80211/patches/ath11k/0001-wifi-ath11k-stop-tx-queues-immediately-upon-firmware.patch b/package/kernel/mac80211/patches/ath11k/0001-wifi-ath11k-stop-tx-queues-immediately-upon-firmware.patch
deleted file mode 100644
index d0dc04fe..00000000
--- a/package/kernel/mac80211/patches/ath11k/0001-wifi-ath11k-stop-tx-queues-immediately-upon-firmware.patch
+++ /dev/null
@@ -1,78 +0,0 @@
-From 81e60b2dfb2744ab6642c4aa62534b4f711fdc5d Mon Sep 17 00:00:00 2001
-From: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Date: Tue, 27 Sep 2022 09:18:54 +0300
-Subject: [PATCH] wifi: ath11k: stop tx queues immediately upon firmware exit
-
-Currently, recovery flag is set immediately upon firmware
-exit but tx queues are stopped once firmware arrives back
-and is ready which is during ath11k_core_restart. Once
-ieee80211 hw restart is completed, tx queues are resumed.
-If during the time delta between firmware exit and firmware
-ready, mac80211 send packets, currently ath11k will drop it
-since recovery flag will be set. But warning prints will
-come -
-  "ath11k c000000.wifi: failed to transmit frame -108"
-
-If more tx packets are there, this could lead to flooding
-of above print.
-
-However, actually tx queues should be stopped immediately
-when firmware leaves. This will prevent packets to get
-dropped when firmware is recovering.
-
-Add fix to stop tx queues immediately after firmware exit.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20220923170235.18873-1-quic_adisi@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 5 +----
- drivers/net/wireless/ath/ath11k/core.h | 1 +
- drivers/net/wireless/ath/ath11k/qmi.c  | 3 +++
- 3 files changed, 5 insertions(+), 4 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -1641,7 +1641,7 @@ static void ath11k_update_11d(struct wor
- 	}
- }
- 
--static void ath11k_core_pre_reconfigure_recovery(struct ath11k_base *ab)
-+void ath11k_core_pre_reconfigure_recovery(struct ath11k_base *ab)
- {
- 	struct ath11k *ar;
- 	struct ath11k_pdev *pdev;
-@@ -1730,9 +1730,6 @@ static void ath11k_core_restart(struct w
- 	struct ath11k_base *ab = container_of(work, struct ath11k_base, restart_work);
- 	int ret;
- 
--	if (!ab->is_reset)
--		ath11k_core_pre_reconfigure_recovery(ab);
--
- 	ret = ath11k_core_reconfigure_on_crash(ab);
- 	if (ret) {
- 		ath11k_err(ab, "failed to reconfigure driver on crash recovery\n");
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -1158,6 +1158,7 @@ int ath11k_core_check_smbios(struct ath1
- void ath11k_core_halt(struct ath11k *ar);
- int ath11k_core_resume(struct ath11k_base *ab);
- int ath11k_core_suspend(struct ath11k_base *ab);
-+void ath11k_core_pre_reconfigure_recovery(struct ath11k_base *ab);
- 
- const struct firmware *ath11k_core_firmware_request(struct ath11k_base *ab,
- 						    const char *filename);
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -3164,6 +3164,9 @@ static void ath11k_qmi_driver_event_work
- 		case ATH11K_QMI_EVENT_SERVER_EXIT:
- 			set_bit(ATH11K_FLAG_CRASH_FLUSH, &ab->dev_flags);
- 			set_bit(ATH11K_FLAG_RECOVERY, &ab->dev_flags);
-+
-+			if (!ab->is_reset)
-+				ath11k_core_pre_reconfigure_recovery(ab);
- 			break;
- 		case ATH11K_QMI_EVENT_REQUEST_MEM:
- 			ret = ath11k_qmi_event_mem_request(qmi);
diff --git a/package/kernel/mac80211/patches/ath11k/0002-wifi-ath11k-Don-t-exit-on-wakeup-failure.patch b/package/kernel/mac80211/patches/ath11k/0002-wifi-ath11k-Don-t-exit-on-wakeup-failure.patch
deleted file mode 100644
index 47385e04..00000000
--- a/package/kernel/mac80211/patches/ath11k/0002-wifi-ath11k-Don-t-exit-on-wakeup-failure.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From 45d2e268369b0c768d5a644f319758bcfd370521 Mon Sep 17 00:00:00 2001
-From: Baochen Qiang <quic_bqiang@quicinc.com>
-Date: Wed, 28 Sep 2022 09:51:40 +0800
-Subject: [PATCH] wifi: ath11k: Don't exit on wakeup failure
-
-Currently, ath11k_pcic_read() returns an error if wakeup()
-fails, this makes firmware crash debug quite hard because we can
-get nothing.
-
-Change to go ahead on wakeup failure, in that case we still may
-get something valid to check. There should be no mislead due
-to incorrect content because we are aware of the failure with the
-log printed.
-
-Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-01720.1-QCAHSPSWPL_V1_V2_SILICONZ_LITE-1
-
-Signed-off-by: Baochen Qiang <quic_bqiang@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20220928015140.5431-1-quic_bqiang@quicinc.com
----
- drivers/net/wireless/ath/ath11k/pcic.c | 13 ++++++++++---
- 1 file changed, 10 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/pcic.c
-+++ b/drivers/net/wireless/ath/ath11k/pcic.c
-@@ -218,9 +218,16 @@ int ath11k_pcic_read(struct ath11k_base
- 	if (wakeup_required && ab->pci.ops->wakeup) {
- 		ret = ab->pci.ops->wakeup(ab);
- 		if (ret) {
--			ath11k_warn(ab, "failed to wakeup for read from 0x%x: %d\n",
--				    start, ret);
--			return ret;
-+			ath11k_warn(ab,
-+				    "wakeup failed, data may be invalid: %d",
-+				    ret);
-+			/* Even though wakeup() failed, continue processing rather
-+			 * than returning because some parts of the data may still
-+			 * be valid and useful in some cases, e.g. could give us
-+			 * some clues on firmware crash.
-+			 * Mislead due to invalid data could be avoided because we
-+			 * are aware of the wakeup failure.
-+			 */
- 		}
- 	}
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0005-wifi-ath11k-Fix-spelling-mistake-chnange-change.patch b/package/kernel/mac80211/patches/ath11k/0005-wifi-ath11k-Fix-spelling-mistake-chnange-change.patch
deleted file mode 100644
index 4b52252e..00000000
--- a/package/kernel/mac80211/patches/ath11k/0005-wifi-ath11k-Fix-spelling-mistake-chnange-change.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From a797f479bf3e02c6d179c2e6aeace7f9b22b0acd Mon Sep 17 00:00:00 2001
-From: Colin Ian King <colin.i.king@gmail.com>
-Date: Wed, 28 Sep 2022 15:38:34 +0100
-Subject: [PATCH] wifi: ath11k: Fix spelling mistake "chnange" -> "change"
-
-There is a spelling mistake in an ath11k_dbg debug message. Fix it.
-
-Signed-off-by: Colin Ian King <colin.i.king@gmail.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20220928143834.35189-1-colin.i.king@gmail.com
----
- drivers/net/wireless/ath/ath11k/wmi.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -6829,7 +6829,7 @@ static void ath11k_wmi_event_peer_sta_ps
- 	}
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI,
--		   "peer sta ps chnange ev addr %pM state %u sup_bitmap %x ps_valid %u ts %u\n",
-+		   "peer sta ps change ev addr %pM state %u sup_bitmap %x ps_valid %u ts %u\n",
- 		   ev->peer_macaddr.addr, ev->peer_ps_state,
- 		   ev->ps_supported_bitmap, ev->peer_ps_valid,
- 		   ev->peer_ps_timestamp);
diff --git a/package/kernel/mac80211/patches/ath11k/0007-wifi-ath11k-suppress-add-interface-error.patch b/package/kernel/mac80211/patches/ath11k/0007-wifi-ath11k-suppress-add-interface-error.patch
deleted file mode 100644
index fbef0abb..00000000
--- a/package/kernel/mac80211/patches/ath11k/0007-wifi-ath11k-suppress-add-interface-error.patch
+++ /dev/null
@@ -1,52 +0,0 @@
-From 638b26652b0438563a76ec90014c8cba34db982b Mon Sep 17 00:00:00 2001
-From: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
-Date: Thu, 6 Oct 2022 06:28:42 +0530
-Subject: [PATCH 7/9] wifi: ath11k: suppress add interface error
-
-In the VIF (other than monitor type) creation request, we should not
-throw the error code when the monitor VIF creation fails, since the
-actual VIF creation succeeds. If we throw the error code from driver
-then the actual VIF creation get fail. So suppress the monitor VIF
-creation error by throwing warning message instead of error code.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.6.0.1-00760-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Karthikeyan Periyasamy <quic_periyasa@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221006005842.8599-1-quic_periyasa@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 9 +++------
- 1 file changed, 3 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -6421,18 +6421,16 @@ static int ath11k_mac_op_add_interface(s
- 
- 	ath11k_dp_vdev_tx_attach(ar, arvif);
- 
-+	ath11k_debugfs_add_interface(arvif);
-+
- 	if (vif->type != NL80211_IFTYPE_MONITOR &&
- 	    test_bit(ATH11K_FLAG_MONITOR_CONF_ENABLED, &ar->monitor_flags)) {
- 		ret = ath11k_mac_monitor_vdev_create(ar);
--		if (ret) {
-+		if (ret)
- 			ath11k_warn(ar->ab, "failed to create monitor vdev during add interface: %d",
- 				    ret);
--			goto err_peer_del;
--		}
- 	}
- 
--	ath11k_debugfs_add_interface(arvif);
--
- 	mutex_unlock(&ar->conf_mutex);
- 
- 	return 0;
-@@ -6457,7 +6455,6 @@ err_vdev_del:
- 	spin_unlock_bh(&ar->data_lock);
- 
- err:
--	ath11k_debugfs_remove_interface(arvif);
- 	mutex_unlock(&ar->conf_mutex);
- 
- 	return ret;
diff --git a/package/kernel/mac80211/patches/ath11k/0008-wifi-ath11k-add-support-to-configure-channel-dwell-t.patch b/package/kernel/mac80211/patches/ath11k/0008-wifi-ath11k-add-support-to-configure-channel-dwell-t.patch
deleted file mode 100644
index d0b19fe5..00000000
--- a/package/kernel/mac80211/patches/ath11k/0008-wifi-ath11k-add-support-to-configure-channel-dwell-t.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From c362daa213cdeb0a9e7c2ed84849544c24505720 Mon Sep 17 00:00:00 2001
-From: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
-Date: Fri, 7 Oct 2022 10:41:30 +0530
-Subject: [PATCH 8/9] wifi: ath11k: add support to configure channel dwell time
-
-Add support to configure channel dwell time during scan.
-Dwell time help to stay on the channel for a specified duration
-during scan and aid userspace in finding WiFi networks. Very
-useful in passive scans where longer dwell times are needed
-to find the WiFi networks.
-
-Configure channel dwell time from duration of the scan request
-received from mac80211 when the duration is non-zero. When the
-scan request does not have duration value, use the default ones,
-the current implementation.
-
-Advertise corresponding feature flag NL80211_EXT_FEATURE_SET_SCAN_DWELL
-to enable the feature.
-
-Change is applicable for all ath11k hardware.
-
-Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00887-QCAMSLSWPLZ-1
-
-Signed-off-by: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
-Reviewed-by: Jeff Johnson <quic_jjohnson@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221007051130.6067-1-quic_mpubbise@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 33 +++++++++++++++++++++++----
- 1 file changed, 29 insertions(+), 4 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -241,7 +241,10 @@ const struct htt_rx_ring_tlv_filter ath1
- #define ath11k_a_rates (ath11k_legacy_rates + 4)
- #define ath11k_a_rates_size (ARRAY_SIZE(ath11k_legacy_rates) - 4)
- 
--#define ATH11K_MAC_SCAN_TIMEOUT_MSECS 200 /* in msecs */
-+#define ATH11K_MAC_SCAN_CMD_EVT_OVERHEAD		200 /* in msecs */
-+
-+/* Overhead due to the processing of channel switch events from FW */
-+#define ATH11K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD	10 /* in msecs */
- 
- static const u32 ath11k_smps_map[] = {
- 	[WLAN_HT_CAP_SM_PS_STATIC] = WMI_PEER_SMPS_STATIC,
-@@ -3612,6 +3615,7 @@ static int ath11k_mac_op_hw_scan(struct
- 	struct scan_req_params arg;
- 	int ret = 0;
- 	int i;
-+	u32 scan_timeout;
- 
- 	mutex_lock(&ar->conf_mutex);
- 
-@@ -3681,6 +3685,26 @@ static int ath11k_mac_op_hw_scan(struct
- 		ether_addr_copy(arg.mac_mask.addr, req->mac_addr_mask);
- 	}
- 
-+	/* if duration is set, default dwell times will be overwritten */
-+	if (req->duration) {
-+		arg.dwell_time_active = req->duration;
-+		arg.dwell_time_active_2g = req->duration;
-+		arg.dwell_time_active_6g = req->duration;
-+		arg.dwell_time_passive = req->duration;
-+		arg.dwell_time_passive_6g = req->duration;
-+		arg.burst_duration = req->duration;
-+
-+		scan_timeout = min_t(u32, arg.max_rest_time *
-+				(arg.num_chan - 1) + (req->duration +
-+				ATH11K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD) *
-+				arg.num_chan, arg.max_scan_time);
-+	} else {
-+		scan_timeout = arg.max_scan_time;
-+	}
-+
-+	/* Add a margin to account for event/command processing */
-+	scan_timeout += ATH11K_MAC_SCAN_CMD_EVT_OVERHEAD;
-+
- 	ret = ath11k_start_scan(ar, &arg);
- 	if (ret) {
- 		ath11k_warn(ar->ab, "failed to start hw scan: %d\n", ret);
-@@ -3689,10 +3713,8 @@ static int ath11k_mac_op_hw_scan(struct
- 		spin_unlock_bh(&ar->data_lock);
- 	}
- 
--	/* Add a 200ms margin to account for event/command processing */
- 	ieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,
--				     msecs_to_jiffies(arg.max_scan_time +
--						      ATH11K_MAC_SCAN_TIMEOUT_MSECS));
-+				     msecs_to_jiffies(scan_timeout));
- 
- exit:
- 	kfree(arg.chan_list);
-@@ -9060,6 +9082,9 @@ static int __ath11k_mac_register(struct
- 				      NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP);
- 	}
- 
-+	wiphy_ext_feature_set(ar->hw->wiphy,
-+			      NL80211_EXT_FEATURE_SET_SCAN_DWELL);
-+
- 	ath11k_reg_init(ar);
- 
- 	if (!test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags)) {
diff --git a/package/kernel/mac80211/patches/ath11k/0010-wifi-ath11k-Fix-firmware-crash-on-vdev-delete-race-c.patch b/package/kernel/mac80211/patches/ath11k/0010-wifi-ath11k-Fix-firmware-crash-on-vdev-delete-race-c.patch
deleted file mode 100644
index 7275af06..00000000
--- a/package/kernel/mac80211/patches/ath11k/0010-wifi-ath11k-Fix-firmware-crash-on-vdev-delete-race-c.patch
+++ /dev/null
@@ -1,116 +0,0 @@
-From 3811fa1f231f1a3e29759efef4992116604aab8b Mon Sep 17 00:00:00 2001
-From: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Date: Tue, 11 Oct 2022 15:23:46 +0530
-Subject: [PATCH] wifi: ath11k: Fix firmware crash on vdev delete race
- condition
-
-Current code does not wait for vdev delete completion on vdev create
-failures and tries to send another vdev create followed by vdev set
-param to firmware with same vdev id. This causes firmware crash.
-Fix this crash by waiting for vdev delete completion on vdev
-create failures.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.6.0.1-00905-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221011095346.3901-1-quic_ssreeela@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 60 +++++++++++++++++----------
- 1 file changed, 37 insertions(+), 23 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -6233,6 +6233,40 @@ void ath11k_mac_11d_scan_stop_all(struct
- 	}
- }
- 
-+static int ath11k_mac_vdev_delete(struct ath11k *ar, struct ath11k_vif *arvif)
-+{
-+	unsigned long time_left;
-+	struct ieee80211_vif *vif = arvif->vif;
-+	int ret = 0;
-+
-+	lockdep_assert_held(&ar->conf_mutex);
-+
-+	reinit_completion(&ar->vdev_delete_done);
-+
-+	ret = ath11k_wmi_vdev_delete(ar, arvif->vdev_id);
-+	if (ret) {
-+		ath11k_warn(ar->ab, "failed to delete WMI vdev %d: %d\n",
-+			    arvif->vdev_id, ret);
-+		return ret;
-+	}
-+
-+	time_left = wait_for_completion_timeout(&ar->vdev_delete_done,
-+						ATH11K_VDEV_DELETE_TIMEOUT_HZ);
-+	if (time_left == 0) {
-+		ath11k_warn(ar->ab, "Timeout in receiving vdev delete response\n");
-+		return -ETIMEDOUT;
-+	}
-+
-+	ar->ab->free_vdev_map |= 1LL << (arvif->vdev_id);
-+	ar->allocated_vdev_map &= ~(1LL << arvif->vdev_id);
-+	ar->num_created_vdevs--;
-+
-+	ath11k_dbg(ar->ab, ATH11K_DBG_MAC, "vdev %pM deleted, vdev_id %d\n",
-+		   vif->addr, arvif->vdev_id);
-+
-+	return ret;
-+}
-+
- static int ath11k_mac_op_add_interface(struct ieee80211_hw *hw,
- 				       struct ieee80211_vif *vif)
- {
-@@ -6468,10 +6502,7 @@ err_peer_del:
- 	}
- 
- err_vdev_del:
--	ath11k_wmi_vdev_delete(ar, arvif->vdev_id);
--	ar->num_created_vdevs--;
--	ar->allocated_vdev_map &= ~(1LL << arvif->vdev_id);
--	ab->free_vdev_map |= 1LL << arvif->vdev_id;
-+	ath11k_mac_vdev_delete(ar, arvif);
- 	spin_lock_bh(&ar->data_lock);
- 	list_del(&arvif->list);
- 	spin_unlock_bh(&ar->data_lock);
-@@ -6499,7 +6530,6 @@ static void ath11k_mac_op_remove_interfa
- 	struct ath11k *ar = hw->priv;
- 	struct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);
- 	struct ath11k_base *ab = ar->ab;
--	unsigned long time_left;
- 	int ret;
- 	int i;
- 
-@@ -6520,29 +6550,13 @@ static void ath11k_mac_op_remove_interfa
- 				    arvif->vdev_id, ret);
- 	}
- 
--	reinit_completion(&ar->vdev_delete_done);
--
--	ret = ath11k_wmi_vdev_delete(ar, arvif->vdev_id);
-+	ret = ath11k_mac_vdev_delete(ar, arvif);
- 	if (ret) {
--		ath11k_warn(ab, "failed to delete WMI vdev %d: %d\n",
-+		ath11k_warn(ab, "failed to delete vdev %d: %d\n",
- 			    arvif->vdev_id, ret);
- 		goto err_vdev_del;
- 	}
- 
--	time_left = wait_for_completion_timeout(&ar->vdev_delete_done,
--						ATH11K_VDEV_DELETE_TIMEOUT_HZ);
--	if (time_left == 0) {
--		ath11k_warn(ab, "Timeout in receiving vdev delete response\n");
--		goto err_vdev_del;
--	}
--
--	ab->free_vdev_map |= 1LL << (arvif->vdev_id);
--	ar->allocated_vdev_map &= ~(1LL << arvif->vdev_id);
--	ar->num_created_vdevs--;
--
--	ath11k_dbg(ab, ATH11K_DBG_MAC, "vdev %pM deleted, vdev_id %d\n",
--		   vif->addr, arvif->vdev_id);
--
- 	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
- 		clear_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);
- 		ar->monitor_vdev_id = -1;
diff --git a/package/kernel/mac80211/patches/ath11k/0011-wifi-ath11k-fix-monitor-vdev-creation-with-firmware-.patch b/package/kernel/mac80211/patches/ath11k/0011-wifi-ath11k-fix-monitor-vdev-creation-with-firmware-.patch
deleted file mode 100644
index 2f066d0a..00000000
--- a/package/kernel/mac80211/patches/ath11k/0011-wifi-ath11k-fix-monitor-vdev-creation-with-firmware-.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From f3ca72b0327101a074a871539e61775d43908ca4 Mon Sep 17 00:00:00 2001
-From: Nagarajan Maran <quic_nmaran@quicinc.com>
-Date: Fri, 14 Oct 2022 21:20:54 +0530
-Subject: [PATCH] wifi: ath11k: fix monitor vdev creation with firmware
- recovery
-
-During firmware recovery, the monitor interface is not
-getting created in the driver and firmware since
-the respective flags are not updated properly.
-
-So after firmware recovery is successful, when monitor
-interface is brought down manually, firmware assertion
-is observed, since we are trying to bring down the
-interface which is not yet created in the firmware.
-
-Fix this by updating the monitor flags properly per
-phy#, during firmware recovery.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221014155054.11471-1-quic_nmaran@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -1677,6 +1677,10 @@ void ath11k_core_pre_reconfigure_recover
- 			     ath11k_mac_tx_mgmt_pending_free, ar);
- 		idr_destroy(&ar->txmgmt_idr);
- 		wake_up(&ar->txmgmt_empty_waitq);
-+
-+		ar->monitor_vdev_id = -1;
-+		clear_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags);
-+		clear_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);
- 	}
- 
- 	wake_up(&ab->wmi_ab.tx_credits_wq);
diff --git a/package/kernel/mac80211/patches/ath11k/0012-wifi-ath11k-Fix-qmi_msg_handler-data-structure-initi.patch b/package/kernel/mac80211/patches/ath11k/0012-wifi-ath11k-Fix-qmi_msg_handler-data-structure-initi.patch
deleted file mode 100644
index fccfa438..00000000
--- a/package/kernel/mac80211/patches/ath11k/0012-wifi-ath11k-Fix-qmi_msg_handler-data-structure-initi.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From ed3725e15a154ebebf44e0c34806c57525483f92 Mon Sep 17 00:00:00 2001
-From: Rahul Bhattacharjee <quic_rbhattac@quicinc.com>
-Date: Fri, 21 Oct 2022 14:31:26 +0530
-Subject: [PATCH] wifi: ath11k: Fix qmi_msg_handler data structure
- initialization
-
-qmi_msg_handler is required to be null terminated by QMI module.
-There might be a case where a handler for a msg id is not present in the
-handlers array which can lead to infinite loop while searching the handler
-and therefore out of bound access in qmi_invoke_handler().
-Hence update the initialization in qmi_msg_handler data structure.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Rahul Bhattacharjee <quic_rbhattac@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221021090126.28626-1-quic_rbhattac@quicinc.com
----
- drivers/net/wireless/ath/ath11k/qmi.c | 3 +++
- 1 file changed, 3 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -1702,6 +1702,9 @@ static struct qmi_elem_info qmi_wlfw_fw_
- 		.data_type = QMI_EOTI,
- 		.array_type = NO_ARRAY,
- 	},
-+
-+	/* end of list */
-+	{},
- };
- 
- static int ath11k_qmi_host_cap_send(struct ath11k_base *ab)
diff --git a/package/kernel/mac80211/patches/ath11k/0013-wifi-ath11k-synchronize-ath11k_mac_he_gi_to_nl80211_.patch b/package/kernel/mac80211/patches/ath11k/0013-wifi-ath11k-synchronize-ath11k_mac_he_gi_to_nl80211_.patch
deleted file mode 100644
index 1e89b4d4..00000000
--- a/package/kernel/mac80211/patches/ath11k/0013-wifi-ath11k-synchronize-ath11k_mac_he_gi_to_nl80211_.patch
+++ /dev/null
@@ -1,42 +0,0 @@
-From dd1c2322694522f674c874f5fa02ac5ae39135dd Mon Sep 17 00:00:00 2001
-From: "Jiri Slaby (SUSE)" <jirislaby@kernel.org>
-Date: Mon, 31 Oct 2022 12:43:41 +0100
-Subject: [PATCH] wifi: ath11k: synchronize
- ath11k_mac_he_gi_to_nl80211_he_gi()'s return type
-
-ath11k_mac_he_gi_to_nl80211_he_gi() generates a valid warning with gcc-13:
-  drivers/net/wireless/ath/ath11k/mac.c:321:20: error: conflicting types for 'ath11k_mac_he_gi_to_nl80211_he_gi' due to enum/integer mismatch; have 'enum nl80211_he_gi(u8)'
-  drivers/net/wireless/ath/ath11k/mac.h:166:5: note: previous declaration of 'ath11k_mac_he_gi_to_nl80211_he_gi' with type 'u32(u8)'
-
-I.e. the type of the return value ath11k_mac_he_gi_to_nl80211_he_gi() in
-the declaration is u32, while the definition spells enum nl80211_he_gi.
-Synchronize them to the latter.
-
-Cc: Martin Liska <mliska@suse.cz>
-Cc: Kalle Valo <kvalo@kernel.org>
-Cc: "David S. Miller" <davem@davemloft.net>
-Cc: Eric Dumazet <edumazet@google.com>
-Cc: Jakub Kicinski <kuba@kernel.org>
-Cc: Paolo Abeni <pabeni@redhat.com>
-Cc: ath11k@lists.infradead.org
-Cc: linux-wireless@vger.kernel.org
-Cc: netdev@vger.kernel.org
-Signed-off-by: Jiri Slaby (SUSE) <jirislaby@kernel.org>
-Reviewed-by: Jeff Johnson <quic_jjohnson@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221031114341.10377-1-jirislaby@kernel.org
----
- drivers/net/wireless/ath/ath11k/mac.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.h
-+++ b/drivers/net/wireless/ath/ath11k/mac.h
-@@ -163,7 +163,7 @@ void ath11k_mac_drain_tx(struct ath11k *
- void ath11k_mac_peer_cleanup_all(struct ath11k *ar);
- int ath11k_mac_tx_mgmt_pending_free(int buf_id, void *skb, void *ctx);
- u8 ath11k_mac_bw_to_mac80211_bw(u8 bw);
--u32 ath11k_mac_he_gi_to_nl80211_he_gi(u8 sgi);
-+enum nl80211_he_gi ath11k_mac_he_gi_to_nl80211_he_gi(u8 sgi);
- enum nl80211_he_ru_alloc ath11k_mac_phy_he_ru_to_nl80211_he_ru_alloc(u16 ru_phy);
- enum nl80211_he_ru_alloc ath11k_mac_he_ru_tones_to_nl80211_he_ru_alloc(u16 ru_tones);
- enum ath11k_supported_bw ath11k_mac_mac80211_bw_to_ath11k_bw(enum rate_info_bw bw);
diff --git a/package/kernel/mac80211/patches/ath11k/0016-wifi-ath11k-Make-QMI-message-rules-const.patch b/package/kernel/mac80211/patches/ath11k/0016-wifi-ath11k-Make-QMI-message-rules-const.patch
deleted file mode 100644
index 1f48df73..00000000
--- a/package/kernel/mac80211/patches/ath11k/0016-wifi-ath11k-Make-QMI-message-rules-const.patch
+++ /dev/null
@@ -1,341 +0,0 @@
-From 93c1592889fca46d09d833455628bab05516cdbf Mon Sep 17 00:00:00 2001
-From: Jeff Johnson <quic_jjohnson@quicinc.com>
-Date: Wed, 14 Sep 2022 17:23:03 -0700
-Subject: [PATCH] wifi: ath11k: Make QMI message rules const
-
-Commit ff6d365898d4 ("soc: qcom: qmi: use const for struct
-qmi_elem_info") allows QMI message encoding/decoding rules to be
-const, so do that for ath11k.
-
-Compile tested only.
-
-Signed-off-by: Jeff Johnson <quic_jjohnson@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20220915002303.12206-1-quic_jjohnson@quicinc.com
----
- drivers/net/wireless/ath/ath11k/qmi.c | 72 +++++++++++++--------------
- 1 file changed, 36 insertions(+), 36 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -29,7 +29,7 @@ module_param_named(cold_boot_cal, ath11k
- MODULE_PARM_DESC(cold_boot_cal,
- 		 "Decrease the channel switch time but increase the driver load time (Default: true)");
- 
--static struct qmi_elem_info qmi_wlanfw_host_cap_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_host_cap_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_OPT_FLAG,
- 		.elem_len	= 1,
-@@ -280,7 +280,7 @@ static struct qmi_elem_info qmi_wlanfw_h
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_host_cap_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_host_cap_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -297,7 +297,7 @@ static struct qmi_elem_info qmi_wlanfw_h
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_ind_register_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_ind_register_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_OPT_FLAG,
- 		.elem_len	= 1,
-@@ -522,7 +522,7 @@ static struct qmi_elem_info qmi_wlanfw_i
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_ind_register_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_ind_register_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -558,7 +558,7 @@ static struct qmi_elem_info qmi_wlanfw_i
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_mem_cfg_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_mem_cfg_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_8_BYTE,
- 		.elem_len	= 1,
-@@ -590,7 +590,7 @@ static struct qmi_elem_info qmi_wlanfw_m
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_mem_seg_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_mem_seg_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -632,7 +632,7 @@ static struct qmi_elem_info qmi_wlanfw_m
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_request_mem_ind_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_request_mem_ind_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_DATA_LEN,
- 		.elem_len	= 1,
-@@ -659,7 +659,7 @@ static struct qmi_elem_info qmi_wlanfw_r
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_mem_seg_resp_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_mem_seg_resp_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_8_BYTE,
- 		.elem_len	= 1,
-@@ -699,7 +699,7 @@ static struct qmi_elem_info qmi_wlanfw_m
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_respond_mem_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_respond_mem_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_DATA_LEN,
- 		.elem_len	= 1,
-@@ -726,7 +726,7 @@ static struct qmi_elem_info qmi_wlanfw_r
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_respond_mem_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_respond_mem_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -744,7 +744,7 @@ static struct qmi_elem_info qmi_wlanfw_r
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_cap_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_cap_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_EOTI,
- 		.array_type	= NO_ARRAY,
-@@ -752,7 +752,7 @@ static struct qmi_elem_info qmi_wlanfw_c
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_device_info_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_device_info_req_msg_v01_ei[] = {
- 	{
- 		.data_type      = QMI_EOTI,
- 		.array_type     = NO_ARRAY,
-@@ -760,7 +760,7 @@ static struct qmi_elem_info qmi_wlanfw_d
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlfw_device_info_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlfw_device_info_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -814,7 +814,7 @@ static struct qmi_elem_info qmi_wlfw_dev
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_rf_chip_info_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_rf_chip_info_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -840,7 +840,7 @@ static struct qmi_elem_info qmi_wlanfw_r
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_rf_board_info_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_rf_board_info_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -857,7 +857,7 @@ static struct qmi_elem_info qmi_wlanfw_r
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_soc_info_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_soc_info_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -873,7 +873,7 @@ static struct qmi_elem_info qmi_wlanfw_s
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_fw_version_info_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_fw_version_info_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -899,7 +899,7 @@ static struct qmi_elem_info qmi_wlanfw_f
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_cap_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_cap_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -1100,7 +1100,7 @@ static struct qmi_elem_info qmi_wlanfw_c
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_bdf_download_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_bdf_download_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_1_BYTE,
- 		.elem_len	= 1,
-@@ -1235,7 +1235,7 @@ static struct qmi_elem_info qmi_wlanfw_b
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_bdf_download_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_bdf_download_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -1253,7 +1253,7 @@ static struct qmi_elem_info qmi_wlanfw_b
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_m3_info_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_m3_info_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_8_BYTE,
- 		.elem_len	= 1,
-@@ -1277,7 +1277,7 @@ static struct qmi_elem_info qmi_wlanfw_m
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_m3_info_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_m3_info_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -1294,7 +1294,7 @@ static struct qmi_elem_info qmi_wlanfw_m
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_ce_tgt_pipe_cfg_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_ce_tgt_pipe_cfg_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -1347,7 +1347,7 @@ static struct qmi_elem_info qmi_wlanfw_c
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_ce_svc_pipe_cfg_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_ce_svc_pipe_cfg_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -1382,7 +1382,7 @@ static struct qmi_elem_info qmi_wlanfw_c
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_shadow_reg_cfg_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_shadow_reg_cfg_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_2_BYTE,
- 		.elem_len	= 1,
-@@ -1406,7 +1406,7 @@ static struct qmi_elem_info qmi_wlanfw_s
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_shadow_reg_v2_cfg_s_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_shadow_reg_v2_cfg_s_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -1423,7 +1423,7 @@ static struct qmi_elem_info qmi_wlanfw_s
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_wlan_mode_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_wlan_mode_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_UNSIGNED_4_BYTE,
- 		.elem_len	= 1,
-@@ -1458,7 +1458,7 @@ static struct qmi_elem_info qmi_wlanfw_w
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_wlan_mode_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_wlan_mode_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -1476,7 +1476,7 @@ static struct qmi_elem_info qmi_wlanfw_w
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_wlan_cfg_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_wlan_cfg_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_OPT_FLAG,
- 		.elem_len	= 1,
-@@ -1615,7 +1615,7 @@ static struct qmi_elem_info qmi_wlanfw_w
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_wlan_cfg_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_wlan_cfg_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -1632,28 +1632,28 @@ static struct qmi_elem_info qmi_wlanfw_w
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_mem_ready_ind_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_mem_ready_ind_msg_v01_ei[] = {
- 	{
- 		.data_type = QMI_EOTI,
- 		.array_type = NO_ARRAY,
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_fw_ready_ind_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_fw_ready_ind_msg_v01_ei[] = {
- 	{
- 		.data_type = QMI_EOTI,
- 		.array_type = NO_ARRAY,
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_cold_boot_cal_done_ind_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_cold_boot_cal_done_ind_msg_v01_ei[] = {
- 	{
- 		.data_type = QMI_EOTI,
- 		.array_type = NO_ARRAY,
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_wlan_ini_req_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_wlan_ini_req_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_OPT_FLAG,
- 		.elem_len	= 1,
-@@ -1679,7 +1679,7 @@ static struct qmi_elem_info qmi_wlanfw_w
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlanfw_wlan_ini_resp_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlanfw_wlan_ini_resp_msg_v01_ei[] = {
- 	{
- 		.data_type	= QMI_STRUCT,
- 		.elem_len	= 1,
-@@ -1697,7 +1697,7 @@ static struct qmi_elem_info qmi_wlanfw_w
- 	},
- };
- 
--static struct qmi_elem_info qmi_wlfw_fw_init_done_ind_msg_v01_ei[] = {
-+static const struct qmi_elem_info qmi_wlfw_fw_init_done_ind_msg_v01_ei[] = {
- 	{
- 		.data_type = QMI_EOTI,
- 		.array_type = NO_ARRAY,
diff --git a/package/kernel/mac80211/patches/ath11k/0017-wifi-ath11k-Trigger-sta-disconnect-on-hardware-resta.patch b/package/kernel/mac80211/patches/ath11k/0017-wifi-ath11k-Trigger-sta-disconnect-on-hardware-resta.patch
deleted file mode 100644
index f95e5027..00000000
--- a/package/kernel/mac80211/patches/ath11k/0017-wifi-ath11k-Trigger-sta-disconnect-on-hardware-resta.patch
+++ /dev/null
@@ -1,119 +0,0 @@
-From a018750a2cceaf4427c4ee3d9ce3e83a171d5bd6 Mon Sep 17 00:00:00 2001
-From: Youghandhar Chintala <quic_youghand@quicinc.com>
-Date: Fri, 4 Nov 2022 14:24:03 +0530
-Subject: [PATCH] wifi: ath11k: Trigger sta disconnect on hardware restart
-
-Currently after the hardware restart triggered from the driver, the
-station interface connection remains intact, since a disconnect trigger
-is not sent to userspace. This can lead to a problem in targets where
-the wifi mac sequence is added by the firmware.
-
-After the target restart, its wifi mac sequence number gets reset to
-zero. Hence AP to which our device is connected will receive frames with
-a  wifi mac sequence number jump to the past, thereby resulting in the
-AP dropping all these frames, until the frame arrives with a wifi mac
-sequence number which AP was expecting.
-
-To avoid such frame drops, its better to trigger a station disconnect
-upon target hardware restart which can be done with API
-ieee80211_reconfig_disconnect exposed to mac80211.
-
-The other targets are not affected by this change, since the hardware
-params flag is not set.
-
-Reported-by: kernel test robot <lkp@intel.com>
-
-Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00887-QCAMSLSWPLZ-1
-
-Signed-off-by: Youghandhar Chintala <quic_youghand@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221104085403.11025-1-quic_youghand@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 6 ++++++
- drivers/net/wireless/ath/ath11k/hw.h   | 1 +
- drivers/net/wireless/ath/ath11k/mac.c  | 7 +++++++
- 3 files changed, 14 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -195,6 +195,7 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = true,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
-+		.support_fw_mac_sequence = false,
- 	},
- 	{
- 		.name = "qca6390 hw2.0",
-@@ -277,6 +278,7 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = true,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
-+		.support_fw_mac_sequence = true,
- 	},
- 	{
- 		.name = "qcn9074 hw1.0",
-@@ -356,6 +358,7 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = true,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
-+		.support_fw_mac_sequence = false,
- 	},
- 	{
- 		.name = "wcn6855 hw2.0",
-@@ -438,6 +441,7 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = true,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
-+		.support_fw_mac_sequence = true,
- 	},
- 	{
- 		.name = "wcn6855 hw2.1",
-@@ -519,6 +523,7 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = true,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
-+		.support_fw_mac_sequence = true,
- 	},
- 	{
- 		.name = "wcn6750 hw1.0",
-@@ -597,6 +602,7 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = false,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE_WCN6750,
- 		.smp2p_wow_exit = true,
-+		.support_fw_mac_sequence = true,
- 	},
- };
- 
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -219,6 +219,7 @@ struct ath11k_hw_params {
- 	bool tcl_ring_retry;
- 	u32 tx_ring_size;
- 	bool smp2p_wow_exit;
-+	bool support_fw_mac_sequence;
- };
- 
- struct ath11k_hw_ops {
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -8010,6 +8010,7 @@ ath11k_mac_op_reconfig_complete(struct i
- 	struct ath11k *ar = hw->priv;
- 	struct ath11k_base *ab = ar->ab;
- 	int recovery_count;
-+	struct ath11k_vif *arvif;
- 
- 	if (reconfig_type != IEEE80211_RECONFIG_TYPE_RESTART)
- 		return;
-@@ -8045,6 +8046,12 @@ ath11k_mac_op_reconfig_complete(struct i
- 				ath11k_dbg(ab, ATH11K_DBG_BOOT, "reset success\n");
- 			}
- 		}
-+		if (ar->ab->hw_params.support_fw_mac_sequence) {
-+			list_for_each_entry(arvif, &ar->arvifs, list) {
-+				if (arvif->is_up && arvif->vdev_type == WMI_VDEV_TYPE_STA)
-+					ieee80211_hw_restart_disconnect(arvif->vif);
-+			}
-+		}
- 	}
- 
- 	mutex_unlock(&ar->conf_mutex);
diff --git a/package/kernel/mac80211/patches/ath11k/0018-wifi-ath11k-Fix-race-condition-with-struct-htt_ppdu_.patch b/package/kernel/mac80211/patches/ath11k/0018-wifi-ath11k-Fix-race-condition-with-struct-htt_ppdu_.patch
deleted file mode 100644
index cef61ee3..00000000
--- a/package/kernel/mac80211/patches/ath11k/0018-wifi-ath11k-Fix-race-condition-with-struct-htt_ppdu_.patch
+++ /dev/null
@@ -1,103 +0,0 @@
-From e44de90453bb2b46a523df78c39eb896bab35dcd Mon Sep 17 00:00:00 2001
-From: Govindaraj Saminathan <quic_gsaminat@quicinc.com>
-Date: Tue, 29 Nov 2022 13:04:02 +0200
-Subject: [PATCH] wifi: ath11k: Fix race condition with struct
- htt_ppdu_stats_info
-
-A crash happens when running the traffic with multiple clients:
-
-Crash Signature : Unable to handle kernel paging request at
-virtual address ffffffd700970918 During the crash, PC points to
-"ieee80211_tx_rate_update+0x30/0x68 [mac80211]"
-LR points to "ath11k_dp_htt_htc_t2h_msg_handler+0x5a8/0x8a0 [ath11k]".
-
-Struct ppdu_stats_info is allocated and accessed from event callback via copy
-engine tasklet, this has a problem when freeing it from ath11k_mac_op_stop().
-
-Use data_lock during entire ath11k_dp_htt_get_ppdu_desc() call to protect
-struct htt_ppdu_stats_info access and to avoid race condition when accessing it
-from ath11k_mac_op_stop().
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Govindaraj Saminathan <quic_gsaminat@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221124071104.22506-1-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp_rx.c | 22 +++++++++++-----------
- 1 file changed, 11 insertions(+), 11 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -1535,13 +1535,12 @@ struct htt_ppdu_stats_info *ath11k_dp_ht
- {
- 	struct htt_ppdu_stats_info *ppdu_info;
- 
--	spin_lock_bh(&ar->data_lock);
-+	lockdep_assert_held(&ar->data_lock);
-+
- 	if (!list_empty(&ar->ppdu_stats_info)) {
- 		list_for_each_entry(ppdu_info, &ar->ppdu_stats_info, list) {
--			if (ppdu_info->ppdu_id == ppdu_id) {
--				spin_unlock_bh(&ar->data_lock);
-+			if (ppdu_info->ppdu_id == ppdu_id)
- 				return ppdu_info;
--			}
- 		}
- 
- 		if (ar->ppdu_stat_list_depth > HTT_PPDU_DESC_MAX_DEPTH) {
-@@ -1553,16 +1552,13 @@ struct htt_ppdu_stats_info *ath11k_dp_ht
- 			kfree(ppdu_info);
- 		}
- 	}
--	spin_unlock_bh(&ar->data_lock);
- 
- 	ppdu_info = kzalloc(sizeof(*ppdu_info), GFP_ATOMIC);
- 	if (!ppdu_info)
- 		return NULL;
- 
--	spin_lock_bh(&ar->data_lock);
- 	list_add_tail(&ppdu_info->list, &ar->ppdu_stats_info);
- 	ar->ppdu_stat_list_depth++;
--	spin_unlock_bh(&ar->data_lock);
- 
- 	return ppdu_info;
- }
-@@ -1586,16 +1582,17 @@ static int ath11k_htt_pull_ppdu_stats(st
- 	ar = ath11k_mac_get_ar_by_pdev_id(ab, pdev_id);
- 	if (!ar) {
- 		ret = -EINVAL;
--		goto exit;
-+		goto out;
- 	}
- 
- 	if (ath11k_debugfs_is_pktlog_lite_mode_enabled(ar))
- 		trace_ath11k_htt_ppdu_stats(ar, skb->data, len);
- 
-+	spin_lock_bh(&ar->data_lock);
- 	ppdu_info = ath11k_dp_htt_get_ppdu_desc(ar, ppdu_id);
- 	if (!ppdu_info) {
- 		ret = -EINVAL;
--		goto exit;
-+		goto out_unlock_data;
- 	}
- 
- 	ppdu_info->ppdu_id = ppdu_id;
-@@ -1604,10 +1601,13 @@ static int ath11k_htt_pull_ppdu_stats(st
- 				     (void *)ppdu_info);
- 	if (ret) {
- 		ath11k_warn(ab, "Failed to parse tlv %d\n", ret);
--		goto exit;
-+		goto out_unlock_data;
- 	}
- 
--exit:
-+out_unlock_data:
-+	spin_unlock_bh(&ar->data_lock);
-+
-+out:
- 	rcu_read_unlock();
- 
- 	return ret;
diff --git a/package/kernel/mac80211/patches/ath11k/0019-wifi-ath11k-update-hw-params-for-IPQ5018.patch b/package/kernel/mac80211/patches/ath11k/0019-wifi-ath11k-update-hw-params-for-IPQ5018.patch
deleted file mode 100644
index 25d39ddb..00000000
--- a/package/kernel/mac80211/patches/ath11k/0019-wifi-ath11k-update-hw-params-for-IPQ5018.patch
+++ /dev/null
@@ -1,125 +0,0 @@
-From 8dfe875aa24aec68baf6702018633c84c2c1feca Mon Sep 17 00:00:00 2001
-From: Sriram R <quic_srirrama@quicinc.com>
-Date: Fri, 2 Dec 2022 23:37:13 +0200
-Subject: [PATCH] wifi: ath11k: update hw params for IPQ5018
-
-Add new compatible string for IPQ5018 and add
-required hw params for IPQ5018. The hw descriptors size and
-datapath ops are similar to QCN9074, hence reuse the same.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221122132152.17771-3-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 71 ++++++++++++++++++++++++++
- drivers/net/wireless/ath/ath11k/core.h |  8 +++
- 2 files changed, 79 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -604,6 +604,77 @@ static const struct ath11k_hw_params ath
- 		.smp2p_wow_exit = true,
- 		.support_fw_mac_sequence = true,
- 	},
-+	{
-+		.hw_rev = ATH11K_HW_IPQ5018_HW10,
-+		.name = "ipq5018 hw1.0",
-+		.fw = {
-+			.dir = "IPQ5018/hw1.0",
-+			.board_size = 256 * 1024,
-+			.cal_offset = 128 * 1024,
-+		},
-+		.max_radios = MAX_RADIOS_5018,
-+		.bdf_addr = 0x4BA00000,
-+		/* hal_desc_sz and hw ops are similar to qcn9074 */
-+		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),
-+		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074,
-+		.ring_mask = &ath11k_hw_ring_mask_ipq8074,
-+		.credit_flow = false,
-+		.max_tx_ring = 1,
-+		.spectral = {
-+			.fft_sz = 2,
-+			.fft_pad_sz = 0,
-+			.summary_pad_sz = 16,
-+			.fft_hdr_len = 24,
-+			.max_fft_bins = 1024,
-+		},
-+		.internal_sleep_clock = false,
-+		.host_ce_config = ath11k_host_ce_config_qcn9074,
-+		.ce_count = CE_CNT_5018,
-+		.rxdma1_enable = true,
-+		.num_rxmda_per_pdev = RXDMA_PER_PDEV_5018,
-+		.rx_mac_buf_ring = false,
-+		.vdev_start_delay = false,
-+		.htt_peer_map_v2 = true,
-+		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
-+			BIT(NL80211_IFTYPE_AP) |
-+			BIT(NL80211_IFTYPE_MESH_POINT),
-+		.supports_monitor = false,
-+		.supports_sta_ps = false,
-+		.supports_shadow_regs = false,
-+		.fw_mem_mode = 0,
-+		.num_vdevs = 16 + 1,
-+		.num_peers = 512,
-+		.supports_regdb = false,
-+		.idle_ps = false,
-+		.supports_suspend = false,
-+		.hal_params = &ath11k_hw_hal_params_ipq8074,
-+		.single_pdev_only = false,
-+		.cold_boot_calib = true,
-+		.fix_l1ss = true,
-+		.supports_dynamic_smps_6ghz = false,
-+		.alloc_cacheable_memory = true,
-+		.supports_rssi_stats = false,
-+		.fw_wmi_diag_event = false,
-+		.current_cc_support = false,
-+		.dbr_debug_support = true,
-+		.global_reset = false,
-+		.bios_sar_capa = NULL,
-+		.m3_fw_support = false,
-+		.fixed_bdf_addr = true,
-+		.fixed_mem_region = true,
-+		.static_window_map = false,
-+		.hybrid_bus_type = false,
-+		.fixed_fw_mem = false,
-+		.support_off_channel_tx = false,
-+		.supports_multi_bssid = false,
-+
-+		.sram_dump = {},
-+
-+		.tcl_ring_retry = true,
-+		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
-+		.smp2p_wow_exit = false,
-+		.support_fw_mac_sequence = false,
-+	},
- };
- 
- static inline struct ath11k_pdev *ath11k_core_get_single_pdev(struct ath11k_base *ab)
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -142,6 +142,7 @@ enum ath11k_hw_rev {
- 	ATH11K_HW_WCN6855_HW20,
- 	ATH11K_HW_WCN6855_HW21,
- 	ATH11K_HW_WCN6750_HW10,
-+	ATH11K_HW_IPQ5018_HW10,
- };
- 
- enum ath11k_firmware_mode {
-@@ -230,6 +231,13 @@ struct ath11k_he {
- 
- #define MAX_RADIOS 3
- 
-+/* ipq5018 hw param macros */
-+#define MAX_RADIOS_5018	1
-+#define CE_CNT_5018	6
-+#define TARGET_CE_CNT_5018	9
-+#define SVC_CE_MAP_LEN_5018	17
-+#define RXDMA_PER_PDEV_5018	1
-+
- enum {
- 	WMI_HOST_TP_SCALE_MAX   = 0,
- 	WMI_HOST_TP_SCALE_50    = 1,
diff --git a/package/kernel/mac80211/patches/ath11k/0020-wifi-ath11k-update-ce-configurations-for-IPQ5018.patch b/package/kernel/mac80211/patches/ath11k/0020-wifi-ath11k-update-ce-configurations-for-IPQ5018.patch
deleted file mode 100644
index 95643a95..00000000
--- a/package/kernel/mac80211/patches/ath11k/0020-wifi-ath11k-update-ce-configurations-for-IPQ5018.patch
+++ /dev/null
@@ -1,246 +0,0 @@
-From 26af7aabd2d8225c6b2056234626ba5099610871 Mon Sep 17 00:00:00 2001
-From: Sriram R <quic_srirrama@quicinc.com>
-Date: Fri, 2 Dec 2022 23:37:14 +0200
-Subject: [PATCH] wifi: ath11k: update ce configurations for IPQ5018
-
-IPQ5018 is a single pdev device. Update host
-and target CE configurations accordingly.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221122132152.17771-4-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c |   4 +
- drivers/net/wireless/ath/ath11k/core.h |   3 +
- drivers/net/wireless/ath/ath11k/hw.c   | 191 +++++++++++++++++++++++++
- 3 files changed, 198 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -630,6 +630,10 @@ static const struct ath11k_hw_params ath
- 		.internal_sleep_clock = false,
- 		.host_ce_config = ath11k_host_ce_config_qcn9074,
- 		.ce_count = CE_CNT_5018,
-+		.target_ce_config = ath11k_target_ce_config_wlan_ipq5018,
-+		.target_ce_count = TARGET_CE_CNT_5018,
-+		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq5018,
-+		.svc_to_ce_map_len = SVC_CE_MAP_LEN_5018,
- 		.rxdma1_enable = true,
- 		.num_rxmda_per_pdev = RXDMA_PER_PDEV_5018,
- 		.rx_mac_buf_ring = false,
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -1145,6 +1145,9 @@ extern const struct service_to_pipe ath1
- extern const struct ce_pipe_config ath11k_target_ce_config_wlan_qca6390[];
- extern const struct service_to_pipe ath11k_target_service_to_ce_map_wlan_qca6390[];
- 
-+extern const struct ce_pipe_config ath11k_target_ce_config_wlan_ipq5018[];
-+extern const struct service_to_pipe ath11k_target_service_to_ce_map_wlan_ipq5018[];
-+
- extern const struct ce_pipe_config ath11k_target_ce_config_wlan_qcn9074[];
- extern const struct service_to_pipe ath11k_target_service_to_ce_map_wlan_qcn9074[];
- int ath11k_core_qmi_firmware_ready(struct ath11k_base *ab);
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -1972,6 +1972,197 @@ const struct ath11k_hw_ring_mask ath11k_
- 	},
- };
- 
-+/* Target firmware's Copy Engine configuration for IPQ5018 */
-+const struct ce_pipe_config ath11k_target_ce_config_wlan_ipq5018[] = {
-+	/* CE0: host->target HTC control and raw streams */
-+	{
-+		.pipenum = __cpu_to_le32(0),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(2048),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE1: target->host HTT + HTC control */
-+	{
-+		.pipenum = __cpu_to_le32(1),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(2048),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE2: target->host WMI */
-+	{
-+		.pipenum = __cpu_to_le32(2),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(2048),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE3: host->target WMI */
-+	{
-+		.pipenum = __cpu_to_le32(3),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(2048),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE4: host->target HTT */
-+	{
-+		.pipenum = __cpu_to_le32(4),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),
-+		.nentries = __cpu_to_le32(256),
-+		.nbytes_max = __cpu_to_le32(256),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS | CE_ATTR_DIS_INTR),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE5: target->host Pktlog */
-+	{
-+		.pipenum = __cpu_to_le32(5),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(2048),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE6: Reserved for target autonomous hif_memcpy */
-+	{
-+		.pipenum = __cpu_to_le32(6),
-+		.pipedir = __cpu_to_le32(PIPEDIR_INOUT),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(16384),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE7 used only by Host */
-+	{
-+		.pipenum = __cpu_to_le32(7),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(2048),
-+		.flags = __cpu_to_le32(0x2000),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+
-+	/* CE8 target->host used only by IPA */
-+	{
-+		.pipenum = __cpu_to_le32(8),
-+		.pipedir = __cpu_to_le32(PIPEDIR_INOUT),
-+		.nentries = __cpu_to_le32(32),
-+		.nbytes_max = __cpu_to_le32(16384),
-+		.flags = __cpu_to_le32(CE_ATTR_FLAGS),
-+		.reserved = __cpu_to_le32(0),
-+	},
-+};
-+
-+/* Map from service/endpoint to Copy Engine for IPQ5018.
-+ * This table is derived from the CE TABLE, above.
-+ * It is passed to the Target at startup for use by firmware.
-+ */
-+const struct service_to_pipe ath11k_target_service_to_ce_map_wlan_ipq5018[] = {
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_VO),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(3),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_VO),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(2),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_BK),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(3),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_BK),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(2),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_BE),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(3),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_BE),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(2),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_VI),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(3),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_DATA_VI),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(2),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_CONTROL),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(3),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_WMI_CONTROL),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(2),
-+	},
-+
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_RSVD_CTRL),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(0),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_RSVD_CTRL),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(1),
-+	},
-+
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_TEST_RAW_STREAMS),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(0),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_TEST_RAW_STREAMS),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(1),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_HTT_DATA_MSG),
-+		.pipedir = __cpu_to_le32(PIPEDIR_OUT),	/* out = UL = host -> target */
-+		.pipenum = __cpu_to_le32(4),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_HTT_DATA_MSG),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(1),
-+	},
-+	{
-+		.service_id = __cpu_to_le32(ATH11K_HTC_SVC_ID_PKT_LOG),
-+		.pipedir = __cpu_to_le32(PIPEDIR_IN),	/* in = DL = target -> host */
-+		.pipenum = __cpu_to_le32(5),
-+	},
-+
-+       /* (Additions here) */
-+
-+	{ /* terminator entry */ }
-+};
-+
- const struct ath11k_hw_regs ipq8074_regs = {
- 	/* SW2TCL(x) R0 ring configuration address */
- 	.hal_tcl1_ring_base_lsb = 0x00000510,
diff --git a/package/kernel/mac80211/patches/ath11k/0021-wifi-ath11k-remap-ce-register-space-for-IPQ5018.patch b/package/kernel/mac80211/patches/ath11k/0021-wifi-ath11k-remap-ce-register-space-for-IPQ5018.patch
deleted file mode 100644
index d07a258a..00000000
--- a/package/kernel/mac80211/patches/ath11k/0021-wifi-ath11k-remap-ce-register-space-for-IPQ5018.patch
+++ /dev/null
@@ -1,351 +0,0 @@
-From b42b3678c91f3ca6e0888bf5a15c1e8678fd5f2d Mon Sep 17 00:00:00 2001
-From: Sriram R <quic_srirrama@quicinc.com>
-Date: Fri, 2 Dec 2022 23:37:14 +0200
-Subject: [PATCH] wifi: ath11k: remap ce register space for IPQ5018
-
-In IPQ5018 ce register space is moved out of wcss unlike
-ipq8074 or ipq6018 and the space is not contiguous,
-hence remap the CE registers to a new space to access them.
-
-Register read/write is modified to check if the register to be written
-falls in the CE register space and corresponding register is written.
-Also adjust the interrupt register address to ce irq enable/disable.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221122132152.17771-5-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/ahb.c  | 44 ++++++++++++++++++++++----
- drivers/net/wireless/ath/ath11k/ce.h   | 16 ++++++++++
- drivers/net/wireless/ath/ath11k/core.c |  8 +++++
- drivers/net/wireless/ath/ath11k/core.h |  1 +
- drivers/net/wireless/ath/ath11k/hal.c  | 17 ++++++----
- drivers/net/wireless/ath/ath11k/hal.h  |  5 +++
- drivers/net/wireless/ath/ath11k/hw.c   | 17 ++++++++++
- drivers/net/wireless/ath/ath11k/hw.h   |  9 ++++++
- drivers/net/wireless/ath/ath11k/pci.c  |  2 ++
- 9 files changed, 107 insertions(+), 12 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -267,30 +267,42 @@ static void ath11k_ahb_clearbit32(struct
- static void ath11k_ahb_ce_irq_enable(struct ath11k_base *ab, u16 ce_id)
- {
- 	const struct ce_attr *ce_attr;
-+	const struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;
-+	u32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;
-+
-+	ie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);
-+	ie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);
-+	ie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);
- 
- 	ce_attr = &ab->hw_params.host_ce_config[ce_id];
- 	if (ce_attr->src_nentries)
--		ath11k_ahb_setbit32(ab, ce_id, CE_HOST_IE_ADDRESS);
-+		ath11k_ahb_setbit32(ab, ce_id, ie1_reg_addr);
- 
- 	if (ce_attr->dest_nentries) {
--		ath11k_ahb_setbit32(ab, ce_id, CE_HOST_IE_2_ADDRESS);
-+		ath11k_ahb_setbit32(ab, ce_id, ie2_reg_addr);
- 		ath11k_ahb_setbit32(ab, ce_id + CE_HOST_IE_3_SHIFT,
--				    CE_HOST_IE_3_ADDRESS);
-+				    ie3_reg_addr);
- 	}
- }
- 
- static void ath11k_ahb_ce_irq_disable(struct ath11k_base *ab, u16 ce_id)
- {
- 	const struct ce_attr *ce_attr;
-+	const struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;
-+	u32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;
-+
-+	ie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);
-+	ie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);
-+	ie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);
- 
- 	ce_attr = &ab->hw_params.host_ce_config[ce_id];
- 	if (ce_attr->src_nentries)
--		ath11k_ahb_clearbit32(ab, ce_id, CE_HOST_IE_ADDRESS);
-+		ath11k_ahb_clearbit32(ab, ce_id, ie1_reg_addr);
- 
- 	if (ce_attr->dest_nentries) {
--		ath11k_ahb_clearbit32(ab, ce_id, CE_HOST_IE_2_ADDRESS);
-+		ath11k_ahb_clearbit32(ab, ce_id, ie2_reg_addr);
- 		ath11k_ahb_clearbit32(ab, ce_id + CE_HOST_IE_3_SHIFT,
--				      CE_HOST_IE_3_ADDRESS);
-+				      ie3_reg_addr);
- 	}
- }
- 
-@@ -1142,10 +1154,26 @@ static int ath11k_ahb_probe(struct platf
- 		goto err_core_free;
- 	}
- 
-+	ab->mem_ce = ab->mem;
-+
- 	ret = ath11k_core_pre_init(ab);
- 	if (ret)
- 		goto err_core_free;
- 
-+	if (ab->hw_params.ce_remap) {
-+		const struct ce_remap *ce_remap = ab->hw_params.ce_remap;
-+		/* ce register space is moved out of wcss unlike ipq8074 or ipq6018
-+		 * and the space is not contiguous, hence remapping the CE registers
-+		 * to a new space for accessing them.
-+		 */
-+		ab->mem_ce = ioremap(ce_remap->base, ce_remap->size);
-+		if (IS_ERR(ab->mem_ce)) {
-+			dev_err(&pdev->dev, "ce ioremap error\n");
-+			ret = -ENOMEM;
-+			goto err_core_free;
-+		}
-+	}
-+
- 	ret = ath11k_ahb_setup_resources(ab);
- 	if (ret)
- 		goto err_core_free;
-@@ -1236,6 +1264,10 @@ static void ath11k_ahb_free_resources(st
- 	ath11k_ahb_release_smp2p_handle(ab);
- 	ath11k_ahb_fw_resource_deinit(ab);
- 	ath11k_ce_free_pipes(ab);
-+
-+	if (ab->hw_params.ce_remap)
-+		iounmap(ab->mem_ce);
-+
- 	ath11k_core_free(ab);
- 	platform_set_drvdata(pdev, NULL);
- }
---- a/drivers/net/wireless/ath/ath11k/ce.h
-+++ b/drivers/net/wireless/ath/ath11k/ce.h
-@@ -49,6 +49,11 @@ void ath11k_ce_byte_swap(void *mem, u32
- #define CE_HOST_IE_2_ADDRESS	0x00A18040
- #define CE_HOST_IE_3_ADDRESS	CE_HOST_IE_ADDRESS
- 
-+/* CE IE registers are different for IPQ5018 */
-+#define CE_HOST_IPQ5018_IE_ADDRESS		0x0841804C
-+#define CE_HOST_IPQ5018_IE_2_ADDRESS		0x08418050
-+#define CE_HOST_IPQ5018_IE_3_ADDRESS		CE_HOST_IPQ5018_IE_ADDRESS
-+
- #define CE_HOST_IE_3_SHIFT	0xC
- 
- #define CE_RING_IDX_INCR(nentries_mask, idx) (((idx) + 1) & (nentries_mask))
-@@ -84,6 +89,17 @@ struct ce_pipe_config {
- 	__le32 reserved;
- };
- 
-+struct ce_ie_addr {
-+	u32 ie1_reg_addr;
-+	u32 ie2_reg_addr;
-+	u32 ie3_reg_addr;
-+};
-+
-+struct ce_remap {
-+	u32 base;
-+	u32 size;
-+};
-+
- struct ce_attr {
- 	/* CE_ATTR_* values */
- 	unsigned int flags;
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -54,6 +54,7 @@ static const struct ath11k_hw_params ath
- 		.target_ce_count = 11,
- 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq8074,
- 		.svc_to_ce_map_len = 21,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
- 		.single_pdev_only = false,
- 		.rxdma1_enable = true,
- 		.num_rxmda_per_pdev = 1,
-@@ -137,6 +138,7 @@ static const struct ath11k_hw_params ath
- 		.target_ce_count = 11,
- 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq6018,
- 		.svc_to_ce_map_len = 19,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
- 		.single_pdev_only = false,
- 		.rxdma1_enable = true,
- 		.num_rxmda_per_pdev = 1,
-@@ -218,6 +220,7 @@ static const struct ath11k_hw_params ath
- 		.target_ce_count = 9,
- 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,
- 		.svc_to_ce_map_len = 14,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
- 		.single_pdev_only = true,
- 		.rxdma1_enable = false,
- 		.num_rxmda_per_pdev = 2,
-@@ -301,6 +304,7 @@ static const struct ath11k_hw_params ath
- 		.target_ce_count = 9,
- 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qcn9074,
- 		.svc_to_ce_map_len = 18,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
- 		.rxdma1_enable = true,
- 		.num_rxmda_per_pdev = 1,
- 		.rx_mac_buf_ring = false,
-@@ -381,6 +385,7 @@ static const struct ath11k_hw_params ath
- 		.target_ce_count = 9,
- 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,
- 		.svc_to_ce_map_len = 14,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
- 		.single_pdev_only = true,
- 		.rxdma1_enable = false,
- 		.num_rxmda_per_pdev = 2,
-@@ -546,6 +551,7 @@ static const struct ath11k_hw_params ath
- 		.target_ce_count = 9,
- 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,
- 		.svc_to_ce_map_len = 14,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
- 		.single_pdev_only = true,
- 		.rxdma1_enable = false,
- 		.num_rxmda_per_pdev = 1,
-@@ -634,6 +640,8 @@ static const struct ath11k_hw_params ath
- 		.target_ce_count = TARGET_CE_CNT_5018,
- 		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq5018,
- 		.svc_to_ce_map_len = SVC_CE_MAP_LEN_5018,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq5018,
-+		.ce_remap = &ath11k_ce_remap_ipq5018,
- 		.rxdma1_enable = true,
- 		.num_rxmda_per_pdev = RXDMA_PER_PDEV_5018,
- 		.rx_mac_buf_ring = false,
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -851,6 +851,7 @@ struct ath11k_base {
- 	struct ath11k_dp dp;
- 
- 	void __iomem *mem;
-+	void __iomem *mem_ce;
- 	unsigned long mem_len;
- 
- 	struct {
---- a/drivers/net/wireless/ath/ath11k/hal.c
-+++ b/drivers/net/wireless/ath/ath11k/hal.c
-@@ -1220,16 +1220,20 @@ static int ath11k_hal_srng_create_config
- 	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_TCL_REG + HAL_TCL_STATUS_RING_HP;
- 
- 	s = &hal->srng_config[HAL_CE_SRC];
--	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_BASE_LSB;
--	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_HP;
-+	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_BASE_LSB +
-+		ATH11K_CE_OFFSET(ab);
-+	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_HP +
-+		ATH11K_CE_OFFSET(ab);
- 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_SRC_REG(ab) -
- 		HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab);
- 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_SRC_REG(ab) -
- 		HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab);
- 
- 	s = &hal->srng_config[HAL_CE_DST];
--	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_BASE_LSB;
--	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_HP;
-+	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_BASE_LSB +
-+		ATH11K_CE_OFFSET(ab);
-+	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_HP +
-+		ATH11K_CE_OFFSET(ab);
- 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
- 		HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab);
- 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
-@@ -1237,8 +1241,9 @@ static int ath11k_hal_srng_create_config
- 
- 	s = &hal->srng_config[HAL_CE_DST_STATUS];
- 	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) +
--		HAL_CE_DST_STATUS_RING_BASE_LSB;
--	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_STATUS_RING_HP;
-+		HAL_CE_DST_STATUS_RING_BASE_LSB + ATH11K_CE_OFFSET(ab);
-+	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_STATUS_RING_HP +
-+		ATH11K_CE_OFFSET(ab);
- 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
- 		HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab);
- 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
---- a/drivers/net/wireless/ath/ath11k/hal.h
-+++ b/drivers/net/wireless/ath/ath11k/hal.h
-@@ -321,6 +321,10 @@ struct ath11k_base;
- #define HAL_WBM2SW_RELEASE_RING_BASE_MSB_RING_SIZE	0x000fffff
- #define HAL_RXDMA_RING_MAX_SIZE				0x0000ffff
- 
-+/* IPQ5018 ce registers */
-+#define HAL_IPQ5018_CE_WFSS_REG_BASE		0x08400000
-+#define HAL_IPQ5018_CE_SIZE			0x200000
-+
- /* Add any other errors here and return them in
-  * ath11k_hal_rx_desc_get_err().
-  */
-@@ -519,6 +523,7 @@ enum hal_srng_dir {
- #define HAL_SRNG_FLAGS_MSI_INTR			0x00020000
- #define HAL_SRNG_FLAGS_CACHED                   0x20000000
- #define HAL_SRNG_FLAGS_LMAC_RING		0x80000000
-+#define HAL_SRNG_FLAGS_REMAP_CE_RING        0x10000000
- 
- #define HAL_SRNG_TLV_HDR_TAG		GENMASK(9, 1)
- #define HAL_SRNG_TLV_HDR_LEN		GENMASK(25, 10)
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -2163,6 +2163,23 @@ const struct service_to_pipe ath11k_targ
- 	{ /* terminator entry */ }
- };
- 
-+const struct ce_ie_addr ath11k_ce_ie_addr_ipq8074 = {
-+	.ie1_reg_addr = CE_HOST_IE_ADDRESS,
-+	.ie2_reg_addr = CE_HOST_IE_2_ADDRESS,
-+	.ie3_reg_addr = CE_HOST_IE_3_ADDRESS,
-+};
-+
-+const struct ce_ie_addr ath11k_ce_ie_addr_ipq5018 = {
-+	.ie1_reg_addr = CE_HOST_IPQ5018_IE_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
-+	.ie2_reg_addr = CE_HOST_IPQ5018_IE_2_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
-+	.ie3_reg_addr = CE_HOST_IPQ5018_IE_3_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
-+};
-+
-+const struct ce_remap ath11k_ce_remap_ipq5018 = {
-+	.base = HAL_IPQ5018_CE_WFSS_REG_BASE,
-+	.size = HAL_IPQ5018_CE_SIZE,
-+};
-+
- const struct ath11k_hw_regs ipq8074_regs = {
- 	/* SW2TCL(x) R0 ring configuration address */
- 	.hal_tcl1_ring_base_lsb = 0x00000510,
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -80,6 +80,8 @@
- #define ATH11K_M3_FILE			"m3.bin"
- #define ATH11K_REGDB_FILE_NAME		"regdb.bin"
- 
-+#define ATH11K_CE_OFFSET(ab)	(ab->mem_ce - ab->mem)
-+
- enum ath11k_hw_rate_cck {
- 	ATH11K_HW_RATE_CCK_LP_11M = 0,
- 	ATH11K_HW_RATE_CCK_LP_5_5M,
-@@ -158,6 +160,8 @@ struct ath11k_hw_params {
- 	u32 target_ce_count;
- 	const struct service_to_pipe *svc_to_ce_map;
- 	u32 svc_to_ce_map_len;
-+	const struct ce_ie_addr *ce_ie_addr;
-+	const struct ce_remap *ce_remap;
- 
- 	bool single_pdev_only;
- 
-@@ -277,6 +281,11 @@ extern const struct ath11k_hw_ring_mask
- extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn9074;
- extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_wcn6750;
- 
-+extern const struct ce_ie_addr ath11k_ce_ie_addr_ipq8074;
-+extern const struct ce_ie_addr ath11k_ce_ie_addr_ipq5018;
-+
-+extern const struct ce_remap ath11k_ce_remap_ipq5018;
-+
- extern const struct ath11k_hw_hal_params ath11k_hw_hal_params_ipq8074;
- extern const struct ath11k_hw_hal_params ath11k_hw_hal_params_qca6390;
- extern const struct ath11k_hw_hal_params ath11k_hw_hal_params_wcn6750;
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -543,6 +543,8 @@ static int ath11k_pci_claim(struct ath11
- 		goto clear_master;
- 	}
- 
-+	ab->mem_ce = ab->mem;
-+
- 	ath11k_dbg(ab, ATH11K_DBG_BOOT, "boot pci_mem 0x%pK\n", ab->mem);
- 	return 0;
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0022-wifi-ath11k-update-hal-srng-regs-for-IPQ5018.patch b/package/kernel/mac80211/patches/ath11k/0022-wifi-ath11k-update-hal-srng-regs-for-IPQ5018.patch
deleted file mode 100644
index 35ea20a3..00000000
--- a/package/kernel/mac80211/patches/ath11k/0022-wifi-ath11k-update-hal-srng-regs-for-IPQ5018.patch
+++ /dev/null
@@ -1,130 +0,0 @@
-From 711b80acbdfb9667a9cf8374e13320a6e624ce73 Mon Sep 17 00:00:00 2001
-From: Sriram R <quic_srirrama@quicinc.com>
-Date: Fri, 2 Dec 2022 23:37:14 +0200
-Subject: [PATCH] wifi: ath11k: update hal srng regs for IPQ5018
-
-IPQ5018 hal srng register address & offsets are not
-similar to IPQ8074/IPQ6018/QCN9074, hence define a
-new set of srng register group data for IPQ5018.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221122132152.17771-6-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c |  1 +
- drivers/net/wireless/ath/ath11k/hw.c   | 79 ++++++++++++++++++++++++++
- drivers/net/wireless/ath/ath11k/hw.h   |  1 +
- 3 files changed, 81 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -634,6 +634,7 @@ static const struct ath11k_hw_params ath
- 			.max_fft_bins = 1024,
- 		},
- 		.internal_sleep_clock = false,
-+		.regs = &ipq5018_regs,
- 		.host_ce_config = ath11k_host_ce_config_qcn9074,
- 		.ce_count = CE_CNT_5018,
- 		.target_ce_config = ath11k_target_ce_config_wlan_ipq5018,
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -2645,6 +2645,85 @@ static const struct ath11k_hw_tcl2wbm_rb
- 	},
- };
- 
-+const struct ath11k_hw_regs ipq5018_regs = {
-+	/* SW2TCL(x) R0 ring configuration address */
-+	.hal_tcl1_ring_base_lsb = 0x00000694,
-+	.hal_tcl1_ring_base_msb = 0x00000698,
-+	.hal_tcl1_ring_id =	0x0000069c,
-+	.hal_tcl1_ring_misc = 0x000006a4,
-+	.hal_tcl1_ring_tp_addr_lsb = 0x000006b0,
-+	.hal_tcl1_ring_tp_addr_msb = 0x000006b4,
-+	.hal_tcl1_ring_consumer_int_setup_ix0 = 0x000006c4,
-+	.hal_tcl1_ring_consumer_int_setup_ix1 = 0x000006c8,
-+	.hal_tcl1_ring_msi1_base_lsb = 0x000006dc,
-+	.hal_tcl1_ring_msi1_base_msb = 0x000006e0,
-+	.hal_tcl1_ring_msi1_data = 0x000006e4,
-+	.hal_tcl2_ring_base_lsb = 0x000006ec,
-+	.hal_tcl_ring_base_lsb = 0x0000079c,
-+
-+	/* TCL STATUS ring address */
-+	.hal_tcl_status_ring_base_lsb = 0x000008a4,
-+
-+	/* REO2SW(x) R0 ring configuration address */
-+	.hal_reo1_ring_base_lsb = 0x000001ec,
-+	.hal_reo1_ring_base_msb = 0x000001f0,
-+	.hal_reo1_ring_id = 0x000001f4,
-+	.hal_reo1_ring_misc = 0x000001fc,
-+	.hal_reo1_ring_hp_addr_lsb = 0x00000200,
-+	.hal_reo1_ring_hp_addr_msb = 0x00000204,
-+	.hal_reo1_ring_producer_int_setup = 0x00000210,
-+	.hal_reo1_ring_msi1_base_lsb = 0x00000234,
-+	.hal_reo1_ring_msi1_base_msb = 0x00000238,
-+	.hal_reo1_ring_msi1_data = 0x0000023c,
-+	.hal_reo2_ring_base_lsb = 0x00000244,
-+	.hal_reo1_aging_thresh_ix_0 = 0x00000564,
-+	.hal_reo1_aging_thresh_ix_1 = 0x00000568,
-+	.hal_reo1_aging_thresh_ix_2 = 0x0000056c,
-+	.hal_reo1_aging_thresh_ix_3 = 0x00000570,
-+
-+	/* REO2SW(x) R2 ring pointers (head/tail) address */
-+	.hal_reo1_ring_hp = 0x00003028,
-+	.hal_reo1_ring_tp = 0x0000302c,
-+	.hal_reo2_ring_hp = 0x00003030,
-+
-+	/* REO2TCL R0 ring configuration address */
-+	.hal_reo_tcl_ring_base_lsb = 0x000003fc,
-+	.hal_reo_tcl_ring_hp = 0x00003058,
-+
-+	/* SW2REO ring address */
-+	.hal_sw2reo_ring_base_lsb = 0x0000013c,
-+	.hal_sw2reo_ring_hp = 0x00003018,
-+
-+	/* REO CMD ring address */
-+	.hal_reo_cmd_ring_base_lsb = 0x000000e4,
-+	.hal_reo_cmd_ring_hp = 0x00003010,
-+
-+	/* REO status address */
-+	.hal_reo_status_ring_base_lsb = 0x00000504,
-+	.hal_reo_status_hp = 0x00003070,
-+
-+	/* WCSS relative address */
-+	.hal_seq_wcss_umac_ce0_src_reg = 0x08400000
-+		- HAL_IPQ5018_CE_WFSS_REG_BASE,
-+	.hal_seq_wcss_umac_ce0_dst_reg = 0x08401000
-+		- HAL_IPQ5018_CE_WFSS_REG_BASE,
-+	.hal_seq_wcss_umac_ce1_src_reg = 0x08402000
-+		- HAL_IPQ5018_CE_WFSS_REG_BASE,
-+	.hal_seq_wcss_umac_ce1_dst_reg = 0x08403000
-+		- HAL_IPQ5018_CE_WFSS_REG_BASE,
-+
-+	/* WBM Idle address */
-+	.hal_wbm_idle_link_ring_base_lsb = 0x00000874,
-+	.hal_wbm_idle_link_ring_misc = 0x00000884,
-+
-+	/* SW2WBM release address */
-+	.hal_wbm_release_ring_base_lsb = 0x000001ec,
-+
-+	/* WBM2SW release address */
-+	.hal_wbm0_release_ring_base_lsb = 0x00000924,
-+	.hal_wbm1_release_ring_base_lsb = 0x0000097c,
-+};
-+
- const struct ath11k_hw_hal_params ath11k_hw_hal_params_ipq8074 = {
- 	.rx_buf_rbm = HAL_RX_BUF_RBM_SW3_BM,
- 	.tcl2wbm_rbm_map = ath11k_hw_tcl2wbm_rbm_map_ipq8074,
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -415,6 +415,7 @@ extern const struct ath11k_hw_regs qca63
- extern const struct ath11k_hw_regs qcn9074_regs;
- extern const struct ath11k_hw_regs wcn6855_regs;
- extern const struct ath11k_hw_regs wcn6750_regs;
-+extern const struct ath11k_hw_regs ipq5018_regs;
- 
- static inline const char *ath11k_bd_ie_type_str(enum ath11k_bd_ie_type type)
- {
diff --git a/package/kernel/mac80211/patches/ath11k/0023-wifi-ath11k-initialize-hw_ops-for-IPQ5018.patch b/package/kernel/mac80211/patches/ath11k/0023-wifi-ath11k-initialize-hw_ops-for-IPQ5018.patch
deleted file mode 100644
index 5ef701a4..00000000
--- a/package/kernel/mac80211/patches/ath11k/0023-wifi-ath11k-initialize-hw_ops-for-IPQ5018.patch
+++ /dev/null
@@ -1,90 +0,0 @@
-From ba60f2793d3a37a00da14bb56a26558a902d2831 Mon Sep 17 00:00:00 2001
-From: Sriram R <quic_srirrama@quicinc.com>
-Date: Fri, 2 Dec 2022 23:37:14 +0200
-Subject: [PATCH] wifi: ath11k: initialize hw_ops for IPQ5018
-
-The ipq5018_ops is initialized for IPQ5018. This is different from
-other platforms.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221122132152.17771-7-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c |  1 +
- drivers/net/wireless/ath/ath11k/hw.c   | 40 ++++++++++++++++++++++++++
- drivers/net/wireless/ath/ath11k/hw.h   |  1 +
- 3 files changed, 42 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -635,6 +635,7 @@ static const struct ath11k_hw_params ath
- 		},
- 		.internal_sleep_clock = false,
- 		.regs = &ipq5018_regs,
-+		.hw_ops = &ipq5018_ops,
- 		.host_ce_config = ath11k_host_ce_config_qcn9074,
- 		.ce_count = CE_CNT_5018,
- 		.target_ce_config = ath11k_target_ce_config_wlan_ipq5018,
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -1084,6 +1084,46 @@ const struct ath11k_hw_ops wcn6750_ops =
- 	.get_ring_selector = ath11k_hw_wcn6750_get_tcl_ring_selector,
- };
- 
-+/* IPQ5018 hw ops is similar to QCN9074 except for the dest ring remap */
-+const struct ath11k_hw_ops ipq5018_ops = {
-+	.get_hw_mac_from_pdev_id = ath11k_hw_ipq6018_mac_from_pdev_id,
-+	.wmi_init_config = ath11k_init_wmi_config_ipq8074,
-+	.mac_id_to_pdev_id = ath11k_hw_mac_id_to_pdev_id_ipq8074,
-+	.mac_id_to_srng_id = ath11k_hw_mac_id_to_srng_id_ipq8074,
-+	.tx_mesh_enable = ath11k_hw_qcn9074_tx_mesh_enable,
-+	.rx_desc_get_first_msdu = ath11k_hw_qcn9074_rx_desc_get_first_msdu,
-+	.rx_desc_get_last_msdu = ath11k_hw_qcn9074_rx_desc_get_last_msdu,
-+	.rx_desc_get_l3_pad_bytes = ath11k_hw_qcn9074_rx_desc_get_l3_pad_bytes,
-+	.rx_desc_get_hdr_status = ath11k_hw_qcn9074_rx_desc_get_hdr_status,
-+	.rx_desc_encrypt_valid = ath11k_hw_qcn9074_rx_desc_encrypt_valid,
-+	.rx_desc_get_encrypt_type = ath11k_hw_qcn9074_rx_desc_get_encrypt_type,
-+	.rx_desc_get_decap_type = ath11k_hw_qcn9074_rx_desc_get_decap_type,
-+	.rx_desc_get_mesh_ctl = ath11k_hw_qcn9074_rx_desc_get_mesh_ctl,
-+	.rx_desc_get_ldpc_support = ath11k_hw_qcn9074_rx_desc_get_ldpc_support,
-+	.rx_desc_get_mpdu_seq_ctl_vld = ath11k_hw_qcn9074_rx_desc_get_mpdu_seq_ctl_vld,
-+	.rx_desc_get_mpdu_fc_valid = ath11k_hw_qcn9074_rx_desc_get_mpdu_fc_valid,
-+	.rx_desc_get_mpdu_start_seq_no = ath11k_hw_qcn9074_rx_desc_get_mpdu_start_seq_no,
-+	.rx_desc_get_msdu_len = ath11k_hw_qcn9074_rx_desc_get_msdu_len,
-+	.rx_desc_get_msdu_sgi = ath11k_hw_qcn9074_rx_desc_get_msdu_sgi,
-+	.rx_desc_get_msdu_rate_mcs = ath11k_hw_qcn9074_rx_desc_get_msdu_rate_mcs,
-+	.rx_desc_get_msdu_rx_bw = ath11k_hw_qcn9074_rx_desc_get_msdu_rx_bw,
-+	.rx_desc_get_msdu_freq = ath11k_hw_qcn9074_rx_desc_get_msdu_freq,
-+	.rx_desc_get_msdu_pkt_type = ath11k_hw_qcn9074_rx_desc_get_msdu_pkt_type,
-+	.rx_desc_get_msdu_nss = ath11k_hw_qcn9074_rx_desc_get_msdu_nss,
-+	.rx_desc_get_mpdu_tid = ath11k_hw_qcn9074_rx_desc_get_mpdu_tid,
-+	.rx_desc_get_mpdu_peer_id = ath11k_hw_qcn9074_rx_desc_get_mpdu_peer_id,
-+	.rx_desc_copy_attn_end_tlv = ath11k_hw_qcn9074_rx_desc_copy_attn_end,
-+	.rx_desc_get_mpdu_start_tag = ath11k_hw_qcn9074_rx_desc_get_mpdu_start_tag,
-+	.rx_desc_get_mpdu_ppdu_id = ath11k_hw_qcn9074_rx_desc_get_mpdu_ppdu_id,
-+	.rx_desc_set_msdu_len = ath11k_hw_qcn9074_rx_desc_set_msdu_len,
-+	.rx_desc_get_attention = ath11k_hw_qcn9074_rx_desc_get_attention,
-+	.rx_desc_get_msdu_payload = ath11k_hw_qcn9074_rx_desc_get_msdu_payload,
-+	.mpdu_info_get_peerid = ath11k_hw_ipq8074_mpdu_info_get_peerid,
-+	.rx_desc_mac_addr2_valid = ath11k_hw_ipq9074_rx_desc_mac_addr2_valid,
-+	.rx_desc_mpdu_start_addr2 = ath11k_hw_ipq9074_rx_desc_mpdu_start_addr2,
-+
-+};
-+
- #define ATH11K_TX_RING_MASK_0 BIT(0)
- #define ATH11K_TX_RING_MASK_1 BIT(1)
- #define ATH11K_TX_RING_MASK_2 BIT(2)
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -275,6 +275,7 @@ extern const struct ath11k_hw_ops qca639
- extern const struct ath11k_hw_ops qcn9074_ops;
- extern const struct ath11k_hw_ops wcn6855_ops;
- extern const struct ath11k_hw_ops wcn6750_ops;
-+extern const struct ath11k_hw_ops ipq5018_ops;
- 
- extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_ipq8074;
- extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qca6390;
diff --git a/package/kernel/mac80211/patches/ath11k/0024-wifi-ath11k-add-new-hw-ops-for-IPQ5018-to-get-rx-des.patch b/package/kernel/mac80211/patches/ath11k/0024-wifi-ath11k-add-new-hw-ops-for-IPQ5018-to-get-rx-des.patch
deleted file mode 100644
index 64531f13..00000000
--- a/package/kernel/mac80211/patches/ath11k/0024-wifi-ath11k-add-new-hw-ops-for-IPQ5018-to-get-rx-des.patch
+++ /dev/null
@@ -1,84 +0,0 @@
-From 69968f88f1770d61cae0febef805fd00d66cf6a1 Mon Sep 17 00:00:00 2001
-From: Sriram R <quic_srirrama@quicinc.com>
-Date: Fri, 2 Dec 2022 23:37:15 +0200
-Subject: [PATCH] wifi: ath11k: add new hw ops for IPQ5018 to get rx dest ring
- hashmap
-
-The Destination ring control register is different
-for IPQ5018 when compared to IPQ8074/IPQ6018/QCN9074.
-Hence create a new hw ops to fetch the hash ring map
-for different device variants. ipq5018 hw ops
-is similar to qcn9074 except for this change, so reuse
-all the qcn9074 ops for ipq5018.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221122132152.17771-8-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/hw.c | 44 ++++++++++++++++++++++++++++
- 1 file changed, 44 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -791,6 +791,49 @@ static void ath11k_hw_wcn6855_reo_setup(
- 			   ring_hash_map);
- }
- 
-+static void ath11k_hw_ipq5018_reo_setup(struct ath11k_base *ab)
-+{
-+	u32 reo_base = HAL_SEQ_WCSS_UMAC_REO_REG;
-+	u32 val;
-+
-+	/* Each hash entry uses three bits to map to a particular ring. */
-+	u32 ring_hash_map = HAL_HASH_ROUTING_RING_SW1 << 0 |
-+		HAL_HASH_ROUTING_RING_SW2 << 4 |
-+		HAL_HASH_ROUTING_RING_SW3 << 8 |
-+		HAL_HASH_ROUTING_RING_SW4 << 12 |
-+		HAL_HASH_ROUTING_RING_SW1 << 16 |
-+		HAL_HASH_ROUTING_RING_SW2 << 20 |
-+		HAL_HASH_ROUTING_RING_SW3 << 24 |
-+		HAL_HASH_ROUTING_RING_SW4 << 28;
-+
-+	val = ath11k_hif_read32(ab, reo_base + HAL_REO1_GEN_ENABLE);
-+
-+	val &= ~HAL_REO1_GEN_ENABLE_FRAG_DST_RING;
-+	val |= FIELD_PREP(HAL_REO1_GEN_ENABLE_FRAG_DST_RING,
-+			HAL_SRNG_RING_ID_REO2SW1) |
-+		FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_LIST_ENABLE, 1) |
-+		FIELD_PREP(HAL_REO1_GEN_ENABLE_AGING_FLUSH_ENABLE, 1);
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_GEN_ENABLE, val);
-+
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_0(ab),
-+			   HAL_DEFAULT_REO_TIMEOUT_USEC);
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_1(ab),
-+			   HAL_DEFAULT_REO_TIMEOUT_USEC);
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_2(ab),
-+			   HAL_DEFAULT_REO_TIMEOUT_USEC);
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_3(ab),
-+			   HAL_DEFAULT_REO_TIMEOUT_USEC);
-+
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_0,
-+			   ring_hash_map);
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_1,
-+			   ring_hash_map);
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_2,
-+			   ring_hash_map);
-+	ath11k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_3,
-+			   ring_hash_map);
-+}
-+
- static u16 ath11k_hw_ipq8074_mpdu_info_get_peerid(u8 *tlv_data)
- {
- 	u16 peer_id = 0;
-@@ -1117,6 +1160,7 @@ const struct ath11k_hw_ops ipq5018_ops =
- 	.rx_desc_get_mpdu_ppdu_id = ath11k_hw_qcn9074_rx_desc_get_mpdu_ppdu_id,
- 	.rx_desc_set_msdu_len = ath11k_hw_qcn9074_rx_desc_set_msdu_len,
- 	.rx_desc_get_attention = ath11k_hw_qcn9074_rx_desc_get_attention,
-+	.reo_setup = ath11k_hw_ipq5018_reo_setup,
- 	.rx_desc_get_msdu_payload = ath11k_hw_qcn9074_rx_desc_get_msdu_payload,
- 	.mpdu_info_get_peerid = ath11k_hw_ipq8074_mpdu_info_get_peerid,
- 	.rx_desc_mac_addr2_valid = ath11k_hw_ipq9074_rx_desc_mac_addr2_valid,
diff --git a/package/kernel/mac80211/patches/ath11k/0025-wifi-ath11k-add-ipq5018-device-support.patch b/package/kernel/mac80211/patches/ath11k/0025-wifi-ath11k-add-ipq5018-device-support.patch
deleted file mode 100644
index 5b930e8d..00000000
--- a/package/kernel/mac80211/patches/ath11k/0025-wifi-ath11k-add-ipq5018-device-support.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From 25edca7bb18a2a40cc7e54c6f522e9b3c917e2c5 Mon Sep 17 00:00:00 2001
-From: Sriram R <quic_srirrama@quicinc.com>
-Date: Fri, 2 Dec 2022 23:37:15 +0200
-Subject: [PATCH] wifi: ath11k: add ipq5018 device support
-
-ipq5018 is a ahb 2ghz device, enable the compatible support for
-ipq5018 in ahb.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sriram R <quic_srirrama@quicinc.com>
-Co-developed-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221122132152.17771-9-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/ahb.c | 3 +++
- 1 file changed, 3 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -32,6 +32,9 @@ static const struct of_device_id ath11k_
- 	{ .compatible = "qcom,wcn6750-wifi",
- 	  .data = (void *)ATH11K_HW_WCN6750_HW10,
- 	},
-+	{ .compatible = "qcom,ipq5018-wifi",
-+	  .data = (void *)ATH11K_HW_IPQ5018_HW10,
-+	},
- 	{ }
- };
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0026-wifi-ath11k-Fix-scan-request-param-frame-size-warnin.patch b/package/kernel/mac80211/patches/ath11k/0026-wifi-ath11k-Fix-scan-request-param-frame-size-warnin.patch
deleted file mode 100644
index 50c14e7b..00000000
--- a/package/kernel/mac80211/patches/ath11k/0026-wifi-ath11k-Fix-scan-request-param-frame-size-warnin.patch
+++ /dev/null
@@ -1,161 +0,0 @@
-From d45daa6d1a8da080f1b516c570a8428a7b9225e4 Mon Sep 17 00:00:00 2001
-From: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Date: Tue, 6 Dec 2022 00:51:25 +0530
-Subject: [PATCH] wifi: ath11k: Fix scan request param frame size warning
-
-Following warning was observed
-
-drivers/net/wireless/ath/ath11k/mac.c:2351:1: warning: the frame
-size of 1184 bytes is larger than 1024 bytes [-Wframe-larger-than=]
-
-A local variable is declared with a size larger than 1024 bytes
-this causing a compilation warning. Change the local variable to
-heap memory to fix the warning.
-
-Tested-on: IPQ8074 AHB WLAN.HK.2.7.0.1-01701-QCAHKSWPL_SILICONZ-1 v2
-
-Signed-off-by: Karthikeyan Kathirvel <quic_kathirve@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221205192125.13533-1-quic_kathirve@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 83 +++++++++++++++------------
- 1 file changed, 45 insertions(+), 38 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -3612,7 +3612,7 @@ static int ath11k_mac_op_hw_scan(struct
- 	struct ath11k *ar = hw->priv;
- 	struct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);
- 	struct cfg80211_scan_request *req = &hw_req->req;
--	struct scan_req_params arg;
-+	struct scan_req_params *arg = NULL;
- 	int ret = 0;
- 	int i;
- 	u32 scan_timeout;
-@@ -3640,72 +3640,78 @@ static int ath11k_mac_op_hw_scan(struct
- 	if (ret)
- 		goto exit;
- 
--	memset(&arg, 0, sizeof(arg));
--	ath11k_wmi_start_scan_init(ar, &arg);
--	arg.vdev_id = arvif->vdev_id;
--	arg.scan_id = ATH11K_SCAN_ID;
-+	arg = kzalloc(sizeof(*arg), GFP_KERNEL);
-+
-+	if (!arg) {
-+		ret = -ENOMEM;
-+		goto exit;
-+	}
-+
-+	ath11k_wmi_start_scan_init(ar, arg);
-+	arg->vdev_id = arvif->vdev_id;
-+	arg->scan_id = ATH11K_SCAN_ID;
- 
- 	if (req->ie_len) {
--		arg.extraie.ptr = kmemdup(req->ie, req->ie_len, GFP_KERNEL);
--		if (!arg.extraie.ptr) {
-+		arg->extraie.ptr = kmemdup(req->ie, req->ie_len, GFP_KERNEL);
-+		if (!arg->extraie.ptr) {
- 			ret = -ENOMEM;
- 			goto exit;
- 		}
--		arg.extraie.len = req->ie_len;
-+		arg->extraie.len = req->ie_len;
- 	}
- 
- 	if (req->n_ssids) {
--		arg.num_ssids = req->n_ssids;
--		for (i = 0; i < arg.num_ssids; i++) {
--			arg.ssid[i].length  = req->ssids[i].ssid_len;
--			memcpy(&arg.ssid[i].ssid, req->ssids[i].ssid,
-+		arg->num_ssids = req->n_ssids;
-+		for (i = 0; i < arg->num_ssids; i++) {
-+			arg->ssid[i].length  = req->ssids[i].ssid_len;
-+			memcpy(&arg->ssid[i].ssid, req->ssids[i].ssid,
- 			       req->ssids[i].ssid_len);
- 		}
- 	} else {
--		arg.scan_flags |= WMI_SCAN_FLAG_PASSIVE;
-+		arg->scan_flags |= WMI_SCAN_FLAG_PASSIVE;
- 	}
- 
- 	if (req->n_channels) {
--		arg.num_chan = req->n_channels;
--		arg.chan_list = kcalloc(arg.num_chan, sizeof(*arg.chan_list),
--					GFP_KERNEL);
-+		arg->num_chan = req->n_channels;
-+		arg->chan_list = kcalloc(arg->num_chan, sizeof(*arg->chan_list),
-+					 GFP_KERNEL);
- 
--		if (!arg.chan_list) {
-+		if (!arg->chan_list) {
- 			ret = -ENOMEM;
- 			goto exit;
- 		}
- 
--		for (i = 0; i < arg.num_chan; i++)
--			arg.chan_list[i] = req->channels[i]->center_freq;
-+		for (i = 0; i < arg->num_chan; i++)
-+			arg->chan_list[i] = req->channels[i]->center_freq;
- 	}
- 
- 	if (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {
--		arg.scan_f_add_spoofed_mac_in_probe = 1;
--		ether_addr_copy(arg.mac_addr.addr, req->mac_addr);
--		ether_addr_copy(arg.mac_mask.addr, req->mac_addr_mask);
-+		arg->scan_f_add_spoofed_mac_in_probe = 1;
-+		ether_addr_copy(arg->mac_addr.addr, req->mac_addr);
-+		ether_addr_copy(arg->mac_mask.addr, req->mac_addr_mask);
- 	}
- 
- 	/* if duration is set, default dwell times will be overwritten */
- 	if (req->duration) {
--		arg.dwell_time_active = req->duration;
--		arg.dwell_time_active_2g = req->duration;
--		arg.dwell_time_active_6g = req->duration;
--		arg.dwell_time_passive = req->duration;
--		arg.dwell_time_passive_6g = req->duration;
--		arg.burst_duration = req->duration;
-+		arg->dwell_time_active = req->duration;
-+		arg->dwell_time_active_2g = req->duration;
-+		arg->dwell_time_active_6g = req->duration;
-+		arg->dwell_time_passive = req->duration;
-+		arg->dwell_time_passive_6g = req->duration;
-+		arg->burst_duration = req->duration;
- 
--		scan_timeout = min_t(u32, arg.max_rest_time *
--				(arg.num_chan - 1) + (req->duration +
-+		scan_timeout = min_t(u32, arg->max_rest_time *
-+				(arg->num_chan - 1) + (req->duration +
- 				ATH11K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD) *
--				arg.num_chan, arg.max_scan_time);
-+				arg->num_chan, arg->max_scan_time);
- 	} else {
--		scan_timeout = arg.max_scan_time;
-+		scan_timeout = arg->max_scan_time;
- 	}
- 
- 	/* Add a margin to account for event/command processing */
- 	scan_timeout += ATH11K_MAC_SCAN_CMD_EVT_OVERHEAD;
- 
--	ret = ath11k_start_scan(ar, &arg);
-+	ret = ath11k_start_scan(ar, arg);
- 	if (ret) {
- 		ath11k_warn(ar->ab, "failed to start hw scan: %d\n", ret);
- 		spin_lock_bh(&ar->data_lock);
-@@ -3717,10 +3723,11 @@ static int ath11k_mac_op_hw_scan(struct
- 				     msecs_to_jiffies(scan_timeout));
- 
- exit:
--	kfree(arg.chan_list);
--
--	if (req->ie_len)
--		kfree(arg.extraie.ptr);
-+	if (arg) {
-+		kfree(arg->chan_list);
-+		kfree(arg->extraie.ptr);
-+		kfree(arg);
-+	}
- 
- 	mutex_unlock(&ar->conf_mutex);
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0029-wifi-ath11k-Add-support-to-configure-FTM-responder-r.patch b/package/kernel/mac80211/patches/ath11k/0029-wifi-ath11k-Add-support-to-configure-FTM-responder-r.patch
deleted file mode 100644
index f652d689..00000000
--- a/package/kernel/mac80211/patches/ath11k/0029-wifi-ath11k-Add-support-to-configure-FTM-responder-r.patch
+++ /dev/null
@@ -1,169 +0,0 @@
-From a27c6a5853eb9d4f293b99be73a6891fe88263c7 Mon Sep 17 00:00:00 2001
-From: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Date: Tue, 10 Jan 2023 15:30:57 +0200
-Subject: [PATCH] wifi: ath11k: Add support to configure FTM responder role
-
-Fine Timing Measurement(FTM) support is used to measure round trip
-time between two nodes.
-
-Enable FTM responder feature using hw_params on supported device.
-Since FTM functionality is offloaded to firmware, adding the
-interface allows user space to enable or disable FTM responder.
-Also add support for advertising the same in extended capabilities.
-
-QCA6390, WCN6855 and WCN6750 do not support this feature.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221220044435.10506-1-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c |  8 ++++++++
- drivers/net/wireless/ath/ath11k/core.h |  1 +
- drivers/net/wireless/ath/ath11k/hw.h   |  1 +
- drivers/net/wireless/ath/ath11k/mac.c  | 20 +++++++++++++++++++-
- drivers/net/wireless/ath/ath11k/wmi.h  |  1 +
- 5 files changed, 30 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -116,6 +116,7 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = true,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
-+		.ftm_responder = true,
- 	},
- 	{
- 		.hw_rev = ATH11K_HW_IPQ6018_HW10,
-@@ -198,6 +199,7 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = false,
-+		.ftm_responder = true,
- 	},
- 	{
- 		.name = "qca6390 hw2.0",
-@@ -282,6 +284,7 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = true,
-+		.ftm_responder = false,
- 	},
- 	{
- 		.name = "qcn9074 hw1.0",
-@@ -363,6 +366,7 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = false,
-+		.ftm_responder = true,
- 	},
- 	{
- 		.name = "wcn6855 hw2.0",
-@@ -447,6 +451,7 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = true,
-+		.ftm_responder = false,
- 	},
- 	{
- 		.name = "wcn6855 hw2.1",
-@@ -529,6 +534,7 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = true,
-+		.ftm_responder = false,
- 	},
- 	{
- 		.name = "wcn6750 hw1.0",
-@@ -609,6 +615,7 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE_WCN6750,
- 		.smp2p_wow_exit = true,
- 		.support_fw_mac_sequence = true,
-+		.ftm_responder = false,
- 	},
- 	{
- 		.hw_rev = ATH11K_HW_IPQ5018_HW10,
-@@ -688,6 +695,7 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = false,
-+		.ftm_responder = true,
- 	},
- };
- 
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -346,6 +346,7 @@ struct ath11k_vif {
- 
- 	bool is_started;
- 	bool is_up;
-+	bool ftm_responder;
- 	bool spectral_enabled;
- 	bool ps;
- 	u32 aid;
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -224,6 +224,7 @@ struct ath11k_hw_params {
- 	u32 tx_ring_size;
- 	bool smp2p_wow_exit;
- 	bool support_fw_mac_sequence;
-+	bool ftm_responder;
- };
- 
- struct ath11k_hw_ops {
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -3110,7 +3110,7 @@ static void ath11k_mac_op_bss_info_chang
- 	u16 bitrate;
- 	int ret = 0;
- 	u8 rateidx;
--	u32 rate;
-+	u32 rate, param;
- 	u32 ipv4_cnt;
- 
- 	mutex_lock(&ar->conf_mutex);
-@@ -3412,6 +3412,20 @@ static void ath11k_mac_op_bss_info_chang
- 		}
- 	}
- 
-+	if (changed & BSS_CHANGED_FTM_RESPONDER &&
-+	    arvif->ftm_responder != info->ftm_responder &&
-+	    ar->ab->hw_params.ftm_responder &&
-+	    (vif->type == NL80211_IFTYPE_AP ||
-+	     vif->type == NL80211_IFTYPE_MESH_POINT)) {
-+		arvif->ftm_responder = info->ftm_responder;
-+		param = WMI_VDEV_PARAM_ENABLE_DISABLE_RTT_RESPONDER_ROLE;
-+		ret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param,
-+						    arvif->ftm_responder);
-+		if (ret)
-+			ath11k_warn(ar->ab, "Failed to set ftm responder %i: %d\n",
-+				    arvif->vdev_id, ret);
-+	}
-+
- 	if (changed & BSS_CHANGED_FILS_DISCOVERY ||
- 	    changed & BSS_CHANGED_UNSOL_BCAST_PROBE_RESP)
- 		ath11k_mac_fils_discovery(arvif, info);
-@@ -9113,6 +9127,10 @@ static int __ath11k_mac_register(struct
- 	wiphy_ext_feature_set(ar->hw->wiphy,
- 			      NL80211_EXT_FEATURE_SET_SCAN_DWELL);
- 
-+	if (ab->hw_params.ftm_responder)
-+		wiphy_ext_feature_set(ar->hw->wiphy,
-+				      NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);
-+
- 	ath11k_reg_init(ar);
- 
- 	if (!test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags)) {
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -1073,6 +1073,7 @@ enum wmi_tlv_vdev_param {
- 	WMI_VDEV_PARAM_ENABLE_BCAST_PROBE_RESPONSE,
- 	WMI_VDEV_PARAM_FILS_MAX_CHANNEL_GUARD_TIME,
- 	WMI_VDEV_PARAM_HE_LTF = 0x74,
-+	WMI_VDEV_PARAM_ENABLE_DISABLE_RTT_RESPONDER_ROLE = 0x7d,
- 	WMI_VDEV_PARAM_BA_MODE = 0x7e,
- 	WMI_VDEV_PARAM_AUTORATE_MISC_CFG = 0x80,
- 	WMI_VDEV_PARAM_SET_HE_SOUNDING_MODE = 0x87,
diff --git a/package/kernel/mac80211/patches/ath11k/0030-wifi-ath11k-add-channel-177-into-5-GHz-channel-list.patch b/package/kernel/mac80211/patches/ath11k/0030-wifi-ath11k-add-channel-177-into-5-GHz-channel-list.patch
deleted file mode 100644
index d0ed9c54..00000000
--- a/package/kernel/mac80211/patches/ath11k/0030-wifi-ath11k-add-channel-177-into-5-GHz-channel-list.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From e5e94d10c85653609a2893c8d0ef24a27471b68f Mon Sep 17 00:00:00 2001
-From: Wen Gong <quic_wgong@quicinc.com>
-Date: Tue, 10 Jan 2023 15:30:58 +0200
-Subject: [PATCH] wifi: ath11k: add channel 177 into 5 GHz channel list
-
-Add support for the 5 GHz channel 177 with center frequency 5885 MHz and
-operating class 125 per IEEE Std 802.11ax-2021, Table E-4.
-
-Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
-
-Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221220101912.30816-1-quic_wgong@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.h | 4 ++--
- drivers/net/wireless/ath/ath11k/mac.c  | 1 +
- 2 files changed, 3 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -521,8 +521,8 @@ struct ath11k_sta {
- #define ATH11K_MIN_5G_FREQ 4150
- #define ATH11K_MIN_6G_FREQ 5925
- #define ATH11K_MAX_6G_FREQ 7115
--#define ATH11K_NUM_CHANS 101
--#define ATH11K_MAX_5G_CHAN 173
-+#define ATH11K_NUM_CHANS 102
-+#define ATH11K_MAX_5G_CHAN 177
- 
- enum ath11k_state {
- 	ATH11K_STATE_OFF,
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -96,6 +96,7 @@ static const struct ieee80211_channel at
- 	CHAN5G(165, 5825, 0),
- 	CHAN5G(169, 5845, 0),
- 	CHAN5G(173, 5865, 0),
-+	CHAN5G(177, 5885, 0),
- };
- 
- static const struct ieee80211_channel ath11k_6ghz_channels[] = {
diff --git a/package/kernel/mac80211/patches/ath11k/0031-wifi-ath11k-fix-ce-memory-mapping-for-ahb-devices.patch b/package/kernel/mac80211/patches/ath11k/0031-wifi-ath11k-fix-ce-memory-mapping-for-ahb-devices.patch
deleted file mode 100644
index 27867999..00000000
--- a/package/kernel/mac80211/patches/ath11k/0031-wifi-ath11k-fix-ce-memory-mapping-for-ahb-devices.patch
+++ /dev/null
@@ -1,114 +0,0 @@
-From 53a998c4d7284debd77734d01e1466e59a1d03b2 Mon Sep 17 00:00:00 2001
-From: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Date: Fri, 13 Jan 2023 12:02:09 +0530
-Subject: [PATCH] wifi: ath11k: fix ce memory mapping for ahb devices
-
-Currently ath11k_ahb module is not loaded successfully and the wifi
-interface is not created. Kernel trace is seen while loading the
-ath11k_ahb module. The issue is seen in all ath11k AHB devices except
-in IPQ5018.
-
-This happens because in ath11k_ahb_probe(), ab->mem_ce is initialized
-with the value of ab->mem. However, at this instant ab->mem is not
-yet set.
-
-Later, during write to a particular memory via ath11k_ahb_write32()
-this ab->mem_ce is used with particular offset. Since ab->mem_ce is
-not set properly this possibly leads to memory conflict to handle
-kernel paging request and the below trace is seen.
-
-[   93.035047] Unable to handle kernel paging request at virtual address ffff800100a00000
-[   93.035083] Mem abort info:
-[   93.041869]   ESR = 0x0000000096000045
-[   93.044561]   EC = 0x25: DABT (current EL), IL = 32 bits
-[   93.048377]   SET = 0, FnV = 0
-[   93.053840]   EA = 0, S1PTW = 0
-[   93.056704]   FSC = 0x05: level 1 translation fault
-[   93.059745] Data abort info:
-[   93.064603]   ISV = 0, ISS = 0x00000045
-[   93.067729]   CM = 0, WnR = 1
-[   93.071287] swapper pgtable: 4k pages, 48-bit VAs, pgdp=0000000042219000
-[   93.074409] [ffff800100a00000] pgd=100000007ffff003, p4d=100000007ffff003, pud=0000000000000000
-[   93.081195] Internal error: Oops: 0000000096000045 [#1] PREEMPT SMP
-[   93.089598] Modules linked in: ath11k_ahb ath11k_pci ath11k qmi_helpers
-[   93.095851] CPU: 2 PID: 66 Comm: kworker/u8:3 Not tainted 6.1.0-rc8-wt-ath-658126-g58e4b9df840c-dirty #2
-[   93.102454] Hardware name: Qualcomm Technologies, Inc. IPQ8074/AP-HK14 (DT)
-[   93.112171] Workqueue: ath11k_qmi_driver_event ath11k_qmi_driver_event_work [ath11k]
-[   93.118856] pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
-[   93.126838] pc : ath11k_ahb_write32+0xc/0x18 [ath11k_ahb]
-[   93.133520] lr : ath11k_hal_srng_setup+0x860/0x8f0 [ath11k]
-[   93.139075] sp : ffff80000aaebb70
-[   93.144452] x29: ffff80000aaebb70 x28: 0000000000000020 x27: ffff80000aaebc50
-[   93.147934] x26: ffff000004923750 x25: ffff000004921200 x24: ffff000004928000
-[   93.155051] x23: 0000000000000020 x22: ffff000004930000 x21: ffff000004923200
-[   93.162170] x20: ffff000004920000 x19: 00000000eea00000 x18: ffff0000049200f0
-[   93.169288] x17: 0000000000000000 x16: 0000000000000000 x15: 000000000000025e
-[   93.176405] x14: ffff000003c414f0 x13: 0000000000000000 x12: 0000000000000008
-[   93.183524] x11: ffff000003c41488 x10: 0000000000000040 x9 : 0000000000000000
-[   93.190641] x8 : ffff80000a9dd100 x7 : 0000000000000000 x6 : 000000000000003f
-[   93.197759] x5 : ffff800100a00400 x4 : ffff8000031f4018 x3 : 0000000000000004
-[   93.204877] x2 : 0000000047b62000 x1 : ffff800100a00000 x0 : ffff800012000000
-[   93.211996] Call trace:
-[   93.219104]  ath11k_ahb_write32+0xc/0x18 [ath11k_ahb]
-[   93.221366]  ath11k_ce_init_ring+0x184/0x278 [ath11k]
-[   93.226576]  ath11k_ce_init_pipes+0x4c/0x1a0 [ath11k]
-[   93.231610]  ath11k_core_qmi_firmware_ready+0x3c/0x568 [ath11k]
-[   93.236646]  ath11k_qmi_driver_event_work+0x168/0x4f8 [ath11k]
-[   93.242376]  process_one_work+0x144/0x350
-[   93.248275]  worker_thread+0x120/0x430
-[   93.252352]  kthread+0xf4/0x110
-[   93.255997]  ret_from_fork+0x10/0x20
-[   93.259043] Code: d503201f f94e1c00 8b214001 d50332bf (b9000022)
-[   93.262863] ---[ end trace 0000000000000000 ]---
-
-However, for the device IPQ5018 ath11k_hw_params .ce_remap is
-defined. This parameter is used to recalculate ab->mem_ce and hence,
-this issue is not seen in IPQ5018.
-
-Hence, fix this by initializing ab->mem_ce after ab->mem is set.
-ab->mem is set inside the ath11k_ahb_setup_resources() therefore
-initialize ab->mem_ce after ath11k_ahb_setup_resources().
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Fixes: b42b3678c91f ("wifi: ath11k: remap ce register space for IPQ5018")
-
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230113063209.7256-1-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/ahb.c | 12 ++++++------
- 1 file changed, 6 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -1157,12 +1157,16 @@ static int ath11k_ahb_probe(struct platf
- 		goto err_core_free;
- 	}
- 
--	ab->mem_ce = ab->mem;
--
- 	ret = ath11k_core_pre_init(ab);
- 	if (ret)
- 		goto err_core_free;
- 
-+	ret = ath11k_ahb_setup_resources(ab);
-+	if (ret)
-+		goto err_core_free;
-+
-+	ab->mem_ce = ab->mem;
-+
- 	if (ab->hw_params.ce_remap) {
- 		const struct ce_remap *ce_remap = ab->hw_params.ce_remap;
- 		/* ce register space is moved out of wcss unlike ipq8074 or ipq6018
-@@ -1177,10 +1181,6 @@ static int ath11k_ahb_probe(struct platf
- 		}
- 	}
- 
--	ret = ath11k_ahb_setup_resources(ab);
--	if (ret)
--		goto err_core_free;
--
- 	ret = ath11k_ahb_fw_resources_init(ab);
- 	if (ret)
- 		goto err_core_free;
diff --git a/package/kernel/mac80211/patches/ath11k/0033-wifi-ath11k-Set-ext-passive-scan-flag-to-adjust-pass.patch b/package/kernel/mac80211/patches/ath11k/0033-wifi-ath11k-Set-ext-passive-scan-flag-to-adjust-pass.patch
deleted file mode 100644
index 79b79e10..00000000
--- a/package/kernel/mac80211/patches/ath11k/0033-wifi-ath11k-Set-ext-passive-scan-flag-to-adjust-pass.patch
+++ /dev/null
@@ -1,73 +0,0 @@
-From cf8f3d4deb02a8fdc806c46d4112b69868544697 Mon Sep 17 00:00:00 2001
-From: Tamizh Chelvam Raja <quic_tamizhr@quicinc.com>
-Date: Wed, 15 Feb 2023 20:31:36 +0200
-Subject: [PATCH] wifi: ath11k: Set ext passive scan flag to adjust passive
- scan start time
-
-Set the WMI_SCAN_FLAG_EXT_PASSIVE_SCAN_START_TIME_ENHANCE flag
-while sending the scan command.  If this flag is enabled when the
-incoming scan request comes with a strict start time and its duration
-overlaps with next TBTT, then target adjust the start time accordingly
-for passive scan. Target supporting this feature will advertise
-WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-01467-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Tamizh Chelvam Raja <quic_tamizhr@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221222131720.11368-1-quic_tamizhr@quicinc.com
----
- drivers/net/wireless/ath/ath11k/wmi.c | 8 ++++++++
- drivers/net/wireless/ath/ath11k/wmi.h | 3 +++
- 2 files changed, 11 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -2068,6 +2068,12 @@ void ath11k_wmi_start_scan_init(struct a
- 				  WMI_SCAN_EVENT_FOREIGN_CHAN |
- 				  WMI_SCAN_EVENT_DEQUEUED;
- 	arg->scan_flags |= WMI_SCAN_CHAN_STAT_EVENT;
-+
-+	if (test_bit(WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE,
-+		     ar->ab->wmi_ab.svc_map))
-+		arg->scan_ctrl_flags_ext |=
-+			WMI_SCAN_FLAG_EXT_PASSIVE_SCAN_START_TIME_ENHANCE;
-+
- 	arg->num_bssid = 1;
- 
- 	/* fill bssid_list[0] with 0xff, otherwise bssid and RA will be
-@@ -2149,6 +2155,8 @@ ath11k_wmi_copy_scan_event_cntrl_flags(s
- 	/* for adaptive scan mode using 3 bits (21 - 23 bits) */
- 	WMI_SCAN_SET_DWELL_MODE(cmd->scan_ctrl_flags,
- 				param->adaptive_dwell_time_mode);
-+
-+	cmd->scan_ctrl_flags_ext = param->scan_ctrl_flags_ext;
- }
- 
- int ath11k_wmi_send_scan_start_cmd(struct ath11k *ar,
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2093,6 +2093,7 @@ enum wmi_tlv_service {
- 	WMI_TLV_SERVICE_EXT2_MSG = 220,
- 	WMI_TLV_SERVICE_PEER_POWER_SAVE_DURATION_SUPPORT = 246,
- 	WMI_TLV_SERVICE_SRG_SRP_SPATIAL_REUSE_SUPPORT = 249,
-+	WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE = 263,
- 
- 	/* The second 128 bits */
- 	WMI_MAX_EXT_SERVICE = 256,
-@@ -3223,6 +3224,7 @@ struct  wmi_start_scan_cmd {
- 
- #define WMI_SCAN_DWELL_MODE_MASK 0x00E00000
- #define WMI_SCAN_DWELL_MODE_SHIFT        21
-+#define WMI_SCAN_FLAG_EXT_PASSIVE_SCAN_START_TIME_ENHANCE   0x00000800
- 
- enum {
- 	WMI_SCAN_DWELL_MODE_DEFAULT      = 0,
-@@ -3270,6 +3272,7 @@ struct scan_req_params {
- 		};
- 		u32 scan_events;
- 	};
-+	u32 scan_ctrl_flags_ext;
- 	u32 dwell_time_active;
- 	u32 dwell_time_active_2g;
- 	u32 dwell_time_passive;
diff --git a/package/kernel/mac80211/patches/ath11k/0034-wifi-ath11k-fix-return-value-check-in-ath11k_ahb_pro.patch b/package/kernel/mac80211/patches/ath11k/0034-wifi-ath11k-fix-return-value-check-in-ath11k_ahb_pro.patch
deleted file mode 100644
index 59132913..00000000
--- a/package/kernel/mac80211/patches/ath11k/0034-wifi-ath11k-fix-return-value-check-in-ath11k_ahb_pro.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 342fcde9d91460f01f65707e16368a1571271a3a Mon Sep 17 00:00:00 2001
-From: Yang Yingliang <yangyingliang@huawei.com>
-Date: Fri, 17 Feb 2023 11:00:31 +0800
-Subject: [PATCH] wifi: ath11k: fix return value check in ath11k_ahb_probe()
-
-ioremap() returns NULL pointer not PTR_ERR() when it fails,
-so replace the IS_ERR() check with NULL pointer check.
-
-Fixes: b42b3678c91f ("wifi: ath11k: remap ce register space for IPQ5018")
-Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230217030031.4021289-1-yangyingliang@huawei.com
----
- drivers/net/wireless/ath/ath11k/ahb.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -1174,7 +1174,7 @@ static int ath11k_ahb_probe(struct platf
- 		 * to a new space for accessing them.
- 		 */
- 		ab->mem_ce = ioremap(ce_remap->base, ce_remap->size);
--		if (IS_ERR(ab->mem_ce)) {
-+		if (!ab->mem_ce) {
- 			dev_err(&pdev->dev, "ce ioremap error\n");
- 			ret = -ENOMEM;
- 			goto err_core_free;
diff --git a/package/kernel/mac80211/patches/ath11k/0035-wifi-ath11k-Use-platform_get_irq-to-get-the-interrup.patch b/package/kernel/mac80211/patches/ath11k/0035-wifi-ath11k-Use-platform_get_irq-to-get-the-interrup.patch
deleted file mode 100644
index 93a9da8f..00000000
--- a/package/kernel/mac80211/patches/ath11k/0035-wifi-ath11k-Use-platform_get_irq-to-get-the-interrup.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From f117276638b7600b981b3fe28550823cfbe1ef23 Mon Sep 17 00:00:00 2001
-From: Douglas Anderson <dianders@chromium.org>
-Date: Wed, 1 Feb 2023 08:54:42 -0800
-Subject: [PATCH] wifi: ath11k: Use platform_get_irq() to get the interrupt
-
-As of commit a1a2b7125e10 ("of/platform: Drop static setup of IRQ
-resource from DT core"), we need to use platform_get_irq() instead of
-platform_get_resource() to get our IRQs because
-platform_get_resource() simply won't get them anymore.
-
-This was already fixed in several other Atheros WiFi drivers,
-apparently in response to Zeal Robot reports. An example of another
-fix is commit 9503a1fc123d ("ath9k: Use platform_get_irq() to get the
-interrupt"). ath11k seems to have been missed in this effort, though.
-
-Without this change, WiFi wasn't coming up on my Qualcomm sc7280-based
-hardware. Specifically, "platform_get_resource(pdev, IORESOURCE_IRQ,
-i)" was failing even for i=0.
-
-Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00887-QCAMSLSWPLZ-1
-
-Fixes: a1a2b7125e10 ("of/platform: Drop static setup of IRQ resource from DT core")
-Fixes: 00402f49d26f ("ath11k: Add support for WCN6750 device")
-Signed-off-by: Douglas Anderson <dianders@chromium.org>
-Tested-by: Jun Yu <junyuu@chromium.org>
-Reviewed-by: Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230201084131.v2.1.I69cf3d56c97098287fe3a70084ee515098390b70@changeid
----
- drivers/net/wireless/ath/ath11k/ahb.c | 8 ++++----
- 1 file changed, 4 insertions(+), 4 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -874,11 +874,11 @@ static int ath11k_ahb_setup_msi_resource
- 	ab->pci.msi.ep_base_data = int_prop + 32;
- 
- 	for (i = 0; i < ab->pci.msi.config->total_vectors; i++) {
--		res = platform_get_resource(pdev, IORESOURCE_IRQ, i);
--		if (!res)
--			return -ENODEV;
-+		ret = platform_get_irq(pdev, i);
-+		if (ret < 0)
-+			return ret;
- 
--		ab->pci.msi.irqs[i] = res->start;
-+		ab->pci.msi.irqs[i] = ret;
- 	}
- 
- 	set_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags);
diff --git a/package/kernel/mac80211/patches/ath11k/0036-wifi-ath11k-fix-SAC-bug-on-peer-addition-with-sta-ba.patch b/package/kernel/mac80211/patches/ath11k/0036-wifi-ath11k-fix-SAC-bug-on-peer-addition-with-sta-ba.patch
deleted file mode 100644
index b37f070b..00000000
--- a/package/kernel/mac80211/patches/ath11k/0036-wifi-ath11k-fix-SAC-bug-on-peer-addition-with-sta-ba.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From 60b7d62ba8cdbd073997bff0f1cdae8d844002c0 Mon Sep 17 00:00:00 2001
-From: Christian Marangi <ansuelsmth@gmail.com>
-Date: Thu, 9 Feb 2023 23:26:22 +0100
-Subject: [PATCH] wifi: ath11k: fix SAC bug on peer addition with sta band
- migration
-
-Fix sleep in atomic context warning detected by Smatch static checker
-analyzer.
-
-Following the locking pattern for peer_rhash_add lock tbl_mtx_lock mutex
-always even if sta is not transitioning to another band.
-This is peer_add function and a more secure locking should not cause
-performance regression.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.5.0.1-01208-QCAHKSWPL_SILICONZ-1
-
-Fixes: d673cb6fe6c0 ("wifi: ath11k: fix peer addition/deletion error on sta band migration")
-Reported-by: Dan Carpenter <error27@gmail.com>
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230209222622.1751-1-ansuelsmth@gmail.com
----
- drivers/net/wireless/ath/ath11k/peer.c | 5 +++--
- 1 file changed, 3 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/peer.c
-+++ b/drivers/net/wireless/ath/ath11k/peer.c
-@@ -382,22 +382,23 @@ int ath11k_peer_create(struct ath11k *ar
- 		return -ENOBUFS;
- 	}
- 
-+	mutex_lock(&ar->ab->tbl_mtx_lock);
- 	spin_lock_bh(&ar->ab->base_lock);
- 	peer = ath11k_peer_find_by_addr(ar->ab, param->peer_addr);
- 	if (peer) {
- 		if (peer->vdev_id == param->vdev_id) {
- 			spin_unlock_bh(&ar->ab->base_lock);
-+			mutex_unlock(&ar->ab->tbl_mtx_lock);
- 			return -EINVAL;
- 		}
- 
- 		/* Assume sta is transitioning to another band.
- 		 * Remove here the peer from rhash.
- 		 */
--		mutex_lock(&ar->ab->tbl_mtx_lock);
- 		ath11k_peer_rhash_delete(ar->ab, peer);
--		mutex_unlock(&ar->ab->tbl_mtx_lock);
- 	}
- 	spin_unlock_bh(&ar->ab->base_lock);
-+	mutex_unlock(&ar->ab->tbl_mtx_lock);
- 
- 	ret = ath11k_wmi_send_peer_create_cmd(ar, param);
- 	if (ret) {
diff --git a/package/kernel/mac80211/patches/ath11k/0037-wifi-ath11k-allow-system-suspend-to-survive-ath11k.patch b/package/kernel/mac80211/patches/ath11k/0037-wifi-ath11k-allow-system-suspend-to-survive-ath11k.patch
deleted file mode 100644
index fa680954..00000000
--- a/package/kernel/mac80211/patches/ath11k/0037-wifi-ath11k-allow-system-suspend-to-survive-ath11k.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From 7c15430822e71e90203d87e6d0cfe83fa058b0dc Mon Sep 17 00:00:00 2001
-From: Len Brown <len.brown@intel.com>
-Date: Wed, 1 Feb 2023 12:32:01 -0600
-Subject: [PATCH] wifi: ath11k: allow system suspend to survive ath11k
-
-When ath11k runs into internal errors upon suspend,
-it returns an error code to pci_pm_suspend, which
-aborts the entire system suspend.
-
-The driver should not abort system suspend, but should
-keep its internal errors to itself, and allow the system
-to suspend.  Otherwise, a user can suspend a laptop
-by closing the lid and sealing it into a case, assuming
-that is will suspend, rather than heating up and draining
-the battery when in transit.
-
-In practice, the ath11k device seems to have plenty of transient
-errors, and subsequent suspend cycles after this failure
-often succeed.
-
-https://bugzilla.kernel.org/show_bug.cgi?id=216968
-
-Fixes: d1b0c33850d29 ("ath11k: implement suspend for QCA6390 PCI devices")
-
-Signed-off-by: Len Brown <len.brown@intel.com>
-Cc: stable@vger.kernel.org
-Signed-off-by: Kalle Valo <kvalo@kernel.org>
-Link: https://lore.kernel.org/r/20230201183201.14431-1-len.brown@intel.com
----
- drivers/net/wireless/ath/ath11k/pci.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -998,7 +998,7 @@ static __maybe_unused int ath11k_pci_pm_
- 	if (ret)
- 		ath11k_warn(ab, "failed to resume core: %d\n", ret);
- 
--	return ret;
-+	return 0;
- }
- 
- static SIMPLE_DEV_PM_OPS(ath11k_pci_pm_ops,
diff --git a/package/kernel/mac80211/patches/ath11k/0038-wifi-ath11k-modify-accessor-macros-to-match-index-si.patch b/package/kernel/mac80211/patches/ath11k/0038-wifi-ath11k-modify-accessor-macros-to-match-index-si.patch
deleted file mode 100644
index 42bf170a..00000000
--- a/package/kernel/mac80211/patches/ath11k/0038-wifi-ath11k-modify-accessor-macros-to-match-index-si.patch
+++ /dev/null
@@ -1,61 +0,0 @@
-From a96f10422e74cde27c100b321b127ec32ae75747 Mon Sep 17 00:00:00 2001
-From: Muna Sinada <quic_msinada@quicinc.com>
-Date: Fri, 24 Feb 2023 12:28:03 +0200
-Subject: [PATCH] wifi: ath11k: modify accessor macros to match index size
-
-HE PHY is only 11 bytes, therefore it should be using byte indexes
-instead of dword. Change corresponding macros to reflect this.
-
-Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/1666128501-12364-2-git-send-email-quic_msinada@quicinc.com
----
- drivers/net/wireless/ath/ath11k/wmi.h | 24 +++++++++++++-----------
- 1 file changed, 13 insertions(+), 11 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2859,30 +2859,32 @@ struct rx_reorder_queue_remove_params {
- #define WMI_VDEV_PARAM_TXBF_SU_TX_BFER BIT(2)
- #define WMI_VDEV_PARAM_TXBF_MU_TX_BFER BIT(3)
- 
--#define HECAP_PHYDWORD_0	0
--#define HECAP_PHYDWORD_1	1
--#define HECAP_PHYDWORD_2	2
-+#define HE_PHYCAP_BYTE_0	0
-+#define HE_PHYCAP_BYTE_1	1
-+#define HE_PHYCAP_BYTE_2	2
-+#define HE_PHYCAP_BYTE_3	3
-+#define HE_PHYCAP_BYTE_4	4
- 
--#define HECAP_PHY_SU_BFER		BIT(31)
-+#define HECAP_PHY_SU_BFER		BIT(7)
- #define HECAP_PHY_SU_BFEE		BIT(0)
- #define HECAP_PHY_MU_BFER		BIT(1)
--#define HECAP_PHY_UL_MUMIMO		BIT(22)
--#define HECAP_PHY_UL_MUOFDMA		BIT(23)
-+#define HECAP_PHY_UL_MUMIMO		BIT(6)
-+#define HECAP_PHY_UL_MUOFDMA		BIT(7)
- 
- #define HECAP_PHY_SUBFMR_GET(hecap_phy) \
--	FIELD_GET(HECAP_PHY_SU_BFER, hecap_phy[HECAP_PHYDWORD_0])
-+	FIELD_GET(HECAP_PHY_SU_BFER, hecap_phy[HE_PHYCAP_BYTE_3])
- 
- #define HECAP_PHY_SUBFME_GET(hecap_phy) \
--	FIELD_GET(HECAP_PHY_SU_BFEE, hecap_phy[HECAP_PHYDWORD_1])
-+	FIELD_GET(HECAP_PHY_SU_BFEE, hecap_phy[HE_PHYCAP_BYTE_4])
- 
- #define HECAP_PHY_MUBFMR_GET(hecap_phy) \
--	FIELD_GET(HECAP_PHY_MU_BFER, hecap_phy[HECAP_PHYDWORD_1])
-+	FIELD_GET(HECAP_PHY_MU_BFER, hecap_phy[HE_PHYCAP_BYTE_4])
- 
- #define HECAP_PHY_ULMUMIMO_GET(hecap_phy) \
--	FIELD_GET(HECAP_PHY_UL_MUMIMO, hecap_phy[HECAP_PHYDWORD_0])
-+	FIELD_GET(HECAP_PHY_UL_MUMIMO, hecap_phy[HE_PHYCAP_BYTE_2])
- 
- #define HECAP_PHY_ULOFDMA_GET(hecap_phy) \
--	FIELD_GET(HECAP_PHY_UL_MUOFDMA, hecap_phy[HECAP_PHYDWORD_0])
-+	FIELD_GET(HECAP_PHY_UL_MUOFDMA, hecap_phy[HE_PHYCAP_BYTE_2])
- 
- #define HE_MODE_SU_TX_BFEE	BIT(0)
- #define HE_MODE_SU_TX_BFER	BIT(1)
diff --git a/package/kernel/mac80211/patches/ath11k/0039-wifi-ath11k-push-MU-MIMO-params-from-hostapd-to-hard.patch b/package/kernel/mac80211/patches/ath11k/0039-wifi-ath11k-push-MU-MIMO-params-from-hostapd-to-hard.patch
deleted file mode 100644
index 298ce1a6..00000000
--- a/package/kernel/mac80211/patches/ath11k/0039-wifi-ath11k-push-MU-MIMO-params-from-hostapd-to-hard.patch
+++ /dev/null
@@ -1,300 +0,0 @@
-From 38dfe775d0abf511341f37c1cb77b919a3ad410b Mon Sep 17 00:00:00 2001
-From: Muna Sinada <quic_msinada@quicinc.com>
-Date: Fri, 24 Feb 2023 12:28:04 +0200
-Subject: [PATCH] wifi: ath11k: push MU-MIMO params from hostapd to hardware
-
-In the previous behaviour only HE IE in management frames are changed
-regarding MU-MIMO configurations and not in hardware. Adding push of
-MU-MIMO configurations to the hardware as well.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-00356-QCAHKSWPL_SILICONZ-1
-
-Co-developed-by: Anilkumar Kolli <quic_akolli@quicinc.com>
-Signed-off-by: Anilkumar Kolli <quic_akolli@quicinc.com>
-Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/1666128501-12364-3-git-send-email-quic_msinada@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 200 ++++++++++++++++----------
- drivers/net/wireless/ath/ath11k/wmi.h |   3 +
- 2 files changed, 130 insertions(+), 73 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -2699,6 +2699,117 @@ static int ath11k_setup_peer_smps(struct
- 					 ath11k_smps_map[smps]);
- }
- 
-+static bool ath11k_mac_set_he_txbf_conf(struct ath11k_vif *arvif)
-+{
-+	struct ath11k *ar = arvif->ar;
-+	u32 param, value;
-+	int ret;
-+
-+	if (!arvif->vif->bss_conf.he_support)
-+		return true;
-+
-+	param = WMI_VDEV_PARAM_SET_HEMU_MODE;
-+	value = 0;
-+	if (arvif->vif->bss_conf.he_su_beamformer) {
-+		value |= FIELD_PREP(HE_MODE_SU_TX_BFER, HE_SU_BFER_ENABLE);
-+		if (arvif->vif->bss_conf.he_mu_beamformer &&
-+		    arvif->vdev_type == WMI_VDEV_TYPE_AP)
-+			value |= FIELD_PREP(HE_MODE_MU_TX_BFER, HE_MU_BFER_ENABLE);
-+	}
-+
-+	if (arvif->vif->type != NL80211_IFTYPE_MESH_POINT) {
-+		value |= FIELD_PREP(HE_MODE_DL_OFDMA, HE_DL_MUOFDMA_ENABLE) |
-+			 FIELD_PREP(HE_MODE_UL_OFDMA, HE_UL_MUOFDMA_ENABLE);
-+
-+		if (arvif->vif->bss_conf.he_full_ul_mumimo)
-+			value |= FIELD_PREP(HE_MODE_UL_MUMIMO, HE_UL_MUMIMO_ENABLE);
-+
-+		if (arvif->vif->bss_conf.he_su_beamformee)
-+			value |= FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE);
-+	}
-+
-+	ret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param, value);
-+	if (ret) {
-+		ath11k_warn(ar->ab, "failed to set vdev %d HE MU mode: %d\n",
-+			    arvif->vdev_id, ret);
-+		return false;
-+	}
-+
-+	param = WMI_VDEV_PARAM_SET_HE_SOUNDING_MODE;
-+	value =	FIELD_PREP(HE_VHT_SOUNDING_MODE, HE_VHT_SOUNDING_MODE_ENABLE) |
-+		FIELD_PREP(HE_TRIG_NONTRIG_SOUNDING_MODE,
-+			   HE_TRIG_NONTRIG_SOUNDING_MODE_ENABLE);
-+	ret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
-+					    param, value);
-+	if (ret) {
-+		ath11k_warn(ar->ab, "failed to set vdev %d sounding mode: %d\n",
-+			    arvif->vdev_id, ret);
-+		return false;
-+	}
-+	return true;
-+}
-+
-+static bool ath11k_mac_vif_recalc_sta_he_txbf(struct ath11k *ar,
-+					      struct ieee80211_vif *vif,
-+					      struct ieee80211_sta_he_cap *he_cap)
-+{
-+	struct ath11k_vif *arvif = (void *)vif->drv_priv;
-+	struct ieee80211_he_cap_elem he_cap_elem = {0};
-+	struct ieee80211_sta_he_cap *cap_band = NULL;
-+	struct cfg80211_chan_def def;
-+	u32 param = WMI_VDEV_PARAM_SET_HEMU_MODE;
-+	u32 hemode = 0;
-+	int ret;
-+
-+	if (!vif->bss_conf.he_support)
-+		return true;
-+
-+	if (vif->type != NL80211_IFTYPE_STATION)
-+		return false;
-+
-+	if (WARN_ON(ath11k_mac_vif_chan(vif, &def)))
-+		return false;
-+
-+	if (def.chan->band == NL80211_BAND_2GHZ)
-+		cap_band = &ar->mac.iftype[NL80211_BAND_2GHZ][vif->type].he_cap;
-+	else
-+		cap_band = &ar->mac.iftype[NL80211_BAND_5GHZ][vif->type].he_cap;
-+
-+	memcpy(&he_cap_elem, &cap_band->he_cap_elem, sizeof(he_cap_elem));
-+
-+	if (HECAP_PHY_SUBFME_GET(he_cap_elem.phy_cap_info)) {
-+		if (HECAP_PHY_SUBFMR_GET(he_cap->he_cap_elem.phy_cap_info))
-+			hemode |= FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE);
-+		if (HECAP_PHY_MUBFMR_GET(he_cap->he_cap_elem.phy_cap_info))
-+			hemode |= FIELD_PREP(HE_MODE_MU_TX_BFEE, HE_MU_BFEE_ENABLE);
-+	}
-+
-+	if (vif->type != NL80211_IFTYPE_MESH_POINT) {
-+		hemode |= FIELD_PREP(HE_MODE_DL_OFDMA, HE_DL_MUOFDMA_ENABLE) |
-+			  FIELD_PREP(HE_MODE_UL_OFDMA, HE_UL_MUOFDMA_ENABLE);
-+
-+		if (HECAP_PHY_ULMUMIMO_GET(he_cap_elem.phy_cap_info))
-+			if (HECAP_PHY_ULMUMIMO_GET(he_cap->he_cap_elem.phy_cap_info))
-+				hemode |= FIELD_PREP(HE_MODE_UL_MUMIMO,
-+						     HE_UL_MUMIMO_ENABLE);
-+
-+		if (FIELD_GET(HE_MODE_MU_TX_BFEE, hemode))
-+			hemode |= FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE);
-+
-+		if (FIELD_GET(HE_MODE_MU_TX_BFER, hemode))
-+			hemode |= FIELD_PREP(HE_MODE_SU_TX_BFER, HE_SU_BFER_ENABLE);
-+	}
-+
-+	ret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param, hemode);
-+	if (ret) {
-+		ath11k_warn(ar->ab, "failed to submit vdev param txbf 0x%x: %d\n",
-+			    hemode, ret);
-+		return false;
-+	}
-+
-+	return true;
-+}
-+
- static void ath11k_bss_assoc(struct ieee80211_hw *hw,
- 			     struct ieee80211_vif *vif,
- 			     struct ieee80211_bss_conf *bss_conf)
-@@ -2709,6 +2820,7 @@ static void ath11k_bss_assoc(struct ieee
- 	struct ieee80211_sta *ap_sta;
- 	struct ath11k_peer *peer;
- 	bool is_auth = false;
-+	struct ieee80211_sta_he_cap  he_cap;
- 	int ret;
- 
- 	lockdep_assert_held(&ar->conf_mutex);
-@@ -2726,6 +2838,9 @@ static void ath11k_bss_assoc(struct ieee
- 		return;
- 	}
- 
-+	/* he_cap here is updated at assoc success for sta mode only */
-+	he_cap  = ap_sta->deflink.he_cap;
-+
- 	ath11k_peer_assoc_prepare(ar, vif, ap_sta, &peer_arg, false);
- 
- 	rcu_read_unlock();
-@@ -2753,6 +2868,12 @@ static void ath11k_bss_assoc(struct ieee
- 		return;
- 	}
- 
-+	if (!ath11k_mac_vif_recalc_sta_he_txbf(ar, vif, &he_cap)) {
-+		ath11k_warn(ar->ab, "failed to recalc he txbf for vdev %i on bss %pM\n",
-+			    arvif->vdev_id, bss_conf->bssid);
-+		return;
-+	}
-+
- 	WARN_ON(arvif->is_up);
- 
- 	arvif->aid = vif->cfg.aid;
-@@ -3202,6 +3323,8 @@ static void ath11k_mac_op_bss_info_chang
- 		ether_addr_copy(arvif->bssid, info->bssid);
- 
- 	if (changed & BSS_CHANGED_BEACON_ENABLED) {
-+		if (info->enable_beacon)
-+			ath11k_mac_set_he_txbf_conf(arvif);
- 		ath11k_control_beaconing(arvif, info);
- 
- 		if (arvif->is_up && vif->bss_conf.he_support &&
-@@ -5392,6 +5515,10 @@ static int ath11k_mac_copy_he_cap(struct
- 
- 		he_cap_elem->mac_cap_info[1] &=
- 			IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_MASK;
-+		he_cap_elem->phy_cap_info[0] &=
-+			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
-+		he_cap_elem->phy_cap_info[0] &=
-+			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;
- 
- 		he_cap_elem->phy_cap_info[5] &=
- 			~IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK;
-@@ -6026,69 +6153,6 @@ ath11k_mac_setup_vdev_create_params(stru
- 	}
- }
- 
--static u32
--ath11k_mac_prepare_he_mode(struct ath11k_pdev *pdev, u32 viftype)
--{
--	struct ath11k_pdev_cap *pdev_cap = &pdev->cap;
--	struct ath11k_band_cap *cap_band = NULL;
--	u32 *hecap_phy_ptr = NULL;
--	u32 hemode = 0;
--
--	if (pdev->cap.supported_bands & WMI_HOST_WLAN_2G_CAP)
--		cap_band = &pdev_cap->band[NL80211_BAND_2GHZ];
--	else
--		cap_band = &pdev_cap->band[NL80211_BAND_5GHZ];
--
--	hecap_phy_ptr = &cap_band->he_cap_phy_info[0];
--
--	hemode = FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE) |
--		 FIELD_PREP(HE_MODE_SU_TX_BFER, HECAP_PHY_SUBFMR_GET(hecap_phy_ptr)) |
--		 FIELD_PREP(HE_MODE_UL_MUMIMO, HECAP_PHY_ULMUMIMO_GET(hecap_phy_ptr));
--
--	/* TODO WDS and other modes */
--	if (viftype == NL80211_IFTYPE_AP) {
--		hemode |= FIELD_PREP(HE_MODE_MU_TX_BFER,
--			  HECAP_PHY_MUBFMR_GET(hecap_phy_ptr)) |
--			  FIELD_PREP(HE_MODE_DL_OFDMA, HE_DL_MUOFDMA_ENABLE) |
--			  FIELD_PREP(HE_MODE_UL_OFDMA, HE_UL_MUOFDMA_ENABLE);
--	} else {
--		hemode |= FIELD_PREP(HE_MODE_MU_TX_BFEE, HE_MU_BFEE_ENABLE);
--	}
--
--	return hemode;
--}
--
--static int ath11k_set_he_mu_sounding_mode(struct ath11k *ar,
--					  struct ath11k_vif *arvif)
--{
--	u32 param_id, param_value;
--	struct ath11k_base *ab = ar->ab;
--	int ret = 0;
--
--	param_id = WMI_VDEV_PARAM_SET_HEMU_MODE;
--	param_value = ath11k_mac_prepare_he_mode(ar->pdev, arvif->vif->type);
--	ret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
--					    param_id, param_value);
--	if (ret) {
--		ath11k_warn(ab, "failed to set vdev %d HE MU mode: %d param_value %x\n",
--			    arvif->vdev_id, ret, param_value);
--		return ret;
--	}
--	param_id = WMI_VDEV_PARAM_SET_HE_SOUNDING_MODE;
--	param_value =
--		FIELD_PREP(HE_VHT_SOUNDING_MODE, HE_VHT_SOUNDING_MODE_ENABLE) |
--		FIELD_PREP(HE_TRIG_NONTRIG_SOUNDING_MODE,
--			   HE_TRIG_NONTRIG_SOUNDING_MODE_ENABLE);
--	ret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,
--					    param_id, param_value);
--	if (ret) {
--		ath11k_warn(ab, "failed to set vdev %d HE MU mode: %d\n",
--			    arvif->vdev_id, ret);
--		return ret;
--	}
--	return ret;
--}
--
- static void ath11k_mac_op_update_vif_offload(struct ieee80211_hw *hw,
- 					     struct ieee80211_vif *vif)
- {
-@@ -6757,7 +6821,6 @@ ath11k_mac_vdev_start_restart(struct ath
- 	struct ath11k_base *ab = ar->ab;
- 	struct wmi_vdev_start_req_arg arg = {};
- 	const struct cfg80211_chan_def *chandef = &ctx->def;
--	int he_support = arvif->vif->bss_conf.he_support;
- 	int ret = 0;
- 
- 	lockdep_assert_held(&ar->conf_mutex);
-@@ -6798,15 +6861,6 @@ ath11k_mac_vdev_start_restart(struct ath
- 		spin_lock_bh(&ab->base_lock);
- 		arg.regdomain = ar->ab->dfs_region;
- 		spin_unlock_bh(&ab->base_lock);
--
--		if (he_support) {
--			ret = ath11k_set_he_mu_sounding_mode(ar, arvif);
--			if (ret) {
--				ath11k_warn(ar->ab, "failed to set he mode vdev %i\n",
--					    arg.vdev_id);
--				return ret;
--			}
--		}
- 	}
- 
- 	arg.channel.passive |= !!(chandef->chan->flags & IEEE80211_CHAN_NO_IR);
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2897,8 +2897,11 @@ struct rx_reorder_queue_remove_params {
- #define HE_DL_MUOFDMA_ENABLE	1
- #define HE_UL_MUOFDMA_ENABLE	1
- #define HE_DL_MUMIMO_ENABLE	1
-+#define HE_UL_MUMIMO_ENABLE	1
- #define HE_MU_BFEE_ENABLE	1
- #define HE_SU_BFEE_ENABLE	1
-+#define HE_MU_BFER_ENABLE	1
-+#define HE_SU_BFER_ENABLE	1
- 
- #define HE_VHT_SOUNDING_MODE_ENABLE		1
- #define HE_SU_MU_SOUNDING_MODE_ENABLE		1
diff --git a/package/kernel/mac80211/patches/ath11k/0040-wifi-ath11k-move-HE-MCS-mapper-to-a-separate-functio.patch b/package/kernel/mac80211/patches/ath11k/0040-wifi-ath11k-move-HE-MCS-mapper-to-a-separate-functio.patch
deleted file mode 100644
index 6bc9880e..00000000
--- a/package/kernel/mac80211/patches/ath11k/0040-wifi-ath11k-move-HE-MCS-mapper-to-a-separate-functio.patch
+++ /dev/null
@@ -1,67 +0,0 @@
-From 8077c1bbbc28e527fb29143c46f32c6a9d6cadf0 Mon Sep 17 00:00:00 2001
-From: Muna Sinada <quic_msinada@quicinc.com>
-Date: Fri, 24 Feb 2023 12:28:04 +0200
-Subject: [PATCH] wifi: ath11k: move HE MCS mapper to a separate function
-
-Move HE MCS mapper to a separate function and call new function
-in ath11k_mac_copy_he_cap().
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-00356-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/1666128501-12364-4-git-send-email-quic_msinada@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 34 +++++++++++++++++----------
- 1 file changed, 22 insertions(+), 12 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -5483,6 +5483,27 @@ static __le16 ath11k_mac_setup_he_6ghz_c
- 	return cpu_to_le16(bcap->he_6ghz_capa);
- }
- 
-+static void ath11k_mac_set_hemcsmap(struct ath11k *ar,
-+				    struct ath11k_pdev_cap *cap,
-+				    struct ieee80211_sta_he_cap *he_cap,
-+				    int band)
-+{
-+	struct ath11k_band_cap *band_cap = &cap->band[band];
-+
-+	he_cap->he_mcs_nss_supp.rx_mcs_80 =
-+		cpu_to_le16(band_cap->he_mcs & 0xffff);
-+	he_cap->he_mcs_nss_supp.tx_mcs_80 =
-+		cpu_to_le16(band_cap->he_mcs & 0xffff);
-+	he_cap->he_mcs_nss_supp.rx_mcs_160 =
-+		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+	he_cap->he_mcs_nss_supp.tx_mcs_160 =
-+		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+	he_cap->he_mcs_nss_supp.rx_mcs_80p80 =
-+		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+	he_cap->he_mcs_nss_supp.tx_mcs_80p80 =
-+		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+}
-+
- static int ath11k_mac_copy_he_cap(struct ath11k *ar,
- 				  struct ath11k_pdev_cap *cap,
- 				  struct ieee80211_sband_iftype_data *data,
-@@ -5544,18 +5565,7 @@ static int ath11k_mac_copy_he_cap(struct
- 			break;
- 		}
- 
--		he_cap->he_mcs_nss_supp.rx_mcs_80 =
--			cpu_to_le16(band_cap->he_mcs & 0xffff);
--		he_cap->he_mcs_nss_supp.tx_mcs_80 =
--			cpu_to_le16(band_cap->he_mcs & 0xffff);
--		he_cap->he_mcs_nss_supp.rx_mcs_160 =
--			cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
--		he_cap->he_mcs_nss_supp.tx_mcs_160 =
--			cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
--		he_cap->he_mcs_nss_supp.rx_mcs_80p80 =
--			cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
--		he_cap->he_mcs_nss_supp.tx_mcs_80p80 =
--			cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+		ath11k_mac_set_hemcsmap(ar, cap, he_cap, band);
- 
- 		memset(he_cap->ppe_thres, 0, sizeof(he_cap->ppe_thres));
- 		if (he_cap_elem->phy_cap_info[6] &
diff --git a/package/kernel/mac80211/patches/ath11k/0041-wifi-ath11k-generate-rx-and-tx-mcs-maps-for-supporte.patch b/package/kernel/mac80211/patches/ath11k/0041-wifi-ath11k-generate-rx-and-tx-mcs-maps-for-supporte.patch
deleted file mode 100644
index 5cb7801b..00000000
--- a/package/kernel/mac80211/patches/ath11k/0041-wifi-ath11k-generate-rx-and-tx-mcs-maps-for-supporte.patch
+++ /dev/null
@@ -1,64 +0,0 @@
-From ebf82988f844dd98e6b007cffcc5e95986056995 Mon Sep 17 00:00:00 2001
-From: Muna Sinada <quic_msinada@quicinc.com>
-Date: Fri, 24 Feb 2023 12:28:04 +0200
-Subject: [PATCH] wifi: ath11k: generate rx and tx mcs maps for supported HE
- mcs
-
-Generate rx and tx mcs maps in ath11k_mac_set_hemcsmap() and set them
-in supported mcs/nss for HE capabilities.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-00356-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/1666128501-12364-5-git-send-email-quic_msinada@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 30 ++++++++++++++++++++-------
- 1 file changed, 23 insertions(+), 7 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -5488,20 +5488,36 @@ static void ath11k_mac_set_hemcsmap(stru
- 				    struct ieee80211_sta_he_cap *he_cap,
- 				    int band)
- {
--	struct ath11k_band_cap *band_cap = &cap->band[band];
-+	u16 txmcs_map, rxmcs_map;
-+	u32 i;
- 
-+	rxmcs_map = 0;
-+	txmcs_map = 0;
-+	for (i = 0; i < 8; i++) {
-+		if (i < ar->num_tx_chains &&
-+		    (ar->cfg_tx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))
-+			txmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);
-+		else
-+			txmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);
-+
-+		if (i < ar->num_rx_chains &&
-+		    (ar->cfg_rx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))
-+			rxmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);
-+		else
-+			rxmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);
-+	}
- 	he_cap->he_mcs_nss_supp.rx_mcs_80 =
--		cpu_to_le16(band_cap->he_mcs & 0xffff);
-+		cpu_to_le16(rxmcs_map & 0xffff);
- 	he_cap->he_mcs_nss_supp.tx_mcs_80 =
--		cpu_to_le16(band_cap->he_mcs & 0xffff);
-+		cpu_to_le16(txmcs_map & 0xffff);
- 	he_cap->he_mcs_nss_supp.rx_mcs_160 =
--		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+		cpu_to_le16(rxmcs_map & 0xffff);
- 	he_cap->he_mcs_nss_supp.tx_mcs_160 =
--		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+		cpu_to_le16(txmcs_map & 0xffff);
- 	he_cap->he_mcs_nss_supp.rx_mcs_80p80 =
--		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+		cpu_to_le16(rxmcs_map & 0xffff);
- 	he_cap->he_mcs_nss_supp.tx_mcs_80p80 =
--		cpu_to_le16((band_cap->he_mcs >> 16) & 0xffff);
-+		cpu_to_le16(txmcs_map & 0xffff);
- }
- 
- static int ath11k_mac_copy_he_cap(struct ath11k *ar,
diff --git a/package/kernel/mac80211/patches/ath11k/0042-wifi-ath11k-Add-tx-ack-signal-support-for-management.patch b/package/kernel/mac80211/patches/ath11k/0042-wifi-ath11k-Add-tx-ack-signal-support-for-management.patch
deleted file mode 100644
index 8d416573..00000000
--- a/package/kernel/mac80211/patches/ath11k/0042-wifi-ath11k-Add-tx-ack-signal-support-for-management.patch
+++ /dev/null
@@ -1,150 +0,0 @@
-From 01c6c9fccbd51c1d9eab0f5794b0271b026178df Mon Sep 17 00:00:00 2001
-From: Abinaya Kalaiselvan <quic_akalaise@quicinc.com>
-Date: Mon, 19 Dec 2022 11:08:44 +0530
-Subject: [PATCH] wifi: ath11k: Add tx ack signal support for management
- packets
-
-Add support to notify tx ack signal values for management
-packets to userspace through nl80211 interface.
-
-Advertise NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT flag
-to enable this feature and it will be used for data
-packets as well.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Abinaya Kalaiselvan <quic_akalaise@quicinc.com>
-Signed-off-by: Maharaja Kennadyrajan <quic_mkenna@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20221219053844.4084486-1-quic_mkenna@quicinc.com
----
- drivers/net/wireless/ath/ath11k/hw.c  |  1 +
- drivers/net/wireless/ath/ath11k/mac.c |  5 +++++
- drivers/net/wireless/ath/ath11k/wmi.c | 27 ++++++++++++++++-----------
- drivers/net/wireless/ath/ath11k/wmi.h |  3 +++
- 4 files changed, 25 insertions(+), 11 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -201,6 +201,7 @@ static void ath11k_init_wmi_config_ipq80
- 	config->twt_ap_pdev_count = ab->num_radios;
- 	config->twt_ap_sta_count = 1000;
- 	config->flag1 |= WMI_RSRC_CFG_FLAG1_BSS_CHANNEL_INFO_64;
-+	config->flag1 |= WMI_RSRC_CFG_FLAG1_ACK_RSSI;
- }
- 
- static int ath11k_hw_mac_id_to_pdev_id_ipq8074(struct ath11k_hw_params *hw,
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -9174,6 +9174,11 @@ static int __ath11k_mac_register(struct
- 		goto err_free_if_combs;
- 	}
- 
-+	if (test_bit(WMI_TLV_SERVICE_TX_DATA_MGMT_ACK_RSSI,
-+		     ar->ab->wmi_ab.svc_map))
-+		wiphy_ext_feature_set(ar->hw->wiphy,
-+				      NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);
-+
- 	ar->hw->queues = ATH11K_HW_MAX_QUEUES;
- 	ar->hw->wiphy->tx_queue_len = ATH11K_QUEUE_LEN;
- 	ar->hw->offchannel_tx_hw_queue = ATH11K_HW_MAX_QUEUES - 1;
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -5229,8 +5229,8 @@ static int ath11k_pull_mgmt_rx_params_tl
- 	return 0;
- }
- 
--static int wmi_process_mgmt_tx_comp(struct ath11k *ar, u32 desc_id,
--				    u32 status)
-+static int wmi_process_mgmt_tx_comp(struct ath11k *ar,
-+				    struct wmi_mgmt_tx_compl_event *tx_compl_param)
- {
- 	struct sk_buff *msdu;
- 	struct ieee80211_tx_info *info;
-@@ -5238,24 +5238,29 @@ static int wmi_process_mgmt_tx_comp(stru
- 	int num_mgmt;
- 
- 	spin_lock_bh(&ar->txmgmt_idr_lock);
--	msdu = idr_find(&ar->txmgmt_idr, desc_id);
-+	msdu = idr_find(&ar->txmgmt_idr, tx_compl_param->desc_id);
- 
- 	if (!msdu) {
- 		ath11k_warn(ar->ab, "received mgmt tx compl for invalid msdu_id: %d\n",
--			    desc_id);
-+			    tx_compl_param->desc_id);
- 		spin_unlock_bh(&ar->txmgmt_idr_lock);
- 		return -ENOENT;
- 	}
- 
--	idr_remove(&ar->txmgmt_idr, desc_id);
-+	idr_remove(&ar->txmgmt_idr, tx_compl_param->desc_id);
- 	spin_unlock_bh(&ar->txmgmt_idr_lock);
- 
- 	skb_cb = ATH11K_SKB_CB(msdu);
- 	dma_unmap_single(ar->ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);
- 
- 	info = IEEE80211_SKB_CB(msdu);
--	if ((!(info->flags & IEEE80211_TX_CTL_NO_ACK)) && !status)
-+	if ((!(info->flags & IEEE80211_TX_CTL_NO_ACK)) &&
-+	    !tx_compl_param->status) {
- 		info->flags |= IEEE80211_TX_STAT_ACK;
-+		if (test_bit(WMI_TLV_SERVICE_TX_DATA_MGMT_ACK_RSSI,
-+			     ar->ab->wmi_ab.svc_map))
-+			info->status.ack_signal = tx_compl_param->ack_rssi;
-+	}
- 
- 	ieee80211_tx_status_irqsafe(ar->hw, msdu);
- 
-@@ -5267,7 +5272,7 @@ static int wmi_process_mgmt_tx_comp(stru
- 
- 	ath11k_dbg(ar->ab, ATH11K_DBG_WMI,
- 		   "wmi mgmt tx comp pending %d desc id %d\n",
--		   num_mgmt, desc_id);
-+		   num_mgmt, tx_compl_param->desc_id);
- 
- 	if (!num_mgmt)
- 		wake_up(&ar->txmgmt_empty_waitq);
-@@ -5300,6 +5305,7 @@ static int ath11k_pull_mgmt_tx_compl_par
- 	param->pdev_id = ev->pdev_id;
- 	param->desc_id = ev->desc_id;
- 	param->status = ev->status;
-+	param->ack_rssi = ev->ack_rssi;
- 
- 	kfree(tb);
- 	return 0;
-@@ -7070,13 +7076,12 @@ static void ath11k_mgmt_tx_compl_event(s
- 		goto exit;
- 	}
- 
--	wmi_process_mgmt_tx_comp(ar, tx_compl_param.desc_id,
--				 tx_compl_param.status);
-+	wmi_process_mgmt_tx_comp(ar, &tx_compl_param);
- 
- 	ath11k_dbg(ab, ATH11K_DBG_MGMT,
--		   "mgmt tx compl ev pdev_id %d, desc_id %d, status %d",
-+		   "mgmt tx compl ev pdev_id %d, desc_id %d, status %d ack_rssi %d",
- 		   tx_compl_param.pdev_id, tx_compl_param.desc_id,
--		   tx_compl_param.status);
-+		   tx_compl_param.status, tx_compl_param.ack_rssi);
- 
- exit:
- 	rcu_read_unlock();
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2311,6 +2311,7 @@ struct wmi_init_cmd {
- } __packed;
- 
- #define WMI_RSRC_CFG_FLAG1_BSS_CHANNEL_INFO_64 BIT(5)
-+#define WMI_RSRC_CFG_FLAG1_ACK_RSSI BIT(18)
- 
- struct wmi_resource_config {
- 	u32 tlv_header;
-@@ -4550,6 +4551,8 @@ struct wmi_mgmt_tx_compl_event {
- 	u32 desc_id;
- 	u32 status;
- 	u32 pdev_id;
-+	u32 ppdu_id;
-+	u32 ack_rssi;
- } __packed;
- 
- struct wmi_scan_event {
diff --git a/package/kernel/mac80211/patches/ath11k/0043-wifi-ath11k-use-proper-regulatory-reference-for-band.patch b/package/kernel/mac80211/patches/ath11k/0043-wifi-ath11k-use-proper-regulatory-reference-for-band.patch
deleted file mode 100644
index 5bc19552..00000000
--- a/package/kernel/mac80211/patches/ath11k/0043-wifi-ath11k-use-proper-regulatory-reference-for-band.patch
+++ /dev/null
@@ -1,216 +0,0 @@
-From 25e289e1f52e1f4fb1d07622c6a24f8d8a8e420d Mon Sep 17 00:00:00 2001
-From: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Date: Wed, 1 Mar 2023 16:20:58 +0200
-Subject: [PATCH] wifi: ath11k: use proper regulatory reference for bands
-
-Currently, during regulatory event, 2 GHz/5 GHz is referred
-to as 2G/5G including variable names. However, there is no
-such entity as 2G or 5G.
-
-Re-name such occurences to its proper name. No functional changes.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230110121024.14051-2-quic_adisi@quicinc.com
----
- drivers/net/wireless/ath/ath11k/reg.c | 20 ++++-----
- drivers/net/wireless/ath/ath11k/wmi.c | 58 ++++++++++++++-------------
- drivers/net/wireless/ath/ath11k/wmi.h | 28 ++++++-------
- 3 files changed, 54 insertions(+), 52 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/reg.c
-+++ b/drivers/net/wireless/ath/ath11k/reg.c
-@@ -619,7 +619,7 @@ ath11k_reg_build_regd(struct ath11k_base
- 	u32 flags;
- 	char alpha2[3];
- 
--	num_rules = reg_info->num_5g_reg_rules + reg_info->num_2g_reg_rules;
-+	num_rules = reg_info->num_5ghz_reg_rules + reg_info->num_2ghz_reg_rules;
- 
- 	if (!num_rules)
- 		goto ret;
-@@ -644,20 +644,20 @@ ath11k_reg_build_regd(struct ath11k_base
- 		   alpha2, ath11k_reg_get_regdom_str(tmp_regd->dfs_region),
- 		   reg_info->dfs_region, num_rules);
- 	/* Update reg_rules[] below. Firmware is expected to
--	 * send these rules in order(2G rules first and then 5G)
-+	 * send these rules in order(2 GHz rules first and then 5 GHz)
- 	 */
- 	for (; i < num_rules; i++) {
--		if (reg_info->num_2g_reg_rules &&
--		    (i < reg_info->num_2g_reg_rules)) {
--			reg_rule = reg_info->reg_rules_2g_ptr + i;
-+		if (reg_info->num_2ghz_reg_rules &&
-+		    (i < reg_info->num_2ghz_reg_rules)) {
-+			reg_rule = reg_info->reg_rules_2ghz_ptr + i;
- 			max_bw = min_t(u16, reg_rule->max_bw,
--				       reg_info->max_bw_2g);
-+				       reg_info->max_bw_2ghz);
- 			flags = 0;
--		} else if (reg_info->num_5g_reg_rules &&
--			   (j < reg_info->num_5g_reg_rules)) {
--			reg_rule = reg_info->reg_rules_5g_ptr + j++;
-+		} else if (reg_info->num_5ghz_reg_rules &&
-+			   (j < reg_info->num_5ghz_reg_rules)) {
-+			reg_rule = reg_info->reg_rules_5ghz_ptr + j++;
- 			max_bw = min_t(u16, reg_rule->max_bw,
--				       reg_info->max_bw_5g);
-+				       reg_info->max_bw_5ghz);
- 
- 			/* FW doesn't pass NL80211_RRF_AUTO_BW flag for
- 			 * BW Auto correction, we can enable this by default
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -4959,7 +4959,7 @@ static int ath11k_pull_reg_chan_list_upd
- 	const void **tb;
- 	const struct wmi_reg_chan_list_cc_event *chan_list_event_hdr;
- 	struct wmi_regulatory_rule_struct *wmi_reg_rule;
--	u32 num_2g_reg_rules, num_5g_reg_rules;
-+	u32 num_2ghz_reg_rules, num_5ghz_reg_rules;
- 	int ret;
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI, "processing regulatory channel list\n");
-@@ -4978,10 +4978,10 @@ static int ath11k_pull_reg_chan_list_upd
- 		return -EPROTO;
- 	}
- 
--	reg_info->num_2g_reg_rules = chan_list_event_hdr->num_2g_reg_rules;
--	reg_info->num_5g_reg_rules = chan_list_event_hdr->num_5g_reg_rules;
-+	reg_info->num_2ghz_reg_rules = chan_list_event_hdr->num_2ghz_reg_rules;
-+	reg_info->num_5ghz_reg_rules = chan_list_event_hdr->num_5ghz_reg_rules;
- 
--	if (!(reg_info->num_2g_reg_rules + reg_info->num_5g_reg_rules)) {
-+	if (!(reg_info->num_2ghz_reg_rules + reg_info->num_5ghz_reg_rules)) {
- 		ath11k_warn(ab, "No regulatory rules available in the event info\n");
- 		kfree(tb);
- 		return -EINVAL;
-@@ -5008,46 +5008,48 @@ static int ath11k_pull_reg_chan_list_upd
- 	else if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_STATUS_FAIL)
- 		reg_info->status_code = REG_SET_CC_STATUS_FAIL;
- 
--	reg_info->min_bw_2g = chan_list_event_hdr->min_bw_2g;
--	reg_info->max_bw_2g = chan_list_event_hdr->max_bw_2g;
--	reg_info->min_bw_5g = chan_list_event_hdr->min_bw_5g;
--	reg_info->max_bw_5g = chan_list_event_hdr->max_bw_5g;
-+	reg_info->min_bw_2ghz = chan_list_event_hdr->min_bw_2ghz;
-+	reg_info->max_bw_2ghz = chan_list_event_hdr->max_bw_2ghz;
-+	reg_info->min_bw_5ghz = chan_list_event_hdr->min_bw_5ghz;
-+	reg_info->max_bw_5ghz = chan_list_event_hdr->max_bw_5ghz;
- 
--	num_2g_reg_rules = reg_info->num_2g_reg_rules;
--	num_5g_reg_rules = reg_info->num_5g_reg_rules;
-+	num_2ghz_reg_rules = reg_info->num_2ghz_reg_rules;
-+	num_5ghz_reg_rules = reg_info->num_5ghz_reg_rules;
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI,
--		   "%s:cc %s dsf %d BW: min_2g %d max_2g %d min_5g %d max_5g %d",
-+		   "%s:cc %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d",
- 		   __func__, reg_info->alpha2, reg_info->dfs_region,
--		   reg_info->min_bw_2g, reg_info->max_bw_2g,
--		   reg_info->min_bw_5g, reg_info->max_bw_5g);
-+		   reg_info->min_bw_2ghz, reg_info->max_bw_2ghz,
-+		   reg_info->min_bw_5ghz, reg_info->max_bw_5ghz);
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI,
--		   "%s: num_2g_reg_rules %d num_5g_reg_rules %d", __func__,
--		   num_2g_reg_rules, num_5g_reg_rules);
-+		   "%s: num_2ghz_reg_rules %d num_5ghz_reg_rules %d", __func__,
-+		   num_2ghz_reg_rules, num_5ghz_reg_rules);
- 
- 	wmi_reg_rule =
- 		(struct wmi_regulatory_rule_struct *)((u8 *)chan_list_event_hdr
- 						+ sizeof(*chan_list_event_hdr)
- 						+ sizeof(struct wmi_tlv));
- 
--	if (num_2g_reg_rules) {
--		reg_info->reg_rules_2g_ptr = create_reg_rules_from_wmi(num_2g_reg_rules,
--								       wmi_reg_rule);
--		if (!reg_info->reg_rules_2g_ptr) {
-+	if (num_2ghz_reg_rules) {
-+		reg_info->reg_rules_2ghz_ptr =
-+				create_reg_rules_from_wmi(num_2ghz_reg_rules,
-+							  wmi_reg_rule);
-+		if (!reg_info->reg_rules_2ghz_ptr) {
- 			kfree(tb);
--			ath11k_warn(ab, "Unable to Allocate memory for 2g rules\n");
-+			ath11k_warn(ab, "Unable to Allocate memory for 2 GHz rules\n");
- 			return -ENOMEM;
- 		}
- 	}
- 
--	if (num_5g_reg_rules) {
--		wmi_reg_rule += num_2g_reg_rules;
--		reg_info->reg_rules_5g_ptr = create_reg_rules_from_wmi(num_5g_reg_rules,
--								       wmi_reg_rule);
--		if (!reg_info->reg_rules_5g_ptr) {
-+	if (num_5ghz_reg_rules) {
-+		wmi_reg_rule += num_2ghz_reg_rules;
-+		reg_info->reg_rules_5ghz_ptr =
-+				create_reg_rules_from_wmi(num_5ghz_reg_rules,
-+							  wmi_reg_rule);
-+		if (!reg_info->reg_rules_5ghz_ptr) {
- 			kfree(tb);
--			ath11k_warn(ab, "Unable to Allocate memory for 5g rules\n");
-+			ath11k_warn(ab, "Unable to Allocate memory for 5 GHz rules\n");
- 			return -ENOMEM;
- 		}
- 	}
-@@ -6619,8 +6621,8 @@ fallback:
- 	WARN_ON(1);
- mem_free:
- 	if (reg_info) {
--		kfree(reg_info->reg_rules_2g_ptr);
--		kfree(reg_info->reg_rules_5g_ptr);
-+		kfree(reg_info->reg_rules_2ghz_ptr);
-+		kfree(reg_info->reg_rules_5ghz_ptr);
- 		kfree(reg_info);
- 	}
- 	return ret;
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -4129,14 +4129,14 @@ struct cur_regulatory_info {
- 	u8 alpha2[REG_ALPHA2_LEN + 1];
- 	u32 dfs_region;
- 	u32 phybitmap;
--	u32 min_bw_2g;
--	u32 max_bw_2g;
--	u32 min_bw_5g;
--	u32 max_bw_5g;
--	u32 num_2g_reg_rules;
--	u32 num_5g_reg_rules;
--	struct cur_reg_rule *reg_rules_2g_ptr;
--	struct cur_reg_rule *reg_rules_5g_ptr;
-+	u32 min_bw_2ghz;
-+	u32 max_bw_2ghz;
-+	u32 min_bw_5ghz;
-+	u32 max_bw_5ghz;
-+	u32 num_2ghz_reg_rules;
-+	u32 num_5ghz_reg_rules;
-+	struct cur_reg_rule *reg_rules_2ghz_ptr;
-+	struct cur_reg_rule *reg_rules_5ghz_ptr;
- };
- 
- struct wmi_reg_chan_list_cc_event {
-@@ -4148,12 +4148,12 @@ struct wmi_reg_chan_list_cc_event {
- 	u32 domain_code;
- 	u32 dfs_region;
- 	u32 phybitmap;
--	u32 min_bw_2g;
--	u32 max_bw_2g;
--	u32 min_bw_5g;
--	u32 max_bw_5g;
--	u32 num_2g_reg_rules;
--	u32 num_5g_reg_rules;
-+	u32 min_bw_2ghz;
-+	u32 max_bw_2ghz;
-+	u32 min_bw_5ghz;
-+	u32 max_bw_5ghz;
-+	u32 num_2ghz_reg_rules;
-+	u32 num_5ghz_reg_rules;
- } __packed;
- 
- struct wmi_regulatory_rule_struct {
diff --git a/package/kernel/mac80211/patches/ath11k/0044-wifi-ath11k-add-support-to-parse-new-WMI-event-for-6.patch b/package/kernel/mac80211/patches/ath11k/0044-wifi-ath11k-add-support-to-parse-new-WMI-event-for-6.patch
deleted file mode 100644
index e165c09d..00000000
--- a/package/kernel/mac80211/patches/ath11k/0044-wifi-ath11k-add-support-to-parse-new-WMI-event-for-6.patch
+++ /dev/null
@@ -1,844 +0,0 @@
-From 91fa00fa69224aae5afb720c5e68b22e4c4f7333 Mon Sep 17 00:00:00 2001
-From: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Date: Wed, 1 Mar 2023 16:20:59 +0200
-Subject: [PATCH] wifi: ath11k: add support to parse new WMI event for 6 GHz
-
-In order to support different power levels of 6 GHz AP and client,
-new WMI event for regulatory - WMI_REG_CHAN_LIST_CC_EXT_EVENTID is
-added in firmware. This event provides new parameters required for
-6 GHz regulatory rules.
-
-Add support for parsing 2.4 GHz, 5 GHz and 6 GHz reg rules and other
-parameters from WMI_REG_CHAN_LIST_CC_EXT_EVENTID.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Lavanya Suresh <quic_lavaks@quicinc.com>
-Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
-Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230110121024.14051-3-quic_adisi@quicinc.com
----
- drivers/net/wireless/ath/ath11k/reg.c |  37 ++-
- drivers/net/wireless/ath/ath11k/wmi.c | 418 +++++++++++++++++++++++++-
- drivers/net/wireless/ath/ath11k/wmi.h | 163 +++++++++-
- 3 files changed, 584 insertions(+), 34 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/reg.c
-+++ b/drivers/net/wireless/ath/ath11k/reg.c
-@@ -613,7 +613,7 @@ ath11k_reg_build_regd(struct ath11k_base
- {
- 	struct ieee80211_regdomain *tmp_regd, *default_regd, *new_regd = NULL;
- 	struct cur_reg_rule *reg_rule;
--	u8 i = 0, j = 0;
-+	u8 i = 0, j = 0, k = 0;
- 	u8 num_rules;
- 	u16 max_bw;
- 	u32 flags;
-@@ -621,6 +621,12 @@ ath11k_reg_build_regd(struct ath11k_base
- 
- 	num_rules = reg_info->num_5ghz_reg_rules + reg_info->num_2ghz_reg_rules;
- 
-+	/* FIXME: Currently taking reg rules for 6 GHz only from Indoor AP mode list.
-+	 * This can be updated after complete 6 GHz regulatory support is added.
-+	 */
-+	if (reg_info->is_ext_reg_event)
-+		num_rules += reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP];
-+
- 	if (!num_rules)
- 		goto ret;
- 
-@@ -666,6 +672,14 @@ ath11k_reg_build_regd(struct ath11k_base
- 			 * per other BW rule flags we pass from here
- 			 */
- 			flags = NL80211_RRF_AUTO_BW;
-+		} else if (reg_info->is_ext_reg_event &&
-+			   reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP] &&
-+			   (k < reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP])) {
-+			reg_rule = reg_info->reg_rules_6ghz_ap_ptr[WMI_REG_INDOOR_AP] +
-+				   k++;
-+			max_bw = min_t(u16, reg_rule->max_bw,
-+				       reg_info->max_bw_6ghz_ap[WMI_REG_INDOOR_AP]);
-+			flags = NL80211_RRF_AUTO_BW;
- 		} else {
- 			break;
- 		}
-@@ -693,12 +707,21 @@ ath11k_reg_build_regd(struct ath11k_base
- 			continue;
- 		}
- 
--		ath11k_dbg(ab, ATH11K_DBG_REG,
--			   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\n",
--			   i + 1, reg_rule->start_freq, reg_rule->end_freq,
--			   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
--			   tmp_regd->reg_rules[i].dfs_cac_ms,
--			   flags);
-+		if (reg_info->is_ext_reg_event) {
-+			ath11k_dbg(ab, ATH11K_DBG_REG,
-+				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d) (%d, %d)\n",
-+				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
-+				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-+				   tmp_regd->reg_rules[i].dfs_cac_ms, flags,
-+				   reg_rule->psd_flag, reg_rule->psd_eirp);
-+		} else {
-+			ath11k_dbg(ab, ATH11K_DBG_REG,
-+				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\n",
-+				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
-+				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-+				   tmp_regd->reg_rules[i].dfs_cac_ms,
-+				   flags);
-+		}
- 	}
- 
- 	tmp_regd->n_reg_rules = i;
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -105,6 +105,8 @@ static const struct wmi_tlv_policy wmi_t
- 		= { .min_len = sizeof(struct wmi_vdev_stopped_event) },
- 	[WMI_TAG_REG_CHAN_LIST_CC_EVENT]
- 		= { .min_len = sizeof(struct wmi_reg_chan_list_cc_event) },
-+	[WMI_TAG_REG_CHAN_LIST_CC_EXT_EVENT]
-+		= { .min_len = sizeof(struct wmi_reg_chan_list_cc_ext_event) },
- 	[WMI_TAG_MGMT_RX_HDR]
- 		= { .min_len = sizeof(struct wmi_mgmt_rx_hdr) },
- 	[WMI_TAG_MGMT_TX_COMPL_EVENT]
-@@ -3974,6 +3976,10 @@ ath11k_wmi_copy_resource_config(struct w
- 	wmi_cfg->sched_params = tg_cfg->sched_params;
- 	wmi_cfg->twt_ap_pdev_count = tg_cfg->twt_ap_pdev_count;
- 	wmi_cfg->twt_ap_sta_count = tg_cfg->twt_ap_sta_count;
-+	wmi_cfg->host_service_flags &=
-+		~(1 << WMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT);
-+	wmi_cfg->host_service_flags |= (tg_cfg->is_reg_cc_ext_event_supported <<
-+					WMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT);
- }
- 
- static int ath11k_init_cmd_send(struct ath11k_pdev_wmi *wmi,
-@@ -4192,6 +4198,10 @@ int ath11k_wmi_cmd_init(struct ath11k_ba
- 
- 	ab->hw_params.hw_ops->wmi_init_config(ab, &config);
- 
-+	if (test_bit(WMI_TLV_SERVICE_REG_CC_EXT_EVENT_SUPPORT,
-+		     ab->wmi_ab.svc_map))
-+		config.is_reg_cc_ext_event_supported = 1;
-+
- 	memcpy(&wmi_sc->wlan_resource_config, &config, sizeof(config));
- 
- 	init_param.res_cfg = &wmi_sc->wlan_resource_config;
-@@ -4995,18 +5005,11 @@ static int ath11k_pull_reg_chan_list_upd
- 	reg_info->phy_id = chan_list_event_hdr->phy_id;
- 	reg_info->ctry_code = chan_list_event_hdr->country_id;
- 	reg_info->reg_dmn_pair = chan_list_event_hdr->domain_code;
--	if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_STATUS_PASS)
--		reg_info->status_code = REG_SET_CC_STATUS_PASS;
--	else if (chan_list_event_hdr->status_code == WMI_REG_CURRENT_ALPHA2_NOT_FOUND)
--		reg_info->status_code = REG_CURRENT_ALPHA2_NOT_FOUND;
--	else if (chan_list_event_hdr->status_code == WMI_REG_INIT_ALPHA2_NOT_FOUND)
--		reg_info->status_code = REG_INIT_ALPHA2_NOT_FOUND;
--	else if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_CHANGE_NOT_ALLOWED)
--		reg_info->status_code = REG_SET_CC_CHANGE_NOT_ALLOWED;
--	else if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_STATUS_NO_MEMORY)
--		reg_info->status_code = REG_SET_CC_STATUS_NO_MEMORY;
--	else if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_STATUS_FAIL)
--		reg_info->status_code = REG_SET_CC_STATUS_FAIL;
-+
-+	reg_info->status_code =
-+		ath11k_wmi_cc_setting_code_to_reg(chan_list_event_hdr->status_code);
-+
-+	reg_info->is_ext_reg_event = false;
- 
- 	reg_info->min_bw_2ghz = chan_list_event_hdr->min_bw_2ghz;
- 	reg_info->max_bw_2ghz = chan_list_event_hdr->max_bw_2ghz;
-@@ -5060,6 +5063,372 @@ static int ath11k_pull_reg_chan_list_upd
- 	return 0;
- }
- 
-+static struct cur_reg_rule
-+*create_ext_reg_rules_from_wmi(u32 num_reg_rules,
-+			       struct wmi_regulatory_ext_rule *wmi_reg_rule)
-+{
-+	struct cur_reg_rule *reg_rule_ptr;
-+	u32 count;
-+
-+	reg_rule_ptr =  kcalloc(num_reg_rules, sizeof(*reg_rule_ptr), GFP_ATOMIC);
-+
-+	if (!reg_rule_ptr)
-+		return NULL;
-+
-+	for (count = 0; count < num_reg_rules; count++) {
-+		reg_rule_ptr[count].start_freq =
-+			u32_get_bits(wmi_reg_rule[count].freq_info,
-+				     REG_RULE_START_FREQ);
-+		reg_rule_ptr[count].end_freq =
-+			u32_get_bits(wmi_reg_rule[count].freq_info,
-+				     REG_RULE_END_FREQ);
-+		reg_rule_ptr[count].max_bw =
-+			u32_get_bits(wmi_reg_rule[count].bw_pwr_info,
-+				     REG_RULE_MAX_BW);
-+		reg_rule_ptr[count].reg_power =
-+			u32_get_bits(wmi_reg_rule[count].bw_pwr_info,
-+				     REG_RULE_REG_PWR);
-+		reg_rule_ptr[count].ant_gain =
-+			u32_get_bits(wmi_reg_rule[count].bw_pwr_info,
-+				     REG_RULE_ANT_GAIN);
-+		reg_rule_ptr[count].flags =
-+			u32_get_bits(wmi_reg_rule[count].flag_info,
-+				     REG_RULE_FLAGS);
-+		reg_rule_ptr[count].psd_flag =
-+			u32_get_bits(wmi_reg_rule[count].psd_power_info,
-+				     REG_RULE_PSD_INFO);
-+		reg_rule_ptr[count].psd_eirp =
-+			u32_get_bits(wmi_reg_rule[count].psd_power_info,
-+				     REG_RULE_PSD_EIRP);
-+	}
-+
-+	return reg_rule_ptr;
-+}
-+
-+static u8
-+ath11k_invalid_5ghz_reg_ext_rules_from_wmi(u32 num_reg_rules,
-+					   const struct wmi_regulatory_ext_rule *rule)
-+{
-+	u8 num_invalid_5ghz_rules = 0;
-+	u32 count, start_freq;
-+
-+	for (count = 0; count < num_reg_rules; count++) {
-+		start_freq = u32_get_bits(rule[count].freq_info,
-+					  REG_RULE_START_FREQ);
-+
-+		if (start_freq >= ATH11K_MIN_6G_FREQ)
-+			num_invalid_5ghz_rules++;
-+	}
-+
-+	return num_invalid_5ghz_rules;
-+}
-+
-+static int ath11k_pull_reg_chan_list_ext_update_ev(struct ath11k_base *ab,
-+						   struct sk_buff *skb,
-+						   struct cur_regulatory_info *reg_info)
-+{
-+	const void **tb;
-+	const struct wmi_reg_chan_list_cc_ext_event *ext_chan_list_event_hdr;
-+	struct wmi_regulatory_ext_rule *ext_wmi_reg_rule;
-+	u32 num_2ghz_reg_rules, num_5ghz_reg_rules;
-+	u32 num_6ghz_reg_rules_ap[WMI_REG_CURRENT_MAX_AP_TYPE];
-+	u32 num_6ghz_client[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];
-+	u32 total_reg_rules = 0;
-+	int ret, i, j, num_invalid_5ghz_ext_rules = 0;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI, "processing regulatory ext channel list\n");
-+
-+	tb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);
-+	if (IS_ERR(tb)) {
-+		ret = PTR_ERR(tb);
-+		ath11k_warn(ab, "failed to parse tlv: %d\n", ret);
-+		return ret;
-+	}
-+
-+	ext_chan_list_event_hdr = tb[WMI_TAG_REG_CHAN_LIST_CC_EXT_EVENT];
-+	if (!ext_chan_list_event_hdr) {
-+		ath11k_warn(ab, "failed to fetch reg chan list ext update ev\n");
-+		kfree(tb);
-+		return -EPROTO;
-+	}
-+
-+	reg_info->num_2ghz_reg_rules =
-+			ext_chan_list_event_hdr->num_2ghz_reg_rules;
-+	reg_info->num_5ghz_reg_rules =
-+			ext_chan_list_event_hdr->num_5ghz_reg_rules;
-+	reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP] =
-+			ext_chan_list_event_hdr->num_6ghz_reg_rules_ap_lpi;
-+	reg_info->num_6ghz_rules_ap[WMI_REG_STANDARD_POWER_AP] =
-+			ext_chan_list_event_hdr->num_6ghz_reg_rules_ap_sp;
-+	reg_info->num_6ghz_rules_ap[WMI_REG_VERY_LOW_POWER_AP] =
-+			ext_chan_list_event_hdr->num_6ghz_reg_rules_ap_vlp;
-+
-+	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
-+		reg_info->num_6ghz_rules_client[WMI_REG_INDOOR_AP][i] =
-+			ext_chan_list_event_hdr->num_6ghz_reg_rules_client_lpi[i];
-+		reg_info->num_6ghz_rules_client[WMI_REG_STANDARD_POWER_AP][i] =
-+			ext_chan_list_event_hdr->num_6ghz_reg_rules_client_sp[i];
-+		reg_info->num_6ghz_rules_client[WMI_REG_VERY_LOW_POWER_AP][i] =
-+			ext_chan_list_event_hdr->num_6ghz_reg_rules_client_vlp[i];
-+	}
-+
-+	num_2ghz_reg_rules = reg_info->num_2ghz_reg_rules;
-+	num_5ghz_reg_rules = reg_info->num_5ghz_reg_rules;
-+
-+	total_reg_rules += num_2ghz_reg_rules;
-+	total_reg_rules += num_5ghz_reg_rules;
-+
-+	if ((num_2ghz_reg_rules > MAX_REG_RULES) ||
-+	    (num_5ghz_reg_rules > MAX_REG_RULES)) {
-+		ath11k_warn(ab, "Num reg rules for 2.4 GHz/5 GHz exceeds max limit (num_2ghz_reg_rules: %d num_5ghz_reg_rules: %d max_rules: %d)\n",
-+			    num_2ghz_reg_rules, num_5ghz_reg_rules, MAX_REG_RULES);
-+		kfree(tb);
-+		return -EINVAL;
-+	}
-+
-+	for (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++) {
-+		num_6ghz_reg_rules_ap[i] = reg_info->num_6ghz_rules_ap[i];
-+
-+		if (num_6ghz_reg_rules_ap[i] > MAX_6GHZ_REG_RULES) {
-+			ath11k_warn(ab, "Num 6 GHz reg rules for AP mode(%d) exceeds max limit (num_6ghz_reg_rules_ap: %d, max_rules: %d)\n",
-+				    i, num_6ghz_reg_rules_ap[i], MAX_6GHZ_REG_RULES);
-+			kfree(tb);
-+			return -EINVAL;
-+		}
-+
-+		total_reg_rules += num_6ghz_reg_rules_ap[i];
-+	}
-+
-+	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
-+		num_6ghz_client[WMI_REG_INDOOR_AP][i] =
-+			reg_info->num_6ghz_rules_client[WMI_REG_INDOOR_AP][i];
-+		total_reg_rules += num_6ghz_client[WMI_REG_INDOOR_AP][i];
-+
-+		num_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =
-+			reg_info->num_6ghz_rules_client[WMI_REG_STANDARD_POWER_AP][i];
-+		total_reg_rules += num_6ghz_client[WMI_REG_STANDARD_POWER_AP][i];
-+
-+		num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =
-+			reg_info->num_6ghz_rules_client[WMI_REG_VERY_LOW_POWER_AP][i];
-+		total_reg_rules += num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i];
-+
-+		if ((num_6ghz_client[WMI_REG_INDOOR_AP][i] > MAX_6GHZ_REG_RULES) ||
-+		    (num_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] >
-+							     MAX_6GHZ_REG_RULES) ||
-+		    (num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] >
-+							     MAX_6GHZ_REG_RULES)) {
-+			ath11k_warn(ab,
-+				    "Num 6 GHz client reg rules exceeds max limit, for client(type: %d)\n",
-+				    i);
-+			kfree(tb);
-+			return -EINVAL;
-+		}
-+	}
-+
-+	if (!total_reg_rules) {
-+		ath11k_warn(ab, "No reg rules available\n");
-+		kfree(tb);
-+		return -EINVAL;
-+	}
-+
-+	memcpy(reg_info->alpha2, &ext_chan_list_event_hdr->alpha2,
-+	       REG_ALPHA2_LEN);
-+
-+	reg_info->dfs_region = ext_chan_list_event_hdr->dfs_region;
-+	reg_info->phybitmap = ext_chan_list_event_hdr->phybitmap;
-+	reg_info->num_phy = ext_chan_list_event_hdr->num_phy;
-+	reg_info->phy_id = ext_chan_list_event_hdr->phy_id;
-+	reg_info->ctry_code = ext_chan_list_event_hdr->country_id;
-+	reg_info->reg_dmn_pair = ext_chan_list_event_hdr->domain_code;
-+
-+	reg_info->status_code =
-+		ath11k_wmi_cc_setting_code_to_reg(ext_chan_list_event_hdr->status_code);
-+
-+	reg_info->is_ext_reg_event = true;
-+
-+	reg_info->min_bw_2ghz = ext_chan_list_event_hdr->min_bw_2ghz;
-+	reg_info->max_bw_2ghz = ext_chan_list_event_hdr->max_bw_2ghz;
-+	reg_info->min_bw_5ghz = ext_chan_list_event_hdr->min_bw_5ghz;
-+	reg_info->max_bw_5ghz = ext_chan_list_event_hdr->max_bw_5ghz;
-+
-+	reg_info->min_bw_6ghz_ap[WMI_REG_INDOOR_AP] =
-+			ext_chan_list_event_hdr->min_bw_6ghz_ap_lpi;
-+	reg_info->max_bw_6ghz_ap[WMI_REG_INDOOR_AP] =
-+			 ext_chan_list_event_hdr->max_bw_6ghz_ap_lpi;
-+	reg_info->min_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =
-+			ext_chan_list_event_hdr->min_bw_6ghz_ap_sp;
-+	reg_info->max_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =
-+			ext_chan_list_event_hdr->max_bw_6ghz_ap_sp;
-+	reg_info->min_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =
-+			ext_chan_list_event_hdr->min_bw_6ghz_ap_vlp;
-+	reg_info->max_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =
-+			ext_chan_list_event_hdr->max_bw_6ghz_ap_vlp;
-+
-+	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
-+		reg_info->min_bw_6ghz_client[WMI_REG_INDOOR_AP][i] =
-+				ext_chan_list_event_hdr->min_bw_6ghz_client_lpi[i];
-+		reg_info->max_bw_6ghz_client[WMI_REG_INDOOR_AP][i] =
-+				ext_chan_list_event_hdr->max_bw_6ghz_client_lpi[i];
-+		reg_info->min_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =
-+				ext_chan_list_event_hdr->min_bw_6ghz_client_sp[i];
-+		reg_info->max_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =
-+				ext_chan_list_event_hdr->max_bw_6ghz_client_sp[i];
-+		reg_info->min_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =
-+				ext_chan_list_event_hdr->min_bw_6ghz_client_vlp[i];
-+		reg_info->max_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =
-+				ext_chan_list_event_hdr->max_bw_6ghz_client_vlp[i];
-+	}
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "%s:cc_ext %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d",
-+		   __func__, reg_info->alpha2, reg_info->dfs_region,
-+		   reg_info->min_bw_2ghz, reg_info->max_bw_2ghz,
-+		   reg_info->min_bw_5ghz, reg_info->max_bw_5ghz);
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "num_2ghz_reg_rules %d num_5ghz_reg_rules %d",
-+		   num_2ghz_reg_rules, num_5ghz_reg_rules);
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "num_6ghz_reg_rules_ap_lpi: %d num_6ghz_reg_rules_ap_sp: %d num_6ghz_reg_rules_ap_vlp: %d",
-+		   num_6ghz_reg_rules_ap[WMI_REG_INDOOR_AP],
-+		   num_6ghz_reg_rules_ap[WMI_REG_STANDARD_POWER_AP],
-+		   num_6ghz_reg_rules_ap[WMI_REG_VERY_LOW_POWER_AP]);
-+
-+	j = WMI_REG_DEFAULT_CLIENT;
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "6 GHz Regular client: num_6ghz_reg_rules_lpi: %d num_6ghz_reg_rules_sp: %d num_6ghz_reg_rules_vlp: %d",
-+		   num_6ghz_client[WMI_REG_INDOOR_AP][j],
-+		   num_6ghz_client[WMI_REG_STANDARD_POWER_AP][j],
-+		   num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][j]);
-+
-+	j = WMI_REG_SUBORDINATE_CLIENT;
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "6 GHz Subordinate client: num_6ghz_reg_rules_lpi: %d num_6ghz_reg_rules_sp: %d num_6ghz_reg_rules_vlp: %d",
-+		   num_6ghz_client[WMI_REG_INDOOR_AP][j],
-+		   num_6ghz_client[WMI_REG_STANDARD_POWER_AP][j],
-+		   num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][j]);
-+
-+	ext_wmi_reg_rule =
-+		(struct wmi_regulatory_ext_rule *)((u8 *)ext_chan_list_event_hdr
-+						   + sizeof(*ext_chan_list_event_hdr)
-+						   + sizeof(struct wmi_tlv));
-+	if (num_2ghz_reg_rules) {
-+		reg_info->reg_rules_2ghz_ptr =
-+			create_ext_reg_rules_from_wmi(num_2ghz_reg_rules,
-+						      ext_wmi_reg_rule);
-+
-+		if (!reg_info->reg_rules_2ghz_ptr) {
-+			kfree(tb);
-+			ath11k_warn(ab, "Unable to Allocate memory for 2 GHz rules\n");
-+			return -ENOMEM;
-+		}
-+	}
-+
-+	ext_wmi_reg_rule += num_2ghz_reg_rules;
-+
-+	/* Firmware might include 6 GHz reg rule in 5 GHz rule list
-+	 * for few countries along with separate 6 GHz rule.
-+	 * Having same 6 GHz reg rule in 5 GHz and 6 GHz rules list
-+	 * causes intersect check to be true, and same rules will be
-+	 * shown multiple times in iw cmd.
-+	 * Hence, avoid parsing 6 GHz rule from 5 GHz reg rule list
-+	 */
-+	num_invalid_5ghz_ext_rules =
-+		ath11k_invalid_5ghz_reg_ext_rules_from_wmi(num_5ghz_reg_rules,
-+							   ext_wmi_reg_rule);
-+
-+	if (num_invalid_5ghz_ext_rules) {
-+		ath11k_dbg(ab, ATH11K_DBG_WMI,
-+			   "CC: %s 5 GHz reg rules number %d from fw, %d number of invalid 5 GHz rules",
-+			   reg_info->alpha2, reg_info->num_5ghz_reg_rules,
-+			   num_invalid_5ghz_ext_rules);
-+
-+		num_5ghz_reg_rules = num_5ghz_reg_rules - num_invalid_5ghz_ext_rules;
-+		reg_info->num_5ghz_reg_rules = num_5ghz_reg_rules;
-+	}
-+
-+	if (num_5ghz_reg_rules) {
-+		reg_info->reg_rules_5ghz_ptr =
-+			create_ext_reg_rules_from_wmi(num_5ghz_reg_rules,
-+						      ext_wmi_reg_rule);
-+
-+		if (!reg_info->reg_rules_5ghz_ptr) {
-+			kfree(tb);
-+			ath11k_warn(ab, "Unable to Allocate memory for 5 GHz rules\n");
-+			return -ENOMEM;
-+		}
-+	}
-+
-+	/* We have adjusted the number of 5 GHz reg rules above. But still those
-+	 * many rules needs to be adjusted in ext_wmi_reg_rule.
-+	 *
-+	 * NOTE: num_invalid_5ghz_ext_rules will be 0 for rest other cases.
-+	 */
-+	ext_wmi_reg_rule += (num_5ghz_reg_rules + num_invalid_5ghz_ext_rules);
-+
-+	for (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++) {
-+		reg_info->reg_rules_6ghz_ap_ptr[i] =
-+			create_ext_reg_rules_from_wmi(num_6ghz_reg_rules_ap[i],
-+						      ext_wmi_reg_rule);
-+
-+		if (!reg_info->reg_rules_6ghz_ap_ptr[i]) {
-+			kfree(tb);
-+			ath11k_warn(ab, "Unable to Allocate memory for 6 GHz AP rules\n");
-+			return -ENOMEM;
-+		}
-+
-+		ext_wmi_reg_rule += num_6ghz_reg_rules_ap[i];
-+	}
-+
-+	for (j = 0; j < WMI_REG_CURRENT_MAX_AP_TYPE; j++) {
-+		for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
-+			reg_info->reg_rules_6ghz_client_ptr[j][i] =
-+				create_ext_reg_rules_from_wmi(num_6ghz_client[j][i],
-+							      ext_wmi_reg_rule);
-+
-+			if (!reg_info->reg_rules_6ghz_client_ptr[j][i]) {
-+				kfree(tb);
-+				ath11k_warn(ab, "Unable to Allocate memory for 6 GHz client rules\n");
-+				return -ENOMEM;
-+			}
-+
-+			ext_wmi_reg_rule += num_6ghz_client[j][i];
-+		}
-+	}
-+
-+	reg_info->client_type = ext_chan_list_event_hdr->client_type;
-+	reg_info->rnr_tpe_usable = ext_chan_list_event_hdr->rnr_tpe_usable;
-+	reg_info->unspecified_ap_usable =
-+			ext_chan_list_event_hdr->unspecified_ap_usable;
-+	reg_info->domain_code_6ghz_ap[WMI_REG_INDOOR_AP] =
-+			ext_chan_list_event_hdr->domain_code_6ghz_ap_lpi;
-+	reg_info->domain_code_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =
-+			ext_chan_list_event_hdr->domain_code_6ghz_ap_sp;
-+	reg_info->domain_code_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =
-+			ext_chan_list_event_hdr->domain_code_6ghz_ap_vlp;
-+
-+	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
-+		reg_info->domain_code_6ghz_client[WMI_REG_INDOOR_AP][i] =
-+				ext_chan_list_event_hdr->domain_code_6ghz_client_lpi[i];
-+		reg_info->domain_code_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =
-+				ext_chan_list_event_hdr->domain_code_6ghz_client_sp[i];
-+		reg_info->domain_code_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =
-+				ext_chan_list_event_hdr->domain_code_6ghz_client_vlp[i];
-+	}
-+
-+	reg_info->domain_code_6ghz_super_id =
-+			ext_chan_list_event_hdr->domain_code_6ghz_super_id;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI, "6 GHz client_type: %d domain_code_6ghz_super_id: %d",
-+		   reg_info->client_type, reg_info->domain_code_6ghz_super_id);
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI, "processed regulatory ext channel list\n");
-+
-+	kfree(tb);
-+	return 0;
-+}
-+
- static int ath11k_pull_peer_del_resp_ev(struct ath11k_base *ab, struct sk_buff *skb,
- 					struct wmi_peer_delete_resp_event *peer_del_resp)
- {
-@@ -6507,12 +6876,14 @@ static bool ath11k_reg_is_world_alpha(ch
- 	return false;
- }
- 
--static int ath11k_reg_chan_list_event(struct ath11k_base *ab, struct sk_buff *skb)
-+static int ath11k_reg_chan_list_event(struct ath11k_base *ab,
-+				      struct sk_buff *skb,
-+				      enum wmi_reg_chan_list_cmd_type id)
- {
- 	struct cur_regulatory_info *reg_info = NULL;
- 	struct ieee80211_regdomain *regd = NULL;
- 	bool intersect = false;
--	int ret = 0, pdev_idx;
-+	int ret = 0, pdev_idx, i, j;
- 	struct ath11k *ar;
- 
- 	reg_info = kzalloc(sizeof(*reg_info), GFP_ATOMIC);
-@@ -6521,7 +6892,11 @@ static int ath11k_reg_chan_list_event(st
- 		goto fallback;
- 	}
- 
--	ret = ath11k_pull_reg_chan_list_update_ev(ab, skb, reg_info);
-+	if (id == WMI_REG_CHAN_LIST_CC_ID)
-+		ret = ath11k_pull_reg_chan_list_update_ev(ab, skb, reg_info);
-+	else
-+		ret = ath11k_pull_reg_chan_list_ext_update_ev(ab, skb, reg_info);
-+
- 	if (ret) {
- 		ath11k_warn(ab, "failed to extract regulatory info from received event\n");
- 		goto fallback;
-@@ -6623,6 +6998,14 @@ mem_free:
- 	if (reg_info) {
- 		kfree(reg_info->reg_rules_2ghz_ptr);
- 		kfree(reg_info->reg_rules_5ghz_ptr);
-+		if (reg_info->is_ext_reg_event) {
-+			for (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++)
-+				kfree(reg_info->reg_rules_6ghz_ap_ptr[i]);
-+
-+			for (j = 0; j < WMI_REG_CURRENT_MAX_AP_TYPE; j++)
-+				for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++)
-+					kfree(reg_info->reg_rules_6ghz_client_ptr[j][i]);
-+		}
- 		kfree(reg_info);
- 	}
- 	return ret;
-@@ -8054,7 +8437,10 @@ static void ath11k_wmi_tlv_op_rx(struct
- 		ath11k_service_ready_ext2_event(ab, skb);
- 		break;
- 	case WMI_REG_CHAN_LIST_CC_EVENTID:
--		ath11k_reg_chan_list_event(ab, skb);
-+		ath11k_reg_chan_list_event(ab, skb, WMI_REG_CHAN_LIST_CC_ID);
-+		break;
-+	case WMI_REG_CHAN_LIST_CC_EXT_EVENTID:
-+		ath11k_reg_chan_list_event(ab, skb, WMI_REG_CHAN_LIST_CC_EXT_ID);
- 		break;
- 	case WMI_READY_EVENTID:
- 		ath11k_ready_event(ab, skb);
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -797,6 +797,7 @@ enum wmi_tlv_event_id {
- 	WMI_RMC_NEW_LEADER_EVENTID = WMI_TLV_CMD(WMI_GRP_RMC),
- 	WMI_REG_CHAN_LIST_CC_EVENTID = WMI_TLV_CMD(WMI_GRP_REGULATORY),
- 	WMI_11D_NEW_COUNTRY_EVENTID,
-+	WMI_REG_CHAN_LIST_CC_EXT_EVENTID,
- 	WMI_NDI_CAP_RSP_EVENTID = WMI_TLV_CMD(WMI_GRP_PROTOTYPE),
- 	WMI_NDP_INITIATOR_RSP_EVENTID,
- 	WMI_NDP_RESPONDER_RSP_EVENTID,
-@@ -1865,6 +1866,8 @@ enum wmi_tlv_tag {
- 	WMI_TAG_PDEV_SRG_OBSS_BSSID_ENABLE_BITMAP_CMD,
- 	WMI_TAG_PDEV_NON_SRG_OBSS_COLOR_ENABLE_BITMAP_CMD,
- 	WMI_TAG_PDEV_NON_SRG_OBSS_BSSID_ENABLE_BITMAP_CMD,
-+	WMI_TAG_REGULATORY_RULE_EXT_STRUCT = 0x3A9,
-+	WMI_TAG_REG_CHAN_LIST_CC_EXT_EVENT,
- 	WMI_TAG_PDEV_SET_BIOS_SAR_TABLE_CMD = 0x3D8,
- 	WMI_TAG_PDEV_SET_BIOS_GEO_TABLE_CMD,
- 	WMI_TAG_MAX
-@@ -2097,6 +2100,7 @@ enum wmi_tlv_service {
- 
- 	/* The second 128 bits */
- 	WMI_MAX_EXT_SERVICE = 256,
-+	WMI_TLV_SERVICE_REG_CC_EXT_EVENT_SUPPORT = 281,
- 	WMI_TLV_SERVICE_BIOS_SAR_SUPPORT = 326,
- 
- 	/* The third 128 bits */
-@@ -2313,6 +2317,8 @@ struct wmi_init_cmd {
- #define WMI_RSRC_CFG_FLAG1_BSS_CHANNEL_INFO_64 BIT(5)
- #define WMI_RSRC_CFG_FLAG1_ACK_RSSI BIT(18)
- 
-+#define WMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT 4
-+
- struct wmi_resource_config {
- 	u32 tlv_header;
- 	u32 num_vdevs;
-@@ -2372,6 +2378,15 @@ struct wmi_resource_config {
- 	u32 sched_params;
- 	u32 twt_ap_pdev_count;
- 	u32 twt_ap_sta_count;
-+	u32 max_nlo_ssids;
-+	u32 num_pkt_filters;
-+	u32 num_max_sta_vdevs;
-+	u32 max_bssid_indicator;
-+	u32 ul_resp_config;
-+	u32 msdu_flow_override_config0;
-+	u32 msdu_flow_override_config1;
-+	u32 flags2;
-+	u32 host_service_flags;
- } __packed;
- 
- struct wmi_service_ready_event {
-@@ -2854,6 +2869,8 @@ struct rx_reorder_queue_remove_params {
- #define REG_RULE_MAX_BW				0x0000ffff
- #define REG_RULE_REG_PWR			0x00ff0000
- #define REG_RULE_ANT_GAIN			0xff000000
-+#define REG_RULE_PSD_INFO			BIT(0)
-+#define REG_RULE_PSD_EIRP			0xff0000
- 
- #define WMI_VDEV_PARAM_TXBF_SU_TX_BFEE BIT(0)
- #define WMI_VDEV_PARAM_TXBF_MU_TX_BFEE BIT(1)
-@@ -4049,6 +4066,7 @@ struct wmi_he_rate_set {
- 
- #define MAX_REG_RULES 10
- #define REG_ALPHA2_LEN 2
-+#define MAX_6GHZ_REG_RULES 5
- 
- enum wmi_start_event_param {
- 	WMI_VDEV_START_RESP_EVENT = 0,
-@@ -4079,16 +4097,6 @@ enum wmi_vdev_start_resp_status_code {
- 	WMI_VDEV_START_RESPONSE_INVALID_REGDOMAIN = 4,
- };
- 
--;
--enum cc_setting_code {
--	REG_SET_CC_STATUS_PASS = 0,
--	REG_CURRENT_ALPHA2_NOT_FOUND = 1,
--	REG_INIT_ALPHA2_NOT_FOUND = 2,
--	REG_SET_CC_CHANGE_NOT_ALLOWED = 3,
--	REG_SET_CC_STATUS_NO_MEMORY = 4,
--	REG_SET_CC_STATUS_FAIL = 5,
--};
--
- /* Regaulatory Rule Flags Passed by FW */
- #define REGULATORY_CHAN_DISABLED     BIT(0)
- #define REGULATORY_CHAN_NO_IR        BIT(1)
-@@ -4102,13 +4110,72 @@ enum cc_setting_code {
- #define REGULATORY_CHAN_NO_20MHZ     BIT(11)
- #define REGULATORY_CHAN_NO_10MHZ     BIT(12)
- 
--enum {
-+enum wmi_reg_chan_list_cmd_type {
-+	WMI_REG_CHAN_LIST_CC_ID = 0,
-+	WMI_REG_CHAN_LIST_CC_EXT_ID = 1,
-+};
-+
-+enum wmi_reg_cc_setting_code {
- 	WMI_REG_SET_CC_STATUS_PASS = 0,
- 	WMI_REG_CURRENT_ALPHA2_NOT_FOUND = 1,
- 	WMI_REG_INIT_ALPHA2_NOT_FOUND = 2,
- 	WMI_REG_SET_CC_CHANGE_NOT_ALLOWED = 3,
- 	WMI_REG_SET_CC_STATUS_NO_MEMORY = 4,
- 	WMI_REG_SET_CC_STATUS_FAIL = 5,
-+
-+	/* add new setting code above, update in
-+	 * @enum cc_setting_code as well.
-+	 * Also handle it in ath11k_wmi_cc_setting_code_to_reg()
-+	 */
-+};
-+
-+enum cc_setting_code {
-+	REG_SET_CC_STATUS_PASS = 0,
-+	REG_CURRENT_ALPHA2_NOT_FOUND = 1,
-+	REG_INIT_ALPHA2_NOT_FOUND = 2,
-+	REG_SET_CC_CHANGE_NOT_ALLOWED = 3,
-+	REG_SET_CC_STATUS_NO_MEMORY = 4,
-+	REG_SET_CC_STATUS_FAIL = 5,
-+
-+	/* add new setting code above, update in
-+	 * @enum wmi_reg_cc_setting_code as well.
-+	 */
-+};
-+
-+static inline enum cc_setting_code
-+ath11k_wmi_cc_setting_code_to_reg(enum wmi_reg_cc_setting_code status_code)
-+{
-+	switch (status_code) {
-+	case WMI_REG_SET_CC_STATUS_PASS:
-+		return REG_SET_CC_STATUS_PASS;
-+	case WMI_REG_CURRENT_ALPHA2_NOT_FOUND:
-+		return REG_CURRENT_ALPHA2_NOT_FOUND;
-+	case WMI_REG_INIT_ALPHA2_NOT_FOUND:
-+		return REG_INIT_ALPHA2_NOT_FOUND;
-+	case WMI_REG_SET_CC_CHANGE_NOT_ALLOWED:
-+		return REG_SET_CC_CHANGE_NOT_ALLOWED;
-+	case WMI_REG_SET_CC_STATUS_NO_MEMORY:
-+		return REG_SET_CC_STATUS_NO_MEMORY;
-+	case WMI_REG_SET_CC_STATUS_FAIL:
-+		return REG_SET_CC_STATUS_FAIL;
-+	}
-+
-+	return REG_SET_CC_STATUS_FAIL;
-+}
-+
-+enum wmi_reg_6ghz_ap_type {
-+	WMI_REG_INDOOR_AP = 0,
-+	WMI_REG_STANDARD_POWER_AP = 1,
-+	WMI_REG_VERY_LOW_POWER_AP = 2,
-+
-+	WMI_REG_CURRENT_MAX_AP_TYPE,
-+	WMI_REG_MAX_AP_TYPE = 7,
-+};
-+
-+enum wmi_reg_6ghz_client_type {
-+	WMI_REG_DEFAULT_CLIENT = 0,
-+	WMI_REG_SUBORDINATE_CLIENT = 1,
-+	WMI_REG_MAX_CLIENT_TYPE = 2,
- };
- 
- struct cur_reg_rule {
-@@ -4118,6 +4185,8 @@ struct cur_reg_rule {
- 	u8 reg_power;
- 	u8 ant_gain;
- 	u16 flags;
-+	bool psd_flag;
-+	s8 psd_eirp;
- };
- 
- struct cur_regulatory_info {
-@@ -4137,6 +4206,22 @@ struct cur_regulatory_info {
- 	u32 num_5ghz_reg_rules;
- 	struct cur_reg_rule *reg_rules_2ghz_ptr;
- 	struct cur_reg_rule *reg_rules_5ghz_ptr;
-+	bool is_ext_reg_event;
-+	enum wmi_reg_6ghz_client_type client_type;
-+	bool rnr_tpe_usable;
-+	bool unspecified_ap_usable;
-+	u8 domain_code_6ghz_ap[WMI_REG_CURRENT_MAX_AP_TYPE];
-+	u8 domain_code_6ghz_client[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];
-+	u32 domain_code_6ghz_super_id;
-+	u32 min_bw_6ghz_ap[WMI_REG_CURRENT_MAX_AP_TYPE];
-+	u32 max_bw_6ghz_ap[WMI_REG_CURRENT_MAX_AP_TYPE];
-+	u32 min_bw_6ghz_client[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];
-+	u32 max_bw_6ghz_client[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];
-+	u32 num_6ghz_rules_ap[WMI_REG_CURRENT_MAX_AP_TYPE];
-+	u32 num_6ghz_rules_client[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];
-+	struct cur_reg_rule *reg_rules_6ghz_ap_ptr[WMI_REG_CURRENT_MAX_AP_TYPE];
-+	struct cur_reg_rule *reg_rules_6ghz_client_ptr
-+		[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];
- };
- 
- struct wmi_reg_chan_list_cc_event {
-@@ -4163,6 +4248,61 @@ struct wmi_regulatory_rule_struct {
- 	u32  flag_info;
- };
- 
-+#define WMI_REG_CLIENT_MAX 4
-+
-+struct wmi_reg_chan_list_cc_ext_event {
-+	u32 status_code;
-+	u32 phy_id;
-+	u32 alpha2;
-+	u32 num_phy;
-+	u32 country_id;
-+	u32 domain_code;
-+	u32 dfs_region;
-+	u32 phybitmap;
-+	u32 min_bw_2ghz;
-+	u32 max_bw_2ghz;
-+	u32 min_bw_5ghz;
-+	u32 max_bw_5ghz;
-+	u32 num_2ghz_reg_rules;
-+	u32 num_5ghz_reg_rules;
-+	u32 client_type;
-+	u32 rnr_tpe_usable;
-+	u32 unspecified_ap_usable;
-+	u32 domain_code_6ghz_ap_lpi;
-+	u32 domain_code_6ghz_ap_sp;
-+	u32 domain_code_6ghz_ap_vlp;
-+	u32 domain_code_6ghz_client_lpi[WMI_REG_CLIENT_MAX];
-+	u32 domain_code_6ghz_client_sp[WMI_REG_CLIENT_MAX];
-+	u32 domain_code_6ghz_client_vlp[WMI_REG_CLIENT_MAX];
-+	u32 domain_code_6ghz_super_id;
-+	u32 min_bw_6ghz_ap_sp;
-+	u32 max_bw_6ghz_ap_sp;
-+	u32 min_bw_6ghz_ap_lpi;
-+	u32 max_bw_6ghz_ap_lpi;
-+	u32 min_bw_6ghz_ap_vlp;
-+	u32 max_bw_6ghz_ap_vlp;
-+	u32 min_bw_6ghz_client_sp[WMI_REG_CLIENT_MAX];
-+	u32 max_bw_6ghz_client_sp[WMI_REG_CLIENT_MAX];
-+	u32 min_bw_6ghz_client_lpi[WMI_REG_CLIENT_MAX];
-+	u32 max_bw_6ghz_client_lpi[WMI_REG_CLIENT_MAX];
-+	u32 min_bw_6ghz_client_vlp[WMI_REG_CLIENT_MAX];
-+	u32 max_bw_6ghz_client_vlp[WMI_REG_CLIENT_MAX];
-+	u32 num_6ghz_reg_rules_ap_sp;
-+	u32 num_6ghz_reg_rules_ap_lpi;
-+	u32 num_6ghz_reg_rules_ap_vlp;
-+	u32 num_6ghz_reg_rules_client_sp[WMI_REG_CLIENT_MAX];
-+	u32 num_6ghz_reg_rules_client_lpi[WMI_REG_CLIENT_MAX];
-+	u32 num_6ghz_reg_rules_client_vlp[WMI_REG_CLIENT_MAX];
-+} __packed;
-+
-+struct wmi_regulatory_ext_rule {
-+	u32 tlv_header;
-+	u32 freq_info;
-+	u32 bw_pwr_info;
-+	u32 flag_info;
-+	u32 psd_power_info;
-+} __packed;
-+
- struct wmi_vdev_delete_resp_event {
- 	u32 vdev_id;
- } __packed;
-@@ -5358,6 +5498,7 @@ struct target_resource_config {
- 	u32 sched_params;
- 	u32 twt_ap_pdev_count;
- 	u32 twt_ap_sta_count;
-+	u8 is_reg_cc_ext_event_supported;
- };
- 
- enum wmi_debug_log_param {
diff --git a/package/kernel/mac80211/patches/ath11k/0045-wifi-ath11k-add-debug-prints-in-regulatory-WMI-event.patch b/package/kernel/mac80211/patches/ath11k/0045-wifi-ath11k-add-debug-prints-in-regulatory-WMI-event.patch
deleted file mode 100644
index b88e5192..00000000
--- a/package/kernel/mac80211/patches/ath11k/0045-wifi-ath11k-add-debug-prints-in-regulatory-WMI-event.patch
+++ /dev/null
@@ -1,567 +0,0 @@
-From e238e62ba8868a784e485eb94451c87cd1b85cee Mon Sep 17 00:00:00 2001
-From: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Date: Wed, 1 Mar 2023 16:20:59 +0200
-Subject: [PATCH] wifi: ath11k: add debug prints in regulatory WMI event
- processing
-
-Add some more debug prints in processing regulatory WMI event in order to
-increase more debuggability.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230110121024.14051-4-quic_adisi@quicinc.com
----
- drivers/net/wireless/ath/ath11k/reg.c |   2 +-
- drivers/net/wireless/ath/ath11k/wmi.c | 207 ++++++++++++++++++--------
- drivers/net/wireless/ath/ath11k/wmi.h | 142 ++++++++++++++++++
- 3 files changed, 291 insertions(+), 60 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/reg.c
-+++ b/drivers/net/wireless/ath/ath11k/reg.c
-@@ -646,7 +646,7 @@ ath11k_reg_build_regd(struct ath11k_base
- 	tmp_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);
- 
- 	ath11k_dbg(ab, ATH11K_DBG_REG,
--		   "\r\nCountry %s, CFG Regdomain %s FW Regdomain %d, num_reg_rules %d\n",
-+		   "Country %s, CFG Regdomain %s FW Regdomain %d, num_reg_rules %d\n",
- 		   alpha2, ath11k_reg_get_regdom_str(tmp_regd->dfs_region),
- 		   reg_info->dfs_region, num_rules);
- 	/* Update reg_rules[] below. Firmware is expected to
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -4925,6 +4925,26 @@ static int ath11k_pull_vdev_start_resp_t
- 	return 0;
- }
- 
-+static void ath11k_print_reg_rule(struct ath11k_base *ab, const char *band,
-+				  u32 num_reg_rules,
-+				  struct cur_reg_rule *reg_rule_ptr)
-+{
-+	struct cur_reg_rule *reg_rule = reg_rule_ptr;
-+	u32 count;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI, "number of reg rules in %s band: %d\n",
-+		   band, num_reg_rules);
-+
-+	for (count = 0; count < num_reg_rules; count++) {
-+		ath11k_dbg(ab, ATH11K_DBG_WMI,
-+			   "reg rule %d: (%d - %d @ %d) (%d, %d) (FLAGS %d)\n",
-+			   count + 1, reg_rule->start_freq, reg_rule->end_freq,
-+			   reg_rule->max_bw, reg_rule->ant_gain,
-+			   reg_rule->reg_power, reg_rule->flags);
-+		reg_rule++;
-+	}
-+}
-+
- static struct cur_reg_rule
- *create_reg_rules_from_wmi(u32 num_reg_rules,
- 			   struct wmi_regulatory_rule_struct *wmi_reg_rule)
-@@ -5006,6 +5026,10 @@ static int ath11k_pull_reg_chan_list_upd
- 	reg_info->ctry_code = chan_list_event_hdr->country_id;
- 	reg_info->reg_dmn_pair = chan_list_event_hdr->domain_code;
- 
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "status_code %s",
-+		   ath11k_cc_status_to_str(reg_info->status_code));
-+
- 	reg_info->status_code =
- 		ath11k_wmi_cc_setting_code_to_reg(chan_list_event_hdr->status_code);
- 
-@@ -5020,13 +5044,13 @@ static int ath11k_pull_reg_chan_list_upd
- 	num_5ghz_reg_rules = reg_info->num_5ghz_reg_rules;
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI,
--		   "%s:cc %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d",
--		   __func__, reg_info->alpha2, reg_info->dfs_region,
-+		   "cc %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d",
-+		   reg_info->alpha2, reg_info->dfs_region,
- 		   reg_info->min_bw_2ghz, reg_info->max_bw_2ghz,
- 		   reg_info->min_bw_5ghz, reg_info->max_bw_5ghz);
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI,
--		   "%s: num_2ghz_reg_rules %d num_5ghz_reg_rules %d", __func__,
-+		   "num_2ghz_reg_rules %d num_5ghz_reg_rules %d",
- 		   num_2ghz_reg_rules, num_5ghz_reg_rules);
- 
- 	wmi_reg_rule =
-@@ -5043,6 +5067,10 @@ static int ath11k_pull_reg_chan_list_upd
- 			ath11k_warn(ab, "Unable to Allocate memory for 2 GHz rules\n");
- 			return -ENOMEM;
- 		}
-+
-+		ath11k_print_reg_rule(ab, "2 GHz",
-+				      num_2ghz_reg_rules,
-+				      reg_info->reg_rules_2ghz_ptr);
- 	}
- 
- 	if (num_5ghz_reg_rules) {
-@@ -5055,6 +5083,10 @@ static int ath11k_pull_reg_chan_list_upd
- 			ath11k_warn(ab, "Unable to Allocate memory for 5 GHz rules\n");
- 			return -ENOMEM;
- 		}
-+
-+		ath11k_print_reg_rule(ab, "5 GHz",
-+				      num_5ghz_reg_rules,
-+				      reg_info->reg_rules_5ghz_ptr);
- 	}
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI, "processed regulatory channel list\n");
-@@ -5128,7 +5160,7 @@ static int ath11k_pull_reg_chan_list_ext
- 						   struct cur_regulatory_info *reg_info)
- {
- 	const void **tb;
--	const struct wmi_reg_chan_list_cc_ext_event *ext_chan_list_event_hdr;
-+	const struct wmi_reg_chan_list_cc_ext_event *ev;
- 	struct wmi_regulatory_ext_rule *ext_wmi_reg_rule;
- 	u32 num_2ghz_reg_rules, num_5ghz_reg_rules;
- 	u32 num_6ghz_reg_rules_ap[WMI_REG_CURRENT_MAX_AP_TYPE];
-@@ -5145,31 +5177,29 @@ static int ath11k_pull_reg_chan_list_ext
- 		return ret;
- 	}
- 
--	ext_chan_list_event_hdr = tb[WMI_TAG_REG_CHAN_LIST_CC_EXT_EVENT];
--	if (!ext_chan_list_event_hdr) {
-+	ev = tb[WMI_TAG_REG_CHAN_LIST_CC_EXT_EVENT];
-+	if (!ev) {
- 		ath11k_warn(ab, "failed to fetch reg chan list ext update ev\n");
- 		kfree(tb);
- 		return -EPROTO;
- 	}
- 
--	reg_info->num_2ghz_reg_rules =
--			ext_chan_list_event_hdr->num_2ghz_reg_rules;
--	reg_info->num_5ghz_reg_rules =
--			ext_chan_list_event_hdr->num_5ghz_reg_rules;
-+	reg_info->num_2ghz_reg_rules = ev->num_2ghz_reg_rules;
-+	reg_info->num_5ghz_reg_rules = ev->num_5ghz_reg_rules;
- 	reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP] =
--			ext_chan_list_event_hdr->num_6ghz_reg_rules_ap_lpi;
-+			ev->num_6ghz_reg_rules_ap_lpi;
- 	reg_info->num_6ghz_rules_ap[WMI_REG_STANDARD_POWER_AP] =
--			ext_chan_list_event_hdr->num_6ghz_reg_rules_ap_sp;
-+			ev->num_6ghz_reg_rules_ap_sp;
- 	reg_info->num_6ghz_rules_ap[WMI_REG_VERY_LOW_POWER_AP] =
--			ext_chan_list_event_hdr->num_6ghz_reg_rules_ap_vlp;
-+			ev->num_6ghz_reg_rules_ap_vlp;
- 
- 	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
- 		reg_info->num_6ghz_rules_client[WMI_REG_INDOOR_AP][i] =
--			ext_chan_list_event_hdr->num_6ghz_reg_rules_client_lpi[i];
-+			ev->num_6ghz_reg_rules_client_lpi[i];
- 		reg_info->num_6ghz_rules_client[WMI_REG_STANDARD_POWER_AP][i] =
--			ext_chan_list_event_hdr->num_6ghz_reg_rules_client_sp[i];
-+			ev->num_6ghz_reg_rules_client_sp[i];
- 		reg_info->num_6ghz_rules_client[WMI_REG_VERY_LOW_POWER_AP][i] =
--			ext_chan_list_event_hdr->num_6ghz_reg_rules_client_vlp[i];
-+			ev->num_6ghz_reg_rules_client_vlp[i];
- 	}
- 
- 	num_2ghz_reg_rules = reg_info->num_2ghz_reg_rules;
-@@ -5231,57 +5261,79 @@ static int ath11k_pull_reg_chan_list_ext
- 		return -EINVAL;
- 	}
- 
--	memcpy(reg_info->alpha2, &ext_chan_list_event_hdr->alpha2,
--	       REG_ALPHA2_LEN);
-+	memcpy(reg_info->alpha2, &ev->alpha2, REG_ALPHA2_LEN);
-+
-+	reg_info->dfs_region = ev->dfs_region;
-+	reg_info->phybitmap = ev->phybitmap;
-+	reg_info->num_phy = ev->num_phy;
-+	reg_info->phy_id = ev->phy_id;
-+	reg_info->ctry_code = ev->country_id;
-+	reg_info->reg_dmn_pair = ev->domain_code;
- 
--	reg_info->dfs_region = ext_chan_list_event_hdr->dfs_region;
--	reg_info->phybitmap = ext_chan_list_event_hdr->phybitmap;
--	reg_info->num_phy = ext_chan_list_event_hdr->num_phy;
--	reg_info->phy_id = ext_chan_list_event_hdr->phy_id;
--	reg_info->ctry_code = ext_chan_list_event_hdr->country_id;
--	reg_info->reg_dmn_pair = ext_chan_list_event_hdr->domain_code;
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "status_code %s",
-+		   ath11k_cc_status_to_str(reg_info->status_code));
- 
- 	reg_info->status_code =
--		ath11k_wmi_cc_setting_code_to_reg(ext_chan_list_event_hdr->status_code);
-+		ath11k_wmi_cc_setting_code_to_reg(ev->status_code);
- 
- 	reg_info->is_ext_reg_event = true;
- 
--	reg_info->min_bw_2ghz = ext_chan_list_event_hdr->min_bw_2ghz;
--	reg_info->max_bw_2ghz = ext_chan_list_event_hdr->max_bw_2ghz;
--	reg_info->min_bw_5ghz = ext_chan_list_event_hdr->min_bw_5ghz;
--	reg_info->max_bw_5ghz = ext_chan_list_event_hdr->max_bw_5ghz;
-+	reg_info->min_bw_2ghz = ev->min_bw_2ghz;
-+	reg_info->max_bw_2ghz = ev->max_bw_2ghz;
-+	reg_info->min_bw_5ghz = ev->min_bw_5ghz;
-+	reg_info->max_bw_5ghz = ev->max_bw_5ghz;
- 
- 	reg_info->min_bw_6ghz_ap[WMI_REG_INDOOR_AP] =
--			ext_chan_list_event_hdr->min_bw_6ghz_ap_lpi;
-+			ev->min_bw_6ghz_ap_lpi;
- 	reg_info->max_bw_6ghz_ap[WMI_REG_INDOOR_AP] =
--			 ext_chan_list_event_hdr->max_bw_6ghz_ap_lpi;
-+			ev->max_bw_6ghz_ap_lpi;
- 	reg_info->min_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =
--			ext_chan_list_event_hdr->min_bw_6ghz_ap_sp;
-+			ev->min_bw_6ghz_ap_sp;
- 	reg_info->max_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =
--			ext_chan_list_event_hdr->max_bw_6ghz_ap_sp;
-+			ev->max_bw_6ghz_ap_sp;
- 	reg_info->min_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =
--			ext_chan_list_event_hdr->min_bw_6ghz_ap_vlp;
-+			ev->min_bw_6ghz_ap_vlp;
- 	reg_info->max_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =
--			ext_chan_list_event_hdr->max_bw_6ghz_ap_vlp;
-+			ev->max_bw_6ghz_ap_vlp;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "6 GHz AP BW: LPI (%d - %d), SP (%d - %d), VLP (%d - %d)\n",
-+		   reg_info->min_bw_6ghz_ap[WMI_REG_INDOOR_AP],
-+		   reg_info->max_bw_6ghz_ap[WMI_REG_INDOOR_AP],
-+		   reg_info->min_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP],
-+		   reg_info->max_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP],
-+		   reg_info->min_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP],
-+		   reg_info->max_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP]);
- 
- 	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
- 		reg_info->min_bw_6ghz_client[WMI_REG_INDOOR_AP][i] =
--				ext_chan_list_event_hdr->min_bw_6ghz_client_lpi[i];
-+				ev->min_bw_6ghz_client_lpi[i];
- 		reg_info->max_bw_6ghz_client[WMI_REG_INDOOR_AP][i] =
--				ext_chan_list_event_hdr->max_bw_6ghz_client_lpi[i];
-+				ev->max_bw_6ghz_client_lpi[i];
- 		reg_info->min_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =
--				ext_chan_list_event_hdr->min_bw_6ghz_client_sp[i];
-+				ev->min_bw_6ghz_client_sp[i];
- 		reg_info->max_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =
--				ext_chan_list_event_hdr->max_bw_6ghz_client_sp[i];
-+				ev->max_bw_6ghz_client_sp[i];
- 		reg_info->min_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =
--				ext_chan_list_event_hdr->min_bw_6ghz_client_vlp[i];
-+				ev->min_bw_6ghz_client_vlp[i];
- 		reg_info->max_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =
--				ext_chan_list_event_hdr->max_bw_6ghz_client_vlp[i];
-+				ev->max_bw_6ghz_client_vlp[i];
-+
-+		ath11k_dbg(ab, ATH11K_DBG_WMI,
-+			   "6 GHz %s BW: LPI (%d - %d), SP (%d - %d), VLP (%d - %d)\n",
-+			   ath11k_6ghz_client_type_to_str(i),
-+			   reg_info->min_bw_6ghz_client[WMI_REG_INDOOR_AP][i],
-+			   reg_info->max_bw_6ghz_client[WMI_REG_INDOOR_AP][i],
-+			   reg_info->min_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i],
-+			   reg_info->max_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i],
-+			   reg_info->min_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i],
-+			   reg_info->max_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i]);
- 	}
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI,
--		   "%s:cc_ext %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d",
--		   __func__, reg_info->alpha2, reg_info->dfs_region,
-+		   "cc_ext %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d",
-+		   reg_info->alpha2, reg_info->dfs_region,
- 		   reg_info->min_bw_2ghz, reg_info->max_bw_2ghz,
- 		   reg_info->min_bw_5ghz, reg_info->max_bw_5ghz);
- 
-@@ -5310,9 +5362,8 @@ static int ath11k_pull_reg_chan_list_ext
- 		   num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][j]);
- 
- 	ext_wmi_reg_rule =
--		(struct wmi_regulatory_ext_rule *)((u8 *)ext_chan_list_event_hdr
--						   + sizeof(*ext_chan_list_event_hdr)
--						   + sizeof(struct wmi_tlv));
-+		(struct wmi_regulatory_ext_rule *)((u8 *)ev + sizeof(*ev) +
-+						   sizeof(struct wmi_tlv));
- 	if (num_2ghz_reg_rules) {
- 		reg_info->reg_rules_2ghz_ptr =
- 			create_ext_reg_rules_from_wmi(num_2ghz_reg_rules,
-@@ -5323,6 +5374,10 @@ static int ath11k_pull_reg_chan_list_ext
- 			ath11k_warn(ab, "Unable to Allocate memory for 2 GHz rules\n");
- 			return -ENOMEM;
- 		}
-+
-+		ath11k_print_reg_rule(ab, "2 GHz",
-+				      num_2ghz_reg_rules,
-+				      reg_info->reg_rules_2ghz_ptr);
- 	}
- 
- 	ext_wmi_reg_rule += num_2ghz_reg_rules;
-@@ -5358,6 +5413,10 @@ static int ath11k_pull_reg_chan_list_ext
- 			ath11k_warn(ab, "Unable to Allocate memory for 5 GHz rules\n");
- 			return -ENOMEM;
- 		}
-+
-+		ath11k_print_reg_rule(ab, "5 GHz",
-+				      num_5ghz_reg_rules,
-+				      reg_info->reg_rules_5ghz_ptr);
- 	}
- 
- 	/* We have adjusted the number of 5 GHz reg rules above. But still those
-@@ -5378,10 +5437,17 @@ static int ath11k_pull_reg_chan_list_ext
- 			return -ENOMEM;
- 		}
- 
-+		ath11k_print_reg_rule(ab, ath11k_6ghz_ap_type_to_str(i),
-+				      num_6ghz_reg_rules_ap[i],
-+				      reg_info->reg_rules_6ghz_ap_ptr[i]);
-+
- 		ext_wmi_reg_rule += num_6ghz_reg_rules_ap[i];
- 	}
- 
- 	for (j = 0; j < WMI_REG_CURRENT_MAX_AP_TYPE; j++) {
-+		ath11k_dbg(ab, ATH11K_DBG_WMI,
-+			   "6 GHz AP type %s", ath11k_6ghz_ap_type_to_str(j));
-+
- 		for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
- 			reg_info->reg_rules_6ghz_client_ptr[j][i] =
- 				create_ext_reg_rules_from_wmi(num_6ghz_client[j][i],
-@@ -5393,35 +5459,58 @@ static int ath11k_pull_reg_chan_list_ext
- 				return -ENOMEM;
- 			}
- 
-+			ath11k_print_reg_rule(ab,
-+					      ath11k_6ghz_client_type_to_str(i),
-+					      num_6ghz_client[j][i],
-+					      reg_info->reg_rules_6ghz_client_ptr[j][i]);
-+
- 			ext_wmi_reg_rule += num_6ghz_client[j][i];
- 		}
- 	}
- 
--	reg_info->client_type = ext_chan_list_event_hdr->client_type;
--	reg_info->rnr_tpe_usable = ext_chan_list_event_hdr->rnr_tpe_usable;
-+	reg_info->client_type = ev->client_type;
-+	reg_info->rnr_tpe_usable = ev->rnr_tpe_usable;
- 	reg_info->unspecified_ap_usable =
--			ext_chan_list_event_hdr->unspecified_ap_usable;
-+			ev->unspecified_ap_usable;
- 	reg_info->domain_code_6ghz_ap[WMI_REG_INDOOR_AP] =
--			ext_chan_list_event_hdr->domain_code_6ghz_ap_lpi;
-+			ev->domain_code_6ghz_ap_lpi;
- 	reg_info->domain_code_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =
--			ext_chan_list_event_hdr->domain_code_6ghz_ap_sp;
-+			ev->domain_code_6ghz_ap_sp;
- 	reg_info->domain_code_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =
--			ext_chan_list_event_hdr->domain_code_6ghz_ap_vlp;
-+			ev->domain_code_6ghz_ap_vlp;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "6 GHz reg info client type %s rnr_tpe_usable %d unspecified_ap_usable %d AP sub domain: lpi %s, sp %s, vlp %s\n",
-+		   ath11k_6ghz_client_type_to_str(reg_info->client_type),
-+		   reg_info->rnr_tpe_usable,
-+		   reg_info->unspecified_ap_usable,
-+		   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_ap_lpi),
-+		   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_ap_sp),
-+		   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_ap_vlp));
- 
- 	for (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {
- 		reg_info->domain_code_6ghz_client[WMI_REG_INDOOR_AP][i] =
--				ext_chan_list_event_hdr->domain_code_6ghz_client_lpi[i];
-+				ev->domain_code_6ghz_client_lpi[i];
- 		reg_info->domain_code_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =
--				ext_chan_list_event_hdr->domain_code_6ghz_client_sp[i];
-+				ev->domain_code_6ghz_client_sp[i];
- 		reg_info->domain_code_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =
--				ext_chan_list_event_hdr->domain_code_6ghz_client_vlp[i];
-+				ev->domain_code_6ghz_client_vlp[i];
-+
-+		ath11k_dbg(ab, ATH11K_DBG_WMI,
-+			   "6 GHz client type %s client sub domain: lpi %s, sp %s, vlp %s\n",
-+			   ath11k_6ghz_client_type_to_str(i),
-+			   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_client_lpi[i]),
-+			   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_client_sp[i]),
-+			   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_client_vlp[i])
-+			  );
- 	}
- 
--	reg_info->domain_code_6ghz_super_id =
--			ext_chan_list_event_hdr->domain_code_6ghz_super_id;
-+	reg_info->domain_code_6ghz_super_id = ev->domain_code_6ghz_super_id;
- 
--	ath11k_dbg(ab, ATH11K_DBG_WMI, "6 GHz client_type: %d domain_code_6ghz_super_id: %d",
--		   reg_info->client_type, reg_info->domain_code_6ghz_super_id);
-+	ath11k_dbg(ab, ATH11K_DBG_WMI,
-+		   "6 GHz client_type %s 6 GHz super domain %s",
-+		   ath11k_6ghz_client_type_to_str(reg_info->client_type),
-+		   ath11k_super_reg_6ghz_to_str(reg_info->domain_code_6ghz_super_id));
- 
- 	ath11k_dbg(ab, ATH11K_DBG_WMI, "processed regulatory ext channel list\n");
- 
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -4139,6 +4139,7 @@ enum cc_setting_code {
- 
- 	/* add new setting code above, update in
- 	 * @enum wmi_reg_cc_setting_code as well.
-+	 * Also handle it in ath11k_cc_status_to_str()
- 	 */
- };
- 
-@@ -4163,21 +4164,162 @@ ath11k_wmi_cc_setting_code_to_reg(enum w
- 	return REG_SET_CC_STATUS_FAIL;
- }
- 
-+static inline const char *ath11k_cc_status_to_str(enum cc_setting_code code)
-+{
-+	switch (code) {
-+	case REG_SET_CC_STATUS_PASS:
-+		return "REG_SET_CC_STATUS_PASS";
-+	case REG_CURRENT_ALPHA2_NOT_FOUND:
-+		return "REG_CURRENT_ALPHA2_NOT_FOUND";
-+	case REG_INIT_ALPHA2_NOT_FOUND:
-+		return "REG_INIT_ALPHA2_NOT_FOUND";
-+	case REG_SET_CC_CHANGE_NOT_ALLOWED:
-+		return "REG_SET_CC_CHANGE_NOT_ALLOWED";
-+	case REG_SET_CC_STATUS_NO_MEMORY:
-+		return "REG_SET_CC_STATUS_NO_MEMORY";
-+	case REG_SET_CC_STATUS_FAIL:
-+		return "REG_SET_CC_STATUS_FAIL";
-+	}
-+
-+	return "Unknown CC status";
-+}
-+
- enum wmi_reg_6ghz_ap_type {
- 	WMI_REG_INDOOR_AP = 0,
- 	WMI_REG_STANDARD_POWER_AP = 1,
- 	WMI_REG_VERY_LOW_POWER_AP = 2,
- 
-+	/* add AP type above, handle in ath11k_6ghz_ap_type_to_str()
-+	 */
- 	WMI_REG_CURRENT_MAX_AP_TYPE,
- 	WMI_REG_MAX_AP_TYPE = 7,
- };
- 
-+static inline const char *
-+ath11k_6ghz_ap_type_to_str(enum wmi_reg_6ghz_ap_type type)
-+{
-+	switch (type) {
-+	case WMI_REG_INDOOR_AP:
-+		return "INDOOR AP";
-+	case WMI_REG_STANDARD_POWER_AP:
-+		return "STANDARD POWER AP";
-+	case WMI_REG_VERY_LOW_POWER_AP:
-+		return "VERY LOW POWER AP";
-+	case WMI_REG_CURRENT_MAX_AP_TYPE:
-+		return "CURRENT_MAX_AP_TYPE";
-+	case WMI_REG_MAX_AP_TYPE:
-+		return "MAX_AP_TYPE";
-+	}
-+
-+	return "unknown 6 GHz AP type";
-+}
-+
- enum wmi_reg_6ghz_client_type {
- 	WMI_REG_DEFAULT_CLIENT = 0,
- 	WMI_REG_SUBORDINATE_CLIENT = 1,
- 	WMI_REG_MAX_CLIENT_TYPE = 2,
-+
-+	/* add client type above, handle it in
-+	 * ath11k_6ghz_client_type_to_str()
-+	 */
-+};
-+
-+static inline const char *
-+ath11k_6ghz_client_type_to_str(enum wmi_reg_6ghz_client_type type)
-+{
-+	switch (type) {
-+	case WMI_REG_DEFAULT_CLIENT:
-+		return "DEFAULT CLIENT";
-+	case WMI_REG_SUBORDINATE_CLIENT:
-+		return "SUBORDINATE CLIENT";
-+	case WMI_REG_MAX_CLIENT_TYPE:
-+		return "MAX_CLIENT_TYPE";
-+	}
-+
-+	return "unknown 6 GHz client type";
-+}
-+
-+enum reg_subdomains_6ghz {
-+	EMPTY_6GHZ = 0x0,
-+	FCC1_CLIENT_LPI_REGULAR_6GHZ = 0x01,
-+	FCC1_CLIENT_SP_6GHZ = 0x02,
-+	FCC1_AP_LPI_6GHZ = 0x03,
-+	FCC1_CLIENT_LPI_SUBORDINATE = FCC1_AP_LPI_6GHZ,
-+	FCC1_AP_SP_6GHZ = 0x04,
-+	ETSI1_LPI_6GHZ = 0x10,
-+	ETSI1_VLP_6GHZ = 0x11,
-+	ETSI2_LPI_6GHZ = 0x12,
-+	ETSI2_VLP_6GHZ = 0x13,
-+	APL1_LPI_6GHZ = 0x20,
-+	APL1_VLP_6GHZ = 0x21,
-+
-+	/* add sub-domain above, handle it in
-+	 * ath11k_sub_reg_6ghz_to_str()
-+	 */
-+};
-+
-+static inline const char *
-+ath11k_sub_reg_6ghz_to_str(enum reg_subdomains_6ghz sub_id)
-+{
-+	switch (sub_id) {
-+	case EMPTY_6GHZ:
-+		return "N/A";
-+	case FCC1_CLIENT_LPI_REGULAR_6GHZ:
-+		return "FCC1_CLIENT_LPI_REGULAR_6GHZ";
-+	case FCC1_CLIENT_SP_6GHZ:
-+		return "FCC1_CLIENT_SP_6GHZ";
-+	case FCC1_AP_LPI_6GHZ:
-+		return "FCC1_AP_LPI_6GHZ/FCC1_CLIENT_LPI_SUBORDINATE";
-+	case FCC1_AP_SP_6GHZ:
-+		return "FCC1_AP_SP_6GHZ";
-+	case ETSI1_LPI_6GHZ:
-+		return "ETSI1_LPI_6GHZ";
-+	case ETSI1_VLP_6GHZ:
-+		return "ETSI1_VLP_6GHZ";
-+	case ETSI2_LPI_6GHZ:
-+		return "ETSI2_LPI_6GHZ";
-+	case ETSI2_VLP_6GHZ:
-+		return "ETSI2_VLP_6GHZ";
-+	case APL1_LPI_6GHZ:
-+		return "APL1_LPI_6GHZ";
-+	case APL1_VLP_6GHZ:
-+		return "APL1_VLP_6GHZ";
-+	}
-+
-+	return "unknown sub reg id";
-+}
-+
-+enum reg_super_domain_6ghz {
-+	FCC1_6GHZ = 0x01,
-+	ETSI1_6GHZ = 0x02,
-+	ETSI2_6GHZ = 0x03,
-+	APL1_6GHZ = 0x04,
-+	FCC1_6GHZ_CL = 0x05,
-+
-+	/* add super domain above, handle it in
-+	 * ath11k_super_reg_6ghz_to_str()
-+	 */
- };
- 
-+static inline const char *
-+ath11k_super_reg_6ghz_to_str(enum reg_super_domain_6ghz domain_id)
-+{
-+	switch (domain_id) {
-+	case FCC1_6GHZ:
-+		return "FCC1_6GHZ";
-+	case ETSI1_6GHZ:
-+		return "ETSI1_6GHZ";
-+	case ETSI2_6GHZ:
-+		return "ETSI2_6GHZ";
-+	case APL1_6GHZ:
-+		return "APL1_6GHZ";
-+	case FCC1_6GHZ_CL:
-+		return "FCC1_6GHZ_CL";
-+	}
-+
-+	return "unknown domain id";
-+}
-+
- struct cur_reg_rule {
- 	u16 start_freq;
- 	u16 end_freq;
diff --git a/package/kernel/mac80211/patches/ath11k/0046-wifi-ath11k-Replace-fake-flex-array-with-flexible-ar.patch b/package/kernel/mac80211/patches/ath11k/0046-wifi-ath11k-Replace-fake-flex-array-with-flexible-ar.patch
deleted file mode 100644
index bd161785..00000000
--- a/package/kernel/mac80211/patches/ath11k/0046-wifi-ath11k-Replace-fake-flex-array-with-flexible-ar.patch
+++ /dev/null
@@ -1,246 +0,0 @@
-From 3b1088a09ec9438523c251d8435e78988824bc0d Mon Sep 17 00:00:00 2001
-From: "Gustavo A. R. Silva" <gustavoars@kernel.org>
-Date: Tue, 7 Mar 2023 16:22:39 -0600
-Subject: [PATCH] wifi: ath11k: Replace fake flex-array with flexible-array
- member
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Zero-length arrays as fake flexible arrays are deprecated and we are
-moving towards adopting C99 flexible-array members instead.
-
-Address 25 of the following warnings found with GCC-13 and
--fstrict-flex-arrays=3 enabled:
-drivers/net/wireless/ath/ath11k/debugfs_htt_stats.c:30:51: warning: array subscript <unknown> is outside array bounds of ‘const u32[0]’ {aka ‘const unsigned int[]’} [-Warray-bounds=]
-
-This helps with the ongoing efforts to tighten the FORTIFY_SOURCE
-routines on memcpy() and help us make progress towards globally
-enabling -fstrict-flex-arrays=3 [1].
-
-Link: https://github.com/KSPP/linux/issues/21
-Link: https://github.com/KSPP/linux/issues/266
-Link: https://gcc.gnu.org/pipermail/gcc-patches/2022-October/602902.html [1]
-Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
-Reviewed-by: Simon Horman <simon.horman@corigine.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/ZAe5L5DtmsQxzqRH@work
----
- .../wireless/ath/ath11k/debugfs_htt_stats.h   | 73 +++++++++++--------
- 1 file changed, 43 insertions(+), 30 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/debugfs_htt_stats.h
-+++ b/drivers/net/wireless/ath/ath11k/debugfs_htt_stats.h
-@@ -143,7 +143,8 @@ enum htt_tx_pdev_underrun_enum {
- /* Bytes stored in little endian order */
- /* Length should be multiple of DWORD */
- struct htt_stats_string_tlv {
--	u32 data[0]; /* Can be variable length */
-+	 /* Can be variable length */
-+	DECLARE_FLEX_ARRAY(u32, data);
- } __packed;
- 
- #define HTT_STATS_MAC_ID	GENMASK(7, 0)
-@@ -205,27 +206,32 @@ struct htt_tx_pdev_stats_cmn_tlv {
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_pdev_stats_urrn_tlv_v {
--	u32 urrn_stats[0]; /* HTT_TX_PDEV_MAX_URRN_STATS */
-+	/* HTT_TX_PDEV_MAX_URRN_STATS */
-+	DECLARE_FLEX_ARRAY(u32, urrn_stats);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_pdev_stats_flush_tlv_v {
--	u32 flush_errs[0]; /* HTT_TX_PDEV_MAX_FLUSH_REASON_STATS */
-+	/* HTT_TX_PDEV_MAX_FLUSH_REASON_STATS */
-+	DECLARE_FLEX_ARRAY(u32, flush_errs);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_pdev_stats_sifs_tlv_v {
--	u32 sifs_status[0]; /* HTT_TX_PDEV_MAX_SIFS_BURST_STATS */
-+	/* HTT_TX_PDEV_MAX_SIFS_BURST_STATS */
-+	DECLARE_FLEX_ARRAY(u32, sifs_status);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_pdev_stats_phy_err_tlv_v {
--	u32  phy_errs[0]; /* HTT_TX_PDEV_MAX_PHY_ERR_STATS */
-+	/* HTT_TX_PDEV_MAX_PHY_ERR_STATS */
-+	DECLARE_FLEX_ARRAY(u32, phy_errs);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_pdev_stats_sifs_hist_tlv_v {
--	u32 sifs_hist_status[0]; /* HTT_TX_PDEV_SIFS_BURST_HIST_STATS */
-+	/* HTT_TX_PDEV_SIFS_BURST_HIST_STATS */
-+	DECLARE_FLEX_ARRAY(u32, sifs_hist_status);
- };
- 
- struct htt_tx_pdev_stats_tx_ppdu_stats_tlv_v {
-@@ -590,20 +596,20 @@ struct htt_tx_hwq_difs_latency_stats_tlv
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_hwq_cmd_result_stats_tlv_v {
--	/* Histogram of sched cmd result */
--	u32 cmd_result[0]; /* HTT_TX_HWQ_MAX_CMD_RESULT_STATS */
-+	/* Histogram of sched cmd result, HTT_TX_HWQ_MAX_CMD_RESULT_STATS */
-+	DECLARE_FLEX_ARRAY(u32, cmd_result);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_hwq_cmd_stall_stats_tlv_v {
--	/* Histogram of various pause conitions */
--	u32 cmd_stall_status[0]; /* HTT_TX_HWQ_MAX_CMD_STALL_STATS */
-+	/* Histogram of various pause conitions, HTT_TX_HWQ_MAX_CMD_STALL_STATS */
-+	DECLARE_FLEX_ARRAY(u32, cmd_stall_status);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_hwq_fes_result_stats_tlv_v {
--	/* Histogram of number of user fes result */
--	u32 fes_result[0]; /* HTT_TX_HWQ_MAX_FES_RESULT_STATS */
-+	/* Histogram of number of user fes result, HTT_TX_HWQ_MAX_FES_RESULT_STATS */
-+	DECLARE_FLEX_ARRAY(u32, fes_result);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size
-@@ -635,8 +641,8 @@ struct htt_tx_hwq_tried_mpdu_cnt_hist_tl
-  * #define WAL_TXOP_USED_HISTOGRAM_INTERVAL 1000 ( 1 ms )
-  */
- struct htt_tx_hwq_txop_used_cnt_hist_tlv_v {
--	/* Histogram of txop used cnt */
--	u32 txop_used_cnt_hist[0]; /* HTT_TX_HWQ_TXOP_USED_CNT_HIST */
-+	/* Histogram of txop used cnt,  HTT_TX_HWQ_TXOP_USED_CNT_HIST */
-+	DECLARE_FLEX_ARRAY(u32, txop_used_cnt_hist);
- };
- 
- /* == TX SELFGEN STATS == */
-@@ -804,17 +810,20 @@ struct htt_tx_pdev_mpdu_stats_tlv {
- /* == TX SCHED STATS == */
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_sched_txq_cmd_posted_tlv_v {
--	u32 sched_cmd_posted[0]; /* HTT_TX_PDEV_SCHED_TX_MODE_MAX */
-+	/* HTT_TX_PDEV_SCHED_TX_MODE_MAX */
-+	DECLARE_FLEX_ARRAY(u32, sched_cmd_posted);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_sched_txq_cmd_reaped_tlv_v {
--	u32 sched_cmd_reaped[0]; /* HTT_TX_PDEV_SCHED_TX_MODE_MAX */
-+	/* HTT_TX_PDEV_SCHED_TX_MODE_MAX */
-+	DECLARE_FLEX_ARRAY(u32, sched_cmd_reaped);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_sched_txq_sched_order_su_tlv_v {
--	u32 sched_order_su[0]; /* HTT_TX_PDEV_NUM_SCHED_ORDER_LOG */
-+	/* HTT_TX_PDEV_NUM_SCHED_ORDER_LOG */
-+	DECLARE_FLEX_ARRAY(u32, sched_order_su);
- };
- 
- enum htt_sched_txq_sched_ineligibility_tlv_enum {
-@@ -842,7 +851,7 @@ enum htt_sched_txq_sched_ineligibility_t
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_sched_txq_sched_ineligibility_tlv_v {
- 	/* indexed by htt_sched_txq_sched_ineligibility_tlv_enum */
--	u32 sched_ineligibility[0];
-+	DECLARE_FLEX_ARRAY(u32, sched_ineligibility);
- };
- 
- #define	HTT_TX_PDEV_STATS_SCHED_PER_TXQ_MAC_ID	GENMASK(7, 0)
-@@ -888,18 +897,20 @@ struct htt_stats_tx_sched_cmn_tlv {
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_tqm_gen_mpdu_stats_tlv_v {
--	u32 gen_mpdu_end_reason[0]; /* HTT_TX_TQM_MAX_GEN_MPDU_END_REASON */
-+	/* HTT_TX_TQM_MAX_GEN_MPDU_END_REASON */
-+	DECLARE_FLEX_ARRAY(u32, gen_mpdu_end_reason);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_tqm_list_mpdu_stats_tlv_v {
--	u32 list_mpdu_end_reason[0]; /* HTT_TX_TQM_MAX_LIST_MPDU_END_REASON */
-+	 /* HTT_TX_TQM_MAX_LIST_MPDU_END_REASON */
-+	DECLARE_FLEX_ARRAY(u32, list_mpdu_end_reason);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_tx_tqm_list_mpdu_cnt_tlv_v {
--	u32 list_mpdu_cnt_hist[0];
--			/* HTT_TX_TQM_MAX_LIST_MPDU_CNT_HISTOGRAM_BINS */
-+	/* HTT_TX_TQM_MAX_LIST_MPDU_CNT_HISTOGRAM_BINS */
-+	DECLARE_FLEX_ARRAY(u32, list_mpdu_cnt_hist);
- };
- 
- struct htt_tx_tqm_pdev_stats_tlv_v {
-@@ -1098,7 +1109,7 @@ struct htt_tx_de_compl_stats_tlv {
-  *                               ENTRIES_PER_BIN_COUNT)
-  */
- struct htt_tx_de_fw2wbm_ring_full_hist_tlv {
--	u32 fw2wbm_ring_full_hist[0];
-+	DECLARE_FLEX_ARRAY(u32, fw2wbm_ring_full_hist);
- };
- 
- struct htt_tx_de_cmn_stats_tlv {
-@@ -1151,7 +1162,7 @@ struct htt_ring_if_cmn_tlv {
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_sfm_client_user_tlv_v {
- 	/* Number of DWORDS used per user and per client */
--	u32 dwords_used_by_user_n[0];
-+	DECLARE_FLEX_ARRAY(u32, dwords_used_by_user_n);
- };
- 
- struct htt_sfm_client_tlv {
-@@ -1436,12 +1447,14 @@ struct htt_rx_soc_fw_stats_tlv {
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_rx_soc_fw_refill_ring_empty_tlv_v {
--	u32 refill_ring_empty_cnt[0]; /* HTT_RX_STATS_REFILL_MAX_RING */
-+	/* HTT_RX_STATS_REFILL_MAX_RING */
-+	DECLARE_FLEX_ARRAY(u32, refill_ring_empty_cnt);
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_rx_soc_fw_refill_ring_num_refill_tlv_v {
--	u32 refill_ring_num_refill[0]; /* HTT_RX_STATS_REFILL_MAX_RING */
-+	/* HTT_RX_STATS_REFILL_MAX_RING */
-+	DECLARE_FLEX_ARRAY(u32, refill_ring_num_refill);
- };
- 
- /* RXDMA error code from WBM released packets */
-@@ -1473,7 +1486,7 @@ enum htt_rx_rxdma_error_code_enum {
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_rx_soc_fw_refill_ring_num_rxdma_err_tlv_v {
--	u32 rxdma_err[0]; /* HTT_RX_RXDMA_MAX_ERR_CODE */
-+	DECLARE_FLEX_ARRAY(u32, rxdma_err); /* HTT_RX_RXDMA_MAX_ERR_CODE */
- };
- 
- /* REO error code from WBM released packets */
-@@ -1505,7 +1518,7 @@ enum htt_rx_reo_error_code_enum {
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_rx_soc_fw_refill_ring_num_reo_err_tlv_v {
--	u32 reo_err[0]; /* HTT_RX_REO_MAX_ERR_CODE */
-+	DECLARE_FLEX_ARRAY(u32, reo_err); /* HTT_RX_REO_MAX_ERR_CODE */
- };
- 
- /* == RX PDEV STATS == */
-@@ -1622,13 +1635,13 @@ struct htt_rx_pdev_fw_stats_phy_err_tlv
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_rx_pdev_fw_ring_mpdu_err_tlv_v {
- 	/* Num error MPDU for each RxDMA error type  */
--	u32 fw_ring_mpdu_err[0]; /* HTT_RX_STATS_RXDMA_MAX_ERR */
-+	DECLARE_FLEX_ARRAY(u32, fw_ring_mpdu_err); /* HTT_RX_STATS_RXDMA_MAX_ERR */
- };
- 
- /* NOTE: Variable length TLV, use length spec to infer array size */
- struct htt_rx_pdev_fw_mpdu_drop_tlv_v {
- 	/* Num MPDU dropped  */
--	u32 fw_mpdu_drop[0]; /* HTT_RX_STATS_FW_DROP_REASON_MAX */
-+	DECLARE_FLEX_ARRAY(u32, fw_mpdu_drop); /* HTT_RX_STATS_FW_DROP_REASON_MAX */
- };
- 
- #define HTT_PDEV_CCA_STATS_TX_FRAME_INFO_PRESENT               (0x1)
diff --git a/package/kernel/mac80211/patches/ath11k/0047-wifi-ath11k-fix-deinitialization-of-firmware-resourc.patch b/package/kernel/mac80211/patches/ath11k/0047-wifi-ath11k-fix-deinitialization-of-firmware-resourc.patch
deleted file mode 100644
index eec11f50..00000000
--- a/package/kernel/mac80211/patches/ath11k/0047-wifi-ath11k-fix-deinitialization-of-firmware-resourc.patch
+++ /dev/null
@@ -1,79 +0,0 @@
-From 5a78ac33e3cb8822da64dd1af196e83664b332b0 Mon Sep 17 00:00:00 2001
-From: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Date: Thu, 9 Mar 2023 15:23:08 +0530
-Subject: [PATCH] wifi: ath11k: fix deinitialization of firmware resources
-
-Currently, in ath11k_ahb_fw_resources_init(), iommu domain
-mapping is done only for the chipsets having fixed firmware
-memory. Also, for such chipsets, mapping is done only if it
-does not have TrustZone support.
-
-During deinitialization, only if TrustZone support is not there,
-iommu is unmapped back. However, for non fixed firmware memory
-chipsets, TrustZone support is not there and this makes the
-condition check to true and it tries to unmap the memory which
-was not mapped during initialization.
-
-This leads to the following trace -
-
-[   83.198790] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000008
-[   83.259537] Modules linked in: ath11k_ahb ath11k qmi_helpers
-.. snip ..
-[   83.280286] pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
-[   83.287228] pc : __iommu_unmap+0x30/0x140
-[   83.293907] lr : iommu_unmap+0x5c/0xa4
-[   83.298072] sp : ffff80000b3abad0
-.. snip ..
-[   83.369175] Call trace:
-[   83.376282]  __iommu_unmap+0x30/0x140
-[   83.378541]  iommu_unmap+0x5c/0xa4
-[   83.382360]  ath11k_ahb_fw_resource_deinit.part.12+0x2c/0xac [ath11k_ahb]
-[   83.385666]  ath11k_ahb_free_resources+0x140/0x17c [ath11k_ahb]
-[   83.392521]  ath11k_ahb_shutdown+0x34/0x40 [ath11k_ahb]
-[   83.398248]  platform_shutdown+0x20/0x2c
-[   83.403455]  device_shutdown+0x16c/0x1c4
-[   83.407621]  kernel_restart_prepare+0x34/0x3c
-[   83.411529]  kernel_restart+0x14/0x74
-[   83.415781]  __do_sys_reboot+0x1c4/0x22c
-[   83.419427]  __arm64_sys_reboot+0x1c/0x24
-[   83.423420]  invoke_syscall+0x44/0xfc
-[   83.427326]  el0_svc_common.constprop.3+0xac/0xe8
-[   83.430974]  do_el0_svc+0xa0/0xa8
-[   83.435659]  el0_svc+0x1c/0x44
-[   83.438957]  el0t_64_sync_handler+0x60/0x144
-[   83.441910]  el0t_64_sync+0x15c/0x160
-[   83.446343] Code: aa0103f4 f9400001 f90027a1 d2800001 (f94006a0)
-[   83.449903] ---[ end trace 0000000000000000 ]---
-
-This can be reproduced by probing an AHB chipset which is not
-having a fixed memory region. During reboot (or rmmod) trace
-can be seen.
-
-Fix this issue by adding a condition check on firmware fixed memory
-hw_param as done in the counter initialization function.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Fixes: f9eec4947add ("ath11k: Add support for targets without trustzone")
-Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230309095308.24937-1-quic_adisi@quicinc.com
----
- drivers/net/wireless/ath/ath11k/ahb.c | 6 ++++++
- 1 file changed, 6 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -1078,6 +1078,12 @@ static int ath11k_ahb_fw_resource_deinit
- 	struct iommu_domain *iommu;
- 	size_t unmapped_size;
- 
-+	/* Chipsets not requiring MSA would have not initialized
-+	 * MSA resources, return success in such cases.
-+	 */
-+	if (!ab->hw_params.fixed_fw_mem)
-+		return 0;
-+
- 	if (ab_ahb->fw.use_tz)
- 		return 0;
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0048-wifi-ath11k-fix-BUFFER_DONE-read-on-monitor-ring-rx-.patch b/package/kernel/mac80211/patches/ath11k/0048-wifi-ath11k-fix-BUFFER_DONE-read-on-monitor-ring-rx-.patch
deleted file mode 100644
index 3e226453..00000000
--- a/package/kernel/mac80211/patches/ath11k/0048-wifi-ath11k-fix-BUFFER_DONE-read-on-monitor-ring-rx-.patch
+++ /dev/null
@@ -1,130 +0,0 @@
-From 68e93ac5a31d4975b25f819b2dfe914c72abc3bb Mon Sep 17 00:00:00 2001
-From: Harshitha Prem <quic_hprem@quicinc.com>
-Date: Wed, 15 Mar 2023 12:24:43 +0200
-Subject: [PATCH] wifi: ath11k: fix BUFFER_DONE read on monitor ring rx  buffer
-
-Perform dma_sync_single_for_cpu() on monitor ring rx buffer before
-reading BUFFER_DONE tag and do dma_unmap_single() only after device
-had set BUFFER_DONE tag to the buffer.
-
-Also when BUFFER_DONE tag is not set, allow the buffer to get read
-next time without freeing skb.
-
-This helps to fix AP+Monitor VAP with flood traffic scenario to see
-monitor ring rx buffer overrun missing BUFFER_DONE tag to be set.
-
-Also remove redundant rx dma buf free performed on DP
-rx_mon_status_refill_ring.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sathishkumar Muruganandam <quic_murugana@quicinc.com>
-Signed-off-by: Harshitha Prem <quic_hprem@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230309164434.32660-1-quic_hprem@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp_rx.c | 57 ++++++++++---------------
- 1 file changed, 23 insertions(+), 34 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -435,7 +435,6 @@ fail_free_skb:
- static int ath11k_dp_rxdma_buf_ring_free(struct ath11k *ar,
- 					 struct dp_rxdma_ring *rx_ring)
- {
--	struct ath11k_pdev_dp *dp = &ar->dp;
- 	struct sk_buff *skb;
- 	int buf_id;
- 
-@@ -453,28 +452,6 @@ static int ath11k_dp_rxdma_buf_ring_free
- 	idr_destroy(&rx_ring->bufs_idr);
- 	spin_unlock_bh(&rx_ring->idr_lock);
- 
--	/* if rxdma1_enable is false, mon_status_refill_ring
--	 * isn't setup, so don't clean.
--	 */
--	if (!ar->ab->hw_params.rxdma1_enable)
--		return 0;
--
--	rx_ring = &dp->rx_mon_status_refill_ring[0];
--
--	spin_lock_bh(&rx_ring->idr_lock);
--	idr_for_each_entry(&rx_ring->bufs_idr, skb, buf_id) {
--		idr_remove(&rx_ring->bufs_idr, buf_id);
--		/* XXX: Understand where internal driver does this dma_unmap
--		 * of rxdma_buffer.
--		 */
--		dma_unmap_single(ar->ab->dev, ATH11K_SKB_RXCB(skb)->paddr,
--				 skb->len + skb_tailroom(skb), DMA_BIDIRECTIONAL);
--		dev_kfree_skb_any(skb);
--	}
--
--	idr_destroy(&rx_ring->bufs_idr);
--	spin_unlock_bh(&rx_ring->idr_lock);
--
- 	return 0;
- }
- 
-@@ -3029,39 +3006,51 @@ static int ath11k_dp_rx_reap_mon_status_
- 
- 			spin_lock_bh(&rx_ring->idr_lock);
- 			skb = idr_find(&rx_ring->bufs_idr, buf_id);
-+			spin_unlock_bh(&rx_ring->idr_lock);
-+
- 			if (!skb) {
- 				ath11k_warn(ab, "rx monitor status with invalid buf_id %d\n",
- 					    buf_id);
--				spin_unlock_bh(&rx_ring->idr_lock);
- 				pmon->buf_state = DP_MON_STATUS_REPLINISH;
- 				goto move_next;
- 			}
- 
--			idr_remove(&rx_ring->bufs_idr, buf_id);
--			spin_unlock_bh(&rx_ring->idr_lock);
--
- 			rxcb = ATH11K_SKB_RXCB(skb);
- 
--			dma_unmap_single(ab->dev, rxcb->paddr,
--					 skb->len + skb_tailroom(skb),
--					 DMA_FROM_DEVICE);
-+			dma_sync_single_for_cpu(ab->dev, rxcb->paddr,
-+						skb->len + skb_tailroom(skb),
-+						DMA_FROM_DEVICE);
- 
- 			tlv = (struct hal_tlv_hdr *)skb->data;
- 			if (FIELD_GET(HAL_TLV_HDR_TAG, tlv->tl) !=
- 					HAL_RX_STATUS_BUFFER_DONE) {
--				ath11k_warn(ab, "mon status DONE not set %lx\n",
-+				ath11k_warn(ab, "mon status DONE not set %lx, buf_id %d\n",
- 					    FIELD_GET(HAL_TLV_HDR_TAG,
--						      tlv->tl));
--				dev_kfree_skb_any(skb);
-+						      tlv->tl), buf_id);
-+				/* If done status is missing, hold onto status
-+				 * ring until status is done for this status
-+				 * ring buffer.
-+				 * Keep HP in mon_status_ring unchanged,
-+				 * and break from here.
-+				 * Check status for same buffer for next time
-+				 */
- 				pmon->buf_state = DP_MON_STATUS_NO_DMA;
--				goto move_next;
-+				break;
- 			}
- 
-+			spin_lock_bh(&rx_ring->idr_lock);
-+			idr_remove(&rx_ring->bufs_idr, buf_id);
-+			spin_unlock_bh(&rx_ring->idr_lock);
- 			if (ab->hw_params.full_monitor_mode) {
- 				ath11k_dp_rx_mon_update_status_buf_state(pmon, tlv);
- 				if (paddr == pmon->mon_status_paddr)
- 					pmon->buf_state = DP_MON_STATUS_MATCH;
- 			}
-+
-+			dma_unmap_single(ab->dev, rxcb->paddr,
-+					 skb->len + skb_tailroom(skb),
-+					 DMA_FROM_DEVICE);
-+
- 			__skb_queue_tail(skb_list, skb);
- 		} else {
- 			pmon->buf_state = DP_MON_STATUS_REPLINISH;
diff --git a/package/kernel/mac80211/patches/ath11k/0049-wifi-ath11k-Optimize-6-GHz-scan-time.patch b/package/kernel/mac80211/patches/ath11k/0049-wifi-ath11k-Optimize-6-GHz-scan-time.patch
deleted file mode 100644
index f468990f..00000000
--- a/package/kernel/mac80211/patches/ath11k/0049-wifi-ath11k-Optimize-6-GHz-scan-time.patch
+++ /dev/null
@@ -1,101 +0,0 @@
-From 8b4d2f080afbd4280ecca0f4b3ceea943a7a86d0 Mon Sep 17 00:00:00 2001
-From: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
-Date: Thu, 23 Mar 2023 11:39:13 +0530
-Subject: [PATCH] wifi: ath11k: Optimize 6 GHz scan time
-
-Currently, time taken to scan all supported channels on WCN6750
-is ~8 seconds and connection time is almost 10 seconds. WCN6750
-supports three Wi-Fi bands (i.e., 2.4/5/6 GHz) and the numbers of
-channels for scan come around ~100 channels (default case).
-Since the chip doesn't have support for DBS (Dual Band Simultaneous),
-scans cannot be parallelized resulting in longer scan times.
-
-Among the 100 odd channels, ~60 channels are in 6 GHz band. Therefore,
-optimizing the scan for 6 GHz channels will bring down the overall
-scan time.
-
-WCN6750 firmware has support to scan a 6 GHz channel based on co-located
-AP information i.e., RNR IE which is found in the legacy 2.4/5 GHz scan
-results. When a scan request with all supported channel list is enqueued
-to the firmware, then based on WMI_SCAN_CHAN_FLAG_SCAN_ONLY_IF_RNR_FOUND
-scan channel flag, firmware will scan only those 6 GHz channels for which
-RNR IEs are found in the legacy scan results.
-
-In the proposed design, based on NL80211_SCAN_FLAG_COLOCATED_6GHZ scan
-flag, driver will set the WMI_SCAN_CHAN_FLAG_SCAN_ONLY_IF_RNR_FOUND flag
-for non-PSC channels. Since there is high probability to find 6 GHz APs
-on PSC channels, these channels are always scanned. Only non-PSC channels
-are selectively scanned based on cached RNR information from the legacy
-scan results.
-
-If NL80211_SCAN_FLAG_COLOCATED_6GHZ is not set in the scan flags,
-then scan will happen on all supported channels (default behavior).
-
-With these optimizations, scan time is improved by 1.5-1.8 seconds on
-WCN6750. Similar savings have been observed on WCN6855.
-
-Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00887-QCAMSLSWPLZ-1
-Tested-on: WCN6855 hw2.1 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.16
-
-Signed-off-by: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230323060913.10097-1-quic_mpubbise@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 25 +++++++++++++++++++++++--
- drivers/net/wireless/ath/ath11k/wmi.h |  4 ++++
- 2 files changed, 27 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -3819,8 +3819,29 @@ static int ath11k_mac_op_hw_scan(struct
- 			goto exit;
- 		}
- 
--		for (i = 0; i < arg->num_chan; i++)
--			arg->chan_list[i] = req->channels[i]->center_freq;
-+		for (i = 0; i < arg->num_chan; i++) {
-+			if (test_bit(WMI_TLV_SERVICE_SCAN_CONFIG_PER_CHANNEL,
-+				     ar->ab->wmi_ab.svc_map)) {
-+				arg->chan_list[i] =
-+					u32_encode_bits(req->channels[i]->center_freq,
-+							WMI_SCAN_CONFIG_PER_CHANNEL_MASK);
-+
-+				/* If NL80211_SCAN_FLAG_COLOCATED_6GHZ is set in scan
-+				 * flags, then scan all PSC channels in 6 GHz band and
-+				 * those non-PSC channels where RNR IE is found during
-+				 * the legacy 2.4/5 GHz scan.
-+				 * If NL80211_SCAN_FLAG_COLOCATED_6GHZ is not set,
-+				 * then all channels in 6 GHz will be scanned.
-+				 */
-+				if (req->channels[i]->band == NL80211_BAND_6GHZ &&
-+				    req->flags & NL80211_SCAN_FLAG_COLOCATED_6GHZ &&
-+				    !cfg80211_channel_is_psc(req->channels[i]))
-+					arg->chan_list[i] |=
-+						WMI_SCAN_CH_FLAG_SCAN_ONLY_IF_RNR_FOUND;
-+			} else {
-+				arg->chan_list[i] = req->channels[i]->center_freq;
-+			}
-+		}
- 	}
- 
- 	if (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2100,6 +2100,7 @@ enum wmi_tlv_service {
- 
- 	/* The second 128 bits */
- 	WMI_MAX_EXT_SERVICE = 256,
-+	WMI_TLV_SERVICE_SCAN_CONFIG_PER_CHANNEL = 265,
- 	WMI_TLV_SERVICE_REG_CC_EXT_EVENT_SUPPORT = 281,
- 	WMI_TLV_SERVICE_BIOS_SAR_SUPPORT = 326,
- 
-@@ -3249,6 +3250,9 @@ struct  wmi_start_scan_cmd {
- #define WMI_SCAN_DWELL_MODE_SHIFT        21
- #define WMI_SCAN_FLAG_EXT_PASSIVE_SCAN_START_TIME_ENHANCE   0x00000800
- 
-+#define WMI_SCAN_CONFIG_PER_CHANNEL_MASK	GENMASK(19, 0)
-+#define WMI_SCAN_CH_FLAG_SCAN_ONLY_IF_RNR_FOUND	BIT(20)
-+
- enum {
- 	WMI_SCAN_DWELL_MODE_DEFAULT      = 0,
- 	WMI_SCAN_DWELL_MODE_CONSERVATIVE = 1,
diff --git a/package/kernel/mac80211/patches/ath11k/0050-wifi-ath11k-Configure-the-FTM-responder-role-using-f.patch b/package/kernel/mac80211/patches/ath11k/0050-wifi-ath11k-Configure-the-FTM-responder-role-using-f.patch
deleted file mode 100644
index bca08b17..00000000
--- a/package/kernel/mac80211/patches/ath11k/0050-wifi-ath11k-Configure-the-FTM-responder-role-using-f.patch
+++ /dev/null
@@ -1,117 +0,0 @@
-From 813968c24126cc5c8320cd5db0e262069a535063 Mon Sep 17 00:00:00 2001
-From: Ganesh Babu Jothiram <quic_gjothira@quicinc.com>
-Date: Fri, 24 Mar 2023 16:57:00 +0200
-Subject: [PATCH] wifi: ath11k: Configure the FTM responder role using firmware
- capability flag
-
-Fine Time Measurement(FTM) is offloaded feature to firmware.
-Hence, the configuration of FTM responder role is done using
-firmware capability flag instead of hw param.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Ganesh Babu Jothiram <quic_gjothira@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230317072034.8217-1-quic_gjothira@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 8 --------
- drivers/net/wireless/ath/ath11k/hw.h   | 1 -
- drivers/net/wireless/ath/ath11k/mac.c  | 4 ++--
- 3 files changed, 2 insertions(+), 11 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -116,7 +116,6 @@ static const struct ath11k_hw_params ath
- 		.tcl_ring_retry = true,
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
--		.ftm_responder = true,
- 	},
- 	{
- 		.hw_rev = ATH11K_HW_IPQ6018_HW10,
-@@ -199,7 +198,6 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = false,
--		.ftm_responder = true,
- 	},
- 	{
- 		.name = "qca6390 hw2.0",
-@@ -284,7 +282,6 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = true,
--		.ftm_responder = false,
- 	},
- 	{
- 		.name = "qcn9074 hw1.0",
-@@ -366,7 +363,6 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = false,
--		.ftm_responder = true,
- 	},
- 	{
- 		.name = "wcn6855 hw2.0",
-@@ -451,7 +447,6 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = true,
--		.ftm_responder = false,
- 	},
- 	{
- 		.name = "wcn6855 hw2.1",
-@@ -534,7 +529,6 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = true,
--		.ftm_responder = false,
- 	},
- 	{
- 		.name = "wcn6750 hw1.0",
-@@ -615,7 +609,6 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE_WCN6750,
- 		.smp2p_wow_exit = true,
- 		.support_fw_mac_sequence = true,
--		.ftm_responder = false,
- 	},
- 	{
- 		.hw_rev = ATH11K_HW_IPQ5018_HW10,
-@@ -695,7 +688,6 @@ static const struct ath11k_hw_params ath
- 		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = false,
--		.ftm_responder = true,
- 	},
- };
- 
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -224,7 +224,6 @@ struct ath11k_hw_params {
- 	u32 tx_ring_size;
- 	bool smp2p_wow_exit;
- 	bool support_fw_mac_sequence;
--	bool ftm_responder;
- };
- 
- struct ath11k_hw_ops {
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -3538,7 +3538,7 @@ static void ath11k_mac_op_bss_info_chang
- 
- 	if (changed & BSS_CHANGED_FTM_RESPONDER &&
- 	    arvif->ftm_responder != info->ftm_responder &&
--	    ar->ab->hw_params.ftm_responder &&
-+	    test_bit(WMI_TLV_SERVICE_RTT, ar->ab->wmi_ab.svc_map) &&
- 	    (vif->type == NL80211_IFTYPE_AP ||
- 	     vif->type == NL80211_IFTYPE_MESH_POINT)) {
- 		arvif->ftm_responder = info->ftm_responder;
-@@ -9234,7 +9234,7 @@ static int __ath11k_mac_register(struct
- 	wiphy_ext_feature_set(ar->hw->wiphy,
- 			      NL80211_EXT_FEATURE_SET_SCAN_DWELL);
- 
--	if (ab->hw_params.ftm_responder)
-+	if (test_bit(WMI_TLV_SERVICE_RTT, ar->ab->wmi_ab.svc_map))
- 		wiphy_ext_feature_set(ar->hw->wiphy,
- 				      NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0051-wifi-ath11k-fix-rssi-station-dump-not-updated-in-QCN.patch b/package/kernel/mac80211/patches/ath11k/0051-wifi-ath11k-fix-rssi-station-dump-not-updated-in-QCN.patch
deleted file mode 100644
index 835dece1..00000000
--- a/package/kernel/mac80211/patches/ath11k/0051-wifi-ath11k-fix-rssi-station-dump-not-updated-in-QCN.patch
+++ /dev/null
@@ -1,158 +0,0 @@
-From 031ffa6c2cd305a57ccc6d610f2decd956b2e7f6 Mon Sep 17 00:00:00 2001
-From: P Praneesh <quic_ppranees@quicinc.com>
-Date: Fri, 24 Mar 2023 16:57:00 +0200
-Subject: [PATCH] wifi: ath11k: fix rssi station dump not updated in QCN9074
-
-In QCN9074, station dump signal values display default value which
-is -95 dbm, since there is firmware header change for HAL_RX_MPDU_START
-between QCN9074 and IPQ8074 which cause wrong peer_id fetch from msdu.
-Fix this by updating hal_rx_mpdu_info with corresponding QCN9074 tlv
-format.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-01695-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230320110312.20639-1-quic_ppranees@quicinc.com
----
- drivers/net/wireless/ath/ath11k/hal_rx.c | 10 ++++++++-
- drivers/net/wireless/ath/ath11k/hal_rx.h | 18 +++++++++++++++-
- drivers/net/wireless/ath/ath11k/hw.c     | 27 ++++++++++++++++--------
- drivers/net/wireless/ath/ath11k/hw.h     |  2 +-
- 4 files changed, 45 insertions(+), 12 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/hal_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/hal_rx.c
-@@ -865,6 +865,12 @@ ath11k_hal_rx_populate_mu_user_info(void
- 	ath11k_hal_rx_populate_byte_count(rx_tlv, ppdu_info, rx_user_status);
- }
- 
-+static u16 ath11k_hal_rx_mpduinfo_get_peerid(struct ath11k_base *ab,
-+					     struct hal_rx_mpdu_info *mpdu_info)
-+{
-+	return ab->hw_params.hw_ops->mpdu_info_get_peerid(mpdu_info);
-+}
-+
- static enum hal_rx_mon_status
- ath11k_hal_rx_parse_mon_status_tlv(struct ath11k_base *ab,
- 				   struct hal_rx_mon_ppdu_info *ppdu_info,
-@@ -1459,9 +1465,11 @@ ath11k_hal_rx_parse_mon_status_tlv(struc
- 		break;
- 	}
- 	case HAL_RX_MPDU_START: {
-+		struct hal_rx_mpdu_info *mpdu_info =
-+				(struct hal_rx_mpdu_info *)tlv_data;
- 		u16 peer_id;
- 
--		peer_id = ab->hw_params.hw_ops->mpdu_info_get_peerid(tlv_data);
-+		peer_id = ath11k_hal_rx_mpduinfo_get_peerid(ab, mpdu_info);
- 		if (peer_id)
- 			ppdu_info->peer_id = peer_id;
- 		break;
---- a/drivers/net/wireless/ath/ath11k/hal_rx.h
-+++ b/drivers/net/wireless/ath/ath11k/hal_rx.h
-@@ -405,7 +405,7 @@ struct hal_rx_phyrx_rssi_legacy_info {
- #define HAL_RX_MPDU_INFO_INFO0_PEERID_WCN6855	GENMASK(15, 0)
- #define HAL_RX_MPDU_INFO_INFO1_MPDU_LEN		GENMASK(13, 0)
- 
--struct hal_rx_mpdu_info {
-+struct hal_rx_mpdu_info_ipq8074 {
- 	__le32 rsvd0;
- 	__le32 info0;
- 	__le32 rsvd1[11];
-@@ -413,12 +413,28 @@ struct hal_rx_mpdu_info {
- 	__le32 rsvd2[9];
- } __packed;
- 
-+struct hal_rx_mpdu_info_qcn9074 {
-+	__le32 rsvd0[10];
-+	__le32 info0;
-+	__le32 rsvd1[2];
-+	__le32 info1;
-+	__le32 rsvd2[9];
-+} __packed;
-+
- struct hal_rx_mpdu_info_wcn6855 {
- 	__le32 rsvd0[8];
- 	__le32 info0;
- 	__le32 rsvd1[14];
- } __packed;
- 
-+struct hal_rx_mpdu_info {
-+	union {
-+		struct hal_rx_mpdu_info_ipq8074 ipq8074;
-+		struct hal_rx_mpdu_info_qcn9074 qcn9074;
-+		struct hal_rx_mpdu_info_wcn6855 wcn6855;
-+	} u;
-+} __packed;
-+
- #define HAL_RX_PPDU_END_DURATION	GENMASK(23, 0)
- struct hal_rx_ppdu_end_duration {
- 	__le32 rsvd0[9];
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -835,26 +835,35 @@ static void ath11k_hw_ipq5018_reo_setup(
- 			   ring_hash_map);
- }
- 
--static u16 ath11k_hw_ipq8074_mpdu_info_get_peerid(u8 *tlv_data)
-+static u16
-+ath11k_hw_ipq8074_mpdu_info_get_peerid(struct hal_rx_mpdu_info *mpdu_info)
- {
- 	u16 peer_id = 0;
--	struct hal_rx_mpdu_info *mpdu_info =
--		(struct hal_rx_mpdu_info *)tlv_data;
- 
- 	peer_id = FIELD_GET(HAL_RX_MPDU_INFO_INFO0_PEERID,
--			    __le32_to_cpu(mpdu_info->info0));
-+			    __le32_to_cpu(mpdu_info->u.ipq8074.info0));
- 
- 	return peer_id;
- }
- 
--static u16 ath11k_hw_wcn6855_mpdu_info_get_peerid(u8 *tlv_data)
-+static u16
-+ath11k_hw_qcn9074_mpdu_info_get_peerid(struct hal_rx_mpdu_info *mpdu_info)
-+{
-+	u16 peer_id = 0;
-+
-+	peer_id = FIELD_GET(HAL_RX_MPDU_INFO_INFO0_PEERID,
-+			    __le32_to_cpu(mpdu_info->u.qcn9074.info0));
-+
-+	return peer_id;
-+}
-+
-+static u16
-+ath11k_hw_wcn6855_mpdu_info_get_peerid(struct hal_rx_mpdu_info *mpdu_info)
- {
- 	u16 peer_id = 0;
--	struct hal_rx_mpdu_info_wcn6855 *mpdu_info =
--		(struct hal_rx_mpdu_info_wcn6855 *)tlv_data;
- 
- 	peer_id = FIELD_GET(HAL_RX_MPDU_INFO_INFO0_PEERID_WCN6855,
--			    __le32_to_cpu(mpdu_info->info0));
-+			    __le32_to_cpu(mpdu_info->u.wcn6855.info0));
- 	return peer_id;
- }
- 
-@@ -1042,7 +1051,7 @@ const struct ath11k_hw_ops qcn9074_ops =
- 	.rx_desc_get_attention = ath11k_hw_qcn9074_rx_desc_get_attention,
- 	.rx_desc_get_msdu_payload = ath11k_hw_qcn9074_rx_desc_get_msdu_payload,
- 	.reo_setup = ath11k_hw_ipq8074_reo_setup,
--	.mpdu_info_get_peerid = ath11k_hw_ipq8074_mpdu_info_get_peerid,
-+	.mpdu_info_get_peerid = ath11k_hw_qcn9074_mpdu_info_get_peerid,
- 	.rx_desc_mac_addr2_valid = ath11k_hw_ipq9074_rx_desc_mac_addr2_valid,
- 	.rx_desc_mpdu_start_addr2 = ath11k_hw_ipq9074_rx_desc_mpdu_start_addr2,
- 	.get_ring_selector = ath11k_hw_ipq8074_get_tcl_ring_selector,
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -263,7 +263,7 @@ struct ath11k_hw_ops {
- 	struct rx_attention *(*rx_desc_get_attention)(struct hal_rx_desc *desc);
- 	u8 *(*rx_desc_get_msdu_payload)(struct hal_rx_desc *desc);
- 	void (*reo_setup)(struct ath11k_base *ab);
--	u16 (*mpdu_info_get_peerid)(u8 *tlv_data);
-+	u16 (*mpdu_info_get_peerid)(struct hal_rx_mpdu_info *mpdu_info);
- 	bool (*rx_desc_mac_addr2_valid)(struct hal_rx_desc *desc);
- 	u8* (*rx_desc_mpdu_start_addr2)(struct hal_rx_desc *desc);
- 	u32 (*get_ring_selector)(struct sk_buff *skb);
diff --git a/package/kernel/mac80211/patches/ath11k/0052-wifi-ath11k-Fix-invalid-management-rx-frame-length-i.patch b/package/kernel/mac80211/patches/ath11k/0052-wifi-ath11k-Fix-invalid-management-rx-frame-length-i.patch
deleted file mode 100644
index 0c1637fb..00000000
--- a/package/kernel/mac80211/patches/ath11k/0052-wifi-ath11k-Fix-invalid-management-rx-frame-length-i.patch
+++ /dev/null
@@ -1,115 +0,0 @@
-From 447b0398a9cd41ca343dfd43e555af92d6214487 Mon Sep 17 00:00:00 2001
-From: Bhagavathi Perumal S <quic_bperumal@quicinc.com>
-Date: Fri, 24 Mar 2023 16:57:00 +0200
-Subject: [PATCH] wifi: ath11k: Fix invalid management rx frame length issue
-
-The WMI management rx event has multiple arrays of TLVs, however the common
-WMI TLV parser won't handle multiple TLV tags of same type.
-So the multiple array tags of WMI management rx TLV is parsed incorrectly
-and the length calculated becomes wrong when the target sends multiple
-array tags.
-
-Add separate TLV parser to handle multiple arrays for WMI management rx
-TLV. This fixes invalid length issue when the target sends multiple array
-tags.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Bhagavathi Perumal S <quic_bperumal@quicinc.com>
-Co-developed-by: Nagarajan Maran <quic_nmaran@quicinc.com>
-Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230320133840.30162-1-quic_nmaran@quicinc.com
----
- drivers/net/wireless/ath/ath11k/wmi.c | 45 +++++++++++++++++++++------
- 1 file changed, 35 insertions(+), 10 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -82,6 +82,12 @@ struct wmi_tlv_fw_stats_parse {
- 	bool chain_rssi_done;
- };
- 
-+struct wmi_tlv_mgmt_rx_parse {
-+	const struct wmi_mgmt_rx_hdr *fixed;
-+	const u8 *frame_buf;
-+	bool frame_buf_done;
-+};
-+
- static const struct wmi_tlv_policy wmi_tlv_policies[] = {
- 	[WMI_TAG_ARRAY_BYTE]
- 		= { .min_len = 0 },
-@@ -5633,28 +5639,49 @@ static int ath11k_pull_vdev_stopped_para
- 	return 0;
- }
- 
-+static int ath11k_wmi_tlv_mgmt_rx_parse(struct ath11k_base *ab,
-+					u16 tag, u16 len,
-+					const void *ptr, void *data)
-+{
-+	struct wmi_tlv_mgmt_rx_parse *parse = data;
-+
-+	switch (tag) {
-+	case WMI_TAG_MGMT_RX_HDR:
-+		parse->fixed = ptr;
-+		break;
-+	case WMI_TAG_ARRAY_BYTE:
-+		if (!parse->frame_buf_done) {
-+			parse->frame_buf = ptr;
-+			parse->frame_buf_done = true;
-+		}
-+		break;
-+	}
-+	return 0;
-+}
-+
- static int ath11k_pull_mgmt_rx_params_tlv(struct ath11k_base *ab,
- 					  struct sk_buff *skb,
- 					  struct mgmt_rx_event_params *hdr)
- {
--	const void **tb;
-+	struct wmi_tlv_mgmt_rx_parse parse = { };
- 	const struct wmi_mgmt_rx_hdr *ev;
- 	const u8 *frame;
- 	int ret;
- 
--	tb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);
--	if (IS_ERR(tb)) {
--		ret = PTR_ERR(tb);
--		ath11k_warn(ab, "failed to parse tlv: %d\n", ret);
-+	ret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,
-+				  ath11k_wmi_tlv_mgmt_rx_parse,
-+				  &parse);
-+	if (ret) {
-+		ath11k_warn(ab, "failed to parse mgmt rx tlv %d\n",
-+			    ret);
- 		return ret;
- 	}
- 
--	ev = tb[WMI_TAG_MGMT_RX_HDR];
--	frame = tb[WMI_TAG_ARRAY_BYTE];
-+	ev = parse.fixed;
-+	frame = parse.frame_buf;
- 
- 	if (!ev || !frame) {
- 		ath11k_warn(ab, "failed to fetch mgmt rx hdr");
--		kfree(tb);
- 		return -EPROTO;
- 	}
- 
-@@ -5673,7 +5700,6 @@ static int ath11k_pull_mgmt_rx_params_tl
- 
- 	if (skb->len < (frame - skb->data) + hdr->buf_len) {
- 		ath11k_warn(ab, "invalid length in mgmt rx hdr ev");
--		kfree(tb);
- 		return -EPROTO;
- 	}
- 
-@@ -5685,7 +5711,6 @@ static int ath11k_pull_mgmt_rx_params_tl
- 
- 	ath11k_ce_byte_swap(skb->data, hdr->buf_len);
- 
--	kfree(tb);
- 	return 0;
- }
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0053-wifi-ath11k-fix-writing-to-unintended-memory-region.patch b/package/kernel/mac80211/patches/ath11k/0053-wifi-ath11k-fix-writing-to-unintended-memory-region.patch
deleted file mode 100644
index 7b8a7d45..00000000
--- a/package/kernel/mac80211/patches/ath11k/0053-wifi-ath11k-fix-writing-to-unintended-memory-region.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From 756a7f90878f0866fd2fe167ef37e90b47326b96 Mon Sep 17 00:00:00 2001
-From: P Praneesh <quic_ppranees@quicinc.com>
-Date: Fri, 24 Mar 2023 16:57:01 +0200
-Subject: [PATCH] wifi: ath11k: fix writing to unintended memory region
-
-While initializing spectral, the magic value is getting written to the
-invalid memory address leading to random boot-up crash. This occurs
-due to the incorrect index increment in ath11k_dbring_fill_magic_value
-function. Fix it by replacing the existing logic with memset32 to ensure
-there is no invalid memory access.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.4.0.1-01838-QCAHKSWPL_SILICONZ-1
-
-Fixes: d3d358efc553 ("ath11k: add spectral/CFR buffer validation support")
-Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230321052900.16895-1-quic_ppranees@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dbring.c | 12 ++++++------
- 1 file changed, 6 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/dbring.c
-+++ b/drivers/net/wireless/ath/ath11k/dbring.c
-@@ -26,13 +26,13 @@ int ath11k_dbring_validate_buffer(struct
- static void ath11k_dbring_fill_magic_value(struct ath11k *ar,
- 					   void *buffer, u32 size)
- {
--	u32 *temp;
--	int idx;
-+	/* memset32 function fills buffer payload with the ATH11K_DB_MAGIC_VALUE
-+	 * and the variable size is expected to be the number of u32 values
-+	 * to be stored, not the number of bytes.
-+	 */
-+	size = size / sizeof(u32);
- 
--	size = size >> 2;
--
--	for (idx = 0, temp = buffer; idx < size; idx++, temp++)
--		*temp++ = ATH11K_DB_MAGIC_VALUE;
-+	memset32(buffer, ATH11K_DB_MAGIC_VALUE, size);
- }
- 
- static int ath11k_dbring_bufs_replenish(struct ath11k *ar,
diff --git a/package/kernel/mac80211/patches/ath11k/0054-wifi-ath11k-Send-11d-scan-start-before-WMI_START_SCA.patch b/package/kernel/mac80211/patches/ath11k/0054-wifi-ath11k-Send-11d-scan-start-before-WMI_START_SCA.patch
deleted file mode 100644
index 0f8e6375..00000000
--- a/package/kernel/mac80211/patches/ath11k/0054-wifi-ath11k-Send-11d-scan-start-before-WMI_START_SCA.patch
+++ /dev/null
@@ -1,61 +0,0 @@
-From e89a51aedf380bc60219dc9afa96c36507060fb3 Mon Sep 17 00:00:00 2001
-From: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
-Date: Wed, 15 Mar 2023 21:48:17 +0530
-Subject: [PATCH] wifi: ath11k: Send 11d scan start before WMI_START_SCAN_CMDID
-
-Firmwares advertising the support of triggering 11d algorithm on the
-scan results of a regular scan expects driver to send
-WMI_11D_SCAN_START_CMDID before sending WMI_START_SCAN_CMDID.
-Triggering 11d algorithm on the scan results of a normal scan helps
-in completely avoiding a separate 11d scan for determining regdomain.
-This indirectly helps in speeding up connections on station
-interfaces on the chipsets supporting 11D scan.
-
-To enable this feature, send WMI_11D_SCAN_START_CMDID just before
-sending WMI_START_SCAN_CMDID if the firmware advertises
-WMI_TLV_SERVICE_SUPPORT_11D_FOR_HOST_SCAN service flag.
-
-WCN6750 & WCN6855 supports this feature.
-
-Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-01160-QCAMSLSWPLZ-1
-Tested-on: WCN6855 hw2.1 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.23
-
-Signed-off-by: Manikanta Pubbisetty <quic_mpubbise@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230315161817.29627-1-quic_mpubbise@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 12 ++++++++++++
- drivers/net/wireless/ath/ath11k/wmi.h |  1 +
- 2 files changed, 13 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -3755,6 +3755,18 @@ static int ath11k_mac_op_hw_scan(struct
- 	int i;
- 	u32 scan_timeout;
- 
-+	/* Firmwares advertising the support of triggering 11D algorithm
-+	 * on the scan results of a regular scan expects driver to send
-+	 * WMI_11D_SCAN_START_CMDID before sending WMI_START_SCAN_CMDID.
-+	 * With this feature, separate 11D scan can be avoided since
-+	 * regdomain can be determined with the scan results of the
-+	 * regular scan.
-+	 */
-+	if (ar->state_11d == ATH11K_11D_PREPARING &&
-+	    test_bit(WMI_TLV_SERVICE_SUPPORT_11D_FOR_HOST_SCAN,
-+		     ar->ab->wmi_ab.svc_map))
-+		ath11k_mac_11d_scan_start(ar, arvif->vdev_id);
-+
- 	mutex_lock(&ar->conf_mutex);
- 
- 	spin_lock_bh(&ar->data_lock);
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2103,6 +2103,7 @@ enum wmi_tlv_service {
- 	WMI_TLV_SERVICE_SCAN_CONFIG_PER_CHANNEL = 265,
- 	WMI_TLV_SERVICE_REG_CC_EXT_EVENT_SUPPORT = 281,
- 	WMI_TLV_SERVICE_BIOS_SAR_SUPPORT = 326,
-+	WMI_TLV_SERVICE_SUPPORT_11D_FOR_HOST_SCAN = 357,
- 
- 	/* The third 128 bits */
- 	WMI_MAX_EXT2_SERVICE = 384
diff --git a/package/kernel/mac80211/patches/ath11k/0055-wifi-ath11k-Remove-redundant-pci_clear_master.patch b/package/kernel/mac80211/patches/ath11k/0055-wifi-ath11k-Remove-redundant-pci_clear_master.patch
deleted file mode 100644
index 0439727e..00000000
--- a/package/kernel/mac80211/patches/ath11k/0055-wifi-ath11k-Remove-redundant-pci_clear_master.patch
+++ /dev/null
@@ -1,58 +0,0 @@
-From f812e2a9f85d6bea78957ccb5197e4491316848b Mon Sep 17 00:00:00 2001
-From: Cai Huoqing <cai.huoqing@linux.dev>
-Date: Thu, 23 Mar 2023 19:26:09 +0800
-Subject: [PATCH] wifi: ath11k: Remove redundant pci_clear_master
-
-Remove pci_clear_master to simplify the code,
-the bus-mastering is also cleared in do_pci_disable_device,
-like this:
-./drivers/pci/pci.c:2197
-static void do_pci_disable_device(struct pci_dev *dev)
-{
-	u16 pci_command;
-
-	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
-	if (pci_command & PCI_COMMAND_MASTER) {
-		pci_command &= ~PCI_COMMAND_MASTER;
-		pci_write_config_word(dev, PCI_COMMAND, pci_command);
-	}
-
-	pcibios_disable_device(dev);
-}.
-And dev->is_busmaster is set to 0 in pci_disable_device.
-
-Signed-off-by: Cai Huoqing <cai.huoqing@linux.dev>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230323112613.7550-1-cai.huoqing@linux.dev
----
- drivers/net/wireless/ath/ath11k/pci.c | 5 +----
- 1 file changed, 1 insertion(+), 4 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -540,7 +540,7 @@ static int ath11k_pci_claim(struct ath11
- 	if (!ab->mem) {
- 		ath11k_err(ab, "failed to map pci bar %d\n", ATH11K_PCI_BAR_NUM);
- 		ret = -EIO;
--		goto clear_master;
-+		goto release_region;
- 	}
- 
- 	ab->mem_ce = ab->mem;
-@@ -548,8 +548,6 @@ static int ath11k_pci_claim(struct ath11
- 	ath11k_dbg(ab, ATH11K_DBG_BOOT, "boot pci_mem 0x%pK\n", ab->mem);
- 	return 0;
- 
--clear_master:
--	pci_clear_master(pdev);
- release_region:
- 	pci_release_region(pdev, ATH11K_PCI_BAR_NUM);
- disable_device:
-@@ -565,7 +563,6 @@ static void ath11k_pci_free_region(struc
- 
- 	pci_iounmap(pci_dev, ab->mem);
- 	ab->mem = NULL;
--	pci_clear_master(pci_dev);
- 	pci_release_region(pci_dev, ATH11K_PCI_BAR_NUM);
- 	if (pci_is_enabled(pci_dev))
- 		pci_disable_device(pci_dev);
diff --git a/package/kernel/mac80211/patches/ath11k/0056-wifi-ath11k-Disable-Spectral-scan-upon-removing-inte.patch b/package/kernel/mac80211/patches/ath11k/0056-wifi-ath11k-Disable-Spectral-scan-upon-removing-inte.patch
deleted file mode 100644
index 44532a4d..00000000
--- a/package/kernel/mac80211/patches/ath11k/0056-wifi-ath11k-Disable-Spectral-scan-upon-removing-inte.patch
+++ /dev/null
@@ -1,36 +0,0 @@
-From 5c690db63b45c6c4c4932b13173af71df369dba5 Mon Sep 17 00:00:00 2001
-From: Tamizh Chelvam Raja <quic_tamizhr@quicinc.com>
-Date: Tue, 28 Mar 2023 12:41:50 +0530
-Subject: [PATCH] wifi: ath11k: Disable Spectral scan upon removing interface
-
-Host might receive spectral events during interface
-down sequence and this might create below errors.
-
-failed to handle dma buf release event -22
-failed to handle dma buf release event -22
-
-Fix this by disabling spectral config during remove interface.
-
-Tested-on: IPQ5018 hw1.0 AHB WLAN.HK.2.6.0.1-00861-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Tamizh Chelvam Raja <quic_tamizhr@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230328071150.29645-1-quic_tamizhr@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 5 +++++
- 1 file changed, 5 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -6685,6 +6685,11 @@ static void ath11k_mac_op_remove_interfa
- 	ath11k_dbg(ab, ATH11K_DBG_MAC, "mac remove interface (vdev %d)\n",
- 		   arvif->vdev_id);
- 
-+	ret = ath11k_spectral_vif_stop(arvif);
-+	if (ret)
-+		ath11k_warn(ab, "failed to stop spectral for vdev %i: %d\n",
-+			    arvif->vdev_id, ret);
-+
- 	if (arvif->vdev_type == WMI_VDEV_TYPE_STA)
- 		ath11k_mac_11d_scan_stop(ar);
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0057-wifi-ath11k-enable-SAR-support-on-WCN6750.patch b/package/kernel/mac80211/patches/ath11k/0057-wifi-ath11k-enable-SAR-support-on-WCN6750.patch
deleted file mode 100644
index 5e64e552..00000000
--- a/package/kernel/mac80211/patches/ath11k/0057-wifi-ath11k-enable-SAR-support-on-WCN6750.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From abf57d84973ce1abcb67504ac0df8aea1fe09a76 Mon Sep 17 00:00:00 2001
-From: Youghandhar Chintala <quic_youghand@quicinc.com>
-Date: Tue, 28 Mar 2023 17:04:55 +0530
-Subject: [PATCH] wifi: ath11k: enable SAR support on WCN6750
-
-Currently, SAR is enabled only on WCN6855, enable this for WCN6750 too. This
-functionality gets triggered, when the user space application calls
-NL80211_CMD_SET_SAR_SPECS.
-
-Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-00887-QCAMSLSWPLZ-1
-
-Signed-off-by: Youghandhar Chintala <quic_youghand@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230328113455.11252-1-quic_youghand@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -593,7 +593,7 @@ static const struct ath11k_hw_params ath
- 		.current_cc_support = true,
- 		.dbr_debug_support = false,
- 		.global_reset = false,
--		.bios_sar_capa = NULL,
-+		.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,
- 		.m3_fw_support = false,
- 		.fixed_bdf_addr = false,
- 		.fixed_mem_region = false,
diff --git a/package/kernel/mac80211/patches/ath11k/0058-wifi-ath11k-pci-Add-more-MODULE_FIRMWARE-entries.patch b/package/kernel/mac80211/patches/ath11k/0058-wifi-ath11k-pci-Add-more-MODULE_FIRMWARE-entries.patch
deleted file mode 100644
index 585864ef..00000000
--- a/package/kernel/mac80211/patches/ath11k/0058-wifi-ath11k-pci-Add-more-MODULE_FIRMWARE-entries.patch
+++ /dev/null
@@ -1,36 +0,0 @@
-From 06c58473969239e00d76b683edd511952060ca56 Mon Sep 17 00:00:00 2001
-From: Takashi Iwai <tiwai@suse.de>
-Date: Thu, 30 Mar 2023 16:37:18 +0200
-Subject: [PATCH] wifi: ath11k: pci: Add more MODULE_FIRMWARE() entries
-
-As there are a few more models supported by the driver, let's add the
-missing MODULE_FIRMWARE() entries for them.  The lack of them resulted
-in the missing device enablement on some systems, such as the
-installation image of openSUSE.
-
-While we are at it, use the wildcard instead of listing each firmware
-files individually for each.
-
-Signed-off-by: Takashi Iwai <tiwai@suse.de>
-Reviewed-by: Simon Horman <simon.horman@corigine.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230330143718.19511-1-tiwai@suse.de
----
- drivers/net/wireless/ath/ath11k/pci.c | 9 +++++----
- 1 file changed, 5 insertions(+), 4 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -1036,7 +1036,8 @@ module_exit(ath11k_pci_exit);
- MODULE_DESCRIPTION("Driver support for Qualcomm Technologies 802.11ax WLAN PCIe devices");
- MODULE_LICENSE("Dual BSD/GPL");
- 
--/* QCA639x 2.0 firmware files */
--MODULE_FIRMWARE(ATH11K_FW_DIR "/QCA6390/hw2.0/" ATH11K_BOARD_API2_FILE);
--MODULE_FIRMWARE(ATH11K_FW_DIR "/QCA6390/hw2.0/" ATH11K_AMSS_FILE);
--MODULE_FIRMWARE(ATH11K_FW_DIR "/QCA6390/hw2.0/" ATH11K_M3_FILE);
-+/* firmware files */
-+MODULE_FIRMWARE(ATH11K_FW_DIR "/QCA6390/hw2.0/*");
-+MODULE_FIRMWARE(ATH11K_FW_DIR "/QCN9074/hw1.0/*");
-+MODULE_FIRMWARE(ATH11K_FW_DIR "/WCN6855/hw2.0/*");
-+MODULE_FIRMWARE(ATH11K_FW_DIR "/WCN6855/hw2.1/*");
diff --git a/package/kernel/mac80211/patches/ath11k/0059-wifi-ath11k-print-a-warning-when-crypto_alloc_shash-.patch b/package/kernel/mac80211/patches/ath11k/0059-wifi-ath11k-print-a-warning-when-crypto_alloc_shash-.patch
deleted file mode 100644
index fab52a0f..00000000
--- a/package/kernel/mac80211/patches/ath11k/0059-wifi-ath11k-print-a-warning-when-crypto_alloc_shash-.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From a87a9110ac0dcbfd9458b6665c141fa1c16a669d Mon Sep 17 00:00:00 2001
-From: Kalle Valo <quic_kvalo@quicinc.com>
-Date: Wed, 5 Apr 2023 12:04:25 +0300
-Subject: [PATCH] wifi: ath11k: print a warning when crypto_alloc_shash() fails
-
-Christoph reported that ath11k failed to initialise when michael_mic.ko
-module was not installed. To make it easier to notice that case print a
-warning when crypto_alloc_shash() fails.
-
-Compile tested only.
-
-Reported-by: Christoph Hellwig <hch@lst.de>
-Link: https://lore.kernel.org/all/20221130133016.GC3055@lst.de/
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405090425.1351-1-kvalo@kernel.org
----
- drivers/net/wireless/ath/ath11k/dp_rx.c | 5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -3106,8 +3106,11 @@ int ath11k_peer_rx_frag_setup(struct ath
- 	int i;
- 
- 	tfm = crypto_alloc_shash("michael_mic", 0, 0);
--	if (IS_ERR(tfm))
-+	if (IS_ERR(tfm)) {
-+		ath11k_warn(ab, "failed to allocate michael_mic shash: %ld\n",
-+			    PTR_ERR(tfm));
- 		return PTR_ERR(tfm);
-+	}
- 
- 	spin_lock_bh(&ab->base_lock);
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0060-wifi-ath11k-Ignore-frags-from-uninitialized-peer-in-.patch b/package/kernel/mac80211/patches/ath11k/0060-wifi-ath11k-Ignore-frags-from-uninitialized-peer-in-.patch
deleted file mode 100644
index 5bbf9e04..00000000
--- a/package/kernel/mac80211/patches/ath11k/0060-wifi-ath11k-Ignore-frags-from-uninitialized-peer-in-.patch
+++ /dev/null
@@ -1,104 +0,0 @@
-From a06bfb3c9f69f303692cdae87bc0899d2ae8b2a6 Mon Sep 17 00:00:00 2001
-From: Harshitha Prem <quic_hprem@quicinc.com>
-Date: Tue, 4 Apr 2023 00:11:54 +0530
-Subject: [PATCH] wifi: ath11k: Ignore frags from uninitialized peer in dp.
-
-When max virtual ap interfaces are configured in all the bands with
-ACS and hostapd restart is done every 60s, a crash is observed at
-random times.
-In this certain scenario, a fragmented packet is received for
-self peer, for which rx_tid and rx_frags are not initialized in
-datapath. While handling this fragment, crash is observed as the
-rx_frag list is uninitialised and when we walk in
-ath11k_dp_rx_h_sort_frags, skb null leads to exception.
-
-To address this, before processing received fragments we check
-dp_setup_done flag is set to ensure that peer has completed its
-dp peer setup for fragment queue, else ignore processing the
-fragments.
-
-Call trace:
-  ath11k_dp_process_rx_err+0x550/0x1084 [ath11k]
-  ath11k_dp_service_srng+0x70/0x370 [ath11k]
-  0xffffffc009693a04
-  __napi_poll+0x30/0xa4
-  net_rx_action+0x118/0x270
-  __do_softirq+0x10c/0x244
-  irq_exit+0x64/0xb4
-  __handle_domain_irq+0x88/0xac
-  gic_handle_irq+0x74/0xbc
-  el1_irq+0xf0/0x1c0
-  arch_cpu_idle+0x10/0x18
-  do_idle+0x104/0x248
-  cpu_startup_entry+0x20/0x64
-  rest_init+0xd0/0xdc
-  arch_call_rest_init+0xc/0x14
-  start_kernel+0x480/0x4b8
-  Code: f9400281 f94066a2 91405021 b94a0023 (f9406401)
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Harshitha Prem <quic_hprem@quicinc.com>
-Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403184155.8670-2-quic_nmaran@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp.c    | 4 +++-
- drivers/net/wireless/ath/ath11k/dp_rx.c | 8 ++++++++
- drivers/net/wireless/ath/ath11k/peer.h  | 1 +
- 3 files changed, 12 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp.c
-+++ b/drivers/net/wireless/ath/ath11k/dp.c
-@@ -36,6 +36,7 @@ void ath11k_dp_peer_cleanup(struct ath11
- 	}
- 
- 	ath11k_peer_rx_tid_cleanup(ar, peer);
-+	peer->dp_setup_done = false;
- 	crypto_free_shash(peer->tfm_mmic);
- 	spin_unlock_bh(&ab->base_lock);
- }
-@@ -72,7 +73,8 @@ int ath11k_dp_peer_setup(struct ath11k *
- 	ret = ath11k_peer_rx_frag_setup(ar, addr, vdev_id);
- 	if (ret) {
- 		ath11k_warn(ab, "failed to setup rx defrag context\n");
--		return ret;
-+		tid--;
-+		goto peer_clean;
- 	}
- 
- 	/* TODO: Setup other peer specific resource used in data path */
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -3130,6 +3130,7 @@ int ath11k_peer_rx_frag_setup(struct ath
- 	}
- 
- 	peer->tfm_mmic = tfm;
-+	peer->dp_setup_done = true;
- 	spin_unlock_bh(&ab->base_lock);
- 
- 	return 0;
-@@ -3575,6 +3576,13 @@ static int ath11k_dp_rx_frag_h_mpdu(stru
- 		ret = -ENOENT;
- 		goto out_unlock;
- 	}
-+	if (!peer->dp_setup_done) {
-+		ath11k_warn(ab, "The peer %pM [%d] has uninitialized datapath\n",
-+			    peer->addr, peer_id);
-+		ret = -ENOENT;
-+		goto out_unlock;
-+	}
-+
- 	rx_tid = &peer->rx_tid[tid];
- 
- 	if ((!skb_queue_empty(&rx_tid->rx_frags) && seqno != rx_tid->cur_sn) ||
---- a/drivers/net/wireless/ath/ath11k/peer.h
-+++ b/drivers/net/wireless/ath/ath11k/peer.h
-@@ -35,6 +35,7 @@ struct ath11k_peer {
- 	u16 sec_type;
- 	u16 sec_type_grp;
- 	bool is_authorized;
-+	bool dp_setup_done;
- };
- 
- void ath11k_peer_unmap_event(struct ath11k_base *ab, u16 peer_id);
diff --git a/package/kernel/mac80211/patches/ath11k/0061-wifi-ath11k-fix-undefined-behavior-with-__fls-in-dp.patch b/package/kernel/mac80211/patches/ath11k/0061-wifi-ath11k-fix-undefined-behavior-with-__fls-in-dp.patch
deleted file mode 100644
index d68c19f1..00000000
--- a/package/kernel/mac80211/patches/ath11k/0061-wifi-ath11k-fix-undefined-behavior-with-__fls-in-dp.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From 41e02bf4ae32cf2ac47b08b4caaa9c1a032e4ce7 Mon Sep 17 00:00:00 2001
-From: Harshitha Prem <quic_hprem@quicinc.com>
-Date: Tue, 4 Apr 2023 00:11:55 +0530
-Subject: [PATCH] wifi: ath11k: fix undefined behavior with __fls in dp
-
-"__fls" would have an undefined behavior if the argument is passed
-as "0". Hence, added changes to handle the same.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Harshitha Prem <quic_hprem@quicinc.com>
-Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403184155.8670-3-quic_nmaran@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp_rx.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -3598,7 +3598,7 @@ static int ath11k_dp_rx_frag_h_mpdu(stru
- 		goto out_unlock;
- 	}
- 
--	if (frag_no > __fls(rx_tid->rx_frag_bitmap))
-+	if (!rx_tid->rx_frag_bitmap || (frag_no > __fls(rx_tid->rx_frag_bitmap)))
- 		__skb_queue_tail(&rx_tid->rx_frags, msdu);
- 	else
- 		ath11k_dp_rx_h_sort_frags(ar, &rx_tid->rx_frags, msdu);
diff --git a/package/kernel/mac80211/patches/ath11k/0062-wifi-ath11k-fix-double-free-of-peer-rx_tid-during-re.patch b/package/kernel/mac80211/patches/ath11k/0062-wifi-ath11k-fix-double-free-of-peer-rx_tid-during-re.patch
deleted file mode 100644
index dd37b1e4..00000000
--- a/package/kernel/mac80211/patches/ath11k/0062-wifi-ath11k-fix-double-free-of-peer-rx_tid-during-re.patch
+++ /dev/null
@@ -1,144 +0,0 @@
-From 93a91f40c25c3d0e61f8540a7accf105090f9995 Mon Sep 17 00:00:00 2001
-From: Harshitha Prem <quic_hprem@quicinc.com>
-Date: Mon, 17 Apr 2023 13:35:00 +0300
-Subject: [PATCH] wifi: ath11k: fix double free of peer rx_tid during reo cmd
- failure
-
-Peer rx_tid is locally copied thrice during peer_rx_tid_cleanup to
-send REO_CMD_UPDATE_RX_QUEUE followed by REO_CMD_FLUSH_CACHE to flush
-all aged REO descriptors from HW cache.
-
-When sending REO_CMD_FLUSH_CACHE fails, we do dma unmap of already
-mapped rx_tid->vaddr and free it. This is not checked during
-reo_cmd_list_cleanup() and dp_reo_cmd_free() before trying to free and
-unmap again.
-
-Fix this by setting rx_tid->vaddr NULL in rx tid delete and also
-wherever freeing it to check in reo_cmd_list_cleanup() and
-reo_cmd_free() before trying to free again.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sathishkumar Muruganandam <quic_murugana@quicinc.com>
-Signed-off-by: Harshitha Prem <quic_hprem@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403182420.23375-2-quic_hprem@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp_rx.c | 43 ++++++++++++++++++-------
- 1 file changed, 31 insertions(+), 12 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -668,13 +668,18 @@ void ath11k_dp_reo_cmd_list_cleanup(stru
- 	struct ath11k_dp *dp = &ab->dp;
- 	struct dp_reo_cmd *cmd, *tmp;
- 	struct dp_reo_cache_flush_elem *cmd_cache, *tmp_cache;
-+	struct dp_rx_tid *rx_tid;
- 
- 	spin_lock_bh(&dp->reo_cmd_lock);
- 	list_for_each_entry_safe(cmd, tmp, &dp->reo_cmd_list, list) {
- 		list_del(&cmd->list);
--		dma_unmap_single(ab->dev, cmd->data.paddr,
--				 cmd->data.size, DMA_BIDIRECTIONAL);
--		kfree(cmd->data.vaddr);
-+		rx_tid = &cmd->data;
-+		if (rx_tid->vaddr) {
-+			dma_unmap_single(ab->dev, rx_tid->paddr,
-+					 rx_tid->size, DMA_BIDIRECTIONAL);
-+			kfree(rx_tid->vaddr);
-+			rx_tid->vaddr = NULL;
-+		}
- 		kfree(cmd);
- 	}
- 
-@@ -682,9 +687,13 @@ void ath11k_dp_reo_cmd_list_cleanup(stru
- 				 &dp->reo_cmd_cache_flush_list, list) {
- 		list_del(&cmd_cache->list);
- 		dp->reo_cmd_cache_flush_count--;
--		dma_unmap_single(ab->dev, cmd_cache->data.paddr,
--				 cmd_cache->data.size, DMA_BIDIRECTIONAL);
--		kfree(cmd_cache->data.vaddr);
-+		rx_tid = &cmd_cache->data;
-+		if (rx_tid->vaddr) {
-+			dma_unmap_single(ab->dev, rx_tid->paddr,
-+					 rx_tid->size, DMA_BIDIRECTIONAL);
-+			kfree(rx_tid->vaddr);
-+			rx_tid->vaddr = NULL;
-+		}
- 		kfree(cmd_cache);
- 	}
- 	spin_unlock_bh(&dp->reo_cmd_lock);
-@@ -698,10 +707,12 @@ static void ath11k_dp_reo_cmd_free(struc
- 	if (status != HAL_REO_CMD_SUCCESS)
- 		ath11k_warn(dp->ab, "failed to flush rx tid hw desc, tid %d status %d\n",
- 			    rx_tid->tid, status);
--
--	dma_unmap_single(dp->ab->dev, rx_tid->paddr, rx_tid->size,
--			 DMA_BIDIRECTIONAL);
--	kfree(rx_tid->vaddr);
-+	if (rx_tid->vaddr) {
-+		dma_unmap_single(dp->ab->dev, rx_tid->paddr, rx_tid->size,
-+				 DMA_BIDIRECTIONAL);
-+		kfree(rx_tid->vaddr);
-+		rx_tid->vaddr = NULL;
-+	}
- }
- 
- static void ath11k_dp_reo_cache_flush(struct ath11k_base *ab,
-@@ -740,6 +751,7 @@ static void ath11k_dp_reo_cache_flush(st
- 		dma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,
- 				 DMA_BIDIRECTIONAL);
- 		kfree(rx_tid->vaddr);
-+		rx_tid->vaddr = NULL;
- 	}
- }
- 
-@@ -792,6 +804,7 @@ free_desc:
- 	dma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,
- 			 DMA_BIDIRECTIONAL);
- 	kfree(rx_tid->vaddr);
-+	rx_tid->vaddr = NULL;
- }
- 
- void ath11k_peer_rx_tid_delete(struct ath11k *ar,
-@@ -804,6 +817,8 @@ void ath11k_peer_rx_tid_delete(struct at
- 	if (!rx_tid->active)
- 		return;
- 
-+	rx_tid->active = false;
-+
- 	cmd.flag = HAL_REO_CMD_FLG_NEED_STATUS;
- 	cmd.addr_lo = lower_32_bits(rx_tid->paddr);
- 	cmd.addr_hi = upper_32_bits(rx_tid->paddr);
-@@ -818,9 +833,11 @@ void ath11k_peer_rx_tid_delete(struct at
- 		dma_unmap_single(ar->ab->dev, rx_tid->paddr, rx_tid->size,
- 				 DMA_BIDIRECTIONAL);
- 		kfree(rx_tid->vaddr);
-+		rx_tid->vaddr = NULL;
- 	}
- 
--	rx_tid->active = false;
-+	rx_tid->paddr = 0;
-+	rx_tid->size = 0;
- }
- 
- static int ath11k_dp_rx_link_desc_return(struct ath11k_base *ab,
-@@ -967,6 +984,7 @@ static void ath11k_dp_rx_tid_mem_free(st
- 	dma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,
- 			 DMA_BIDIRECTIONAL);
- 	kfree(rx_tid->vaddr);
-+	rx_tid->vaddr = NULL;
- 
- 	rx_tid->active = false;
- 
-@@ -1067,7 +1085,8 @@ int ath11k_peer_rx_tid_setup(struct ath1
- 	return ret;
- 
- err_mem_free:
--	kfree(vaddr);
-+	kfree(rx_tid->vaddr);
-+	rx_tid->vaddr = NULL;
- 
- 	return ret;
- }
diff --git a/package/kernel/mac80211/patches/ath11k/0063-wifi-ath11k-Prevent-REO-cmd-failures.patch b/package/kernel/mac80211/patches/ath11k/0063-wifi-ath11k-Prevent-REO-cmd-failures.patch
deleted file mode 100644
index 4b9af180..00000000
--- a/package/kernel/mac80211/patches/ath11k/0063-wifi-ath11k-Prevent-REO-cmd-failures.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From a8ae833657a45746debde85c38bb7f070d344026 Mon Sep 17 00:00:00 2001
-From: Harshitha Prem <quic_hprem@quicinc.com>
-Date: Mon, 17 Apr 2023 13:35:01 +0300
-Subject: [PATCH] wifi: ath11k: Prevent REO cmd failures
-
-Prevent REO cmd failures causing double free by increasing REO cmd
-ring size and moving REO status ring mask to IRQ group 3 from group
-0 to separate from tx completion ring on IRQ group 0 which may delay
-reo status processing.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sathishkumar Muruganandam <quic_murugana@quicinc.com>
-Signed-off-by: Harshitha Prem <quic_hprem@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403182420.23375-3-quic_hprem@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp.h | 2 +-
- drivers/net/wireless/ath/ath11k/hw.c | 1 +
- 2 files changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp.h
-+++ b/drivers/net/wireless/ath/ath11k/dp.h
-@@ -214,7 +214,7 @@ struct ath11k_pdev_dp {
- #define DP_REO_REINJECT_RING_SIZE	32
- #define DP_RX_RELEASE_RING_SIZE		1024
- #define DP_REO_EXCEPTION_RING_SIZE	128
--#define DP_REO_CMD_RING_SIZE		128
-+#define DP_REO_CMD_RING_SIZE		256
- #define DP_REO_STATUS_RING_SIZE		2048
- #define DP_RXDMA_BUF_RING_SIZE		4096
- #define DP_RXDMA_REFILL_RING_SIZE	2048
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -1233,6 +1233,7 @@ const struct ath11k_hw_ring_mask ath11k_
- 		ATH11K_RX_WBM_REL_RING_MASK_0,
- 	},
- 	.reo_status = {
-+		0, 0, 0,
- 		ATH11K_REO_STATUS_RING_MASK_0,
- 	},
- 	.rxdma2host = {
diff --git a/package/kernel/mac80211/patches/ath11k/0064-wifi-ath11k-add-peer-mac-information-in-failure-case.patch b/package/kernel/mac80211/patches/ath11k/0064-wifi-ath11k-add-peer-mac-information-in-failure-case.patch
deleted file mode 100644
index fbcbdfff..00000000
--- a/package/kernel/mac80211/patches/ath11k/0064-wifi-ath11k-add-peer-mac-information-in-failure-case.patch
+++ /dev/null
@@ -1,74 +0,0 @@
-From 20487cc3ff36bbfa9505f0a078ba98f09abfc717 Mon Sep 17 00:00:00 2001
-From: Harshitha Prem <quic_hprem@quicinc.com>
-Date: Mon, 17 Apr 2023 13:35:01 +0300
-Subject: [PATCH] wifi: ath11k: add peer mac information in failure cases
-
-During reo command failure, the peer mac detail for which the reo
-command was not successful is unknown. Hence, to improve the
-debuggability, add the peer mac information in the failure cases
-which would be useful during multi client cases.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sathishkumar Muruganandam <quic_murugana@quicinc.com>
-Signed-off-by: Harshitha Prem <quic_hprem@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403182420.23375-4-quic_hprem@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp_rx.c | 16 ++++++++++------
- 1 file changed, 10 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -1009,7 +1009,8 @@ int ath11k_peer_rx_tid_setup(struct ath1
- 
- 	peer = ath11k_peer_find(ab, vdev_id, peer_mac);
- 	if (!peer) {
--		ath11k_warn(ab, "failed to find the peer to set up rx tid\n");
-+		ath11k_warn(ab, "failed to find the peer %pM to set up rx tid\n",
-+			    peer_mac);
- 		spin_unlock_bh(&ab->base_lock);
- 		return -ENOENT;
- 	}
-@@ -1022,7 +1023,8 @@ int ath11k_peer_rx_tid_setup(struct ath1
- 						    ba_win_sz, ssn, true);
- 		spin_unlock_bh(&ab->base_lock);
- 		if (ret) {
--			ath11k_warn(ab, "failed to update reo for rx tid %d\n", tid);
-+			ath11k_warn(ab, "failed to update reo for peer %pM rx tid %d\n: %d",
-+				    peer_mac, tid, ret);
- 			return ret;
- 		}
- 
-@@ -1030,8 +1032,8 @@ int ath11k_peer_rx_tid_setup(struct ath1
- 							     peer_mac, paddr,
- 							     tid, 1, ba_win_sz);
- 		if (ret)
--			ath11k_warn(ab, "failed to send wmi command to update rx reorder queue, tid :%d (%d)\n",
--				    tid, ret);
-+			ath11k_warn(ab, "failed to send wmi rx reorder queue for peer %pM tid %d: %d\n",
-+				    peer_mac, tid, ret);
- 		return ret;
- 	}
- 
-@@ -1064,6 +1066,8 @@ int ath11k_peer_rx_tid_setup(struct ath1
- 	ret = dma_mapping_error(ab->dev, paddr);
- 	if (ret) {
- 		spin_unlock_bh(&ab->base_lock);
-+		ath11k_warn(ab, "failed to setup dma map for peer %pM rx tid %d: %d\n",
-+			    peer_mac, tid, ret);
- 		goto err_mem_free;
- 	}
- 
-@@ -1077,8 +1081,8 @@ int ath11k_peer_rx_tid_setup(struct ath1
- 	ret = ath11k_wmi_peer_rx_reorder_queue_setup(ar, vdev_id, peer_mac,
- 						     paddr, tid, 1, ba_win_sz);
- 	if (ret) {
--		ath11k_warn(ar->ab, "failed to setup rx reorder queue, tid :%d (%d)\n",
--			    tid, ret);
-+		ath11k_warn(ar->ab, "failed to setup rx reorder queue for peer %pM tid %d: %d\n",
-+			    peer_mac, tid, ret);
- 		ath11k_dp_rx_tid_mem_free(ab, peer_mac, vdev_id, tid);
- 	}
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0065-wifi-ath11k-fix-tx-status-reporting-in-encap-offload.patch b/package/kernel/mac80211/patches/ath11k/0065-wifi-ath11k-fix-tx-status-reporting-in-encap-offload.patch
deleted file mode 100644
index e2fe4191..00000000
--- a/package/kernel/mac80211/patches/ath11k/0065-wifi-ath11k-fix-tx-status-reporting-in-encap-offload.patch
+++ /dev/null
@@ -1,119 +0,0 @@
-From 6257c702264c44d74c6b71f0c62a7665da2dc356 Mon Sep 17 00:00:00 2001
-From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
-Date: Mon, 17 Apr 2023 13:35:02 +0300
-Subject: [PATCH] wifi: ath11k: fix tx status reporting in encap offload mode
-
-ieee80211_tx_status() treats packets in 802.11 frame format and
-tries to extract sta address from packet header. When tx encap
-offload is enabled, this becomes invalid operation. Hence, switch
-to using ieee80211_tx_status_ext() after filling in station
-address for handling both 802.11 and 802.3 frames.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403195738.25367-2-quic_pradeepc@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp.h    |  4 +++
- drivers/net/wireless/ath/ath11k/dp_tx.c | 33 ++++++++++++++++++++++++-
- drivers/net/wireless/ath/ath11k/dp_tx.h |  1 +
- 3 files changed, 37 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp.h
-+++ b/drivers/net/wireless/ath/ath11k/dp.h
-@@ -303,12 +303,16 @@ struct ath11k_dp {
- 
- #define HTT_TX_WBM_COMP_STATUS_OFFSET 8
- 
-+#define HTT_INVALID_PEER_ID	0xffff
-+
- /* HTT tx completion is overlaid in wbm_release_ring */
- #define HTT_TX_WBM_COMP_INFO0_STATUS		GENMASK(12, 9)
- #define HTT_TX_WBM_COMP_INFO0_REINJECT_REASON	GENMASK(16, 13)
- #define HTT_TX_WBM_COMP_INFO0_REINJECT_REASON	GENMASK(16, 13)
- 
- #define HTT_TX_WBM_COMP_INFO1_ACK_RSSI		GENMASK(31, 24)
-+#define HTT_TX_WBM_COMP_INFO2_SW_PEER_ID	GENMASK(15, 0)
-+#define HTT_TX_WBM_COMP_INFO2_VALID		BIT(21)
- 
- struct htt_tx_wbm_completion {
- 	u32 info0;
---- a/drivers/net/wireless/ath/ath11k/dp_tx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
-@@ -316,10 +316,12 @@ ath11k_dp_tx_htt_tx_complete_buf(struct
- 				 struct dp_tx_ring *tx_ring,
- 				 struct ath11k_dp_htt_wbm_tx_status *ts)
- {
-+	struct ieee80211_tx_status status = { 0 };
- 	struct sk_buff *msdu;
- 	struct ieee80211_tx_info *info;
- 	struct ath11k_skb_cb *skb_cb;
- 	struct ath11k *ar;
-+	struct ath11k_peer *peer;
- 
- 	spin_lock(&tx_ring->tx_idr_lock);
- 	msdu = idr_remove(&tx_ring->txbuf_idr, ts->msdu_id);
-@@ -341,6 +343,11 @@ ath11k_dp_tx_htt_tx_complete_buf(struct
- 
- 	dma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);
- 
-+	if (!skb_cb->vif) {
-+		dev_kfree_skb_any(msdu);
-+		return;
-+	}
-+
- 	memset(&info->status, 0, sizeof(info->status));
- 
- 	if (ts->acked) {
-@@ -355,7 +362,23 @@ ath11k_dp_tx_htt_tx_complete_buf(struct
- 		}
- 	}
- 
--	ieee80211_tx_status(ar->hw, msdu);
-+	spin_lock_bh(&ab->base_lock);
-+	peer = ath11k_peer_find_by_id(ab, ts->peer_id);
-+	if (!peer || !peer->sta) {
-+		ath11k_dbg(ab, ATH11K_DBG_DATA,
-+			   "dp_tx: failed to find the peer with peer_id %d\n",
-+			    ts->peer_id);
-+		spin_unlock_bh(&ab->base_lock);
-+		dev_kfree_skb_any(msdu);
-+		return;
-+	}
-+	spin_unlock_bh(&ab->base_lock);
-+
-+	status.sta = peer->sta;
-+	status.info = info;
-+	status.skb = msdu;
-+
-+	ieee80211_tx_status_ext(ar->hw, &status);
- }
- 
- static void
-@@ -379,7 +402,15 @@ ath11k_dp_tx_process_htt_tx_complete(str
- 		ts.msdu_id = msdu_id;
- 		ts.ack_rssi = FIELD_GET(HTT_TX_WBM_COMP_INFO1_ACK_RSSI,
- 					status_desc->info1);
-+
-+		if (FIELD_GET(HTT_TX_WBM_COMP_INFO2_VALID, status_desc->info2))
-+			ts.peer_id = FIELD_GET(HTT_TX_WBM_COMP_INFO2_SW_PEER_ID,
-+					       status_desc->info2);
-+		else
-+			ts.peer_id = HTT_INVALID_PEER_ID;
-+
- 		ath11k_dp_tx_htt_tx_complete_buf(ab, tx_ring, &ts);
-+
- 		break;
- 	case HAL_WBM_REL_HTT_TX_COMP_STATUS_REINJ:
- 	case HAL_WBM_REL_HTT_TX_COMP_STATUS_INSPECT:
---- a/drivers/net/wireless/ath/ath11k/dp_tx.h
-+++ b/drivers/net/wireless/ath/ath11k/dp_tx.h
-@@ -13,6 +13,7 @@ struct ath11k_dp_htt_wbm_tx_status {
- 	u32 msdu_id;
- 	bool acked;
- 	int ack_rssi;
-+	u16 peer_id;
- };
- 
- void ath11k_dp_tx_update_txcompl(struct ath11k *ar, struct hal_tx_status *ts);
diff --git a/package/kernel/mac80211/patches/ath11k/0066-wifi-ath11k-Fix-incorrect-update-of-radiotap-fields.patch b/package/kernel/mac80211/patches/ath11k/0066-wifi-ath11k-Fix-incorrect-update-of-radiotap-fields.patch
deleted file mode 100644
index 4f945801..00000000
--- a/package/kernel/mac80211/patches/ath11k/0066-wifi-ath11k-Fix-incorrect-update-of-radiotap-fields.patch
+++ /dev/null
@@ -1,49 +0,0 @@
-From 2f0c9ac8362da09c80f1cd422ef7fd6fa9b252b9 Mon Sep 17 00:00:00 2001
-From: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
-Date: Mon, 17 Apr 2023 13:35:02 +0300
-Subject: [PATCH] wifi: ath11k: Fix incorrect update of radiotap fields
-
-Fix incorrect update of ppdu stats causing incorrect radiotap
-fields.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Pradeep Kumar Chitrapu <quic_pradeepc@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403195738.25367-3-quic_pradeepc@quicinc.com
----
- drivers/net/wireless/ath/ath11k/hal_rx.c | 4 ++--
- drivers/net/wireless/ath/ath11k/hal_rx.h | 2 +-
- 2 files changed, 3 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/hal_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/hal_rx.c
-@@ -1029,7 +1029,7 @@ ath11k_hal_rx_parse_mon_status_tlv(struc
- 		info1 = __le32_to_cpu(vht_sig->info1);
- 
- 		ppdu_info->ldpc = FIELD_GET(HAL_RX_VHT_SIG_A_INFO_INFO1_SU_MU_CODING,
--					    info0);
-+					    info1);
- 		ppdu_info->mcs = FIELD_GET(HAL_RX_VHT_SIG_A_INFO_INFO1_MCS,
- 					   info1);
- 		gi_setting = FIELD_GET(HAL_RX_VHT_SIG_A_INFO_INFO1_GI_SETTING,
-@@ -1452,7 +1452,7 @@ ath11k_hal_rx_parse_mon_status_tlv(struc
- 		 * PHYRX_OTHER_RECEIVE_INFO TLV.
- 		 */
- 		ppdu_info->rssi_comb =
--			FIELD_GET(HAL_RX_PHYRX_RSSI_LEGACY_INFO_INFO1_RSSI_COMB,
-+			FIELD_GET(HAL_RX_PHYRX_RSSI_LEGACY_INFO_INFO0_RSSI_COMB,
- 				  __le32_to_cpu(rssi->info0));
- 
- 		if (db2dbm) {
---- a/drivers/net/wireless/ath/ath11k/hal_rx.h
-+++ b/drivers/net/wireless/ath/ath11k/hal_rx.h
-@@ -385,7 +385,7 @@ struct hal_rx_he_sig_b2_ofdma_info {
- 	__le32 info0;
- } __packed;
- 
--#define HAL_RX_PHYRX_RSSI_LEGACY_INFO_INFO1_RSSI_COMB	GENMASK(15, 8)
-+#define HAL_RX_PHYRX_RSSI_LEGACY_INFO_INFO0_RSSI_COMB	GENMASK(15, 8)
- 
- #define HAL_RX_PHYRX_RSSI_PREAMBLE_PRI20	GENMASK(7, 0)
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0067-wifi-ath11k-Fix-SKB-corruption-in-REO-destination-ri.patch b/package/kernel/mac80211/patches/ath11k/0067-wifi-ath11k-Fix-SKB-corruption-in-REO-destination-ri.patch
deleted file mode 100644
index 8b300f3a..00000000
--- a/package/kernel/mac80211/patches/ath11k/0067-wifi-ath11k-Fix-SKB-corruption-in-REO-destination-ri.patch
+++ /dev/null
@@ -1,70 +0,0 @@
-From f9fff67d2d7ca6fa8066132003a3deef654c55b1 Mon Sep 17 00:00:00 2001
-From: Nagarajan Maran <quic_nmaran@quicinc.com>
-Date: Mon, 17 Apr 2023 13:35:02 +0300
-Subject: [PATCH] wifi: ath11k: Fix SKB corruption in REO destination ring
-
-While running traffics for a long time, randomly an RX descriptor
-filled with value "0" from REO destination ring is received.
-This descriptor which is invalid causes the wrong SKB (SKB stored in
-the IDR lookup with buffer id "0") to be fetched which in turn
-causes SKB memory corruption issue and the same leads to crash
-after some time.
-
-Changed the start id for idr allocation to "1" and the buffer id "0"
-is reserved for error validation. Introduced Sanity check to validate
-the descriptor, before processing the SKB.
-
-Crash Signature :
-
-Unable to handle kernel paging request at virtual address 3f004900
-PC points to "b15_dma_inv_range+0x30/0x50"
-LR points to "dma_cache_maint_page+0x8c/0x128".
-The Backtrace obtained is as follows:
-[<8031716c>] (b15_dma_inv_range) from [<80313a4c>] (dma_cache_maint_page+0x8c/0x128)
-[<80313a4c>] (dma_cache_maint_page) from [<80313b90>] (__dma_page_dev_to_cpu+0x28/0xcc)
-[<80313b90>] (__dma_page_dev_to_cpu) from [<7fb5dd68>] (ath11k_dp_process_rx+0x1e8/0x4a4 [ath11k])
-[<7fb5dd68>] (ath11k_dp_process_rx [ath11k]) from [<7fb53c20>] (ath11k_dp_service_srng+0xb0/0x2ac [ath11k])
-[<7fb53c20>] (ath11k_dp_service_srng [ath11k]) from [<7f67bba4>] (ath11k_pci_ext_grp_napi_poll+0x1c/0x78 [ath11k_pci])
-[<7f67bba4>] (ath11k_pci_ext_grp_napi_poll [ath11k_pci]) from [<807d5cf4>] (__napi_poll+0x28/0xb8)
-[<807d5cf4>] (__napi_poll) from [<807d5f28>] (net_rx_action+0xf0/0x280)
-[<807d5f28>] (net_rx_action) from [<80302148>] (__do_softirq+0xd0/0x280)
-[<80302148>] (__do_softirq) from [<80320408>] (irq_exit+0x74/0xd4)
-[<80320408>] (irq_exit) from [<803638a4>] (__handle_domain_irq+0x90/0xb4)
-[<803638a4>] (__handle_domain_irq) from [<805bedec>] (gic_handle_irq+0x58/0x90)
-[<805bedec>] (gic_handle_irq) from [<80301a78>] (__irq_svc+0x58/0x8c)
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Nagarajan Maran <quic_nmaran@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230403191533.28114-1-quic_nmaran@quicinc.com
----
- drivers/net/wireless/ath/ath11k/dp_rx.c | 9 ++++++---
- 1 file changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_rx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
-@@ -389,10 +389,10 @@ int ath11k_dp_rxbufs_replenish(struct at
- 			goto fail_free_skb;
- 
- 		spin_lock_bh(&rx_ring->idr_lock);
--		buf_id = idr_alloc(&rx_ring->bufs_idr, skb, 0,
--				   rx_ring->bufs_max * 3, GFP_ATOMIC);
-+		buf_id = idr_alloc(&rx_ring->bufs_idr, skb, 1,
-+				   (rx_ring->bufs_max * 3) + 1, GFP_ATOMIC);
- 		spin_unlock_bh(&rx_ring->idr_lock);
--		if (buf_id < 0)
-+		if (buf_id <= 0)
- 			goto fail_dma_unmap;
- 
- 		desc = ath11k_hal_srng_src_get_next_entry(ab, srng);
-@@ -2665,6 +2665,9 @@ try_again:
- 				   cookie);
- 		mac_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_PDEV_ID, cookie);
- 
-+		if (unlikely(buf_id == 0))
-+			continue;
-+
- 		ar = ab->pdevs[mac_id].ar;
- 		rx_ring = &ar->dp.rx_refill_buf_ring;
- 		spin_lock_bh(&rx_ring->idr_lock);
diff --git a/package/kernel/mac80211/patches/ath11k/0068-wifi-ath11k-Remove-disabling-of-80-80-and-160-MHz.patch b/package/kernel/mac80211/patches/ath11k/0068-wifi-ath11k-Remove-disabling-of-80-80-and-160-MHz.patch
deleted file mode 100644
index ce5ffd27..00000000
--- a/package/kernel/mac80211/patches/ath11k/0068-wifi-ath11k-Remove-disabling-of-80-80-and-160-MHz.patch
+++ /dev/null
@@ -1,49 +0,0 @@
-From b100722a777f6455d913666a376f81342b2cb995 Mon Sep 17 00:00:00 2001
-From: Muna Sinada <quic_msinada@quicinc.com>
-Date: Mon, 17 Apr 2023 13:22:27 -0700
-Subject: [PATCH] wifi: ath11k: Remove disabling of 80+80 and 160 MHz
-
-This is a regression fix for 80+80 and 160 MHz support bits being
-cleared, therefore not adverised. Remove disable of 80+80 and 160 MHz
-capability flags and assign valid center frequency 2 similar to
-VHT80_80.
-
-Fixes: 38dfe775d0ab ("wifi: ath11k: push MU-MIMO params from hostapd to hardware")
-Reported-by: Robert Marko <robert.marko@sartura.hr>
-Tested-by: Robert Marko <robert.marko@sartura.hr> # IPQ8074 WLAN.HK.2.9.0.1-01385-QCAHKSWPL_SILICONZ-1
-Link: https://bugzilla.kernel.org/show_bug.cgi?id=217299
-Co-developed-by: P Praneesh <quic_ppranees@quicinc.com>
-Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
-Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/1681762947-13882-1-git-send-email-quic_msinada@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 4 ----
- drivers/net/wireless/ath/ath11k/wmi.c | 3 ++-
- 2 files changed, 2 insertions(+), 5 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -5585,10 +5585,6 @@ static int ath11k_mac_copy_he_cap(struct
- 
- 		he_cap_elem->mac_cap_info[1] &=
- 			IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_MASK;
--		he_cap_elem->phy_cap_info[0] &=
--			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;
--		he_cap_elem->phy_cap_info[0] &=
--			~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;
- 
- 		he_cap_elem->phy_cap_info[5] &=
- 			~IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK;
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -871,7 +871,8 @@ static void ath11k_wmi_put_wmi_channel(s
- 
- 		chan->band_center_freq2 = arg->channel.band_center_freq1;
- 
--	} else if (arg->channel.mode == MODE_11AC_VHT80_80) {
-+	} else if ((arg->channel.mode == MODE_11AC_VHT80_80) ||
-+		   (arg->channel.mode == MODE_11AX_HE80_80)) {
- 		chan->band_center_freq2 = arg->channel.band_center_freq2;
- 	} else {
- 		chan->band_center_freq2 = 0;
diff --git a/package/kernel/mac80211/patches/ath11k/0069-wifi-ath11k-fix-registration-of-6Ghz-only-phy-withou.patch b/package/kernel/mac80211/patches/ath11k/0069-wifi-ath11k-fix-registration-of-6Ghz-only-phy-withou.patch
deleted file mode 100644
index 32468dbc..00000000
--- a/package/kernel/mac80211/patches/ath11k/0069-wifi-ath11k-fix-registration-of-6Ghz-only-phy-withou.patch
+++ /dev/null
@@ -1,61 +0,0 @@
-From e2ceb1de2f83aafd8003f0b72dfd4b7441e97d14 Mon Sep 17 00:00:00 2001
-From: Maxime Bizon <mbizon@freebox.fr>
-Date: Fri, 21 Apr 2023 16:54:45 +0200
-Subject: [PATCH] wifi: ath11k: fix registration of 6Ghz-only phy without the
- full channel range
-
-Because of what seems to be a typo, a 6Ghz-only phy for which the BDF
-does not allow the 7115Mhz channel will fail to register:
-
-  WARNING: CPU: 2 PID: 106 at net/wireless/core.c:907 wiphy_register+0x914/0x954
-  Modules linked in: ath11k_pci sbsa_gwdt
-  CPU: 2 PID: 106 Comm: kworker/u8:5 Not tainted 6.3.0-rc7-next-20230418-00549-g1e096a17625a-dirty #9
-  Hardware name: Freebox V7R Board (DT)
-  Workqueue: ath11k_qmi_driver_event ath11k_qmi_driver_event_work
-  pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
-  pc : wiphy_register+0x914/0x954
-  lr : ieee80211_register_hw+0x67c/0xc10
-  sp : ffffff800b123aa0
-  x29: ffffff800b123aa0 x28: 0000000000000000 x27: 0000000000000000
-  x26: 0000000000000000 x25: 0000000000000006 x24: ffffffc008d51418
-  x23: ffffffc008cb0838 x22: ffffff80176c2460 x21: 0000000000000168
-  x20: ffffff80176c0000 x19: ffffff80176c03e0 x18: 0000000000000014
-  x17: 00000000cbef338c x16: 00000000d2a26f21 x15: 00000000ad6bb85f
-  x14: 0000000000000020 x13: 0000000000000020 x12: 00000000ffffffbd
-  x11: 0000000000000208 x10: 00000000fffffdf7 x9 : ffffffc009394718
-  x8 : ffffff80176c0528 x7 : 000000007fffffff x6 : 0000000000000006
-  x5 : 0000000000000005 x4 : ffffff800b304284 x3 : ffffff800b304284
-  x2 : ffffff800b304d98 x1 : 0000000000000000 x0 : 0000000000000000
-  Call trace:
-   wiphy_register+0x914/0x954
-   ieee80211_register_hw+0x67c/0xc10
-   ath11k_mac_register+0x7c4/0xe10
-   ath11k_core_qmi_firmware_ready+0x1f4/0x570
-   ath11k_qmi_driver_event_work+0x198/0x590
-   process_one_work+0x1b8/0x328
-   worker_thread+0x6c/0x414
-   kthread+0x100/0x104
-   ret_from_fork+0x10/0x20
-  ---[ end trace 0000000000000000 ]---
-  ath11k_pci 0002:01:00.0: ieee80211 registration failed: -22
-  ath11k_pci 0002:01:00.0: failed register the radio with mac80211: -22
-  ath11k_pci 0002:01:00.0: failed to create pdev core: -22
-
-Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230421145445.2612280-1-mbizon@freebox.fr
----
- drivers/net/wireless/ath/ath11k/mac.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -8892,7 +8892,7 @@ static int ath11k_mac_setup_channels_rat
- 	}
- 
- 	if (supported_bands & WMI_HOST_WLAN_5G_CAP) {
--		if (reg_cap->high_5ghz_chan >= ATH11K_MAX_6G_FREQ) {
-+		if (reg_cap->high_5ghz_chan >= ATH11K_MIN_6G_FREQ) {
- 			channels = kmemdup(ath11k_6ghz_channels,
- 					   sizeof(ath11k_6ghz_channels), GFP_KERNEL);
- 			if (!channels) {
diff --git a/package/kernel/mac80211/patches/ath11k/0070-wifi-ath-work-around-false-positive-stringop-overrea.patch b/package/kernel/mac80211/patches/ath11k/0070-wifi-ath-work-around-false-positive-stringop-overrea.patch
deleted file mode 100644
index aa4df16a..00000000
--- a/package/kernel/mac80211/patches/ath11k/0070-wifi-ath-work-around-false-positive-stringop-overrea.patch
+++ /dev/null
@@ -1,84 +0,0 @@
-From 695df2f417d25202bdac9cde3c82d2acb6492b4d Mon Sep 17 00:00:00 2001
-From: Arnd Bergmann <arnd@arndb.de>
-Date: Fri, 5 May 2023 16:11:25 +0300
-Subject: [PATCH] wifi: ath: work around false-positive stringop-overread
- warning
-
-In a rare arm64 randconfig build, I got multiple warnings for ath11k
-and ath12k:
-
-In function 'ath11k_peer_assoc_h_ht',
-    inlined from 'ath11k_peer_assoc_prepare' at drivers/net/wireless/ath/ath11k/mac.c:2665:2:
-drivers/net/wireless/ath/ath11k/mac.c:1709:13: error: 'ath11k_peer_assoc_h_ht_masked' reading 10 bytes from a region of size 0 [-Werror=stringop-overread]
- 1709 |         if (ath11k_peer_assoc_h_ht_masked(ht_mcs_mask))
-      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-This happens whenever gcc-13 fails to inline one of the functions
-that take a fixed-length array argument but gets passed a pointer.
-
-Change these functions to all take a regular pointer argument
-instead.
-
-Signed-off-by: Arnd Bergmann <arnd@arndb.de>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230417205447.1800912-1-arnd@kernel.org
----
- drivers/net/wireless/ath/ath11k/mac.c | 12 ++++++------
- 1 file changed, 6 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -433,7 +433,7 @@ u8 ath11k_mac_bitrate_to_idx(const struc
- }
- 
- static u32
--ath11k_mac_max_ht_nss(const u8 ht_mcs_mask[IEEE80211_HT_MCS_MASK_LEN])
-+ath11k_mac_max_ht_nss(const u8 *ht_mcs_mask)
- {
- 	int nss;
- 
-@@ -445,7 +445,7 @@ ath11k_mac_max_ht_nss(const u8 ht_mcs_ma
- }
- 
- static u32
--ath11k_mac_max_vht_nss(const u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])
-+ath11k_mac_max_vht_nss(const u16 *vht_mcs_mask)
- {
- 	int nss;
- 
-@@ -457,7 +457,7 @@ ath11k_mac_max_vht_nss(const u16 vht_mcs
- }
- 
- static u32
--ath11k_mac_max_he_nss(const u16 he_mcs_mask[NL80211_HE_NSS_MAX])
-+ath11k_mac_max_he_nss(const u16 *he_mcs_mask)
- {
- 	int nss;
- 
-@@ -1658,7 +1658,7 @@ static void ath11k_peer_assoc_h_rates(st
- }
- 
- static bool
--ath11k_peer_assoc_h_ht_masked(const u8 ht_mcs_mask[IEEE80211_HT_MCS_MASK_LEN])
-+ath11k_peer_assoc_h_ht_masked(const u8 *ht_mcs_mask)
- {
- 	int nss;
- 
-@@ -1670,7 +1670,7 @@ ath11k_peer_assoc_h_ht_masked(const u8 h
- }
- 
- static bool
--ath11k_peer_assoc_h_vht_masked(const u16 vht_mcs_mask[])
-+ath11k_peer_assoc_h_vht_masked(const u16 *vht_mcs_mask)
- {
- 	int nss;
- 
-@@ -2065,7 +2065,7 @@ static u16 ath11k_peer_assoc_h_he_limit(
- }
- 
- static bool
--ath11k_peer_assoc_h_he_masked(const u16 he_mcs_mask[NL80211_HE_NSS_MAX])
-+ath11k_peer_assoc_h_he_masked(const u16 *he_mcs_mask)
- {
- 	int nss;
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0071-wifi-ath11k-driver-settings-for-MBSSID-and-EMA.patch b/package/kernel/mac80211/patches/ath11k/0071-wifi-ath11k-driver-settings-for-MBSSID-and-EMA.patch
deleted file mode 100644
index bede4819..00000000
--- a/package/kernel/mac80211/patches/ath11k/0071-wifi-ath11k-driver-settings-for-MBSSID-and-EMA.patch
+++ /dev/null
@@ -1,133 +0,0 @@
-From a08dbb04d7365a04d52882143cf196005bfc88c3 Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Fri, 5 May 2023 16:11:27 +0300
-Subject: [PATCH 71/77] wifi: ath11k: driver settings for MBSSID and EMA
-
-Advertise the driver support for multiple BSSID (MBSSID) and
-enhanced multi-BSSID advertisements (EMA) by setting extended
-capabilities.
-
-Configure mbssid_max_interfaces and ema_max_profile_periodicity
-fields in structure wiphy which are used to advertise maximum number
-of interfaces and profile periodicity supported by the driver.
-
-Add new WMI fields to configure maximum vdev count supported for
-MBSSID and profile periodicity in case of EMA.
-Setting WMI_RSRC_CFG_FLAG2_CALC_NEXT_DTIM_COUNT_SET flag
-indicates that the firmware should track and update the DTIM counts
-for each non-transmitted profile.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Co-developed-by: John Crispin <john@phrozen.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405221648.17950-2-quic_alokad@quicinc.com
----
- drivers/net/wireless/ath/ath11k/hw.c  | 3 +++
- drivers/net/wireless/ath/ath11k/hw.h  | 1 +
- drivers/net/wireless/ath/ath11k/mac.c | 7 +++++++
- drivers/net/wireless/ath/ath11k/wmi.c | 3 +++
- drivers/net/wireless/ath/ath11k/wmi.h | 6 ++++++
- 5 files changed, 20 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -202,6 +202,9 @@ static void ath11k_init_wmi_config_ipq80
- 	config->twt_ap_sta_count = 1000;
- 	config->flag1 |= WMI_RSRC_CFG_FLAG1_BSS_CHANNEL_INFO_64;
- 	config->flag1 |= WMI_RSRC_CFG_FLAG1_ACK_RSSI;
-+	config->ema_max_vap_cnt = ab->num_radios;
-+	config->ema_max_profile_period = TARGET_EMA_MAX_PROFILE_PERIOD;
-+	config->beacon_tx_offload_max_vdev += config->ema_max_vap_cnt;
- }
- 
- static int ath11k_hw_mac_id_to_pdev_id_ipq8074(struct ath11k_hw_params *hw,
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -64,6 +64,7 @@
- #define TARGET_NUM_WDS_ENTRIES		32
- #define TARGET_DMA_BURST_SIZE		1
- #define TARGET_RX_BATCHMODE		1
-+#define TARGET_EMA_MAX_PROFILE_PERIOD	8
- 
- #define ATH11K_HW_MAX_QUEUES		4
- #define ATH11K_QUEUE_LEN		4096
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -9001,19 +9001,23 @@ static int ath11k_mac_setup_iface_combin
- 
- static const u8 ath11k_if_types_ext_capa[] = {
- 	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
-+	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
- 	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
- };
- 
- static const u8 ath11k_if_types_ext_capa_sta[] = {
- 	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
-+	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
- 	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
- 	[9] = WLAN_EXT_CAPA10_TWT_REQUESTER_SUPPORT,
- };
- 
- static const u8 ath11k_if_types_ext_capa_ap[] = {
- 	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
-+	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
- 	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
- 	[9] = WLAN_EXT_CAPA10_TWT_RESPONDER_SUPPORT,
-+	[10] = WLAN_EXT_CAPA11_EMA_SUPPORT,
- };
- 
- static const struct wiphy_iftype_ext_capab ath11k_iftypes_ext_capa[] = {
-@@ -9251,6 +9255,9 @@ static int __ath11k_mac_register(struct
- 		wiphy_ext_feature_set(ar->hw->wiphy,
- 				      NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);
- 
-+	ar->hw->wiphy->mbssid_max_interfaces = TARGET_NUM_VDEVS(ab);
-+	ar->hw->wiphy->ema_max_profile_periodicity = TARGET_EMA_MAX_PROFILE_PERIOD;
-+
- 	ath11k_reg_init(ar);
- 
- 	if (!test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags)) {
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -3987,6 +3987,9 @@ ath11k_wmi_copy_resource_config(struct w
- 		~(1 << WMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT);
- 	wmi_cfg->host_service_flags |= (tg_cfg->is_reg_cc_ext_event_supported <<
- 					WMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT);
-+	wmi_cfg->flags2 = WMI_RSRC_CFG_FLAG2_CALC_NEXT_DTIM_COUNT_SET;
-+	wmi_cfg->ema_max_vap_cnt = tg_cfg->ema_max_vap_cnt;
-+	wmi_cfg->ema_max_profile_period = tg_cfg->ema_max_profile_period;
- }
- 
- static int ath11k_init_cmd_send(struct ath11k_pdev_wmi *wmi,
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2317,6 +2317,7 @@ struct wmi_init_cmd {
- } __packed;
- 
- #define WMI_RSRC_CFG_FLAG1_BSS_CHANNEL_INFO_64 BIT(5)
-+#define WMI_RSRC_CFG_FLAG2_CALC_NEXT_DTIM_COUNT_SET BIT(9)
- #define WMI_RSRC_CFG_FLAG1_ACK_RSSI BIT(18)
- 
- #define WMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT 4
-@@ -2389,6 +2390,9 @@ struct wmi_resource_config {
- 	u32 msdu_flow_override_config1;
- 	u32 flags2;
- 	u32 host_service_flags;
-+	u32 max_rnr_neighbours;
-+	u32 ema_max_vap_cnt;
-+	u32 ema_max_profile_period;
- } __packed;
- 
- struct wmi_service_ready_event {
-@@ -5646,6 +5650,8 @@ struct target_resource_config {
- 	u32 twt_ap_pdev_count;
- 	u32 twt_ap_sta_count;
- 	u8 is_reg_cc_ext_event_supported;
-+	u32 ema_max_vap_cnt;
-+	u32 ema_max_profile_period;
- };
- 
- enum wmi_debug_log_param {
diff --git a/package/kernel/mac80211/patches/ath11k/0072-wifi-ath11k-MBSSID-configuration-during-vdev-create-.patch b/package/kernel/mac80211/patches/ath11k/0072-wifi-ath11k-MBSSID-configuration-during-vdev-create-.patch
deleted file mode 100644
index 4ba07173..00000000
--- a/package/kernel/mac80211/patches/ath11k/0072-wifi-ath11k-MBSSID-configuration-during-vdev-create-.patch
+++ /dev/null
@@ -1,215 +0,0 @@
-From 5a81610acf66c4ad6e1a1fbd09f3f555fca863b1 Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Fri, 5 May 2023 16:11:27 +0300
-Subject: [PATCH 72/77] wifi: ath11k: MBSSID configuration during vdev
- create/start
-
-Configure multiple BSSID flags and index of the transmitting interface
-in vdev create/start commands depending on the service bit
-WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Co-developed-by: John Crispin <john@phrozen.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405221648.17950-3-quic_alokad@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 70 +++++++++++++++++++++++++--
- drivers/net/wireless/ath/ath11k/wmi.c |  5 ++
- drivers/net/wireless/ath/ath11k/wmi.h | 19 ++++++++
- 3 files changed, 90 insertions(+), 4 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -6181,17 +6181,62 @@ static void ath11k_mac_op_stop(struct ie
- 	atomic_set(&ar->num_pending_mgmt_tx, 0);
- }
- 
--static void
--ath11k_mac_setup_vdev_create_params(struct ath11k_vif *arvif,
--				    struct vdev_create_params *params)
-+static int ath11k_mac_setup_vdev_params_mbssid(struct ath11k_vif *arvif,
-+					       u32 *flags, u32 *tx_vdev_id)
-+{
-+	struct ath11k *ar = arvif->ar;
-+	struct ath11k_vif *tx_arvif;
-+	struct ieee80211_vif *tx_vif;
-+
-+	*tx_vdev_id = 0;
-+	tx_vif = arvif->vif->mbssid_tx_vif;
-+	if (!tx_vif) {
-+		*flags = WMI_HOST_VDEV_FLAGS_NON_MBSSID_AP;
-+		return 0;
-+	}
-+
-+	tx_arvif = (void *)tx_vif->drv_priv;
-+
-+	if (arvif->vif->bss_conf.nontransmitted) {
-+		if (ar->hw->wiphy != ieee80211_vif_to_wdev(tx_vif)->wiphy)
-+			return -EINVAL;
-+
-+		*flags = WMI_HOST_VDEV_FLAGS_NON_TRANSMIT_AP;
-+		*tx_vdev_id = ath11k_vif_to_arvif(tx_vif)->vdev_id;
-+	} else if (tx_arvif == arvif) {
-+		*flags = WMI_HOST_VDEV_FLAGS_TRANSMIT_AP;
-+	} else {
-+		return -EINVAL;
-+	}
-+
-+	if (arvif->vif->bss_conf.ema_ap)
-+		*flags |= WMI_HOST_VDEV_FLAGS_EMA_MODE;
-+
-+	return 0;
-+}
-+
-+static int ath11k_mac_setup_vdev_create_params(struct ath11k_vif *arvif,
-+					       struct vdev_create_params *params)
- {
- 	struct ath11k *ar = arvif->ar;
- 	struct ath11k_pdev *pdev = ar->pdev;
-+	int ret;
- 
- 	params->if_id = arvif->vdev_id;
- 	params->type = arvif->vdev_type;
- 	params->subtype = arvif->vdev_subtype;
- 	params->pdev_id = pdev->pdev_id;
-+	params->mbssid_flags = 0;
-+	params->mbssid_tx_vdev_id = 0;
-+
-+	if (!test_bit(WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT,
-+		      ar->ab->wmi_ab.svc_map)) {
-+		ret = ath11k_mac_setup_vdev_params_mbssid(arvif,
-+							  &params->mbssid_flags,
-+							  &params->mbssid_tx_vdev_id);
-+		if (ret)
-+			return ret;
-+	}
- 
- 	if (pdev->cap.supported_bands & WMI_HOST_WLAN_2G_CAP) {
- 		params->chains[NL80211_BAND_2GHZ].tx = ar->num_tx_chains;
-@@ -6206,6 +6251,7 @@ ath11k_mac_setup_vdev_create_params(stru
- 		params->chains[NL80211_BAND_6GHZ].tx = ar->num_tx_chains;
- 		params->chains[NL80211_BAND_6GHZ].rx = ar->num_rx_chains;
- 	}
-+	return 0;
- }
- 
- static void ath11k_mac_op_update_vif_offload(struct ieee80211_hw *hw,
-@@ -6500,7 +6546,12 @@ static int ath11k_mac_op_add_interface(s
- 	for (i = 0; i < ARRAY_SIZE(vif->hw_queue); i++)
- 		vif->hw_queue[i] = i % (ATH11K_HW_MAX_QUEUES - 1);
- 
--	ath11k_mac_setup_vdev_create_params(arvif, &vdev_param);
-+	ret = ath11k_mac_setup_vdev_create_params(arvif, &vdev_param);
-+	if (ret) {
-+		ath11k_warn(ab, "failed to create vdev parameters %d: %d\n",
-+			    arvif->vdev_id, ret);
-+		goto err;
-+	}
- 
- 	ret = ath11k_wmi_vdev_create(ar, vif->addr, &vdev_param);
- 	if (ret) {
-@@ -6905,6 +6956,17 @@ ath11k_mac_vdev_start_restart(struct ath
- 	arg.pref_tx_streams = ar->num_tx_chains;
- 	arg.pref_rx_streams = ar->num_rx_chains;
- 
-+	arg.mbssid_flags = 0;
-+	arg.mbssid_tx_vdev_id = 0;
-+	if (test_bit(WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT,
-+		     ar->ab->wmi_ab.svc_map)) {
-+		ret = ath11k_mac_setup_vdev_params_mbssid(arvif,
-+							  &arg.mbssid_flags,
-+							  &arg.mbssid_tx_vdev_id);
-+		if (ret)
-+			return ret;
-+	}
-+
- 	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
- 		arg.ssid = arvif->u.ap.ssid;
- 		arg.ssid_len = arvif->u.ap.ssid_len;
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -724,6 +724,9 @@ int ath11k_wmi_vdev_create(struct ath11k
- 	cmd->vdev_subtype = param->subtype;
- 	cmd->num_cfg_txrx_streams = WMI_NUM_SUPPORTED_BAND_MAX;
- 	cmd->pdev_id = param->pdev_id;
-+	cmd->mbssid_flags = param->mbssid_flags;
-+	cmd->mbssid_tx_vdev_id = param->mbssid_tx_vdev_id;
-+
- 	ether_addr_copy(cmd->vdev_macaddr.addr, macaddr);
- 
- 	ptr = skb->data + sizeof(*cmd);
-@@ -941,6 +944,8 @@ int ath11k_wmi_vdev_start(struct ath11k
- 	cmd->cac_duration_ms = arg->cac_duration_ms;
- 	cmd->regdomain = arg->regdomain;
- 	cmd->he_ops = arg->he_ops;
-+	cmd->mbssid_flags = arg->mbssid_flags;
-+	cmd->mbssid_tx_vdev_id = arg->mbssid_tx_vdev_id;
- 
- 	if (!restart) {
- 		if (arg->ssid) {
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -137,6 +137,14 @@ enum {
- 	WMI_AUTORATE_3200NS_GI = BIT(11),
- };
- 
-+enum {
-+	WMI_HOST_VDEV_FLAGS_NON_MBSSID_AP       = 0x00000001,
-+	WMI_HOST_VDEV_FLAGS_TRANSMIT_AP         = 0x00000002,
-+	WMI_HOST_VDEV_FLAGS_NON_TRANSMIT_AP     = 0x00000004,
-+	WMI_HOST_VDEV_FLAGS_EMA_MODE            = 0x00000008,
-+	WMI_HOST_VDEV_FLAGS_SCAN_MODE_VAP       = 0x00000010,
-+};
-+
- /*
-  * wmi command groups.
-  */
-@@ -2096,6 +2104,7 @@ enum wmi_tlv_service {
- 	WMI_TLV_SERVICE_EXT2_MSG = 220,
- 	WMI_TLV_SERVICE_PEER_POWER_SAVE_DURATION_SUPPORT = 246,
- 	WMI_TLV_SERVICE_SRG_SRP_SPATIAL_REUSE_SUPPORT = 249,
-+	WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT = 253,
- 	WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE = 263,
- 
- 	/* The second 128 bits */
-@@ -2583,6 +2592,8 @@ struct vdev_create_params {
- 		u8 rx;
- 	} chains[NUM_NL80211_BANDS];
- 	u32 pdev_id;
-+	u32 mbssid_flags;
-+	u32 mbssid_tx_vdev_id;
- };
- 
- struct wmi_vdev_create_cmd {
-@@ -2593,6 +2604,8 @@ struct wmi_vdev_create_cmd {
- 	struct wmi_mac_addr vdev_macaddr;
- 	u32 num_cfg_txrx_streams;
- 	u32 pdev_id;
-+	u32 mbssid_flags;
-+	u32 mbssid_tx_vdev_id;
- } __packed;
- 
- struct wmi_vdev_txrx_streams {
-@@ -2656,6 +2669,9 @@ struct wmi_vdev_start_request_cmd {
- 	u32 he_ops;
- 	u32 cac_duration_ms;
- 	u32 regdomain;
-+	u32 min_data_rate;
-+	u32 mbssid_flags;
-+	u32 mbssid_tx_vdev_id;
- } __packed;
- 
- #define MGMT_TX_DL_FRM_LEN		     64
-@@ -2825,6 +2841,9 @@ struct wmi_vdev_start_req_arg {
- 	u32 pref_rx_streams;
- 	u32 pref_tx_streams;
- 	u32 num_noa_descriptors;
-+	u32 min_data_rate;
-+	u32 mbssid_flags;
-+	u32 mbssid_tx_vdev_id;
- };
- 
- struct peer_create_params {
diff --git a/package/kernel/mac80211/patches/ath11k/0073-wifi-ath11k-rename-MBSSID-fields-in-wmi_vdev_up_cmd.patch b/package/kernel/mac80211/patches/ath11k/0073-wifi-ath11k-rename-MBSSID-fields-in-wmi_vdev_up_cmd.patch
deleted file mode 100644
index 023a1dbb..00000000
--- a/package/kernel/mac80211/patches/ath11k/0073-wifi-ath11k-rename-MBSSID-fields-in-wmi_vdev_up_cmd.patch
+++ /dev/null
@@ -1,52 +0,0 @@
-From cf604e72bc6e6db68c7fcaa8779b03ec14b8d2fa Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Fri, 5 May 2023 16:11:27 +0300
-Subject: [PATCH 73/77] wifi: ath11k: rename MBSSID fields in wmi_vdev_up_cmd
-
-Rename trans_bssid to tx_vdev_bssid to make it similar to vdev_bssid.
-
-Rename profile_num to nontx_profile_cnt, and profile_idx to
-nontx_profile_idx which makes it clear that these store configurations
-related to MBSSID non-transmitting profiles.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405221648.17950-4-quic_alokad@quicinc.com
----
- drivers/net/wireless/ath/ath11k/wmi.c | 6 +++---
- drivers/net/wireless/ath/ath11k/wmi.h | 6 +++---
- 2 files changed, 6 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -1029,10 +1029,10 @@ int ath11k_wmi_vdev_up(struct ath11k *ar
- 		bss_conf = &arvif->vif->bss_conf;
- 
- 		if (bss_conf->nontransmitted) {
--			ether_addr_copy(cmd->trans_bssid.addr,
-+			ether_addr_copy(cmd->tx_vdev_bssid.addr,
- 					bss_conf->transmitter_bssid);
--			cmd->profile_idx = bss_conf->bssid_index;
--			cmd->profile_num = bss_conf->bssid_indicator;
-+			cmd->nontx_profile_idx = bss_conf->bssid_index;
-+			cmd->nontx_profile_cnt = bss_conf->bssid_indicator;
- 		}
- 	}
- 
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -2625,9 +2625,9 @@ struct wmi_vdev_up_cmd {
- 	u32 vdev_id;
- 	u32 vdev_assoc_id;
- 	struct wmi_mac_addr vdev_bssid;
--	struct wmi_mac_addr trans_bssid;
--	u32 profile_idx;
--	u32 profile_num;
-+	struct wmi_mac_addr tx_vdev_bssid;
-+	u32 nontx_profile_idx;
-+	u32 nontx_profile_cnt;
- } __packed;
- 
- struct wmi_vdev_stop_cmd {
diff --git a/package/kernel/mac80211/patches/ath11k/0074-wifi-ath11k-MBSSID-parameter-configuration-in-AP-mod.patch b/package/kernel/mac80211/patches/ath11k/0074-wifi-ath11k-MBSSID-parameter-configuration-in-AP-mod.patch
deleted file mode 100644
index d93e27dd..00000000
--- a/package/kernel/mac80211/patches/ath11k/0074-wifi-ath11k-MBSSID-parameter-configuration-in-AP-mod.patch
+++ /dev/null
@@ -1,138 +0,0 @@
-From c82dc33f252fd8883be66f2d0230af0fd734c683 Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Fri, 5 May 2023 16:11:27 +0300
-Subject: [PATCH 74/77] wifi: ath11k: MBSSID parameter configuration in AP mode
-
-Include MBSSID parameters in WMI vdev up operation.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Co-developed-by: John Crispin <john@phrozen.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405221648.17950-5-quic_alokad@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 29 +++++++++++++++++++++------
- drivers/net/wireless/ath/ath11k/wmi.c |  8 +++++++-
- drivers/net/wireless/ath/ath11k/wmi.h |  3 ++-
- 3 files changed, 32 insertions(+), 8 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -964,7 +964,7 @@ static int ath11k_mac_monitor_vdev_start
- 		return ret;
- 	}
- 
--	ret = ath11k_wmi_vdev_up(ar, vdev_id, 0, ar->mac_addr);
-+	ret = ath11k_wmi_vdev_up(ar, vdev_id, 0, ar->mac_addr, NULL, 0, 0);
- 	if (ret) {
- 		ath11k_warn(ar->ab, "failed to put up monitor vdev %i: %d\n",
- 			    vdev_id, ret);
-@@ -1423,6 +1423,7 @@ static void ath11k_control_beaconing(str
- 				     struct ieee80211_bss_conf *info)
- {
- 	struct ath11k *ar = arvif->ar;
-+	struct ath11k_vif *tx_arvif = NULL;
- 	int ret = 0;
- 
- 	lockdep_assert_held(&arvif->ar->conf_mutex);
-@@ -1451,8 +1452,14 @@ static void ath11k_control_beaconing(str
- 
- 	ether_addr_copy(arvif->bssid, info->bssid);
- 
-+	if (arvif->vif->mbssid_tx_vif)
-+		tx_arvif = (struct ath11k_vif *)arvif->vif->mbssid_tx_vif->drv_priv;
-+
- 	ret = ath11k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,
--				 arvif->bssid);
-+				 arvif->bssid,
-+				 tx_arvif ? tx_arvif->bssid : NULL,
-+				 info->bssid_index,
-+				 1 << info->bssid_indicator);
- 	if (ret) {
- 		ath11k_warn(ar->ab, "failed to bring up vdev %d: %i\n",
- 			    arvif->vdev_id, ret);
-@@ -2879,7 +2886,8 @@ static void ath11k_bss_assoc(struct ieee
- 	arvif->aid = vif->cfg.aid;
- 	ether_addr_copy(arvif->bssid, bss_conf->bssid);
- 
--	ret = ath11k_wmi_vdev_up(ar, arvif->vdev_id, arvif->aid, arvif->bssid);
-+	ret = ath11k_wmi_vdev_up(ar, arvif->vdev_id, arvif->aid, arvif->bssid,
-+				 NULL, 0, 0);
- 	if (ret) {
- 		ath11k_warn(ar->ab, "failed to set vdev %d up: %d\n",
- 			    arvif->vdev_id, ret);
-@@ -7133,7 +7141,8 @@ ath11k_mac_update_vif_chan(struct ath11k
- 			   int n_vifs)
- {
- 	struct ath11k_base *ab = ar->ab;
--	struct ath11k_vif *arvif;
-+	struct ath11k_vif *arvif, *tx_arvif = NULL;
-+	struct ieee80211_vif *mbssid_tx_vif;
- 	int ret;
- 	int i;
- 	bool monitor_vif = false;
-@@ -7187,8 +7196,15 @@ ath11k_mac_update_vif_chan(struct ath11k
- 			ath11k_warn(ab, "failed to update bcn tmpl during csa: %d\n",
- 				    ret);
- 
-+		mbssid_tx_vif = arvif->vif->mbssid_tx_vif;
-+		if (mbssid_tx_vif)
-+			tx_arvif = (struct ath11k_vif *)mbssid_tx_vif->drv_priv;
-+
- 		ret = ath11k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,
--					 arvif->bssid);
-+					 arvif->bssid,
-+					 tx_arvif ? tx_arvif->bssid : NULL,
-+					 arvif->vif->bss_conf.bssid_index,
-+					 1 << arvif->vif->bss_conf.bssid_indicator);
- 		if (ret) {
- 			ath11k_warn(ab, "failed to bring vdev up %d: %d\n",
- 				    arvif->vdev_id, ret);
-@@ -7306,7 +7322,8 @@ static int ath11k_start_vdev_delay(struc
- 	}
- 
- 	if (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {
--		ret = ath11k_wmi_vdev_up(ar, arvif->vdev_id, 0, ar->mac_addr);
-+		ret = ath11k_wmi_vdev_up(ar, arvif->vdev_id, 0, ar->mac_addr,
-+					 NULL, 0, 0);
- 		if (ret) {
- 			ath11k_warn(ab, "failed put monitor up: %d\n", ret);
- 			return ret;
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -1001,7 +1001,8 @@ int ath11k_wmi_vdev_start(struct ath11k
- 	return ret;
- }
- 
--int ath11k_wmi_vdev_up(struct ath11k *ar, u32 vdev_id, u32 aid, const u8 *bssid)
-+int ath11k_wmi_vdev_up(struct ath11k *ar, u32 vdev_id, u32 aid, const u8 *bssid,
-+		       u8 *tx_bssid, u32 nontx_profile_idx, u32 nontx_profile_cnt)
- {
- 	struct ath11k_pdev_wmi *wmi = ar->wmi;
- 	struct wmi_vdev_up_cmd *cmd;
-@@ -1025,6 +1026,11 @@ int ath11k_wmi_vdev_up(struct ath11k *ar
- 
- 	ether_addr_copy(cmd->vdev_bssid.addr, bssid);
- 
-+	cmd->nontx_profile_idx = nontx_profile_idx;
-+	cmd->nontx_profile_cnt = nontx_profile_cnt;
-+	if (tx_bssid)
-+		ether_addr_copy(cmd->tx_vdev_bssid.addr, tx_bssid);
-+
- 	if (arvif && arvif->vif->type == NL80211_IFTYPE_STATION) {
- 		bss_conf = &arvif->vif->bss_conf;
- 
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -6301,7 +6301,8 @@ int ath11k_wmi_bcn_tmpl(struct ath11k *a
- 			struct sk_buff *bcn);
- int ath11k_wmi_vdev_down(struct ath11k *ar, u8 vdev_id);
- int ath11k_wmi_vdev_up(struct ath11k *ar, u32 vdev_id, u32 aid,
--		       const u8 *bssid);
-+		       const u8 *bssid, u8 *tx_bssid, u32 nontx_profile_idx,
-+		       u32 nontx_profile_cnt);
- int ath11k_wmi_vdev_stop(struct ath11k *ar, u8 vdev_id);
- int ath11k_wmi_vdev_start(struct ath11k *ar, struct wmi_vdev_start_req_arg *arg,
- 			  bool restart);
diff --git a/package/kernel/mac80211/patches/ath11k/0075-wifi-ath11k-refactor-vif-parameter-configurations.patch b/package/kernel/mac80211/patches/ath11k/0075-wifi-ath11k-refactor-vif-parameter-configurations.patch
deleted file mode 100644
index 8509e559..00000000
--- a/package/kernel/mac80211/patches/ath11k/0075-wifi-ath11k-refactor-vif-parameter-configurations.patch
+++ /dev/null
@@ -1,86 +0,0 @@
-From cb9bea773c85e372931cd7a177db4165adf29d95 Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Fri, 5 May 2023 16:11:28 +0300
-Subject: [PATCH 75/77] wifi: ath11k: refactor vif parameter configurations
-
-Security parameters for each non-transmitting profile can be
-different when MBSSID is enabled and this information is included
-in the MBSSID element in the Beacon frame. Current implementation
-to set rsnie_present and wpaie_present does not parse this element
-hence it applies only to the transmitting interface.
-
-Move the code to a separate function to make additions for
-non-transmitting interfaces cleaner.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405221648.17950-6-quic_alokad@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 41 ++++++++++++++++-----------
- 1 file changed, 24 insertions(+), 17 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -1351,28 +1351,14 @@ err_mon_del:
- 	return ret;
- }
- 
--static int ath11k_mac_setup_bcn_tmpl(struct ath11k_vif *arvif)
-+static void ath11k_mac_set_vif_params(struct ath11k_vif *arvif,
-+				      struct sk_buff *bcn)
- {
--	struct ath11k *ar = arvif->ar;
--	struct ath11k_base *ab = ar->ab;
--	struct ieee80211_hw *hw = ar->hw;
--	struct ieee80211_vif *vif = arvif->vif;
--	struct ieee80211_mutable_offsets offs = {};
--	struct sk_buff *bcn;
- 	struct ieee80211_mgmt *mgmt;
- 	u8 *ies;
--	int ret;
--
--	if (arvif->vdev_type != WMI_VDEV_TYPE_AP)
--		return 0;
--
--	bcn = ieee80211_beacon_get_template(hw, vif, &offs, 0);
--	if (!bcn) {
--		ath11k_warn(ab, "failed to get beacon template from mac80211\n");
--		return -EPERM;
--	}
- 
- 	ies = bcn->data + ieee80211_get_hdrlen_from_skb(bcn);
-+	mgmt = (struct ieee80211_mgmt *)bcn->data;
- 	ies += sizeof(mgmt->u.beacon);
- 
- 	if (cfg80211_find_ie(WLAN_EID_RSN, ies, (skb_tail_pointer(bcn) - ies)))
-@@ -1386,7 +1372,28 @@ static int ath11k_mac_setup_bcn_tmpl(str
- 		arvif->wpaie_present = true;
- 	else
- 		arvif->wpaie_present = false;
-+}
-+
-+static int ath11k_mac_setup_bcn_tmpl(struct ath11k_vif *arvif)
-+{
-+	struct ath11k *ar = arvif->ar;
-+	struct ath11k_base *ab = ar->ab;
-+	struct ieee80211_hw *hw = ar->hw;
-+	struct ieee80211_vif *vif = arvif->vif;
-+	struct ieee80211_mutable_offsets offs = {};
-+	struct sk_buff *bcn;
-+	int ret;
-+
-+	if (arvif->vdev_type != WMI_VDEV_TYPE_AP)
-+		return 0;
-+
-+	bcn = ieee80211_beacon_get_template(hw, vif, &offs, 0);
-+	if (!bcn) {
-+		ath11k_warn(ab, "failed to get beacon template from mac80211\n");
-+		return -EPERM;
-+	}
- 
-+	ath11k_mac_set_vif_params(arvif, bcn);
- 	ret = ath11k_wmi_bcn_tmpl(ar, arvif->vdev_id, &offs, bcn);
- 
- 	kfree_skb(bcn);
diff --git a/package/kernel/mac80211/patches/ath11k/0076-wifi-ath11k-MBSSID-beacon-support.patch b/package/kernel/mac80211/patches/ath11k/0076-wifi-ath11k-MBSSID-beacon-support.patch
deleted file mode 100644
index d23ea8de..00000000
--- a/package/kernel/mac80211/patches/ath11k/0076-wifi-ath11k-MBSSID-beacon-support.patch
+++ /dev/null
@@ -1,190 +0,0 @@
-From 335a92765d308dfe22826f5562cd4b4389b45e71 Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Fri, 5 May 2023 16:11:28 +0300
-Subject: [PATCH 76/77] wifi: ath11k: MBSSID beacon support
-
-- Split ath11k_mac_setup_bcn_tmpl() to move the beacon retrieval and
-  WMI command to a new function, ath11k_mac_setup_bcn_tmpl_legacy().
-  In the original function add checks to use the transmitting interface
-  when MBSSID is enabled.
-- Set rsnie_present and wpaie_present fields for the non-transmitting
-  interfaces when MBSSID is enabled.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Co-developed-by: John Crispin <john@phrozen.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405221648.17950-7-quic_alokad@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 116 ++++++++++++++++++++++++--
- drivers/net/wireless/ath/ath11k/wmi.c |   1 +
- 2 files changed, 112 insertions(+), 5 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -1351,6 +1351,84 @@ err_mon_del:
- 	return ret;
- }
- 
-+static void ath11k_mac_setup_nontx_vif_rsnie(struct ath11k_vif *arvif,
-+					     bool tx_arvif_rsnie_present,
-+					     const u8 *profile, u8 profile_len)
-+{
-+	if (cfg80211_find_ie(WLAN_EID_RSN, profile, profile_len)) {
-+		arvif->rsnie_present = true;
-+	} else if (tx_arvif_rsnie_present) {
-+		int i;
-+		u8 nie_len;
-+		const u8 *nie = cfg80211_find_ext_ie(WLAN_EID_EXT_NON_INHERITANCE,
-+						     profile, profile_len);
-+		if (!nie)
-+			return;
-+
-+		nie_len = nie[1];
-+		nie += 2;
-+		for (i = 0; i < nie_len; i++) {
-+			if (nie[i] == WLAN_EID_RSN) {
-+				arvif->rsnie_present = false;
-+				break;
-+			}
-+		}
-+	}
-+}
-+
-+static bool ath11k_mac_set_nontx_vif_params(struct ath11k_vif *tx_arvif,
-+					    struct ath11k_vif *arvif,
-+					    struct sk_buff *bcn)
-+{
-+	struct ieee80211_mgmt *mgmt;
-+	const u8 *ies, *profile, *next_profile;
-+	int ies_len;
-+
-+	ies = bcn->data + ieee80211_get_hdrlen_from_skb(bcn);
-+	mgmt = (struct ieee80211_mgmt *)bcn->data;
-+	ies += sizeof(mgmt->u.beacon);
-+	ies_len = skb_tail_pointer(bcn) - ies;
-+
-+	ies = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ies, ies_len);
-+	arvif->rsnie_present = tx_arvif->rsnie_present;
-+
-+	while (ies) {
-+		u8 mbssid_len;
-+
-+		ies_len -= (2 + ies[1]);
-+		mbssid_len = ies[1] - 1;
-+		profile = &ies[3];
-+
-+		while (mbssid_len) {
-+			u8 profile_len;
-+
-+			profile_len = profile[1];
-+			next_profile = profile + (2 + profile_len);
-+			mbssid_len -= (2 + profile_len);
-+
-+			profile += 2;
-+			profile_len -= (2 + profile[1]);
-+			profile += (2 + profile[1]); /* nontx capabilities */
-+			profile_len -= (2 + profile[1]);
-+			profile += (2 + profile[1]); /* SSID */
-+			if (profile[2] == arvif->vif->bss_conf.bssid_index) {
-+				profile_len -= 5;
-+				profile = profile + 5;
-+				ath11k_mac_setup_nontx_vif_rsnie(arvif,
-+								 tx_arvif->rsnie_present,
-+								 profile,
-+								 profile_len);
-+				return true;
-+			}
-+			profile = next_profile;
-+		}
-+		ies = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, profile,
-+				       ies_len);
-+	}
-+
-+	return false;
-+}
-+
- static void ath11k_mac_set_vif_params(struct ath11k_vif *arvif,
- 				      struct sk_buff *bcn)
- {
-@@ -1374,18 +1452,26 @@ static void ath11k_mac_set_vif_params(st
- 		arvif->wpaie_present = false;
- }
- 
--static int ath11k_mac_setup_bcn_tmpl(struct ath11k_vif *arvif)
-+static int ath11k_mac_setup_bcn_tmpl_mbssid(struct ath11k_vif *arvif)
- {
- 	struct ath11k *ar = arvif->ar;
- 	struct ath11k_base *ab = ar->ab;
-+	struct ath11k_vif *tx_arvif = arvif;
- 	struct ieee80211_hw *hw = ar->hw;
- 	struct ieee80211_vif *vif = arvif->vif;
- 	struct ieee80211_mutable_offsets offs = {};
- 	struct sk_buff *bcn;
- 	int ret;
- 
--	if (arvif->vdev_type != WMI_VDEV_TYPE_AP)
--		return 0;
-+	if (arvif->vif->mbssid_tx_vif) {
-+		tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
-+		if (tx_arvif != arvif) {
-+			ar = tx_arvif->ar;
-+			ab = ar->ab;
-+			hw = ar->hw;
-+			vif = tx_arvif->vif;
-+		}
-+	}
- 
- 	bcn = ieee80211_beacon_get_template(hw, vif, &offs, 0);
- 	if (!bcn) {
-@@ -1393,9 +1479,12 @@ static int ath11k_mac_setup_bcn_tmpl(str
- 		return -EPERM;
- 	}
- 
--	ath11k_mac_set_vif_params(arvif, bcn);
--	ret = ath11k_wmi_bcn_tmpl(ar, arvif->vdev_id, &offs, bcn);
-+	if (tx_arvif == arvif)
-+		ath11k_mac_set_vif_params(tx_arvif, bcn);
-+	else if (!ath11k_mac_set_nontx_vif_params(tx_arvif, arvif, bcn))
-+		return -EINVAL;
- 
-+	ret = ath11k_wmi_bcn_tmpl(ar, arvif->vdev_id, &offs, bcn);
- 	kfree_skb(bcn);
- 
- 	if (ret)
-@@ -1405,6 +1494,23 @@ static int ath11k_mac_setup_bcn_tmpl(str
- 	return ret;
- }
- 
-+static int ath11k_mac_setup_bcn_tmpl(struct ath11k_vif *arvif)
-+{
-+	struct ieee80211_vif *vif = arvif->vif;
-+
-+	if (arvif->vdev_type != WMI_VDEV_TYPE_AP)
-+		return 0;
-+
-+	/* Target does not expect beacon templates for the already up
-+	 * non-transmitting interfaces, and results in a crash if sent.
-+	 */
-+	if (vif->mbssid_tx_vif &&
-+	    arvif != (void *)vif->mbssid_tx_vif->drv_priv && arvif->is_up)
-+		return 0;
-+
-+	return ath11k_mac_setup_bcn_tmpl_mbssid(arvif);
-+}
-+
- void ath11k_mac_bcn_tx_event(struct ath11k_vif *arvif)
- {
- 	struct ieee80211_vif *vif = arvif->vif;
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -1737,6 +1737,7 @@ int ath11k_wmi_bcn_tmpl(struct ath11k *a
- 	}
- 
- 	cmd->buf_len = bcn->len;
-+	cmd->mbssid_ie_offset = offs->mbssid_off;
- 
- 	ptr = skb->data + sizeof(*cmd);
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0077-wifi-ath11k-EMA-beacon-support.patch b/package/kernel/mac80211/patches/ath11k/0077-wifi-ath11k-EMA-beacon-support.patch
deleted file mode 100644
index 51353fa3..00000000
--- a/package/kernel/mac80211/patches/ath11k/0077-wifi-ath11k-EMA-beacon-support.patch
+++ /dev/null
@@ -1,156 +0,0 @@
-From 87bd401138161008fdb82fbca6e213af117bfeb9 Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Fri, 5 May 2023 16:11:28 +0300
-Subject: [PATCH 77/77] wifi: ath11k: EMA beacon support
-
-Add new function ath11k_mac_setup_bcn_tmpl_ema() which invokes the new
-API provided by MAC80211 to retrieve EMA beacons.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Co-developed-by: John Crispin <john@phrozen.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230405221648.17950-8-quic_alokad@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 59 ++++++++++++++++++++++++++-
- drivers/net/wireless/ath/ath11k/wmi.c |  3 +-
- drivers/net/wireless/ath/ath11k/wmi.h | 11 ++++-
- 3 files changed, 70 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -1452,6 +1452,60 @@ static void ath11k_mac_set_vif_params(st
- 		arvif->wpaie_present = false;
- }
- 
-+static int ath11k_mac_setup_bcn_tmpl_ema(struct ath11k_vif *arvif)
-+{
-+	struct ath11k_vif *tx_arvif;
-+	struct ieee80211_ema_beacons *beacons;
-+	int ret = 0;
-+	bool nontx_vif_params_set = false;
-+	u32 params = 0;
-+	u8 i = 0;
-+
-+	tx_arvif = (void *)arvif->vif->mbssid_tx_vif->drv_priv;
-+
-+	beacons = ieee80211_beacon_get_template_ema_list(tx_arvif->ar->hw,
-+							 tx_arvif->vif, 0);
-+	if (!beacons || !beacons->cnt) {
-+		ath11k_warn(arvif->ar->ab,
-+			    "failed to get ema beacon templates from mac80211\n");
-+		return -EPERM;
-+	}
-+
-+	if (tx_arvif == arvif)
-+		ath11k_mac_set_vif_params(tx_arvif, beacons->bcn[0].skb);
-+	else
-+		arvif->wpaie_present = tx_arvif->wpaie_present;
-+
-+	for (i = 0; i < beacons->cnt; i++) {
-+		if (tx_arvif != arvif && !nontx_vif_params_set)
-+			nontx_vif_params_set =
-+				ath11k_mac_set_nontx_vif_params(tx_arvif, arvif,
-+								beacons->bcn[i].skb);
-+
-+		params = beacons->cnt;
-+		params |= (i << WMI_EMA_TMPL_IDX_SHIFT);
-+		params |= ((!i ? 1 : 0) << WMI_EMA_FIRST_TMPL_SHIFT);
-+		params |= ((i + 1 == beacons->cnt ? 1 : 0) << WMI_EMA_LAST_TMPL_SHIFT);
-+
-+		ret = ath11k_wmi_bcn_tmpl(tx_arvif->ar, tx_arvif->vdev_id,
-+					  &beacons->bcn[i].offs,
-+					  beacons->bcn[i].skb, params);
-+		if (ret) {
-+			ath11k_warn(tx_arvif->ar->ab,
-+				    "failed to set ema beacon template id %i error %d\n",
-+				    i, ret);
-+			break;
-+		}
-+	}
-+
-+	ieee80211_beacon_free_ema_list(beacons);
-+
-+	if (tx_arvif != arvif && !nontx_vif_params_set)
-+		return -EINVAL; /* Profile not found in the beacons */
-+
-+	return ret;
-+}
-+
- static int ath11k_mac_setup_bcn_tmpl_mbssid(struct ath11k_vif *arvif)
- {
- 	struct ath11k *ar = arvif->ar;
-@@ -1484,7 +1538,7 @@ static int ath11k_mac_setup_bcn_tmpl_mbs
- 	else if (!ath11k_mac_set_nontx_vif_params(tx_arvif, arvif, bcn))
- 		return -EINVAL;
- 
--	ret = ath11k_wmi_bcn_tmpl(ar, arvif->vdev_id, &offs, bcn);
-+	ret = ath11k_wmi_bcn_tmpl(ar, arvif->vdev_id, &offs, bcn, 0);
- 	kfree_skb(bcn);
- 
- 	if (ret)
-@@ -1508,6 +1562,9 @@ static int ath11k_mac_setup_bcn_tmpl(str
- 	    arvif != (void *)vif->mbssid_tx_vif->drv_priv && arvif->is_up)
- 		return 0;
- 
-+	if (vif->bss_conf.ema_ap && vif->mbssid_tx_vif)
-+		return ath11k_mac_setup_bcn_tmpl_ema(arvif);
-+
- 	return ath11k_mac_setup_bcn_tmpl_mbssid(arvif);
- }
- 
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -1699,7 +1699,7 @@ int ath11k_wmi_send_bcn_offload_control_
- 
- int ath11k_wmi_bcn_tmpl(struct ath11k *ar, u32 vdev_id,
- 			struct ieee80211_mutable_offsets *offs,
--			struct sk_buff *bcn)
-+			struct sk_buff *bcn, u32 ema_params)
- {
- 	struct ath11k_pdev_wmi *wmi = ar->wmi;
- 	struct wmi_bcn_tmpl_cmd *cmd;
-@@ -1738,6 +1738,7 @@ int ath11k_wmi_bcn_tmpl(struct ath11k *a
- 
- 	cmd->buf_len = bcn->len;
- 	cmd->mbssid_ie_offset = offs->mbssid_off;
-+	cmd->ema_params = ema_params;
- 
- 	ptr = skb->data + sizeof(*cmd);
- 
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -3566,6 +3566,10 @@ struct wmi_get_pdev_temperature_cmd {
- 
- #define WMI_BEACON_TX_BUFFER_SIZE	512
- 
-+#define WMI_EMA_TMPL_IDX_SHIFT            8
-+#define WMI_EMA_FIRST_TMPL_SHIFT          16
-+#define WMI_EMA_LAST_TMPL_SHIFT           24
-+
- struct wmi_bcn_tmpl_cmd {
- 	u32 tlv_header;
- 	u32 vdev_id;
-@@ -3576,6 +3580,11 @@ struct wmi_bcn_tmpl_cmd {
- 	u32 csa_event_bitmap;
- 	u32 mbssid_ie_offset;
- 	u32 esp_ie_offset;
-+	u32 csc_switch_count_offset;
-+	u32 csc_event_bitmap;
-+	u32 mu_edca_ie_offset;
-+	u32 feature_enable_bitmap;
-+	u32 ema_params;
- } __packed;
- 
- struct wmi_key_seq_counter {
-@@ -6298,7 +6307,7 @@ int ath11k_wmi_mgmt_send(struct ath11k *
- 			 struct sk_buff *frame);
- int ath11k_wmi_bcn_tmpl(struct ath11k *ar, u32 vdev_id,
- 			struct ieee80211_mutable_offsets *offs,
--			struct sk_buff *bcn);
-+			struct sk_buff *bcn, u32 ema_param);
- int ath11k_wmi_vdev_down(struct ath11k *ar, u8 vdev_id);
- int ath11k_wmi_vdev_up(struct ath11k *ar, u32 vdev_id, u32 aid,
- 		       const u8 *bssid, u8 *tx_bssid, u32 nontx_profile_idx,
diff --git a/package/kernel/mac80211/patches/ath11k/0078-wifi-ath11k-Relocate-the-func-ath11k_mac_bitrate_mas.patch b/package/kernel/mac80211/patches/ath11k/0078-wifi-ath11k-Relocate-the-func-ath11k_mac_bitrate_mas.patch
deleted file mode 100644
index 610bf725..00000000
--- a/package/kernel/mac80211/patches/ath11k/0078-wifi-ath11k-Relocate-the-func-ath11k_mac_bitrate_mas.patch
+++ /dev/null
@@ -1,75 +0,0 @@
-From 570eec3d40505c30babbe3b8f85a38496c975ab2 Mon Sep 17 00:00:00 2001
-From: Maharaja Kennadyrajan <quic_mkenna@quicinc.com>
-Date: Tue, 9 May 2023 20:07:23 +0300
-Subject: [PATCH] wifi: ath11k: Relocate the func
- ath11k_mac_bitrate_mask_num_ht_rates() and change hweight16 to hweight8
-
-Relocate the function ath11k_mac_bitrate_mask_num_ht_rates() definition
-to call this function from other functions which helps to avoid the
-compilation error (function not defined).
-
-ht_mcs[] is 1 byte array and it is enough to use hweight8() instead
-of hweight16(). Hence, fixed the same.
-
-Tested on: Compile tested only.
-
-Signed-off-by: Maharaja Kennadyrajan <quic_mkenna@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230504092033.3542456-2-quic_mkenna@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 30 +++++++++++++--------------
- 1 file changed, 15 insertions(+), 15 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2021-2022 Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2021-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <net/mac80211.h>
-@@ -4338,6 +4338,20 @@ exit:
- }
- 
- static int
-+ath11k_mac_bitrate_mask_num_ht_rates(struct ath11k *ar,
-+				     enum nl80211_band band,
-+				     const struct cfg80211_bitrate_mask *mask)
-+{
-+	int num_rates = 0;
-+	int i;
-+
-+	for (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++)
-+		num_rates += hweight8(mask->control[band].ht_mcs[i]);
-+
-+	return num_rates;
-+}
-+
-+static int
- ath11k_mac_bitrate_mask_num_vht_rates(struct ath11k *ar,
- 				      enum nl80211_band band,
- 				      const struct cfg80211_bitrate_mask *mask)
-@@ -7791,20 +7805,6 @@ static void ath11k_mac_op_flush(struct i
- 	ath11k_mac_flush_tx_complete(ar);
- }
- 
--static int
--ath11k_mac_bitrate_mask_num_ht_rates(struct ath11k *ar,
--				     enum nl80211_band band,
--				     const struct cfg80211_bitrate_mask *mask)
--{
--	int num_rates = 0;
--	int i;
--
--	for (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++)
--		num_rates += hweight16(mask->control[band].ht_mcs[i]);
--
--	return num_rates;
--}
--
- static bool
- ath11k_mac_has_single_legacy_rate(struct ath11k *ar,
- 				  enum nl80211_band band,
diff --git a/package/kernel/mac80211/patches/ath11k/0079-wifi-ath11k-Send-HT-fixed-rate-in-WMI-peer-fixed-par.patch b/package/kernel/mac80211/patches/ath11k/0079-wifi-ath11k-Send-HT-fixed-rate-in-WMI-peer-fixed-par.patch
deleted file mode 100644
index 6282f446..00000000
--- a/package/kernel/mac80211/patches/ath11k/0079-wifi-ath11k-Send-HT-fixed-rate-in-WMI-peer-fixed-par.patch
+++ /dev/null
@@ -1,141 +0,0 @@
-From df8e3729ffc0aa645839693f74ee7b6d999cdf64 Mon Sep 17 00:00:00 2001
-From: Maharaja Kennadyrajan <quic_mkenna@quicinc.com>
-Date: Tue, 9 May 2023 20:07:24 +0300
-Subject: [PATCH] wifi: ath11k: Send HT fixed rate in WMI peer fixed param
-
-Due to the firmware behavior with HT fixed rate setting,
-HT fixed rate MCS with NSS > 1 are treated as NSS = 1
-HT rates in the firmware and enables the HT fixed rate of
-NSS = 1.
-
-This leads to HT fixed rate is always configured for NSS = 1
-even though the user sets NSS = 2 or > 1 HT fixed MCS in the
-set bitrate command.
-
-Currently HT fixed MCS is sent via WMI peer assoc command.
-Fix this issue, by sending the HT fixed rate MCS in WMI peer
-fixed param instead of sending in peer assoc command.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Maharaja Kennadyrajan <quic_mkenna@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230504092033.3542456-3-quic_mkenna@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 63 ++++++++++++++++++++++++++-
- 1 file changed, 61 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -4480,6 +4480,54 @@ ath11k_mac_set_peer_he_fixed_rate(struct
- 	return ret;
- }
- 
-+static int
-+ath11k_mac_set_peer_ht_fixed_rate(struct ath11k_vif *arvif,
-+				  struct ieee80211_sta *sta,
-+				  const struct cfg80211_bitrate_mask *mask,
-+				  enum nl80211_band band)
-+{
-+	struct ath11k *ar = arvif->ar;
-+	u8 ht_rate, nss = 0;
-+	u32 rate_code;
-+	int ret, i;
-+
-+	lockdep_assert_held(&ar->conf_mutex);
-+
-+	for (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++) {
-+		if (hweight8(mask->control[band].ht_mcs[i]) == 1) {
-+			nss = i + 1;
-+			ht_rate = ffs(mask->control[band].ht_mcs[i]) - 1;
-+		}
-+	}
-+
-+	if (!nss) {
-+		ath11k_warn(ar->ab, "No single HT Fixed rate found to set for %pM",
-+			    sta->addr);
-+		return -EINVAL;
-+	}
-+
-+	/* Avoid updating invalid nss as fixed rate*/
-+	if (nss > sta->deflink.rx_nss)
-+		return -EINVAL;
-+
-+	ath11k_dbg(ar->ab, ATH11K_DBG_MAC,
-+		   "Setting Fixed HT Rate for peer %pM. Device will not switch to any other selected rates",
-+		   sta->addr);
-+
-+	rate_code = ATH11K_HW_RATE_CODE(ht_rate, nss - 1,
-+					WMI_RATE_PREAMBLE_HT);
-+	ret = ath11k_wmi_set_peer_param(ar, sta->addr,
-+					arvif->vdev_id,
-+					WMI_PEER_PARAM_FIXED_RATE,
-+					rate_code);
-+	if (ret)
-+		ath11k_warn(ar->ab,
-+			    "failed to update STA %pM HT Fixed Rate %d: %d\n",
-+			    sta->addr, rate_code, ret);
-+
-+	return ret;
-+}
-+
- static int ath11k_station_assoc(struct ath11k *ar,
- 				struct ieee80211_vif *vif,
- 				struct ieee80211_sta *sta,
-@@ -4491,7 +4539,7 @@ static int ath11k_station_assoc(struct a
- 	struct cfg80211_chan_def def;
- 	enum nl80211_band band;
- 	struct cfg80211_bitrate_mask *mask;
--	u8 num_vht_rates, num_he_rates;
-+	u8 num_ht_rates, num_vht_rates, num_he_rates;
- 
- 	lockdep_assert_held(&ar->conf_mutex);
- 
-@@ -4519,6 +4567,7 @@ static int ath11k_station_assoc(struct a
- 
- 	num_vht_rates = ath11k_mac_bitrate_mask_num_vht_rates(ar, band, mask);
- 	num_he_rates = ath11k_mac_bitrate_mask_num_he_rates(ar, band, mask);
-+	num_ht_rates = ath11k_mac_bitrate_mask_num_ht_rates(ar, band, mask);
- 
- 	/* If single VHT/HE rate is configured (by set_bitrate_mask()),
- 	 * peer_assoc will disable VHT/HE. This is now enabled by a peer specific
-@@ -4535,6 +4584,11 @@ static int ath11k_station_assoc(struct a
- 							band);
- 		if (ret)
- 			return ret;
-+	} else if (sta->deflink.ht_cap.ht_supported && num_ht_rates == 1) {
-+		ret = ath11k_mac_set_peer_ht_fixed_rate(arvif, sta, mask,
-+							band);
-+		if (ret)
-+			return ret;
- 	}
- 
- 	/* Re-assoc is run only to update supported rates for given station. It
-@@ -4608,7 +4662,7 @@ static void ath11k_sta_rc_update_wk(stru
- 	const u16 *vht_mcs_mask;
- 	const u16 *he_mcs_mask;
- 	u32 changed, bw, nss, smps, bw_prev;
--	int err, num_vht_rates, num_he_rates;
-+	int err, num_ht_rates, num_vht_rates, num_he_rates;
- 	const struct cfg80211_bitrate_mask *mask;
- 	struct peer_assoc_params peer_arg;
- 	enum wmi_phy_mode peer_phymode;
-@@ -4724,6 +4778,8 @@ static void ath11k_sta_rc_update_wk(stru
- 
- 	if (changed & IEEE80211_RC_SUPP_RATES_CHANGED) {
- 		mask = &arvif->bitrate_mask;
-+		num_ht_rates = ath11k_mac_bitrate_mask_num_ht_rates(ar, band,
-+								    mask);
- 		num_vht_rates = ath11k_mac_bitrate_mask_num_vht_rates(ar, band,
- 								      mask);
- 		num_he_rates = ath11k_mac_bitrate_mask_num_he_rates(ar, band,
-@@ -4746,6 +4802,9 @@ static void ath11k_sta_rc_update_wk(stru
- 		} else if (sta->deflink.he_cap.has_he && num_he_rates == 1) {
- 			ath11k_mac_set_peer_he_fixed_rate(arvif, sta, mask,
- 							  band);
-+		} else if (sta->deflink.ht_cap.ht_supported && num_ht_rates == 1) {
-+			ath11k_mac_set_peer_ht_fixed_rate(arvif, sta, mask,
-+							  band);
- 		} else {
- 			/* If the peer is non-VHT/HE or no fixed VHT/HE rate
- 			 * is provided in the new bitrate mask we set the
diff --git a/package/kernel/mac80211/patches/ath11k/0080-wifi-ath11k-add-support-default-regdb-while-searchin.patch b/package/kernel/mac80211/patches/ath11k/0080-wifi-ath11k-add-support-default-regdb-while-searchin.patch
deleted file mode 100644
index 5ff40aac..00000000
--- a/package/kernel/mac80211/patches/ath11k/0080-wifi-ath11k-add-support-default-regdb-while-searchin.patch
+++ /dev/null
@@ -1,127 +0,0 @@
-From 88ca89202f8e8afb5225eb5244d79cd67c15d744 Mon Sep 17 00:00:00 2001
-From: Wen Gong <quic_wgong@quicinc.com>
-Date: Fri, 26 May 2023 12:41:06 +0300
-Subject: [PATCH] wifi: ath11k: add support default regdb while searching
- board-2.bin for WCN6855
-
-Sometimes board-2.bin does not have the regdb data which matched the
-parameters such as vendor, device, subsystem-vendor, subsystem-device
-and etc. Add default regdb data with 'bus=%s' into board-2.bin for
-WCN6855, then ath11k use 'bus=pci' to search regdb data in board-2.bin
-for WCN6855.
-
-kernel: [  122.515808] ath11k_pci 0000:03:00.0: boot using board name 'bus=pci,vendor=17cb,device=1103,subsystem-vendor=17cb,subsystem-device=3374,qmi-chip-id=2,qmi-board-id=262'
-kernel: [  122.517240] ath11k_pci 0000:03:00.0: boot firmware request ath11k/WCN6855/hw2.0/board-2.bin size 6179564
-kernel: [  122.517280] ath11k_pci 0000:03:00.0: failed to fetch regdb data for bus=pci,vendor=17cb,device=1103,subsystem-vendor=17cb,subsystem-device=3374,qmi-chip-id=2,qmi-board-id=262 from ath11k/WCN6855/hw2.0/board-2.bin
-kernel: [  122.517464] ath11k_pci 0000:03:00.0: boot using board name 'bus=pci'
-kernel: [  122.518901] ath11k_pci 0000:03:00.0: boot firmware request ath11k/WCN6855/hw2.0/board-2.bin size 6179564
-kernel: [  122.518915] ath11k_pci 0000:03:00.0: board name
-kernel: [  122.518917] ath11k_pci 0000:03:00.0: 00000000: 62 75 73 3d 70 63 69                             bus=pci
-kernel: [  122.518918] ath11k_pci 0000:03:00.0: boot found match regdb data for name 'bus=pci'
-kernel: [  122.518920] ath11k_pci 0000:03:00.0: boot found regdb data for 'bus=pci'
-kernel: [  122.518921] ath11k_pci 0000:03:00.0: fetched regdb
-
-Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
-
-Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230517133959.8224-1-quic_wgong@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 53 +++++++++++++++++++-------
- 1 file changed, 40 insertions(+), 13 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -961,7 +961,8 @@ int ath11k_core_check_dt(struct ath11k_b
- }
- 
- static int __ath11k_core_create_board_name(struct ath11k_base *ab, char *name,
--					   size_t name_len, bool with_variant)
-+					   size_t name_len, bool with_variant,
-+					   bool bus_type_mode)
- {
- 	/* strlen(',variant=') + strlen(ab->qmi.target.bdf_ext) */
- 	char variant[9 + ATH11K_QMI_BDF_EXT_STR_LENGTH] = { 0 };
-@@ -972,15 +973,20 @@ static int __ath11k_core_create_board_na
- 
- 	switch (ab->id.bdf_search) {
- 	case ATH11K_BDF_SEARCH_BUS_AND_BOARD:
--		scnprintf(name, name_len,
--			  "bus=%s,vendor=%04x,device=%04x,subsystem-vendor=%04x,subsystem-device=%04x,qmi-chip-id=%d,qmi-board-id=%d%s",
--			  ath11k_bus_str(ab->hif.bus),
--			  ab->id.vendor, ab->id.device,
--			  ab->id.subsystem_vendor,
--			  ab->id.subsystem_device,
--			  ab->qmi.target.chip_id,
--			  ab->qmi.target.board_id,
--			  variant);
-+		if (bus_type_mode)
-+			scnprintf(name, name_len,
-+				  "bus=%s",
-+				  ath11k_bus_str(ab->hif.bus));
-+		else
-+			scnprintf(name, name_len,
-+				  "bus=%s,vendor=%04x,device=%04x,subsystem-vendor=%04x,subsystem-device=%04x,qmi-chip-id=%d,qmi-board-id=%d%s",
-+				  ath11k_bus_str(ab->hif.bus),
-+				  ab->id.vendor, ab->id.device,
-+				  ab->id.subsystem_vendor,
-+				  ab->id.subsystem_device,
-+				  ab->qmi.target.chip_id,
-+				  ab->qmi.target.board_id,
-+				  variant);
- 		break;
- 	default:
- 		scnprintf(name, name_len,
-@@ -999,13 +1005,19 @@ static int __ath11k_core_create_board_na
- static int ath11k_core_create_board_name(struct ath11k_base *ab, char *name,
- 					 size_t name_len)
- {
--	return __ath11k_core_create_board_name(ab, name, name_len, true);
-+	return __ath11k_core_create_board_name(ab, name, name_len, true, false);
- }
- 
- static int ath11k_core_create_fallback_board_name(struct ath11k_base *ab, char *name,
- 						  size_t name_len)
- {
--	return __ath11k_core_create_board_name(ab, name, name_len, false);
-+	return __ath11k_core_create_board_name(ab, name, name_len, false, false);
-+}
-+
-+static int ath11k_core_create_bus_type_board_name(struct ath11k_base *ab, char *name,
-+						  size_t name_len)
-+{
-+	return __ath11k_core_create_board_name(ab, name, name_len, false, true);
- }
- 
- const struct firmware *ath11k_core_firmware_request(struct ath11k_base *ab,
-@@ -1309,7 +1321,7 @@ success:
- 
- int ath11k_core_fetch_regdb(struct ath11k_base *ab, struct ath11k_board_data *bd)
- {
--	char boardname[BOARD_NAME_SIZE];
-+	char boardname[BOARD_NAME_SIZE], default_boardname[BOARD_NAME_SIZE];
- 	int ret;
- 
- 	ret = ath11k_core_create_board_name(ab, boardname, BOARD_NAME_SIZE);
-@@ -1323,6 +1335,21 @@ int ath11k_core_fetch_regdb(struct ath11
- 						 ATH11K_BD_IE_REGDB,
- 						 ATH11K_BD_IE_REGDB_NAME,
- 						 ATH11K_BD_IE_REGDB_DATA);
-+	if (!ret)
-+		goto exit;
-+
-+	ret = ath11k_core_create_bus_type_board_name(ab, default_boardname,
-+						     BOARD_NAME_SIZE);
-+	if (ret) {
-+		ath11k_dbg(ab, ATH11K_DBG_BOOT,
-+			   "failed to create default board name for regdb: %d", ret);
-+		goto exit;
-+	}
-+
-+	ret = ath11k_core_fetch_board_data_api_n(ab, bd, default_boardname,
-+						 ATH11K_BD_IE_REGDB,
-+						 ATH11K_BD_IE_REGDB_NAME,
-+						 ATH11K_BD_IE_REGDB_DATA);
- 	if (!ret)
- 		goto exit;
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0081-wifi-ath11k-remove-unused-function-ath11k_tm_event_w.patch b/package/kernel/mac80211/patches/ath11k/0081-wifi-ath11k-remove-unused-function-ath11k_tm_event_w.patch
deleted file mode 100644
index b5dc83f0..00000000
--- a/package/kernel/mac80211/patches/ath11k/0081-wifi-ath11k-remove-unused-function-ath11k_tm_event_w.patch
+++ /dev/null
@@ -1,128 +0,0 @@
-From 86f85575a3f6a20cef1c8bb98e78585fe3a53ccc Mon Sep 17 00:00:00 2001
-From: Govindaraj Saminathan <quic_gsaminat@quicinc.com>
-Date: Fri, 26 May 2023 12:41:06 +0300
-Subject: [PATCH 82/84] wifi: ath11k: remove unused function
- ath11k_tm_event_wmi()
-
-The function ath11k_tm_event_wmi() is only defined and it is not used
-anywhere. Hence remove the unused.
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Govindaraj Saminathan <quic_gsaminat@quicinc.com>
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230517135934.16408-2-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/testmode.c | 64 +---------------------
- drivers/net/wireless/ath/ath11k/testmode.h |  8 +--
- 2 files changed, 2 insertions(+), 70 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/testmode.c
-+++ b/drivers/net/wireless/ath/ath11k/testmode.c
-@@ -1,6 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include "testmode.h"
-@@ -20,69 +21,6 @@ static const struct nla_policy ath11k_tm
- 	[ATH11K_TM_ATTR_VERSION_MINOR]	= { .type = NLA_U32 },
- };
- 
--/* Returns true if callee consumes the skb and the skb should be discarded.
-- * Returns false if skb is not used. Does not sleep.
-- */
--bool ath11k_tm_event_wmi(struct ath11k *ar, u32 cmd_id, struct sk_buff *skb)
--{
--	struct sk_buff *nl_skb;
--	bool consumed;
--	int ret;
--
--	ath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE,
--		   "testmode event wmi cmd_id %d skb %pK skb->len %d\n",
--		   cmd_id, skb, skb->len);
--
--	ath11k_dbg_dump(ar->ab, ATH11K_DBG_TESTMODE, NULL, "", skb->data, skb->len);
--
--	spin_lock_bh(&ar->data_lock);
--
--	consumed = true;
--
--	nl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy,
--						   2 * sizeof(u32) + skb->len,
--						   GFP_ATOMIC);
--	if (!nl_skb) {
--		ath11k_warn(ar->ab,
--			    "failed to allocate skb for testmode wmi event\n");
--		goto out;
--	}
--
--	ret = nla_put_u32(nl_skb, ATH11K_TM_ATTR_CMD, ATH11K_TM_CMD_WMI);
--	if (ret) {
--		ath11k_warn(ar->ab,
--			    "failed to put testmode wmi event cmd attribute: %d\n",
--			    ret);
--		kfree_skb(nl_skb);
--		goto out;
--	}
--
--	ret = nla_put_u32(nl_skb, ATH11K_TM_ATTR_WMI_CMDID, cmd_id);
--	if (ret) {
--		ath11k_warn(ar->ab,
--			    "failed to put testmode wmi even cmd_id: %d\n",
--			    ret);
--		kfree_skb(nl_skb);
--		goto out;
--	}
--
--	ret = nla_put(nl_skb, ATH11K_TM_ATTR_DATA, skb->len, skb->data);
--	if (ret) {
--		ath11k_warn(ar->ab,
--			    "failed to copy skb to testmode wmi event: %d\n",
--			    ret);
--		kfree_skb(nl_skb);
--		goto out;
--	}
--
--	cfg80211_testmode_event(nl_skb, GFP_ATOMIC);
--
--out:
--	spin_unlock_bh(&ar->data_lock);
--
--	return consumed;
--}
--
- static int ath11k_tm_cmd_get_version(struct ath11k *ar, struct nlattr *tb[])
- {
- 	struct sk_buff *skb;
---- a/drivers/net/wireless/ath/ath11k/testmode.h
-+++ b/drivers/net/wireless/ath/ath11k/testmode.h
-@@ -1,24 +1,18 @@
- /* SPDX-License-Identifier: BSD-3-Clause-Clear */
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include "core.h"
- 
- #ifdef CPTCFG_NL80211_TESTMODE
- 
--bool ath11k_tm_event_wmi(struct ath11k *ar, u32 cmd_id, struct sk_buff *skb);
- int ath11k_tm_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
- 		  void *data, int len);
- 
- #else
- 
--static inline bool ath11k_tm_event_wmi(struct ath11k *ar, u32 cmd_id,
--				       struct sk_buff *skb)
--{
--	return false;
--}
--
- static inline int ath11k_tm_cmd(struct ieee80211_hw *hw,
- 				struct ieee80211_vif *vif,
- 				void *data, int len)
diff --git a/package/kernel/mac80211/patches/ath11k/0082-wifi-ath11k-factory-test-mode-support.patch b/package/kernel/mac80211/patches/ath11k/0082-wifi-ath11k-factory-test-mode-support.patch
deleted file mode 100644
index f1b26272..00000000
--- a/package/kernel/mac80211/patches/ath11k/0082-wifi-ath11k-factory-test-mode-support.patch
+++ /dev/null
@@ -1,850 +0,0 @@
-From b43310e44edc823a7f02af1e1e2b4e8a9abc7d91 Mon Sep 17 00:00:00 2001
-From: Govindaraj Saminathan <quic_gsaminat@quicinc.com>
-Date: Fri, 26 May 2023 12:41:07 +0300
-Subject: [PATCH 83/84] wifi: ath11k: factory test mode support
-
-Add support to process factory test mode commands (FTM) for calibration.
-By default firmware start with NORMAL mode and to process the FTM commands
-firmware needs to be restarted in FTM mode using module parameter ftm_mode.
-The pre-request is all the radios should be down before starting the test.
-
-When start command ATH11K_TM_CMD_TESTMODE_START is received, ar->state
-is set to Test Mode. If the FTM command or event length is greater
-than 256 bytes, it will be broken down into multiple segments and
-encoded with TLV header if it is segmented commands, else it is sent
-to firmware as it is.
-
-On receiving UTF event from firmware, if it is segmented event, the driver
-will wait until it receives all the segments and notify the complete
-data to user application. In case the segmented sequence are missed or
-lost from the firmware, driver will skip the already received partial data.
-
-In case of unsegmented UTF event from firmware, driver notifies the
-data to the user application as it comes. Applications handles
-the data further.
-
-Command to boot in ftm mode:
-
-insmod ath11k ftm_mode=1
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Govindaraj Saminathan <quic_gsaminat@quicinc.com>
-Co-developed-by: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Signed-off-by: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230517135934.16408-4-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/ahb.c        |   3 +-
- drivers/net/wireless/ath/ath11k/core.c       |  21 +-
- drivers/net/wireless/ath/ath11k/core.h       |  16 +-
- drivers/net/wireless/ath/ath11k/debug.h      |   1 +
- drivers/net/wireless/ath/ath11k/mac.c        |  11 +-
- drivers/net/wireless/ath/ath11k/pci.c        |   3 +-
- drivers/net/wireless/ath/ath11k/testmode.c   | 350 ++++++++++++++++++-
- drivers/net/wireless/ath/ath11k/testmode.h   |   6 +
- drivers/net/wireless/ath/ath11k/testmode_i.h |  18 +-
- drivers/net/wireless/ath/ath11k/wmi.c        |  11 +-
- drivers/net/wireless/ath/ath11k/wmi.h        |  22 ++
- drivers/net/wireless/ath/ath11k/wow.c        |   3 +-
- 12 files changed, 444 insertions(+), 21 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <linux/module.h>
-@@ -1155,6 +1155,7 @@ static int ath11k_ahb_probe(struct platf
- 	ab->hif.ops = hif_ops;
- 	ab->pdev = pdev;
- 	ab->hw_rev = hw_rev;
-+	ab->fw_mode = ATH11K_FIRMWARE_MODE_NORMAL;
- 	platform_set_drvdata(pdev, ab);
- 
- 	ret = ath11k_pcic_register_pci_ops(ab, pci_ops);
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2021-2022 Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2021-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <linux/module.h>
-@@ -32,6 +32,10 @@ module_param_named(frame_mode, ath11k_fr
- MODULE_PARM_DESC(frame_mode,
- 		 "Datapath frame mode (0: raw, 1: native wifi (default), 2: ethernet)");
- 
-+bool ath11k_ftm_mode;
-+module_param_named(ftm_mode, ath11k_ftm_mode, bool, 0444);
-+MODULE_PARM_DESC(ftm_mode, "Boots up in factory test mode");
-+
- static const struct ath11k_hw_params ath11k_hw_params[] = {
- 	{
- 		.hw_rev = ATH11K_HW_IPQ8074,
-@@ -1381,6 +1385,11 @@ static int ath11k_core_soc_create(struct
- {
- 	int ret;
- 
-+	if (ath11k_ftm_mode) {
-+		ab->fw_mode = ATH11K_FIRMWARE_MODE_FTM;
-+		ath11k_info(ab, "Booting in factory test mode\n");
-+	}
-+
- 	ret = ath11k_qmi_init_service(ab);
- 	if (ret) {
- 		ath11k_err(ab, "failed to initialize qmi :%d\n", ret);
-@@ -1607,7 +1616,7 @@ int ath11k_core_qmi_firmware_ready(struc
- {
- 	int ret;
- 
--	ret = ath11k_core_start_firmware(ab, ATH11K_FIRMWARE_MODE_NORMAL);
-+	ret = ath11k_core_start_firmware(ab, ab->fw_mode);
- 	if (ret) {
- 		ath11k_err(ab, "failed to start firmware: %d\n", ret);
- 		return ret;
-@@ -1772,7 +1781,8 @@ void ath11k_core_pre_reconfigure_recover
- 	for (i = 0; i < ab->num_radios; i++) {
- 		pdev = &ab->pdevs[i];
- 		ar = pdev->ar;
--		if (!ar || ar->state == ATH11K_STATE_OFF)
-+		if (!ar || ar->state == ATH11K_STATE_OFF ||
-+		    ar->state == ATH11K_STATE_FTM)
- 			continue;
- 
- 		ieee80211_stop_queues(ar->hw);
-@@ -1841,7 +1851,12 @@ static void ath11k_core_post_reconfigure
- 			ath11k_warn(ab,
- 				    "device is wedged, will not restart radio %d\n", i);
- 			break;
-+		case ATH11K_STATE_FTM:
-+			ath11k_dbg(ab, ATH11K_DBG_TESTMODE,
-+				   "fw mode reset done radio %d\n", i);
-+			break;
- 		}
-+
- 		mutex_unlock(&ar->conf_mutex);
- 	}
- 	complete(&ab->driver_recovery);
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -1,7 +1,7 @@
- /* SPDX-License-Identifier: BSD-3-Clause-Clear */
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2021-2022 Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2021-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #ifndef ATH11K_CORE_H
-@@ -52,6 +52,7 @@
- #define ATH11K_SMBIOS_BDF_EXT_MAGIC "BDF_"
- 
- extern unsigned int ath11k_frame_mode;
-+extern bool ath11k_ftm_mode;
- 
- #define ATH11K_SCAN_TIMEOUT_HZ (20 * HZ)
- 
-@@ -277,6 +278,7 @@ enum ath11k_dev_flags {
- 	ATH11K_FLAG_FIXED_MEM_RGN,
- 	ATH11K_FLAG_DEVICE_INIT_DONE,
- 	ATH11K_FLAG_MULTI_MSI_VECTORS,
-+	ATH11K_FLAG_FTM_SEGMENTED,
- };
- 
- enum ath11k_monitor_flags {
-@@ -530,6 +532,7 @@ enum ath11k_state {
- 	ATH11K_STATE_RESTARTING,
- 	ATH11K_STATE_RESTARTED,
- 	ATH11K_STATE_WEDGED,
-+	ATH11K_STATE_FTM,
- 	/* Add other states as required */
- };
- 
-@@ -709,6 +712,8 @@ struct ath11k {
- 	u32 last_ppdu_id;
- 	u32 cached_ppdu_id;
- 	int monitor_vdev_id;
-+	struct completion fw_mode_reset;
-+	u8 ftm_msgref;
- #ifdef CPTCFG_ATH11K_DEBUGFS
- 	struct ath11k_debug debug;
- #endif
-@@ -838,6 +843,7 @@ struct ath11k_msi_config {
- /* Master structure to hold the hw data which may be used in core module */
- struct ath11k_base {
- 	enum ath11k_hw_rev hw_rev;
-+	enum ath11k_firmware_mode fw_mode;
- 	struct platform_device *pdev;
- 	struct device *dev;
- 	struct ath11k_qmi qmi;
-@@ -978,6 +984,14 @@ struct ath11k_base {
- 		const struct ath11k_pci_ops *ops;
- 	} pci;
- 
-+#ifdef CPTCFG_NL80211_TESTMODE
-+	struct {
-+		u32 data_pos;
-+		u32 expected_seq;
-+		u8 *eventdata;
-+	} testmode;
-+#endif
-+
- 	/* must be last */
- 	u8 drv_priv[] __aligned(sizeof(void *));
- };
---- a/drivers/net/wireless/ath/ath11k/debug.h
-+++ b/drivers/net/wireless/ath/ath11k/debug.h
-@@ -1,6 +1,7 @@
- /* SPDX-License-Identifier: BSD-3-Clause-Clear */
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #ifndef _ATH11K_DEBUG_H_
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -643,7 +643,10 @@ struct ath11k *ath11k_mac_get_ar_by_pdev
- 		return NULL;
- 
- 	for (i = 0; i < ab->num_radios; i++) {
--		pdev = rcu_dereference(ab->pdevs_active[i]);
-+		if (ab->fw_mode == ATH11K_FIRMWARE_MODE_FTM)
-+			pdev = &ab->pdevs[i];
-+		else
-+			pdev = rcu_dereference(ab->pdevs_active[i]);
- 
- 		if (pdev && pdev->pdev_id == pdev_id)
- 			return (pdev->ar ? pdev->ar : NULL);
-@@ -6271,6 +6274,11 @@ static int ath11k_mac_op_start(struct ie
- 	struct ath11k_pdev *pdev = ar->pdev;
- 	int ret;
- 
-+	if (ath11k_ftm_mode) {
-+		ath11k_warn(ab, "mac operations not supported in factory test mode\n");
-+		return -EOPNOTSUPP;
-+	}
-+
- 	ath11k_mac_drain_tx(ar);
- 	mutex_lock(&ar->conf_mutex);
- 
-@@ -6285,6 +6293,7 @@ static int ath11k_mac_op_start(struct ie
- 	case ATH11K_STATE_RESTARTED:
- 	case ATH11K_STATE_WEDGED:
- 	case ATH11K_STATE_ON:
-+	case ATH11K_STATE_FTM:
- 		WARN_ON(1);
- 		ret = -EINVAL;
- 		goto err;
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2019-2020 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2021-2022, Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2021-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <linux/module.h>
-@@ -745,6 +745,7 @@ static int ath11k_pci_probe(struct pci_d
- 	ab_pci->ab = ab;
- 	ab_pci->pdev = pdev;
- 	ab->hif.ops = &ath11k_pci_hif_ops;
-+	ab->fw_mode = ATH11K_FIRMWARE_MODE_NORMAL;
- 	pci_set_drvdata(pdev, ab);
- 	spin_lock_init(&ab_pci->window_lock);
- 
---- a/drivers/net/wireless/ath/ath11k/testmode.c
-+++ b/drivers/net/wireless/ath/ath11k/testmode.c
-@@ -12,6 +12,9 @@
- #include "core.h"
- #include "testmode_i.h"
- 
-+#define ATH11K_FTM_SEGHDR_CURRENT_SEQ		GENMASK(3, 0)
-+#define ATH11K_FTM_SEGHDR_TOTAL_SEGMENTS	GENMASK(7, 4)
-+
- static const struct nla_policy ath11k_tm_policy[ATH11K_TM_ATTR_MAX + 1] = {
- 	[ATH11K_TM_ATTR_CMD]		= { .type = NLA_U32 },
- 	[ATH11K_TM_ATTR_DATA]		= { .type = NLA_BINARY,
-@@ -21,13 +24,217 @@ static const struct nla_policy ath11k_tm
- 	[ATH11K_TM_ATTR_VERSION_MINOR]	= { .type = NLA_U32 },
- };
- 
-+static struct ath11k *ath11k_tm_get_ar(struct ath11k_base *ab)
-+{
-+	struct ath11k_pdev *pdev;
-+	struct ath11k *ar = NULL;
-+	int i;
-+
-+	for (i = 0; i < ab->num_radios; i++) {
-+		pdev = &ab->pdevs[i];
-+		ar = pdev->ar;
-+
-+		if (ar && ar->state == ATH11K_STATE_FTM)
-+			break;
-+	}
-+
-+	return ar;
-+}
-+
-+/* This function handles unsegmented events. Data in various events are aggregated
-+ * in application layer, this event is unsegmented from host perspective.
-+ */
-+static void ath11k_tm_wmi_event_unsegmented(struct ath11k_base *ab, u32 cmd_id,
-+					    struct sk_buff *skb)
-+{
-+	struct sk_buff *nl_skb;
-+	struct ath11k *ar;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_TESTMODE,
-+		   "event wmi cmd_id %d skb length %d\n",
-+		   cmd_id, skb->len);
-+	ath11k_dbg_dump(ab, ATH11K_DBG_TESTMODE, NULL, "", skb->data, skb->len);
-+
-+	ar = ath11k_tm_get_ar(ab);
-+	if (!ar) {
-+		ath11k_warn(ab, "testmode event not handled due to invalid pdev\n");
-+		return;
-+	}
-+
-+	spin_lock_bh(&ar->data_lock);
-+
-+	nl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy,
-+						   2 * nla_total_size(sizeof(u32)) +
-+						   nla_total_size(skb->len),
-+						   GFP_ATOMIC);
-+	if (!nl_skb) {
-+		ath11k_warn(ab,
-+			    "failed to allocate skb for unsegmented testmode wmi event\n");
-+		goto out;
-+	}
-+
-+	if (nla_put_u32(nl_skb, ATH11K_TM_ATTR_CMD, ATH11K_TM_CMD_WMI) ||
-+	    nla_put_u32(nl_skb, ATH11K_TM_ATTR_WMI_CMDID, cmd_id) ||
-+	    nla_put(nl_skb, ATH11K_TM_ATTR_DATA, skb->len, skb->data)) {
-+		ath11k_warn(ab, "failed to populate testmode unsegmented event\n");
-+		kfree_skb(nl_skb);
-+		goto out;
-+	}
-+
-+	cfg80211_testmode_event(nl_skb, GFP_ATOMIC);
-+	spin_unlock_bh(&ar->data_lock);
-+	return;
-+
-+out:
-+	spin_unlock_bh(&ar->data_lock);
-+	ath11k_warn(ab, "Failed to send testmode event to higher layers\n");
-+}
-+
-+/* This function handles segmented events. Data of various events received
-+ * from firmware is aggregated and sent to application layer
-+ */
-+static int ath11k_tm_process_event(struct ath11k_base *ab, u32 cmd_id,
-+				   const struct wmi_ftm_event_msg *ftm_msg,
-+				   u16 length)
-+{
-+	struct sk_buff *nl_skb;
-+	int ret = 0;
-+	struct ath11k *ar;
-+	u8 const *buf_pos;
-+	u16 datalen;
-+	u8 total_segments, current_seq;
-+	u32 data_pos;
-+	u32 pdev_id;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_TESTMODE,
-+		   "event wmi cmd_id %d ftm event msg %pK datalen %d\n",
-+		   cmd_id, ftm_msg, length);
-+	ath11k_dbg_dump(ab, ATH11K_DBG_TESTMODE, NULL, "", ftm_msg, length);
-+	pdev_id = DP_HW2SW_MACID(ftm_msg->seg_hdr.pdev_id);
-+
-+	if (pdev_id >= ab->num_radios) {
-+		ath11k_warn(ab, "testmode event not handled due to invalid pdev id: %d\n",
-+			    pdev_id);
-+		return -EINVAL;
-+	}
-+
-+	ar = ab->pdevs[pdev_id].ar;
-+	if (!ar) {
-+		ath11k_warn(ab, "testmode event not handled due to absence of pdev\n");
-+		return -ENODEV;
-+	}
-+
-+	current_seq = FIELD_GET(ATH11K_FTM_SEGHDR_CURRENT_SEQ,
-+				ftm_msg->seg_hdr.segmentinfo);
-+	total_segments = FIELD_GET(ATH11K_FTM_SEGHDR_TOTAL_SEGMENTS,
-+				   ftm_msg->seg_hdr.segmentinfo);
-+	datalen = length - (sizeof(struct wmi_ftm_seg_hdr));
-+	buf_pos = ftm_msg->data;
-+
-+	spin_lock_bh(&ar->data_lock);
-+
-+	if (current_seq == 0) {
-+		ab->testmode.expected_seq = 0;
-+		ab->testmode.data_pos = 0;
-+	}
-+
-+	data_pos = ab->testmode.data_pos;
-+
-+	if ((data_pos + datalen) > ATH11K_FTM_EVENT_MAX_BUF_LENGTH) {
-+		ath11k_warn(ab, "Invalid ftm event length at %d: %d\n",
-+			    data_pos, datalen);
-+		ret = -EINVAL;
-+		goto out;
-+	}
-+
-+	memcpy(&ab->testmode.eventdata[data_pos], buf_pos, datalen);
-+	data_pos += datalen;
-+
-+	if (++ab->testmode.expected_seq != total_segments) {
-+		ab->testmode.data_pos = data_pos;
-+		ath11k_dbg(ab, ATH11K_DBG_TESTMODE,
-+			   "partial data received current_seq %d total_seg %d\n",
-+			    current_seq, total_segments);
-+		goto out;
-+	}
-+
-+	ath11k_dbg(ab, ATH11K_DBG_TESTMODE,
-+		   "total data length pos %d len %d\n",
-+		    data_pos, ftm_msg->seg_hdr.len);
-+	nl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy,
-+						   2 * nla_total_size(sizeof(u32)) +
-+						   nla_total_size(data_pos),
-+						   GFP_ATOMIC);
-+	if (!nl_skb) {
-+		ath11k_warn(ab,
-+			    "failed to allocate skb for segmented testmode wmi event\n");
-+		ret = -ENOMEM;
-+		goto out;
-+	}
-+
-+	if (nla_put_u32(nl_skb, ATH11K_TM_ATTR_CMD,
-+			ATH11K_TM_CMD_WMI_FTM) ||
-+	    nla_put_u32(nl_skb, ATH11K_TM_ATTR_WMI_CMDID, cmd_id) ||
-+	    nla_put(nl_skb, ATH11K_TM_ATTR_DATA, data_pos,
-+		    &ab->testmode.eventdata[0])) {
-+		ath11k_warn(ab, "failed to populate segmented testmode event");
-+		kfree_skb(nl_skb);
-+		ret = -ENOBUFS;
-+		goto out;
-+	}
-+
-+	cfg80211_testmode_event(nl_skb, GFP_ATOMIC);
-+
-+out:
-+	spin_unlock_bh(&ar->data_lock);
-+	return ret;
-+}
-+
-+static void ath11k_tm_wmi_event_segmented(struct ath11k_base *ab, u32 cmd_id,
-+					  struct sk_buff *skb)
-+{
-+	const void **tb;
-+	const struct wmi_ftm_event_msg *ev;
-+	u16 length;
-+	int ret;
-+
-+	tb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);
-+	if (IS_ERR(tb)) {
-+		ret = PTR_ERR(tb);
-+		ath11k_warn(ab, "failed to parse ftm event tlv: %d\n", ret);
-+		return;
-+	}
-+
-+	ev = tb[WMI_TAG_ARRAY_BYTE];
-+	if (!ev) {
-+		ath11k_warn(ab, "failed to fetch ftm msg\n");
-+		kfree(tb);
-+		return;
-+	}
-+
-+	length = skb->len - TLV_HDR_SIZE;
-+	ret = ath11k_tm_process_event(ab, cmd_id, ev, length);
-+	if (ret)
-+		ath11k_warn(ab, "Failed to process ftm event\n");
-+
-+	kfree(tb);
-+}
-+
-+void ath11k_tm_wmi_event(struct ath11k_base *ab, u32 cmd_id, struct sk_buff *skb)
-+{
-+	if (test_bit(ATH11K_FLAG_FTM_SEGMENTED, &ab->dev_flags))
-+		ath11k_tm_wmi_event_segmented(ab, cmd_id, skb);
-+	else
-+		ath11k_tm_wmi_event_unsegmented(ab, cmd_id, skb);
-+}
-+
- static int ath11k_tm_cmd_get_version(struct ath11k *ar, struct nlattr *tb[])
- {
- 	struct sk_buff *skb;
- 	int ret;
- 
- 	ath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE,
--		   "testmode cmd get version_major %d version_minor %d\n",
-+		   "cmd get version_major %d version_minor %d\n",
- 		   ATH11K_TESTMODE_VERSION_MAJOR,
- 		   ATH11K_TESTMODE_VERSION_MINOR);
- 
-@@ -53,6 +260,43 @@ static int ath11k_tm_cmd_get_version(str
- 	return cfg80211_testmode_reply(skb);
- }
- 
-+static int ath11k_tm_cmd_testmode_start(struct ath11k *ar, struct nlattr *tb[])
-+{
-+	int ret;
-+
-+	mutex_lock(&ar->conf_mutex);
-+
-+	if (ar->state == ATH11K_STATE_FTM) {
-+		ret = -EALREADY;
-+		goto err;
-+	}
-+
-+	/* start utf only when the driver is not in use  */
-+	if (ar->state != ATH11K_STATE_OFF) {
-+		ret = -EBUSY;
-+		goto err;
-+	}
-+
-+	ar->ab->testmode.eventdata = kzalloc(ATH11K_FTM_EVENT_MAX_BUF_LENGTH,
-+					     GFP_KERNEL);
-+	if (!ar->ab->testmode.eventdata) {
-+		ret = -ENOMEM;
-+		goto err;
-+	}
-+
-+	ar->state = ATH11K_STATE_FTM;
-+	ar->ftm_msgref = 0;
-+
-+	mutex_unlock(&ar->conf_mutex);
-+
-+	ath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE, "cmd start\n");
-+	return 0;
-+
-+err:
-+	mutex_unlock(&ar->conf_mutex);
-+	return ret;
-+}
-+
- static int ath11k_tm_cmd_wmi(struct ath11k *ar, struct nlattr *tb[])
- {
- 	struct ath11k_pdev_wmi *wmi = ar->wmi;
-@@ -63,11 +307,6 @@ static int ath11k_tm_cmd_wmi(struct ath1
- 
- 	mutex_lock(&ar->conf_mutex);
- 
--	if (ar->state != ATH11K_STATE_ON) {
--		ret = -ENETDOWN;
--		goto out;
--	}
--
- 	if (!tb[ATH11K_TM_ATTR_DATA]) {
- 		ret = -EINVAL;
- 		goto out;
-@@ -80,11 +319,17 @@ static int ath11k_tm_cmd_wmi(struct ath1
- 
- 	buf = nla_data(tb[ATH11K_TM_ATTR_DATA]);
- 	buf_len = nla_len(tb[ATH11K_TM_ATTR_DATA]);
-+	if (!buf_len) {
-+		ath11k_warn(ar->ab, "No data present in testmode wmi command\n");
-+		ret = -EINVAL;
-+		goto out;
-+	}
-+
- 	cmd_id = nla_get_u32(tb[ATH11K_TM_ATTR_WMI_CMDID]);
- 
- 	ath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE,
--		   "testmode cmd wmi cmd_id %d buf %pK buf_len %d\n",
--		   cmd_id, buf, buf_len);
-+		   "cmd wmi cmd_id %d buf length %d\n",
-+		   cmd_id, buf_len);
- 
- 	ath11k_dbg_dump(ar->ab, ATH11K_DBG_TESTMODE, NULL, "", buf, buf_len);
- 
-@@ -111,6 +356,91 @@ out:
- 	return ret;
- }
- 
-+static int ath11k_tm_cmd_wmi_ftm(struct ath11k *ar, struct nlattr *tb[])
-+{
-+	struct ath11k_pdev_wmi *wmi = ar->wmi;
-+	struct ath11k_base *ab = ar->ab;
-+	struct sk_buff *skb;
-+	u32 cmd_id, buf_len, hdr_info;
-+	int ret;
-+	void *buf;
-+	u8 segnumber = 0, seginfo;
-+	u16 chunk_len, total_bytes, num_segments;
-+	u8 *bufpos;
-+	struct wmi_ftm_cmd *ftm_cmd;
-+
-+	set_bit(ATH11K_FLAG_FTM_SEGMENTED, &ab->dev_flags);
-+
-+	mutex_lock(&ar->conf_mutex);
-+
-+	if (ar->state != ATH11K_STATE_FTM) {
-+		ret = -ENETDOWN;
-+		goto out;
-+	}
-+
-+	if (!tb[ATH11K_TM_ATTR_DATA]) {
-+		ret = -EINVAL;
-+		goto out;
-+	}
-+
-+	buf = nla_data(tb[ATH11K_TM_ATTR_DATA]);
-+	buf_len = nla_len(tb[ATH11K_TM_ATTR_DATA]);
-+	cmd_id = WMI_PDEV_UTF_CMDID;
-+
-+	ath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE,
-+		   "cmd wmi ftm cmd_id %d buffer length %d\n",
-+		   cmd_id, buf_len);
-+	ath11k_dbg_dump(ar->ab, ATH11K_DBG_TESTMODE, NULL, "", buf, buf_len);
-+
-+	bufpos = buf;
-+	total_bytes = buf_len;
-+	num_segments = total_bytes / MAX_WMI_UTF_LEN;
-+
-+	if (buf_len - (num_segments * MAX_WMI_UTF_LEN))
-+		num_segments++;
-+
-+	while (buf_len) {
-+		chunk_len = min_t(u16, buf_len, MAX_WMI_UTF_LEN);
-+
-+		skb = ath11k_wmi_alloc_skb(wmi->wmi_ab, (chunk_len +
-+					   sizeof(struct wmi_ftm_cmd)));
-+		if (!skb) {
-+			ret = -ENOMEM;
-+			goto out;
-+		}
-+
-+		ftm_cmd = (struct wmi_ftm_cmd *)skb->data;
-+		hdr_info = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |
-+			   FIELD_PREP(WMI_TLV_LEN, (chunk_len +
-+				      sizeof(struct wmi_ftm_seg_hdr)));
-+		ftm_cmd->tlv_header = hdr_info;
-+		ftm_cmd->seg_hdr.len = total_bytes;
-+		ftm_cmd->seg_hdr.msgref = ar->ftm_msgref;
-+		seginfo = FIELD_PREP(ATH11K_FTM_SEGHDR_TOTAL_SEGMENTS, num_segments) |
-+			  FIELD_PREP(ATH11K_FTM_SEGHDR_CURRENT_SEQ, segnumber);
-+		ftm_cmd->seg_hdr.segmentinfo = seginfo;
-+		segnumber++;
-+
-+		memcpy(&ftm_cmd->data, bufpos, chunk_len);
-+
-+		ret = ath11k_wmi_cmd_send(wmi, skb, cmd_id);
-+		if (ret) {
-+			ath11k_warn(ar->ab, "failed to send wmi ftm command: %d\n", ret);
-+			goto out;
-+		}
-+
-+		buf_len -= chunk_len;
-+		bufpos += chunk_len;
-+	}
-+
-+	ar->ftm_msgref++;
-+	ret = 0;
-+
-+out:
-+	mutex_unlock(&ar->conf_mutex);
-+	return ret;
-+}
-+
- int ath11k_tm_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
- 		  void *data, int len)
- {
-@@ -131,6 +461,10 @@ int ath11k_tm_cmd(struct ieee80211_hw *h
- 		return ath11k_tm_cmd_get_version(ar, tb);
- 	case ATH11K_TM_CMD_WMI:
- 		return ath11k_tm_cmd_wmi(ar, tb);
-+	case ATH11K_TM_CMD_TESTMODE_START:
-+		return ath11k_tm_cmd_testmode_start(ar, tb);
-+	case ATH11K_TM_CMD_WMI_FTM:
-+		return ath11k_tm_cmd_wmi_ftm(ar, tb);
- 	default:
- 		return -EOPNOTSUPP;
- 	}
---- a/drivers/net/wireless/ath/ath11k/testmode.h
-+++ b/drivers/net/wireless/ath/ath11k/testmode.h
-@@ -8,11 +8,17 @@
- 
- #ifdef CPTCFG_NL80211_TESTMODE
- 
-+void ath11k_tm_wmi_event(struct ath11k_base *ab, u32 cmd_id, struct sk_buff *skb);
- int ath11k_tm_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
- 		  void *data, int len);
- 
- #else
- 
-+static inline void ath11k_tm_wmi_event(struct ath11k_base *ab, u32 cmd_id,
-+				       struct sk_buff *skb)
-+{
-+}
-+
- static inline int ath11k_tm_cmd(struct ieee80211_hw *hw,
- 				struct ieee80211_vif *vif,
- 				void *data, int len)
---- a/drivers/net/wireless/ath/ath11k/testmode_i.h
-+++ b/drivers/net/wireless/ath/ath11k/testmode_i.h
-@@ -1,6 +1,7 @@
- /* SPDX-License-Identifier: BSD-3-Clause-Clear */
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- /* "API" level of the ath11k testmode interface. Bump it after every
-@@ -11,9 +12,10 @@
- /* Bump this after every _compatible_ interface change, for example
-  * addition of a new command or an attribute.
-  */
--#define ATH11K_TESTMODE_VERSION_MINOR 0
-+#define ATH11K_TESTMODE_VERSION_MINOR 1
- 
- #define ATH11K_TM_DATA_MAX_LEN		5000
-+#define ATH11K_FTM_EVENT_MAX_BUF_LENGTH 2048
- 
- enum ath11k_tm_attr {
- 	__ATH11K_TM_ATTR_INVALID		= 0,
-@@ -47,4 +49,18 @@ enum ath11k_tm_cmd {
- 	 * ATH11K_TM_ATTR_DATA.
- 	 */
- 	ATH11K_TM_CMD_WMI = 1,
-+
-+	/* Boots the UTF firmware, the netdev interface must be down at the
-+	 * time.
-+	 */
-+	ATH11K_TM_CMD_TESTMODE_START = 2,
-+
-+	/* The command used to transmit a FTM WMI command to the firmware
-+	 * and the event to receive WMI events from the firmware. The data
-+	 * received only contain the payload, need to add the tlv header
-+	 * and send the cmd to firmware with command id WMI_PDEV_UTF_CMDID.
-+	 * The data payload size could be large and the driver needs to
-+	 * send segmented data to firmware.
-+	 */
-+	ATH11K_TM_CMD_WMI_FTM = 3,
- };
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2021, Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2021, 2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- #include <linux/skbuff.h>
- #include <linux/ctype.h>
-@@ -19,6 +19,7 @@
- #include "mac.h"
- #include "hw.h"
- #include "peer.h"
-+#include "testmode.h"
- 
- struct wmi_tlv_policy {
- 	size_t min_len;
-@@ -237,9 +238,8 @@ static int ath11k_wmi_tlv_parse(struct a
- 				   (void *)tb);
- }
- 
--static const void **
--ath11k_wmi_tlv_parse_alloc(struct ath11k_base *ab, const void *ptr,
--			   size_t len, gfp_t gfp)
-+const void **ath11k_wmi_tlv_parse_alloc(struct ath11k_base *ab, const void *ptr,
-+					size_t len, gfp_t gfp)
- {
- 	const void **tb;
- 	int ret;
-@@ -8628,6 +8628,9 @@ static void ath11k_wmi_tlv_op_rx(struct
- 	case WMI_PDEV_CSA_SWITCH_COUNT_STATUS_EVENTID:
- 		ath11k_wmi_pdev_csa_switch_count_status_event(ab, skb);
- 		break;
-+	case WMI_PDEV_UTF_EVENTID:
-+		ath11k_tm_wmi_event(ab, id, skb);
-+		break;
- 	case WMI_PDEV_TEMPERATURE_EVENTID:
- 		ath11k_wmi_pdev_temperature_event(ab, skb);
- 		break;
---- a/drivers/net/wireless/ath/ath11k/wmi.h
-+++ b/drivers/net/wireless/ath/ath11k/wmi.h
-@@ -1,6 +1,7 @@
- /* SPDX-License-Identifier: BSD-3-Clause-Clear */
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-+ * Copyright (c) 2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #ifndef ATH11K_WMI_H
-@@ -68,6 +69,7 @@ struct wmi_tlv {
- 
- #define WMI_APPEND_TO_EXISTING_CHAN_LIST_FLAG 1
- 
-+#define MAX_WMI_UTF_LEN 252
- #define WMI_BA_MODE_BUFFER_SIZE_256  3
- /*
-  * HW mode config type replicated from FW header
-@@ -3564,6 +3566,24 @@ struct wmi_get_pdev_temperature_cmd {
- 	u32 pdev_id;
- } __packed;
- 
-+struct wmi_ftm_seg_hdr {
-+	u32 len;
-+	u32 msgref;
-+	u32 segmentinfo;
-+	u32 pdev_id;
-+} __packed;
-+
-+struct wmi_ftm_cmd {
-+	u32 tlv_header;
-+	struct wmi_ftm_seg_hdr seg_hdr;
-+	u8 data[];
-+} __packed;
-+
-+struct wmi_ftm_event_msg {
-+	struct wmi_ftm_seg_hdr seg_hdr;
-+	u8 data[];
-+} __packed;
-+
- #define WMI_BEACON_TX_BUFFER_SIZE	512
- 
- #define WMI_EMA_TMPL_IDX_SHIFT            8
-@@ -6300,6 +6320,8 @@ enum wmi_sta_keepalive_method {
- #define WMI_STA_KEEPALIVE_INTERVAL_DEFAULT	30
- #define WMI_STA_KEEPALIVE_INTERVAL_DISABLE	0
- 
-+const void **ath11k_wmi_tlv_parse_alloc(struct ath11k_base *ab, const void *ptr,
-+					size_t len, gfp_t gfp);
- int ath11k_wmi_cmd_send(struct ath11k_pdev_wmi *wmi, struct sk_buff *skb,
- 			u32 cmd_id);
- struct sk_buff *ath11k_wmi_alloc_skb(struct ath11k_wmi_base *wmi_sc, u32 len);
---- a/drivers/net/wireless/ath/ath11k/wow.c
-+++ b/drivers/net/wireless/ath/ath11k/wow.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2020 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <linux/delay.h>
-@@ -838,6 +838,7 @@ exit:
- 		case ATH11K_STATE_RESTARTING:
- 		case ATH11K_STATE_RESTARTED:
- 		case ATH11K_STATE_WEDGED:
-+		case ATH11K_STATE_FTM:
- 			ath11k_warn(ar->ab, "encountered unexpected device state %d on resume, cannot recover\n",
- 				    ar->state);
- 			ret = -EIO;
diff --git a/package/kernel/mac80211/patches/ath11k/0083-wifi-ath11k-Allow-ath11k-to-boot-without-caldata-in-.patch b/package/kernel/mac80211/patches/ath11k/0083-wifi-ath11k-Allow-ath11k-to-boot-without-caldata-in-.patch
deleted file mode 100644
index 5a1fa882..00000000
--- a/package/kernel/mac80211/patches/ath11k/0083-wifi-ath11k-Allow-ath11k-to-boot-without-caldata-in-.patch
+++ /dev/null
@@ -1,47 +0,0 @@
-From 8aeba427296bff6a6051686f1d139c89a0b00e4c Mon Sep 17 00:00:00 2001
-From: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Date: Fri, 26 May 2023 12:41:07 +0300
-Subject: [PATCH 84/84] wifi: ath11k: Allow ath11k to boot without caldata in
- ftm mode
-
-Currently, if ath11k is unable to load the calibration data file it will
-always exit. However the calibration data may not be present in factory
-test mode, so update the logic to allow the driver to execute in FTM mode
-even if downloading the calibration data fails.
-
-Tested-on : IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Sowmiya Sree Elavalagan <quic_ssreeela@quicinc.com>
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230517135934.16408-5-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/qmi.c | 10 +++++++++-
- 1 file changed, 9 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -1,7 +1,7 @@
- // SPDX-License-Identifier: BSD-3-Clause-Clear
- /*
-  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
-- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
-+ * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
-  */
- 
- #include <linux/elf.h>
-@@ -2460,6 +2460,14 @@ static int ath11k_qmi_load_bdf_qmi(struc
- 
- 		fw_entry = ath11k_core_firmware_request(ab, ATH11K_DEFAULT_CAL_FILE);
- 		if (IS_ERR(fw_entry)) {
-+			/* Caldata may not be present during first time calibration in
-+			 * factory hence allow to boot without loading caldata in ftm mode
-+			 */
-+			if (ath11k_ftm_mode) {
-+				ath11k_info(ab,
-+					    "Booting without cal data file in factory test mode\n");
-+				return 0;
-+			}
- 			ret = PTR_ERR(fw_entry);
- 			ath11k_warn(ab,
- 				    "qmi failed to load CAL data file:%s\n",
diff --git a/package/kernel/mac80211/patches/ath11k/0084-wifi-ath11k-Add-HTT-stats-for-PHY-reset-case.patch b/package/kernel/mac80211/patches/ath11k/0084-wifi-ath11k-Add-HTT-stats-for-PHY-reset-case.patch
deleted file mode 100644
index 946f5f7b..00000000
--- a/package/kernel/mac80211/patches/ath11k/0084-wifi-ath11k-Add-HTT-stats-for-PHY-reset-case.patch
+++ /dev/null
@@ -1,261 +0,0 @@
-From 2d4f9093e2d8531ad0a2bb98fe5b36dc8addf2a2 Mon Sep 17 00:00:00 2001
-From: Nidhi Jain <quic_nidhjain@quicinc.com>
-Date: Fri, 26 May 2023 12:41:07 +0300
-Subject: [PATCH] wifi: ath11k: Add HTT stats for PHY reset case
-
-New HTT stats are added with stats type 37 to
-provide PHY reset stats and PHY reset counter stats.
-
-PHY reset stats are used to display the current
-PHY-related operation information such as band, CCA
-threshold, current operating channel etc.,
-
-PHY reset counter stats are used to display the
-PHY reset counter values like calibration counts,
-temperature based recalibration counts etc.,
-
-Usage:
-echo 37 > /sys/kernel/debug/ieee80211/phyX/ath11k/htt_stats_type
-cat /sys/kernel/debug/ieee80211/phyx/ath11k/htt_stats
-
-Output:
-
-HTT_PHY_RESET_STATS_TLV:
-pdev_id = 0
-chan_mhz = 5180
-chan_band_center_freq1 = 5210
-chan_band_center_freq2 = 0
-chan_phy_mode = 18
-chan_flags = 0x8
-chan_num = 36
-reset_cause = 0x50000
-prev_reset_cause = 0x50000
-phy_warm_reset_src = 0x0
-rx_gain_tbl_mode = 0
-xbar_val = 0xfac688
-force_calibration = 0
-phyrf_mode = 0
-phy_homechan = 0
-phy_tx_ch_mask = 0x3
-phy_rx_ch_mask = 0x3
-phybb_ini_mask = 0x5
-phyrf_ini_mask = 0x0
-phy_dfs_en_mask = 0x0
-phy_sscan_en_mask = 0x0
-phy_synth_sel_mask = 0x0
-phy_adfs_freq = 0
-cck_fir_settings = 0x0
-phy_dyn_pri_chan = 6
-cca_thresh = 0x26232020
-dyn_cca_status = 0
-rxdesense_thresh_hw = 0xcfe0afe
-rxdesense_thresh_sw = 0xcfe0afe
-
-HTT_PHY_RESET_COUNTERS_TLV:
-pdev_id = 0
-cf_active_low_fail_cnt = 0
-cf_active_low_pass_cnt = 0
-phy_off_through_vreg_cnt = 0
-force_calibration_cnt = 0
-rf_mode_switch_phy_off_cnt = 0
-
-Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Nidhi Jain <quic_nidhjain@quicinc.com>
-Signed-off-by: Maharaja Kennadyrajan <quic_mkenna@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230517141242.2754293-1-quic_mkenna@quicinc.com
----
- .../wireless/ath/ath11k/debugfs_htt_stats.c   | 114 ++++++++++++++++++
- .../wireless/ath/ath11k/debugfs_htt_stats.h   |  43 +++++++
- 2 files changed, 157 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/debugfs_htt_stats.c
-+++ b/drivers/net/wireless/ath/ath11k/debugfs_htt_stats.c
-@@ -4011,6 +4011,114 @@ void htt_print_phy_stats_tlv(const void
- 	stats_req->buf_len = len;
- }
- 
-+static inline void
-+htt_print_phy_reset_counters_tlv(const void *tag_buf,
-+				 u16 tag_len,
-+				 struct debug_htt_stats_req *stats_req)
-+{
-+	const struct htt_phy_reset_counters_tlv *htt_stats_buf = tag_buf;
-+	u8 *buf = stats_req->buf;
-+	u32 len = stats_req->buf_len;
-+	u32 buf_len = ATH11K_HTT_STATS_BUF_SIZE;
-+
-+	if (tag_len < sizeof(*htt_stats_buf))
-+		return;
-+
-+	len += scnprintf(buf + len, buf_len - len, "HTT_PHY_RESET_COUNTERS_TLV:\n");
-+
-+	len += scnprintf(buf + len, buf_len - len, "pdev_id = %u\n",
-+			 htt_stats_buf->pdev_id);
-+	len += scnprintf(buf + len, buf_len - len, "cf_active_low_fail_cnt = %u\n",
-+			 htt_stats_buf->cf_active_low_fail_cnt);
-+	len += scnprintf(buf + len, buf_len - len, "cf_active_low_pass_cnt = %u\n",
-+			 htt_stats_buf->cf_active_low_pass_cnt);
-+	len += scnprintf(buf + len, buf_len - len, "phy_off_through_vreg_cnt = %u\n",
-+			 htt_stats_buf->phy_off_through_vreg_cnt);
-+	len += scnprintf(buf + len, buf_len - len, "force_calibration_cnt = %u\n",
-+			 htt_stats_buf->force_calibration_cnt);
-+	len += scnprintf(buf + len, buf_len - len, "rf_mode_switch_phy_off_cnt = %u\n",
-+			 htt_stats_buf->rf_mode_switch_phy_off_cnt);
-+
-+	stats_req->buf_len = len;
-+}
-+
-+static inline void
-+htt_print_phy_reset_stats_tlv(const void *tag_buf,
-+			      u16 tag_len,
-+			      struct debug_htt_stats_req *stats_req)
-+{
-+	const struct htt_phy_reset_stats_tlv *htt_stats_buf = tag_buf;
-+	u8 *buf = stats_req->buf;
-+	u32 len = stats_req->buf_len;
-+	u32 buf_len = ATH11K_HTT_STATS_BUF_SIZE;
-+
-+	if (tag_len < sizeof(*htt_stats_buf))
-+		return;
-+
-+	len += scnprintf(buf + len, buf_len - len, "HTT_PHY_RESET_STATS_TLV:\n");
-+
-+	len += scnprintf(buf + len, buf_len - len, "pdev_id = %u\n",
-+			 htt_stats_buf->pdev_id);
-+	len += scnprintf(buf + len, buf_len - len, "chan_mhz = %u\n",
-+			 htt_stats_buf->chan_mhz);
-+	len += scnprintf(buf + len, buf_len - len, "chan_band_center_freq1 = %u\n",
-+			 htt_stats_buf->chan_band_center_freq1);
-+	len += scnprintf(buf + len, buf_len - len, "chan_band_center_freq2 = %u\n",
-+			 htt_stats_buf->chan_band_center_freq2);
-+	len += scnprintf(buf + len, buf_len - len, "chan_phy_mode = %u\n",
-+			 htt_stats_buf->chan_phy_mode);
-+	len += scnprintf(buf + len, buf_len - len, "chan_flags = 0x%0x\n",
-+			 htt_stats_buf->chan_flags);
-+	len += scnprintf(buf + len, buf_len - len, "chan_num = %u\n",
-+			 htt_stats_buf->chan_num);
-+	len += scnprintf(buf + len, buf_len - len, "reset_cause = 0x%0x\n",
-+			 htt_stats_buf->reset_cause);
-+	len += scnprintf(buf + len, buf_len - len, "prev_reset_cause = 0x%0x\n",
-+			 htt_stats_buf->prev_reset_cause);
-+	len += scnprintf(buf + len, buf_len - len, "phy_warm_reset_src = 0x%0x\n",
-+			 htt_stats_buf->phy_warm_reset_src);
-+	len += scnprintf(buf + len, buf_len - len, "rx_gain_tbl_mode = %d\n",
-+			 htt_stats_buf->rx_gain_tbl_mode);
-+	len += scnprintf(buf + len, buf_len - len, "xbar_val = 0x%0x\n",
-+			 htt_stats_buf->xbar_val);
-+	len += scnprintf(buf + len, buf_len - len, "force_calibration = %u\n",
-+			 htt_stats_buf->force_calibration);
-+	len += scnprintf(buf + len, buf_len - len, "phyrf_mode = %u\n",
-+			 htt_stats_buf->phyrf_mode);
-+	len += scnprintf(buf + len, buf_len - len, "phy_homechan = %u\n",
-+			 htt_stats_buf->phy_homechan);
-+	len += scnprintf(buf + len, buf_len - len, "phy_tx_ch_mask = 0x%0x\n",
-+			 htt_stats_buf->phy_tx_ch_mask);
-+	len += scnprintf(buf + len, buf_len - len, "phy_rx_ch_mask = 0x%0x\n",
-+			 htt_stats_buf->phy_rx_ch_mask);
-+	len += scnprintf(buf + len, buf_len - len, "phybb_ini_mask = 0x%0x\n",
-+			 htt_stats_buf->phybb_ini_mask);
-+	len += scnprintf(buf + len, buf_len - len, "phyrf_ini_mask = 0x%0x\n",
-+			 htt_stats_buf->phyrf_ini_mask);
-+	len += scnprintf(buf + len, buf_len - len, "phy_dfs_en_mask = 0x%0x\n",
-+			 htt_stats_buf->phy_dfs_en_mask);
-+	len += scnprintf(buf + len, buf_len - len, "phy_sscan_en_mask = 0x%0x\n",
-+			 htt_stats_buf->phy_sscan_en_mask);
-+	len += scnprintf(buf + len, buf_len - len, "phy_synth_sel_mask = 0x%0x\n",
-+			 htt_stats_buf->phy_synth_sel_mask);
-+	len += scnprintf(buf + len, buf_len - len, "phy_adfs_freq = %u\n",
-+			 htt_stats_buf->phy_adfs_freq);
-+	len += scnprintf(buf + len, buf_len - len, "cck_fir_settings = 0x%0x\n",
-+			 htt_stats_buf->cck_fir_settings);
-+	len += scnprintf(buf + len, buf_len - len, "phy_dyn_pri_chan = %u\n",
-+			 htt_stats_buf->phy_dyn_pri_chan);
-+	len += scnprintf(buf + len, buf_len - len, "cca_thresh = 0x%0x\n",
-+			 htt_stats_buf->cca_thresh);
-+	len += scnprintf(buf + len, buf_len - len, "dyn_cca_status = %u\n",
-+			 htt_stats_buf->dyn_cca_status);
-+	len += scnprintf(buf + len, buf_len - len, "rxdesense_thresh_hw = 0x%x\n",
-+			 htt_stats_buf->rxdesense_thresh_hw);
-+	len += scnprintf(buf + len, buf_len - len, "rxdesense_thresh_sw = 0x%x\n",
-+			 htt_stats_buf->rxdesense_thresh_sw);
-+
-+	stats_req->buf_len = len;
-+}
-+
- static inline
- void htt_print_peer_ctrl_path_txrx_stats_tlv(const void *tag_buf,
- 					     struct debug_htt_stats_req *stats_req)
-@@ -4425,6 +4533,12 @@ static int ath11k_dbg_htt_ext_stats_pars
- 	case HTT_STATS_PHY_STATS_TAG:
- 		htt_print_phy_stats_tlv(tag_buf, stats_req);
- 		break;
-+	case HTT_STATS_PHY_RESET_COUNTERS_TAG:
-+		htt_print_phy_reset_counters_tlv(tag_buf, len, stats_req);
-+		break;
-+	case HTT_STATS_PHY_RESET_STATS_TAG:
-+		htt_print_phy_reset_stats_tlv(tag_buf, len, stats_req);
-+		break;
- 	case HTT_STATS_PEER_CTRL_PATH_TXRX_STATS_TAG:
- 		htt_print_peer_ctrl_path_txrx_stats_tlv(tag_buf, stats_req);
- 		break;
---- a/drivers/net/wireless/ath/ath11k/debugfs_htt_stats.h
-+++ b/drivers/net/wireless/ath/ath11k/debugfs_htt_stats.h
-@@ -111,6 +111,8 @@ enum htt_tlv_tag_t {
- 	HTT_STATS_TXBF_OFDMA_STEER_STATS_TAG		    = 116,
- 	HTT_STATS_PHY_COUNTERS_TAG			    = 121,
- 	HTT_STATS_PHY_STATS_TAG				    = 122,
-+	HTT_STATS_PHY_RESET_COUNTERS_TAG		    = 123,
-+	HTT_STATS_PHY_RESET_STATS_TAG			    = 124,
- 
- 	HTT_STATS_MAX_TAG,
- };
-@@ -1964,6 +1966,47 @@ struct htt_phy_stats_tlv {
- 	u32 fw_run_time;
- };
- 
-+struct htt_phy_reset_counters_tlv {
-+	u32 pdev_id;
-+	u32 cf_active_low_fail_cnt;
-+	u32 cf_active_low_pass_cnt;
-+	u32 phy_off_through_vreg_cnt;
-+	u32 force_calibration_cnt;
-+	u32 rf_mode_switch_phy_off_cnt;
-+};
-+
-+struct htt_phy_reset_stats_tlv {
-+	u32 pdev_id;
-+	u32 chan_mhz;
-+	u32 chan_band_center_freq1;
-+	u32 chan_band_center_freq2;
-+	u32 chan_phy_mode;
-+	u32 chan_flags;
-+	u32 chan_num;
-+	u32 reset_cause;
-+	u32 prev_reset_cause;
-+	u32 phy_warm_reset_src;
-+	u32 rx_gain_tbl_mode;
-+	u32 xbar_val;
-+	u32 force_calibration;
-+	u32 phyrf_mode;
-+	u32 phy_homechan;
-+	u32 phy_tx_ch_mask;
-+	u32 phy_rx_ch_mask;
-+	u32 phybb_ini_mask;
-+	u32 phyrf_ini_mask;
-+	u32 phy_dfs_en_mask;
-+	u32 phy_sscan_en_mask;
-+	u32 phy_synth_sel_mask;
-+	u32 phy_adfs_freq;
-+	u32 cck_fir_settings;
-+	u32 phy_dyn_pri_chan;
-+	u32 cca_thresh;
-+	u32 dyn_cca_status;
-+	u32 rxdesense_thresh_hw;
-+	u32 rxdesense_thresh_sw;
-+};
-+
- struct htt_peer_ctrl_path_txrx_stats_tlv {
- 	/* peer mac address */
- 	u8 peer_mac_addr[ETH_ALEN];
diff --git a/package/kernel/mac80211/patches/ath11k/0085-wifi-ath11k-fix-memory-leak-in-WMI-firmware-stats.patch b/package/kernel/mac80211/patches/ath11k/0085-wifi-ath11k-fix-memory-leak-in-WMI-firmware-stats.patch
deleted file mode 100644
index dde30b96..00000000
--- a/package/kernel/mac80211/patches/ath11k/0085-wifi-ath11k-fix-memory-leak-in-WMI-firmware-stats.patch
+++ /dev/null
@@ -1,51 +0,0 @@
-From 6aafa1c2d3e3fea2ebe84c018003f2a91722e607 Mon Sep 17 00:00:00 2001
-From: P Praneesh <quic_ppranees@quicinc.com>
-Date: Tue, 6 Jun 2023 14:41:28 +0530
-Subject: [PATCH] wifi: ath11k: fix memory leak in WMI firmware stats
-
-Memory allocated for firmware pdev, vdev and beacon statistics
-are not released during rmmod.
-
-Fix it by calling ath11k_fw_stats_free() function before hardware
-unregister.
-
-While at it, avoid calling ath11k_fw_stats_free() while processing
-the firmware stats received in the WMI event because the local list
-is getting spliced and reinitialised and hence there are no elements
-in the list after splicing.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: P Praneesh <quic_ppranees@quicinc.com>
-Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230606091128.14202-1-quic_adisi@quicinc.com
----
- drivers/net/wireless/ath/ath11k/mac.c | 1 +
- drivers/net/wireless/ath/ath11k/wmi.c | 5 +++++
- 2 files changed, 6 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -9792,6 +9792,7 @@ void ath11k_mac_destroy(struct ath11k_ba
- 		if (!ar)
- 			continue;
- 
-+		ath11k_fw_stats_free(&ar->fw_stats);
- 		ieee80211_free_hw(ar->hw);
- 		pdev->ar = NULL;
- 	}
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -8119,6 +8119,11 @@ complete:
- 	rcu_read_unlock();
- 	spin_unlock_bh(&ar->data_lock);
- 
-+	/* Since the stats's pdev, vdev and beacon list are spliced and reinitialised
-+	 * at this point, no need to free the individual list.
-+	 */
-+	return;
-+
- free:
- 	ath11k_fw_stats_free(&stats);
- }
diff --git a/package/kernel/mac80211/patches/ath11k/0086-wifi-ath11k-Add-missing-check-for-ioremap.patch b/package/kernel/mac80211/patches/ath11k/0086-wifi-ath11k-Add-missing-check-for-ioremap.patch
deleted file mode 100644
index e536c3bd..00000000
--- a/package/kernel/mac80211/patches/ath11k/0086-wifi-ath11k-Add-missing-check-for-ioremap.patch
+++ /dev/null
@@ -1,38 +0,0 @@
-From 16e0077e14a73866e9b0f4a6bf4ad3d4a5cb0f2a Mon Sep 17 00:00:00 2001
-From: Jiasheng Jiang <jiasheng@iscas.ac.cn>
-Date: Tue, 13 Jun 2023 12:19:40 +0300
-Subject: [PATCH] wifi: ath11k: Add missing check for ioremap
-
-Add check for ioremap() and return the error if it fails in order to
-guarantee the success of ioremap(), same as in
-ath11k_qmi_load_file_target_mem().
-
-Fixes: 6ac04bdc5edb ("ath11k: Use reserved host DDR addresses from DT for PCI devices")
-Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230608022858.27405-1-jiasheng@iscas.ac.cn
----
- drivers/net/wireless/ath/ath11k/qmi.c | 5 +++++
- 1 file changed, 5 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -2061,6 +2061,9 @@ static int ath11k_qmi_assign_target_mem_
- 			ab->qmi.target_mem[idx].iaddr =
- 				ioremap(ab->qmi.target_mem[idx].paddr,
- 					ab->qmi.target_mem[i].size);
-+			if (!ab->qmi.target_mem[idx].iaddr)
-+				return -EIO;
-+
- 			ab->qmi.target_mem[idx].size = ab->qmi.target_mem[i].size;
- 			host_ddr_sz = ab->qmi.target_mem[i].size;
- 			ab->qmi.target_mem[idx].type = ab->qmi.target_mem[i].type;
-@@ -2086,6 +2089,8 @@ static int ath11k_qmi_assign_target_mem_
- 					ab->qmi.target_mem[idx].iaddr =
- 						ioremap(ab->qmi.target_mem[idx].paddr,
- 							ab->qmi.target_mem[i].size);
-+					if (!ab->qmi.target_mem[idx].iaddr)
-+						return -EIO;
- 				} else {
- 					ab->qmi.target_mem[idx].paddr =
- 						ATH11K_QMI_CALDB_ADDRESS;
diff --git a/package/kernel/mac80211/patches/ath11k/0087-wifi-ath11k-Add-missing-ops-config-for-IPQ5018-in.patch b/package/kernel/mac80211/patches/ath11k/0087-wifi-ath11k-Add-missing-ops-config-for-IPQ5018-in.patch
deleted file mode 100644
index fa539ef4..00000000
--- a/package/kernel/mac80211/patches/ath11k/0087-wifi-ath11k-Add-missing-ops-config-for-IPQ5018-in.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From 469ddb20cae61cad9c4f208a4c8682305905a511 Mon Sep 17 00:00:00 2001
-From: Ziyang Huang <hzyitc@outlook.com>
-Date: Thu, 15 Jun 2023 14:41:47 +0300
-Subject: [PATCH] wifi: ath11k: Add missing ops config for IPQ5018 in
- ath11k_ahb_probe()
-
-Without this patch, the IPQ5018 WiFi will fail and print the following
-logs:
-
-	[   11.033179] ath11k c000000.wifi: unsupported device type 7
-	[   11.033223] ath11k: probe of c000000.wifi failed with error -95
-
-Fixes: 25edca7bb18a ("wifi: ath11k: add ipq5018 device support")
-Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/TYZPR01MB5556D7AA10ABEDDDD2D8F39EC953A@TYZPR01MB5556.apcprd01.prod.exchangelabs.com
----
- drivers/net/wireless/ath/ath11k/ahb.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -1127,6 +1127,7 @@ static int ath11k_ahb_probe(struct platf
- 	switch (hw_rev) {
- 	case ATH11K_HW_IPQ8074:
- 	case ATH11K_HW_IPQ6018_HW10:
-+	case ATH11K_HW_IPQ5018_HW10:
- 		hif_ops = &ath11k_ahb_hif_ops_ipq8074;
- 		pci_ops = NULL;
- 		break;
diff --git a/package/kernel/mac80211/patches/ath11k/0088-wifi-ath11k-Restart-firmware-after-cold-boot-calibration.patch b/package/kernel/mac80211/patches/ath11k/0088-wifi-ath11k-Restart-firmware-after-cold-boot-calibration.patch
deleted file mode 100644
index 4a938521..00000000
--- a/package/kernel/mac80211/patches/ath11k/0088-wifi-ath11k-Restart-firmware-after-cold-boot-calibration.patch
+++ /dev/null
@@ -1,47 +0,0 @@
-From 80c5390e1f5e5b16d820512265530ef26073d8e0 Mon Sep 17 00:00:00 2001
-From: Ziyang Huang <hzyitc@outlook.com>
-Date: Thu, 15 Jun 2023 14:41:48 +0300
-Subject: [PATCH] wifi: ath11k: Restart firmware after cold boot calibration
- for IPQ5018
-
-Restart is required after cold boot calibration on IPQ5018. Otherwise,
-we get the following exception:
-
-	[   14.412829] qcom-q6-mpd cd00000.remoteproc: fatal error received: err_smem_ver.2.1:
-	[   14.412829] QC Image Version : QC_IMAGE_VERSION_STRING=WLAN.HK.2.6.0.1-00974-QCAHKSWPL_SILICONZ-1
-	[   14.412829] Image Variant : IMAGE_VARIANT_STRING=5018.wlanfw2.map_spr_spr_evalQ
-	[   14.412829] DALSysLogEvent.c:174 Assertion 0 failed param0 :zero,param1 :zero,param2 :zero
-	[   14.412829] Thread ID : 0x00000048 Thread name : WLAN RT0 Process ID : 0x00000001 Process name :wlan0
-	[   14.412829]
-	[   14.412829] Registers:
-	[   14.412829] SP : 0x4c81c120
-	[   14.412829] FP : 0x4c81c138
-	[   14.412829] PC : 0xb022c590
-	[   14.412829] SSR : 0x00000000
-	[   14.412829] BADVA : 0x00000000
-	[   14.412829] LR : 0xb0008490
-	[   14.412829]
-	[   14.412829] StackDump
-	[   14.412829] from:0x4c81c120
-	[   14.412829] to: 0x00000000:
-	[   14.412829]
-	[   14.463006] remoteproc remoteproc0: crash detected in cd00000.remoteproc: type fatal error
-
-Fixes: 8dfe875aa24a ("wifi: ath11k: update hw params for IPQ5018")
-Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/TYZPR01MB55566969818BD4B49E770445C953A@TYZPR01MB5556.apcprd01.prod.exchangelabs.com
----
- drivers/net/wireless/ath/ath11k/core.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -668,6 +668,7 @@ static const struct ath11k_hw_params ath
- 		.hal_params = &ath11k_hw_hal_params_ipq8074,
- 		.single_pdev_only = false,
- 		.cold_boot_calib = true,
-+		.cbcal_restart_fw = true,
- 		.fix_l1ss = true,
- 		.supports_dynamic_smps_6ghz = false,
- 		.alloc_cacheable_memory = true,
diff --git a/package/kernel/mac80211/patches/ath11k/0089-wifi-ath11k-Add-missing-hw_ops-get_ring_selector-for.patch b/package/kernel/mac80211/patches/ath11k/0089-wifi-ath11k-Add-missing-hw_ops-get_ring_selector-for.patch
deleted file mode 100644
index cb6667f1..00000000
--- a/package/kernel/mac80211/patches/ath11k/0089-wifi-ath11k-Add-missing-hw_ops-get_ring_selector-for.patch
+++ /dev/null
@@ -1,58 +0,0 @@
-From ce282d8de71f07f0056ea319541141152c65f552 Mon Sep 17 00:00:00 2001
-From: Ziyang Huang <hzyitc@outlook.com>
-Date: Thu, 15 Jun 2023 14:41:48 +0300
-Subject: [PATCH] wifi: ath11k: Add missing hw_ops->get_ring_selector() for
- IPQ5018
-
-During sending data after clients connected, hw_ops->get_ring_selector()
-will be called. But for IPQ5018, this member isn't set, and the
-following NULL pointer exception will be occurred:
-
-	[   38.840478] 8<--- cut here ---
-	[   38.840517] Unable to handle kernel NULL pointer dereference at virtual address 00000000
-	...
-	[   38.923161] PC is at 0x0
-	[   38.927930] LR is at ath11k_dp_tx+0x70/0x730 [ath11k]
-	...
-	[   39.063264] Process hostapd (pid: 1034, stack limit = 0x801ceb3d)
-	[   39.068994] Stack: (0x856a9a68 to 0x856aa000)
-	...
-	[   39.438467] [<7f323804>] (ath11k_dp_tx [ath11k]) from [<7f314e6c>] (ath11k_mac_op_tx+0x80/0x190 [ath11k])
-	[   39.446607] [<7f314e6c>] (ath11k_mac_op_tx [ath11k]) from [<7f17dbe0>] (ieee80211_handle_wake_tx_queue+0x7c/0xc0 [mac80211])
-	[   39.456162] [<7f17dbe0>] (ieee80211_handle_wake_tx_queue [mac80211]) from [<7f174450>] (ieee80211_probereq_get+0x584/0x704 [mac80211])
-	[   39.467443] [<7f174450>] (ieee80211_probereq_get [mac80211]) from [<7f178c40>] (ieee80211_tx_prepare_skb+0x1f8/0x248 [mac80211])
-	[   39.479334] [<7f178c40>] (ieee80211_tx_prepare_skb [mac80211]) from [<7f179e28>] (__ieee80211_subif_start_xmit+0x32c/0x3d4 [mac80211])
-	[   39.491053] [<7f179e28>] (__ieee80211_subif_start_xmit [mac80211]) from [<7f17af08>] (ieee80211_tx_control_port+0x19c/0x288 [mac80211])
-	[   39.502946] [<7f17af08>] (ieee80211_tx_control_port [mac80211]) from [<7f0fc704>] (nl80211_tx_control_port+0x174/0x1d4 [cfg80211])
-	[   39.515017] [<7f0fc704>] (nl80211_tx_control_port [cfg80211]) from [<808ceac4>] (genl_rcv_msg+0x154/0x340)
-	[   39.526814] [<808ceac4>] (genl_rcv_msg) from [<808cdb74>] (netlink_rcv_skb+0xb8/0x11c)
-	[   39.536446] [<808cdb74>] (netlink_rcv_skb) from [<808ce1d0>] (genl_rcv+0x28/0x34)
-	[   39.544344] [<808ce1d0>] (genl_rcv) from [<808cd234>] (netlink_unicast+0x174/0x274)
-	[   39.551895] [<808cd234>] (netlink_unicast) from [<808cd510>] (netlink_sendmsg+0x1dc/0x440)
-	[   39.559362] [<808cd510>] (netlink_sendmsg) from [<808596e0>] (____sys_sendmsg+0x1a8/0x1fc)
-	[   39.567697] [<808596e0>] (____sys_sendmsg) from [<8085b1a8>] (___sys_sendmsg+0xa4/0xdc)
-	[   39.575941] [<8085b1a8>] (___sys_sendmsg) from [<8085b310>] (sys_sendmsg+0x44/0x74)
-	[   39.583841] [<8085b310>] (sys_sendmsg) from [<80300060>] (ret_fast_syscall+0x0/0x40)
-	...
-	[   39.620734] Code: bad PC value
-	[   39.625869] ---[ end trace 8aef983ad3cbc032 ]---
-
-Fixes: ba60f2793d3a ("wifi: ath11k: initialize hw_ops for IPQ5018")
-Signed-off-by: Ziyang Huang <hzyitc@outlook.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/TYZPR01MB5556D6E3F63EAB5129D11420C953A@TYZPR01MB5556.apcprd01.prod.exchangelabs.com
----
- drivers/net/wireless/ath/ath11k/hw.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/hw.c
-+++ b/drivers/net/wireless/ath/ath11k/hw.c
-@@ -1178,7 +1178,7 @@ const struct ath11k_hw_ops ipq5018_ops =
- 	.mpdu_info_get_peerid = ath11k_hw_ipq8074_mpdu_info_get_peerid,
- 	.rx_desc_mac_addr2_valid = ath11k_hw_ipq9074_rx_desc_mac_addr2_valid,
- 	.rx_desc_mpdu_start_addr2 = ath11k_hw_ipq9074_rx_desc_mpdu_start_addr2,
--
-+	.get_ring_selector = ath11k_hw_ipq8074_get_tcl_ring_selector,
- };
- 
- #define ATH11K_TX_RING_MASK_0 BIT(0)
diff --git a/package/kernel/mac80211/patches/ath11k/0090-Revert-wifi-ath11k-Enable-threaded-NAPI.patch b/package/kernel/mac80211/patches/ath11k/0090-Revert-wifi-ath11k-Enable-threaded-NAPI.patch
deleted file mode 100644
index 313c18c5..00000000
--- a/package/kernel/mac80211/patches/ath11k/0090-Revert-wifi-ath11k-Enable-threaded-NAPI.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From d265ebe41c911314bd273c218a37088835959fa1 Mon Sep 17 00:00:00 2001
-From: Kalle Valo <quic_kvalo@quicinc.com>
-Date: Thu, 20 Jul 2023 18:14:44 +0300
-Subject: [PATCH] Revert "wifi: ath11k: Enable threaded NAPI"
-
-This reverts commit 13aa2fb692d3717767303817f35b3e650109add3.
-
-This commit broke QCN9074 initialisation:
-
-[  358.960477] ath11k_pci 0000:04:00.0: ce desc not available for wmi command 36866
-[  358.960481] ath11k_pci 0000:04:00.0: failed to send WMI_STA_POWERSAVE_PARAM_CMDID
-[  358.960484] ath11k_pci 0000:04:00.0: could not set uapsd params -105
-
-As there's no fix available let's just revert it to get QCN9074 working again.
-
-Closes: https://bugzilla.kernel.org/show_bug.cgi?id=217536
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Signed-off-by: Kalle Valo <kvalo@kernel.org>
-Link: https://lore.kernel.org/r/20230720151444.2016637-1-kvalo@kernel.org
----
- drivers/net/wireless/ath/ath11k/ahb.c  | 1 -
- drivers/net/wireless/ath/ath11k/pcic.c | 1 -
- 2 files changed, 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -376,7 +376,6 @@ static void ath11k_ahb_ext_irq_enable(st
- 		struct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
- 
- 		if (!irq_grp->napi_enabled) {
--			dev_set_threaded(&irq_grp->napi_ndev, true);
- 			napi_enable(&irq_grp->napi);
- 			irq_grp->napi_enabled = true;
- 		}
---- a/drivers/net/wireless/ath/ath11k/pcic.c
-+++ b/drivers/net/wireless/ath/ath11k/pcic.c
-@@ -466,7 +466,6 @@ void ath11k_pcic_ext_irq_enable(struct a
- 		struct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];
- 
- 		if (!irq_grp->napi_enabled) {
--			dev_set_threaded(&irq_grp->napi_ndev, true);
- 			napi_enable(&irq_grp->napi);
- 			irq_grp->napi_enabled = true;
- 		}
diff --git a/package/kernel/mac80211/patches/ath11k/0091-wifi-ath11k-Split-coldboot-calibration-hw_param.patch b/package/kernel/mac80211/patches/ath11k/0091-wifi-ath11k-Split-coldboot-calibration-hw_param.patch
deleted file mode 100644
index 47053546..00000000
--- a/package/kernel/mac80211/patches/ath11k/0091-wifi-ath11k-Split-coldboot-calibration-hw_param.patch
+++ /dev/null
@@ -1,180 +0,0 @@
-From 011e5a3052a22d3758d17442bf0c04c68bf79bea Mon Sep 17 00:00:00 2001
-From: Seevalamuthu Mariappan <quic_seevalam@quicinc.com>
-Date: Wed, 26 Jul 2023 19:40:30 +0530
-Subject: [PATCH 3/5] wifi: ath11k: Split coldboot calibration hw_param
-
-QCN9074 enables coldboot calibration only in Factory Test Mode (FTM).
-Hence, split cold_boot_calib to two hw_params for mission and FTM
-mode.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Seevalamuthu Mariappan <quic_seevalam@quicinc.com>
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230726141032.3061-2-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/ahb.c  |  3 +--
- drivers/net/wireless/ath/ath11k/core.c | 36 ++++++++++++++++++++------
- drivers/net/wireless/ath/ath11k/core.h |  1 +
- drivers/net/wireless/ath/ath11k/hw.h   |  3 ++-
- drivers/net/wireless/ath/ath11k/qmi.c  |  6 ++---
- 5 files changed, 35 insertions(+), 14 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -422,8 +422,7 @@ static int ath11k_ahb_fwreset_from_cold_
- {
- 	int timeout;
- 
--	if (ath11k_cold_boot_cal == 0 || ab->qmi.cal_done ||
--	    ab->hw_params.cold_boot_calib == 0 ||
-+	if (!ath11k_core_coldboot_cal_support(ab) || ab->qmi.cal_done ||
- 	    ab->hw_params.cbcal_restart_fw == 0)
- 		return 0;
- 
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -86,7 +86,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = false,
- 		.idle_ps = false,
- 		.supports_sta_ps = false,
--		.cold_boot_calib = true,
-+		.coldboot_cal_mm = true,
-+		.coldboot_cal_ftm = true,
- 		.cbcal_restart_fw = true,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
-@@ -167,7 +168,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = false,
- 		.idle_ps = false,
- 		.supports_sta_ps = false,
--		.cold_boot_calib = true,
-+		.coldboot_cal_mm = true,
-+		.coldboot_cal_ftm = true,
- 		.cbcal_restart_fw = true,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
-@@ -248,7 +250,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = true,
- 		.idle_ps = true,
- 		.supports_sta_ps = true,
--		.cold_boot_calib = false,
-+		.coldboot_cal_mm = false,
-+		.coldboot_cal_ftm = false,
- 		.cbcal_restart_fw = false,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
-@@ -332,7 +335,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = false,
- 		.idle_ps = false,
- 		.supports_sta_ps = false,
--		.cold_boot_calib = false,
-+		.coldboot_cal_mm = false,
-+		.coldboot_cal_ftm = false,
- 		.cbcal_restart_fw = false,
- 		.fw_mem_mode = 2,
- 		.num_vdevs = 8,
-@@ -413,7 +417,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = true,
- 		.idle_ps = true,
- 		.supports_sta_ps = true,
--		.cold_boot_calib = false,
-+		.coldboot_cal_mm = false,
-+		.coldboot_cal_ftm = false,
- 		.cbcal_restart_fw = false,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
-@@ -495,7 +500,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = true,
- 		.idle_ps = true,
- 		.supports_sta_ps = true,
--		.cold_boot_calib = false,
-+		.coldboot_cal_mm = false,
-+		.coldboot_cal_ftm = false,
- 		.cbcal_restart_fw = false,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
-@@ -578,7 +584,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = true,
- 		.idle_ps = true,
- 		.supports_sta_ps = true,
--		.cold_boot_calib = true,
-+		.coldboot_cal_mm = true,
-+		.coldboot_cal_ftm = true,
- 		.cbcal_restart_fw = false,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
-@@ -667,7 +674,8 @@ static const struct ath11k_hw_params ath
- 		.supports_suspend = false,
- 		.hal_params = &ath11k_hw_hal_params_ipq8074,
- 		.single_pdev_only = false,
--		.cold_boot_calib = true,
-+		.coldboot_cal_mm = true,
-+		.coldboot_cal_ftm = true,
- 		.cbcal_restart_fw = true,
- 		.fix_l1ss = true,
- 		.supports_dynamic_smps_6ghz = false,
-@@ -749,6 +757,18 @@ void ath11k_fw_stats_free(struct ath11k_
- 	ath11k_fw_stats_bcn_free(&stats->bcn);
- }
- 
-+bool ath11k_core_coldboot_cal_support(struct ath11k_base *ab)
-+{
-+	if (!ath11k_cold_boot_cal)
-+		return false;
-+
-+	if (ath11k_ftm_mode)
-+		return ab->hw_params.coldboot_cal_ftm;
-+
-+	else
-+		return ab->hw_params.coldboot_cal_mm;
-+}
-+
- int ath11k_core_suspend(struct ath11k_base *ab)
- {
- 	int ret;
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -1186,6 +1186,7 @@ void ath11k_core_halt(struct ath11k *ar)
- int ath11k_core_resume(struct ath11k_base *ab);
- int ath11k_core_suspend(struct ath11k_base *ab);
- void ath11k_core_pre_reconfigure_recovery(struct ath11k_base *ab);
-+bool ath11k_core_coldboot_cal_support(struct ath11k_base *ab);
- 
- const struct firmware *ath11k_core_firmware_request(struct ath11k_base *ab,
- 						    const char *filename);
---- a/drivers/net/wireless/ath/ath11k/hw.h
-+++ b/drivers/net/wireless/ath/ath11k/hw.h
-@@ -187,7 +187,8 @@ struct ath11k_hw_params {
- 	bool supports_shadow_regs;
- 	bool idle_ps;
- 	bool supports_sta_ps;
--	bool cold_boot_calib;
-+	bool coldboot_cal_mm;
-+	bool coldboot_cal_ftm;
- 	bool cbcal_restart_fw;
- 	int fw_mem_mode;
- 	u32 num_vdevs;
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -2082,7 +2082,7 @@ static int ath11k_qmi_assign_target_mem_
- 				return -EINVAL;
- 			}
- 
--			if (ath11k_cold_boot_cal && ab->hw_params.cold_boot_calib) {
-+			if (ath11k_core_coldboot_cal_support(ab)) {
- 				if (hremote_node) {
- 					ab->qmi.target_mem[idx].paddr =
- 							res.start + host_ddr_sz;
-@@ -3212,8 +3212,8 @@ static void ath11k_qmi_driver_event_work
- 				break;
- 			}
- 
--			if (ath11k_cold_boot_cal && ab->qmi.cal_done == 0 &&
--			    ab->hw_params.cold_boot_calib) {
-+			if (ab->qmi.cal_done == 0 &&
-+			    ath11k_core_coldboot_cal_support(ab)) {
- 				ath11k_qmi_process_coldboot_calibration(ab);
- 			} else {
- 				clear_bit(ATH11K_FLAG_CRASH_FLUSH,
diff --git a/package/kernel/mac80211/patches/ath11k/0092-wifi-ath11k-Add-coldboot-calibration-support-for-QCN.patch b/package/kernel/mac80211/patches/ath11k/0092-wifi-ath11k-Add-coldboot-calibration-support-for-QCN.patch
deleted file mode 100644
index 31b11dde..00000000
--- a/package/kernel/mac80211/patches/ath11k/0092-wifi-ath11k-Add-coldboot-calibration-support-for-QCN.patch
+++ /dev/null
@@ -1,176 +0,0 @@
-From bdfc967bf5fcd762473a01d39edb81f1165ba290 Mon Sep 17 00:00:00 2001
-From: Anilkumar Kolli <quic_akolli@quicinc.com>
-Date: Wed, 26 Jul 2023 19:40:31 +0530
-Subject: [PATCH 4/5] wifi: ath11k: Add coldboot calibration support for
- QCN9074
-
-QCN9074 supports 6 GHz, which has increased number of channels
-compared to 5 GHz/2 GHz. So, to support coldboot calibration in
-QCN9074 ATH11K_COLD_BOOT_FW_RESET_DELAY extended to 60 seconds. To
-avoid code redundancy, fwreset_from_cold_boot moved to QMI and made
-common for both ahb and pci. Coldboot calibration is enabled only in
-FTM mode for QCN9074. QCN9074 requires firmware restart after coldboot,
-hence enable cbcal_restart_fw in hw_params.
-
-This support can be enabled/disabled using hw params for different
-hardware. Currently it is not enabled for QCA6390.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Anilkumar Kolli <quic_akolli@quicinc.com>
-Signed-off-by: Seevalamuthu Mariappan <quic_seevalam@quicinc.com>
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230726141032.3061-3-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/ahb.c  | 28 ++------------------------
- drivers/net/wireless/ath/ath11k/core.c |  4 ++--
- drivers/net/wireless/ath/ath11k/pci.c  |  2 ++
- drivers/net/wireless/ath/ath11k/qmi.c  | 28 ++++++++++++++++++++++++++
- drivers/net/wireless/ath/ath11k/qmi.h  |  3 ++-
- 5 files changed, 36 insertions(+), 29 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -14,6 +14,7 @@
- #include "ahb.h"
- #include "debug.h"
- #include "hif.h"
-+#include "qmi.h"
- #include <linux/remoteproc.h>
- #include "pcic.h"
- #include <linux/soc/qcom/smem.h>
-@@ -418,31 +419,6 @@ static void ath11k_ahb_power_down(struct
- 	rproc_shutdown(ab_ahb->tgt_rproc);
- }
- 
--static int ath11k_ahb_fwreset_from_cold_boot(struct ath11k_base *ab)
--{
--	int timeout;
--
--	if (!ath11k_core_coldboot_cal_support(ab) || ab->qmi.cal_done ||
--	    ab->hw_params.cbcal_restart_fw == 0)
--		return 0;
--
--	ath11k_dbg(ab, ATH11K_DBG_AHB, "wait for cold boot done\n");
--	timeout = wait_event_timeout(ab->qmi.cold_boot_waitq,
--				     (ab->qmi.cal_done  == 1),
--				     ATH11K_COLD_BOOT_FW_RESET_DELAY);
--	if (timeout <= 0) {
--		ath11k_cold_boot_cal = 0;
--		ath11k_warn(ab, "Coldboot Calibration failed timed out\n");
--	}
--
--	/* reset the firmware */
--	ath11k_ahb_power_down(ab);
--	ath11k_ahb_power_up(ab);
--
--	ath11k_dbg(ab, ATH11K_DBG_AHB, "exited from cold boot mode\n");
--	return 0;
--}
--
- static void ath11k_ahb_init_qmi_ce_config(struct ath11k_base *ab)
- {
- 	struct ath11k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;
-@@ -1225,7 +1201,7 @@ static int ath11k_ahb_probe(struct platf
- 		goto err_ce_free;
- 	}
- 
--	ath11k_ahb_fwreset_from_cold_boot(ab);
-+	ath11k_qmi_fwreset_from_cold_boot(ab);
- 
- 	return 0;
- 
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -336,8 +336,8 @@ static const struct ath11k_hw_params ath
- 		.idle_ps = false,
- 		.supports_sta_ps = false,
- 		.coldboot_cal_mm = false,
--		.coldboot_cal_ftm = false,
--		.cbcal_restart_fw = false,
-+		.coldboot_cal_ftm = true,
-+		.cbcal_restart_fw = true,
- 		.fw_mem_mode = 2,
- 		.num_vdevs = 8,
- 		.num_peers = 128,
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -15,6 +15,7 @@
- #include "mhi.h"
- #include "debug.h"
- #include "pcic.h"
-+#include "qmi.h"
- 
- #define ATH11K_PCI_BAR_NUM		0
- #define ATH11K_PCI_DMA_MASK		32
-@@ -897,6 +898,7 @@ unsupported_wcn6855_soc:
- 		ath11k_err(ab, "failed to init core: %d\n", ret);
- 		goto err_irq_affinity_cleanup;
- 	}
-+	ath11k_qmi_fwreset_from_cold_boot(ab);
- 	return 0;
- 
- err_irq_affinity_cleanup:
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -9,6 +9,7 @@
- #include "qmi.h"
- #include "core.h"
- #include "debug.h"
-+#include "hif.h"
- #include <linux/of.h>
- #include <linux/of_address.h>
- #include <linux/ioport.h>
-@@ -2842,6 +2843,33 @@ int ath11k_qmi_firmware_start(struct ath
- 	return 0;
- }
- 
-+int ath11k_qmi_fwreset_from_cold_boot(struct ath11k_base *ab)
-+{
-+	int timeout;
-+
-+	if (!ath11k_core_coldboot_cal_support(ab) || ab->qmi.cal_done ||
-+	    ab->hw_params.cbcal_restart_fw == 0)
-+		return 0;
-+
-+	ath11k_dbg(ab, ATH11K_DBG_QMI, "wait for cold boot done\n");
-+
-+	timeout = wait_event_timeout(ab->qmi.cold_boot_waitq,
-+				     (ab->qmi.cal_done == 1),
-+				     ATH11K_COLD_BOOT_FW_RESET_DELAY);
-+
-+	if (timeout <= 0) {
-+		ath11k_warn(ab, "Coldboot Calibration timed out\n");
-+		return -ETIMEDOUT;
-+	}
-+
-+	/* reset the firmware */
-+	ath11k_hif_power_down(ab);
-+	ath11k_hif_power_up(ab);
-+	ath11k_dbg(ab, ATH11K_DBG_QMI, "exit wait for cold boot done\n");
-+	return 0;
-+}
-+EXPORT_SYMBOL(ath11k_qmi_fwreset_from_cold_boot);
-+
- static int ath11k_qmi_process_coldboot_calibration(struct ath11k_base *ab)
- {
- 	int timeout;
---- a/drivers/net/wireless/ath/ath11k/qmi.h
-+++ b/drivers/net/wireless/ath/ath11k/qmi.h
-@@ -37,7 +37,7 @@
- 
- #define QMI_WLANFW_MAX_DATA_SIZE_V01		6144
- #define ATH11K_FIRMWARE_MODE_OFF		4
--#define ATH11K_COLD_BOOT_FW_RESET_DELAY		(40 * HZ)
-+#define ATH11K_COLD_BOOT_FW_RESET_DELAY		(60 * HZ)
- 
- #define ATH11K_QMI_DEVICE_BAR_SIZE		0x200000
- 
-@@ -519,5 +519,6 @@ void ath11k_qmi_msg_recv_work(struct wor
- void ath11k_qmi_deinit_service(struct ath11k_base *ab);
- int ath11k_qmi_init_service(struct ath11k_base *ab);
- void ath11k_qmi_free_resource(struct ath11k_base *ab);
-+int ath11k_qmi_fwreset_from_cold_boot(struct ath11k_base *ab);
- 
- #endif
diff --git a/package/kernel/mac80211/patches/ath11k/0093-wifi-ath11k-Remove-cal_done-check-during-probe.patch b/package/kernel/mac80211/patches/ath11k/0093-wifi-ath11k-Remove-cal_done-check-during-probe.patch
deleted file mode 100644
index 513ea3f0..00000000
--- a/package/kernel/mac80211/patches/ath11k/0093-wifi-ath11k-Remove-cal_done-check-during-probe.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From 13329d0cb7212b058bd8451a99d215a8f97645ea Mon Sep 17 00:00:00 2001
-From: Seevalamuthu Mariappan <quic_seevalam@quicinc.com>
-Date: Wed, 26 Jul 2023 19:40:32 +0530
-Subject: [PATCH] wifi: ath11k: Remove cal_done check during probe
-
-In some race conditions, calibration done QMI message is received even
-before host wait starts for calibration to be done.
-Due to this, resetting firmware was not performed after calibration.
-
-Hence, remove cal_done check in ath11k_qmi_fwreset_from_cold_boot()
-as this is called only from probe.
-
-Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.7.0.1-01744-QCAHKSWPL_SILICONZ-1
-
-Signed-off-by: Seevalamuthu Mariappan <quic_seevalam@quicinc.com>
-Signed-off-by: Raj Kumar Bhagat <quic_rajkbhag@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230726141032.3061-4-quic_rajkbhag@quicinc.com
----
- drivers/net/wireless/ath/ath11k/qmi.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/qmi.c
-+++ b/drivers/net/wireless/ath/ath11k/qmi.c
-@@ -2847,7 +2847,7 @@ int ath11k_qmi_fwreset_from_cold_boot(st
- {
- 	int timeout;
- 
--	if (!ath11k_core_coldboot_cal_support(ab) || ab->qmi.cal_done ||
-+	if (!ath11k_core_coldboot_cal_support(ab) ||
- 	    ab->hw_params.cbcal_restart_fw == 0)
- 		return 0;
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0094-wifi-ath11k-Don-t-drop-tx_status-when-peer-cannot-be.patch b/package/kernel/mac80211/patches/ath11k/0094-wifi-ath11k-Don-t-drop-tx_status-when-peer-cannot-be.patch
deleted file mode 100644
index e404a784..00000000
--- a/package/kernel/mac80211/patches/ath11k/0094-wifi-ath11k-Don-t-drop-tx_status-when-peer-cannot-be.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From 400ece6c7f346b0a30867bd00b03b5b2563d4357 Mon Sep 17 00:00:00 2001
-From: Sven Eckelmann <sven@narfation.org>
-Date: Tue, 22 Aug 2023 16:42:24 +0300
-Subject: [PATCH] wifi: ath11k: Don't drop tx_status when peer cannot be found
-
-When a station idles for a long time, hostapd will try to send a QoS Null
-frame to the station as "poll". NL80211_CMD_PROBE_CLIENT is used for this
-purpose. And the skb will be added to ack_status_frame - waiting for a
-completion via ieee80211_report_ack_skb().
-
-But when the peer was already removed before the tx_complete arrives, the
-peer will be missing. And when using dev_kfree_skb_any (instead of going
-through mac80211), the entry will stay inside ack_status_frames. This IDR
-will therefore run full after 8K request were generated for such clients.
-At this point, the access point will then just stall and not allow any new
-clients because idr_alloc() for ack_status_frame will fail.
-
-ieee80211_free_txskb() on the other hand will (when required) call
-ieee80211_report_ack_skb() and make sure that (when required) remove the
-entry from the ack_status_frame.
-
-Tested-on: IPQ6018 hw1.0 WLAN.HK.2.5.0.1-01100-QCAHKSWPL_SILICONZ-1
-
-Fixes: 6257c702264c ("wifi: ath11k: fix tx status reporting in encap offload mode")
-Fixes: 94739d45c388 ("ath11k: switch to using ieee80211_tx_status_ext()")
-Cc: stable@vger.kernel.org
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230802-ath11k-ack_status_leak-v2-1-c0af729d6229@narfation.org
----
- drivers/net/wireless/ath/ath11k/dp_tx.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/dp_tx.c
-+++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
-@@ -369,7 +369,7 @@ ath11k_dp_tx_htt_tx_complete_buf(struct
- 			   "dp_tx: failed to find the peer with peer_id %d\n",
- 			    ts->peer_id);
- 		spin_unlock_bh(&ab->base_lock);
--		dev_kfree_skb_any(msdu);
-+		ieee80211_free_txskb(ar->hw, msdu);
- 		return;
- 	}
- 	spin_unlock_bh(&ab->base_lock);
-@@ -624,7 +624,7 @@ static void ath11k_dp_tx_complete_msdu(s
- 			   "dp_tx: failed to find the peer with peer_id %d\n",
- 			    ts->peer_id);
- 		spin_unlock_bh(&ab->base_lock);
--		dev_kfree_skb_any(msdu);
-+		ieee80211_free_txskb(ar->hw, msdu);
- 		return;
- 	}
- 	arsta = (struct ath11k_sta *)peer->sta->drv_priv;
diff --git a/package/kernel/mac80211/patches/ath11k/0094-wifi-ath11k-mhi-add-a-warning-message-for-MHI_CB_EE.patch b/package/kernel/mac80211/patches/ath11k/0094-wifi-ath11k-mhi-add-a-warning-message-for-MHI_CB_EE.patch
deleted file mode 100644
index e1286c95..00000000
--- a/package/kernel/mac80211/patches/ath11k/0094-wifi-ath11k-mhi-add-a-warning-message-for-MHI_CB_EE.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From 4a93b554cf9fa64faa7cf164c0d32fc3ce67108b Mon Sep 17 00:00:00 2001
-From: Arowa Suliman <arowa@chromium.org>
-Date: Sat, 26 Aug 2023 08:42:42 +0300
-Subject: [PATCH] wifi: ath11k: mhi: add a warning message for MHI_CB_EE_RDDM
- crash
-
-Currently, the ath11k driver does not print a crash signature when a
-MHI_CB_EE_RDDM crash happens. Checked by triggering a simulated crash using the
-command and checking dmesg for logs:
-
-echo assert > /sys/kernel/debug/ath11k/../simulate_fw_crash
-
-Add a warning when firmware crash MHI_CB_EE_RDDM happens.
-
-Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.23
-
-Signed-off-by: Arowa Suliman <arowa@chromium.org>
-Reviewed-by: Jeff Johnson <quic_jjohnson@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230714001126.463127-1-arowa@chromium.org
----
- drivers/net/wireless/ath/ath11k/mhi.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/net/wireless/ath/ath11k/mhi.c
-+++ b/drivers/net/wireless/ath/ath11k/mhi.c
-@@ -333,6 +333,7 @@ static void ath11k_mhi_op_status_cb(stru
- 		ath11k_warn(ab, "firmware crashed: MHI_CB_SYS_ERROR\n");
- 		break;
- 	case MHI_CB_EE_RDDM:
-+		ath11k_warn(ab, "firmware crashed: MHI_CB_EE_RDDM\n");
- 		if (!(test_bit(ATH11K_FLAG_UNREGISTERING, &ab->dev_flags)))
- 			queue_work(ab->workqueue_aux, &ab->reset_work);
- 		break;
diff --git a/package/kernel/mac80211/patches/ath11k/0095-wifi-ath11k-add-chip-id-board-name-while-searching-b.patch b/package/kernel/mac80211/patches/ath11k/0095-wifi-ath11k-add-chip-id-board-name-while-searching-b.patch
deleted file mode 100644
index 662e28f4..00000000
--- a/package/kernel/mac80211/patches/ath11k/0095-wifi-ath11k-add-chip-id-board-name-while-searching-b.patch
+++ /dev/null
@@ -1,214 +0,0 @@
-From 1133af5aea588a58043244a4ecb5ce511b310356 Mon Sep 17 00:00:00 2001
-From: Wen Gong <quic_wgong@quicinc.com>
-Date: Wed, 30 Aug 2023 02:02:26 -0400
-Subject: [PATCH] wifi: ath11k: add chip id board name while searching
- board-2.bin for WCN6855
-
-Sometimes board-2.bin does not have the board data which matched the
-parameters such as bus type, vendor, device, subsystem-vendor,
-subsystem-device, qmi-chip-id and qmi-board-id, then wlan will load fail.
-
-Hence add another type which only matches the bus type and qmi-chip-id,
-then the ratio of missing board data reduced.
-
-Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.23
-
-Signed-off-by: Wen Gong <quic_wgong@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230830060226.18664-1-quic_wgong@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 108 ++++++++++++++++++++-----
- 1 file changed, 87 insertions(+), 21 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -985,9 +985,15 @@ int ath11k_core_check_dt(struct ath11k_b
- 	return 0;
- }
- 
-+enum ath11k_bdf_name_type {
-+	ATH11K_BDF_NAME_FULL,
-+	ATH11K_BDF_NAME_BUS_NAME,
-+	ATH11K_BDF_NAME_CHIP_ID,
-+};
-+
- static int __ath11k_core_create_board_name(struct ath11k_base *ab, char *name,
- 					   size_t name_len, bool with_variant,
--					   bool bus_type_mode)
-+					   enum ath11k_bdf_name_type name_type)
- {
- 	/* strlen(',variant=') + strlen(ab->qmi.target.bdf_ext) */
- 	char variant[9 + ATH11K_QMI_BDF_EXT_STR_LENGTH] = { 0 };
-@@ -998,11 +1004,8 @@ static int __ath11k_core_create_board_na
- 
- 	switch (ab->id.bdf_search) {
- 	case ATH11K_BDF_SEARCH_BUS_AND_BOARD:
--		if (bus_type_mode)
--			scnprintf(name, name_len,
--				  "bus=%s",
--				  ath11k_bus_str(ab->hif.bus));
--		else
-+		switch (name_type) {
-+		case ATH11K_BDF_NAME_FULL:
- 			scnprintf(name, name_len,
- 				  "bus=%s,vendor=%04x,device=%04x,subsystem-vendor=%04x,subsystem-device=%04x,qmi-chip-id=%d,qmi-board-id=%d%s",
- 				  ath11k_bus_str(ab->hif.bus),
-@@ -1012,6 +1015,19 @@ static int __ath11k_core_create_board_na
- 				  ab->qmi.target.chip_id,
- 				  ab->qmi.target.board_id,
- 				  variant);
-+			break;
-+		case ATH11K_BDF_NAME_BUS_NAME:
-+			scnprintf(name, name_len,
-+				  "bus=%s",
-+				  ath11k_bus_str(ab->hif.bus));
-+			break;
-+		case ATH11K_BDF_NAME_CHIP_ID:
-+			scnprintf(name, name_len,
-+				  "bus=%s,qmi-chip-id=%d",
-+				  ath11k_bus_str(ab->hif.bus),
-+				  ab->qmi.target.chip_id);
-+			break;
-+		}
- 		break;
- 	default:
- 		scnprintf(name, name_len,
-@@ -1030,19 +1046,29 @@ static int __ath11k_core_create_board_na
- static int ath11k_core_create_board_name(struct ath11k_base *ab, char *name,
- 					 size_t name_len)
- {
--	return __ath11k_core_create_board_name(ab, name, name_len, true, false);
-+	return __ath11k_core_create_board_name(ab, name, name_len, true,
-+					       ATH11K_BDF_NAME_FULL);
- }
- 
- static int ath11k_core_create_fallback_board_name(struct ath11k_base *ab, char *name,
- 						  size_t name_len)
- {
--	return __ath11k_core_create_board_name(ab, name, name_len, false, false);
-+	return __ath11k_core_create_board_name(ab, name, name_len, false,
-+					       ATH11K_BDF_NAME_FULL);
- }
- 
- static int ath11k_core_create_bus_type_board_name(struct ath11k_base *ab, char *name,
- 						  size_t name_len)
- {
--	return __ath11k_core_create_board_name(ab, name, name_len, false, true);
-+	return __ath11k_core_create_board_name(ab, name, name_len, false,
-+					       ATH11K_BDF_NAME_BUS_NAME);
-+}
-+
-+static int ath11k_core_create_chip_id_board_name(struct ath11k_base *ab, char *name,
-+						 size_t name_len)
-+{
-+	return __ath11k_core_create_board_name(ab, name, name_len, false,
-+					       ATH11K_BDF_NAME_CHIP_ID);
- }
- 
- const struct firmware *ath11k_core_firmware_request(struct ath11k_base *ab,
-@@ -1289,16 +1315,21 @@ int ath11k_core_fetch_board_data_api_1(s
- #define BOARD_NAME_SIZE 200
- int ath11k_core_fetch_bdf(struct ath11k_base *ab, struct ath11k_board_data *bd)
- {
--	char boardname[BOARD_NAME_SIZE], fallback_boardname[BOARD_NAME_SIZE];
-+	char *boardname = NULL, *fallback_boardname = NULL, *chip_id_boardname = NULL;
- 	char *filename, filepath[100];
--	int ret;
-+	int ret = 0;
- 
- 	filename = ATH11K_BOARD_API2_FILE;
-+	boardname = kzalloc(BOARD_NAME_SIZE, GFP_KERNEL);
-+	if (!boardname) {
-+		ret = -ENOMEM;
-+		goto exit;
-+	}
- 
--	ret = ath11k_core_create_board_name(ab, boardname, sizeof(boardname));
-+	ret = ath11k_core_create_board_name(ab, boardname, BOARD_NAME_SIZE);
- 	if (ret) {
- 		ath11k_err(ab, "failed to create board name: %d", ret);
--		return ret;
-+		goto exit;
- 	}
- 
- 	ab->bd_api = 2;
-@@ -1307,13 +1338,19 @@ int ath11k_core_fetch_bdf(struct ath11k_
- 						 ATH11K_BD_IE_BOARD_NAME,
- 						 ATH11K_BD_IE_BOARD_DATA);
- 	if (!ret)
--		goto success;
-+		goto exit;
-+
-+	fallback_boardname = kzalloc(BOARD_NAME_SIZE, GFP_KERNEL);
-+	if (!fallback_boardname) {
-+		ret = -ENOMEM;
-+		goto exit;
-+	}
- 
- 	ret = ath11k_core_create_fallback_board_name(ab, fallback_boardname,
--						     sizeof(fallback_boardname));
-+						     BOARD_NAME_SIZE);
- 	if (ret) {
- 		ath11k_err(ab, "failed to create fallback board name: %d", ret);
--		return ret;
-+		goto exit;
- 	}
- 
- 	ret = ath11k_core_fetch_board_data_api_n(ab, bd, fallback_boardname,
-@@ -1321,7 +1358,28 @@ int ath11k_core_fetch_bdf(struct ath11k_
- 						 ATH11K_BD_IE_BOARD_NAME,
- 						 ATH11K_BD_IE_BOARD_DATA);
- 	if (!ret)
--		goto success;
-+		goto exit;
-+
-+	chip_id_boardname = kzalloc(BOARD_NAME_SIZE, GFP_KERNEL);
-+	if (!chip_id_boardname) {
-+		ret = -ENOMEM;
-+		goto exit;
-+	}
-+
-+	ret = ath11k_core_create_chip_id_board_name(ab, chip_id_boardname,
-+						    BOARD_NAME_SIZE);
-+	if (ret) {
-+		ath11k_err(ab, "failed to create chip id board name: %d", ret);
-+		goto exit;
-+	}
-+
-+	ret = ath11k_core_fetch_board_data_api_n(ab, bd, chip_id_boardname,
-+						 ATH11K_BD_IE_BOARD,
-+						 ATH11K_BD_IE_BOARD_NAME,
-+						 ATH11K_BD_IE_BOARD_DATA);
-+
-+	if (!ret)
-+		goto exit;
- 
- 	ab->bd_api = 1;
- 	ret = ath11k_core_fetch_board_data_api_1(ab, bd, ATH11K_DEFAULT_BOARD_FILE);
-@@ -1334,14 +1392,22 @@ int ath11k_core_fetch_bdf(struct ath11k_
- 			ath11k_err(ab, "failed to fetch board data for %s from %s\n",
- 				   fallback_boardname, filepath);
- 
-+		ath11k_err(ab, "failed to fetch board data for %s from %s\n",
-+			   chip_id_boardname, filepath);
-+
- 		ath11k_err(ab, "failed to fetch board.bin from %s\n",
- 			   ab->hw_params.fw.dir);
--		return ret;
- 	}
- 
--success:
--	ath11k_dbg(ab, ATH11K_DBG_BOOT, "using board api %d\n", ab->bd_api);
--	return 0;
-+exit:
-+	kfree(boardname);
-+	kfree(fallback_boardname);
-+	kfree(chip_id_boardname);
-+
-+	if (!ret)
-+		ath11k_dbg(ab, ATH11K_DBG_BOOT, "using board api %d\n", ab->bd_api);
-+
-+	return ret;
- }
- 
- int ath11k_core_fetch_regdb(struct ath11k_base *ab, struct ath11k_board_data *bd)
diff --git a/package/kernel/mac80211/patches/ath11k/0096-wifi-ath11k-fix-boot-failure-with-one-MSI-vector.patch b/package/kernel/mac80211/patches/ath11k/0096-wifi-ath11k-fix-boot-failure-with-one-MSI-vector.patch
deleted file mode 100644
index 9101a1ea..00000000
--- a/package/kernel/mac80211/patches/ath11k/0096-wifi-ath11k-fix-boot-failure-with-one-MSI-vector.patch
+++ /dev/null
@@ -1,103 +0,0 @@
-From 39564b475ac5a589e6c22c43a08cbd283c295d2c Mon Sep 17 00:00:00 2001
-From: Baochen Qiang <quic_bqiang@quicinc.com>
-Date: Thu, 7 Sep 2023 09:56:06 +0800
-Subject: [PATCH] wifi: ath11k: fix boot failure with one MSI vector
-
-Commit 5b32b6dd96633 ("ath11k: Remove core PCI references from
-PCI common code") breaks with one MSI vector because it moves
-affinity setting after IRQ request, see below log:
-
-[ 1417.278835] ath11k_pci 0000:02:00.0: failed to receive control response completion, polling..
-[ 1418.302829] ath11k_pci 0000:02:00.0: Service connect timeout
-[ 1418.302833] ath11k_pci 0000:02:00.0: failed to connect to HTT: -110
-[ 1418.303669] ath11k_pci 0000:02:00.0: failed to start core: -110
-
-The detail is, if do affinity request after IRQ activated,
-which is done in request_irq(), kernel caches that request and
-returns success directly. Later when a subsequent MHI interrupt is
-fired, kernel will do the real affinity setting work, as a result,
-changs the MSI vector. However at that time host has configured
-old vector to hardware, so host never receives CE or DP interrupts.
-
-Fix it by setting affinity before registering MHI controller
-where host is, for the first time, doing IRQ request.
-
-Tested-on: WCN6855 hw2.0 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
-Tested-on: WCN6855 hw2.1 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3.6510.23
-Tested-on: WCN6750 hw1.0 AHB WLAN.MSL.1.0.1-01160-QCAMSLSWPLZ-1
-
-Fixes: 5b32b6dd9663 ("ath11k: Remove core PCI references from PCI common code")
-Signed-off-by: Baochen Qiang <quic_bqiang@quicinc.com>
-Acked-by: Jeff Johnson <quic_jjohnson@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://lore.kernel.org/r/20230907015606.16297-1-quic_bqiang@quicinc.com
----
- drivers/net/wireless/ath/ath11k/pci.c | 24 ++++++++++++------------
- 1 file changed, 12 insertions(+), 12 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -852,10 +852,16 @@ unsupported_wcn6855_soc:
- 	if (ret)
- 		goto err_pci_disable_msi;
- 
-+	ret = ath11k_pci_set_irq_affinity_hint(ab_pci, cpumask_of(0));
-+	if (ret) {
-+		ath11k_err(ab, "failed to set irq affinity %d\n", ret);
-+		goto err_pci_disable_msi;
-+	}
-+
- 	ret = ath11k_mhi_register(ab_pci);
- 	if (ret) {
- 		ath11k_err(ab, "failed to register mhi: %d\n", ret);
--		goto err_pci_disable_msi;
-+		goto err_irq_affinity_cleanup;
- 	}
- 
- 	ret = ath11k_hal_srng_init(ab);
-@@ -876,12 +882,6 @@ unsupported_wcn6855_soc:
- 		goto err_ce_free;
- 	}
- 
--	ret = ath11k_pci_set_irq_affinity_hint(ab_pci, cpumask_of(0));
--	if (ret) {
--		ath11k_err(ab, "failed to set irq affinity %d\n", ret);
--		goto err_free_irq;
--	}
--
- 	/* kernel may allocate a dummy vector before request_irq and
- 	 * then allocate a real vector when request_irq is called.
- 	 * So get msi_data here again to avoid spurious interrupt
-@@ -890,20 +890,17 @@ unsupported_wcn6855_soc:
- 	ret = ath11k_pci_config_msi_data(ab_pci);
- 	if (ret) {
- 		ath11k_err(ab, "failed to config msi_data: %d\n", ret);
--		goto err_irq_affinity_cleanup;
-+		goto err_free_irq;
- 	}
- 
- 	ret = ath11k_core_init(ab);
- 	if (ret) {
- 		ath11k_err(ab, "failed to init core: %d\n", ret);
--		goto err_irq_affinity_cleanup;
-+		goto err_free_irq;
- 	}
- 	ath11k_qmi_fwreset_from_cold_boot(ab);
- 	return 0;
- 
--err_irq_affinity_cleanup:
--	ath11k_pci_set_irq_affinity_hint(ab_pci, NULL);
--
- err_free_irq:
- 	ath11k_pcic_free_irq(ab);
- 
-@@ -916,6 +913,9 @@ err_hal_srng_deinit:
- err_mhi_unregister:
- 	ath11k_mhi_unregister(ab_pci);
- 
-+err_irq_affinity_cleanup:
-+	ath11k_pci_set_irq_affinity_hint(ab_pci, NULL);
-+
- err_pci_disable_msi:
- 	ath11k_pci_free_msi(ab_pci);
- 
diff --git a/package/kernel/mac80211/patches/ath11k/0097-wifi-ath11k-move-pci.ops-registration-ahead.patch b/package/kernel/mac80211/patches/ath11k/0097-wifi-ath11k-move-pci.ops-registration-ahead.patch
deleted file mode 100644
index 93ebf83b..00000000
--- a/package/kernel/mac80211/patches/ath11k/0097-wifi-ath11k-move-pci.ops-registration-ahead.patch
+++ /dev/null
@@ -1,96 +0,0 @@
-From 515bcdf587f9911f2d5de51524cb7e048d295052 Mon Sep 17 00:00:00 2001
-From: Baochen Qiang <quic_bqiang@quicinc.com>
-Date: Tue, 9 Jan 2024 10:13:35 +0800
-Subject: [PATCH] wifi: ath11k: move pci.ops registration ahead
-
-In ath11k_pci_probe() there is a switch statement that, based
-upon the PCI device ID, assigns pci_ops. After the switch,
-ath11k_pcic_register_pci_ops() is called to register the pci_ops.
-
-Unfortunately, this registration is too late if any of the cases
-in the switch need to perform operations that require the pci_ops
-to already be registered. In particular, an upcoming patch for
-QCA2066 needs to call ath11k_pcic_read32().
-
-To address this issue, call ath11k_pcic_register_pci_ops() from
-each case instead of doing so after the switch. That way the ops
-will be registered if any subsequent operations within the case
-processing require the ops to be present.
-
-Tested-on: WCN6855 hw2.1 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
-
-Signed-off-by: Baochen Qiang <quic_bqiang@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://msgid.link/20240109021336.4143-2-quic_bqiang@quicinc.com
----
- drivers/net/wireless/ath/ath11k/pci.c | 26 ++++++++++++++++----------
- 1 file changed, 16 insertions(+), 10 deletions(-)
-
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -729,7 +729,6 @@ static int ath11k_pci_probe(struct pci_d
- 	struct ath11k_base *ab;
- 	struct ath11k_pci *ab_pci;
- 	u32 soc_hw_version_major, soc_hw_version_minor, addr;
--	const struct ath11k_pci_ops *pci_ops;
- 	int ret;
- 
- 	ab = ath11k_core_alloc(&pdev->dev, sizeof(*ab_pci), ATH11K_BUS_PCI);
-@@ -775,6 +774,12 @@ static int ath11k_pci_probe(struct pci_d
- 
- 	switch (pci_dev->device) {
- 	case QCA6390_DEVICE_ID:
-+		ret = ath11k_pcic_register_pci_ops(ab, &ath11k_pci_ops_qca6390);
-+		if (ret) {
-+			ath11k_err(ab, "failed to register PCI ops: %d\n", ret);
-+			goto err_pci_free_region;
-+		}
-+
- 		ath11k_pci_read_hw_version(ab, &soc_hw_version_major,
- 					   &soc_hw_version_minor);
- 		switch (soc_hw_version_major) {
-@@ -788,13 +793,21 @@ static int ath11k_pci_probe(struct pci_d
- 			goto err_pci_free_region;
- 		}
- 
--		pci_ops = &ath11k_pci_ops_qca6390;
- 		break;
- 	case QCN9074_DEVICE_ID:
--		pci_ops = &ath11k_pci_ops_qcn9074;
-+		ret = ath11k_pcic_register_pci_ops(ab, &ath11k_pci_ops_qcn9074);
-+		if (ret) {
-+			ath11k_err(ab, "failed to register PCI ops: %d\n", ret);
-+			goto err_pci_free_region;
-+		}
- 		ab->hw_rev = ATH11K_HW_QCN9074_HW10;
- 		break;
- 	case WCN6855_DEVICE_ID:
-+		ret = ath11k_pcic_register_pci_ops(ab, &ath11k_pci_ops_qca6390);
-+		if (ret) {
-+			ath11k_err(ab, "failed to register PCI ops: %d\n", ret);
-+			goto err_pci_free_region;
-+		}
- 		ab->id.bdf_search = ATH11K_BDF_SEARCH_BUS_AND_BOARD;
- 		ath11k_pci_read_hw_version(ab, &soc_hw_version_major,
- 					   &soc_hw_version_minor);
-@@ -821,7 +834,6 @@ unsupported_wcn6855_soc:
- 			goto err_pci_free_region;
- 		}
- 
--		pci_ops = &ath11k_pci_ops_qca6390;
- 		break;
- 	default:
- 		dev_err(&pdev->dev, "Unknown PCI device found: 0x%x\n",
-@@ -830,12 +842,6 @@ unsupported_wcn6855_soc:
- 		goto err_pci_free_region;
- 	}
- 
--	ret = ath11k_pcic_register_pci_ops(ab, pci_ops);
--	if (ret) {
--		ath11k_err(ab, "failed to register PCI ops: %d\n", ret);
--		goto err_pci_free_region;
--	}
--
- 	ret = ath11k_pcic_init_msi_config(ab);
- 	if (ret) {
- 		ath11k_err(ab, "failed to init msi config: %d\n", ret);
diff --git a/package/kernel/mac80211/patches/ath11k/0099-wifi-ath11k-add-support-for-QCA2066.patch b/package/kernel/mac80211/patches/ath11k/0099-wifi-ath11k-add-support-for-QCA2066.patch
deleted file mode 100644
index a98ef2c2..00000000
--- a/package/kernel/mac80211/patches/ath11k/0099-wifi-ath11k-add-support-for-QCA2066.patch
+++ /dev/null
@@ -1,201 +0,0 @@
-From 5dc9d1a55e953d9059ecbdd8fe6ec81e9edd349e Mon Sep 17 00:00:00 2001
-From: Baochen Qiang <quic_bqiang@quicinc.com>
-Date: Tue, 9 Jan 2024 10:13:36 +0800
-Subject: [PATCH] wifi: ath11k: add support for QCA2066
-
-QCA2066 is a PCI based DBS device. It is very similar to WCN6855
-overall: they share the same PCI device ID, the same major and
-minor version numbers, the same register address, and same HAL
-descriptors etc. The most significant difference is that QCA2066
-supports 3-antenna configuration while WCN6855 does not. To differentiate
-them, subversion numbers are used. Currently four numbers are used
-by QCA2066: 0x1019A0E1, 0x1019B0E1, 0x1019C0E1 and 0x1019D0E1.
-
-Tested-on: QCA2066 hw2.1 PCI WLAN.HSP.1.1-03737-QCAHSPSWPL_V2_SILICONZ_CE-1
-Tested-on: WCN6855 hw2.1 PCI WLAN.HSP.1.1-03125-QCAHSPSWPL_V1_V2_SILICONZ_LITE-3
-
-Signed-off-by: Baochen Qiang <quic_bqiang@quicinc.com>
-Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>
-Link: https://msgid.link/20240109021336.4143-3-quic_bqiang@quicinc.com
----
- drivers/net/wireless/ath/ath11k/core.c | 86 ++++++++++++++++++++++++++
- drivers/net/wireless/ath/ath11k/core.h |  1 +
- drivers/net/wireless/ath/ath11k/mhi.c  |  1 +
- drivers/net/wireless/ath/ath11k/pci.c  | 17 ++++-
- drivers/net/wireless/ath/ath11k/pcic.c | 11 ++++
- 5 files changed, 115 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -702,6 +702,91 @@ static const struct ath11k_hw_params ath
- 		.smp2p_wow_exit = false,
- 		.support_fw_mac_sequence = false,
- 	},
-+	{
-+		.name = "qca2066 hw2.1",
-+		.hw_rev = ATH11K_HW_QCA2066_HW21,
-+		.fw = {
-+			.dir = "QCA2066/hw2.1",
-+			.board_size = 256 * 1024,
-+			.cal_offset = 128 * 1024,
-+		},
-+		.max_radios = 3,
-+		.bdf_addr = 0x4B0C0000,
-+		.hw_ops = &wcn6855_ops,
-+		.ring_mask = &ath11k_hw_ring_mask_qca6390,
-+		.internal_sleep_clock = true,
-+		.regs = &wcn6855_regs,
-+		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCA6390,
-+		.host_ce_config = ath11k_host_ce_config_qca6390,
-+		.ce_count = 9,
-+		.target_ce_config = ath11k_target_ce_config_wlan_qca6390,
-+		.target_ce_count = 9,
-+		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,
-+		.svc_to_ce_map_len = 14,
-+		.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,
-+		.single_pdev_only = true,
-+		.rxdma1_enable = false,
-+		.num_rxmda_per_pdev = 2,
-+		.rx_mac_buf_ring = true,
-+		.vdev_start_delay = true,
-+		.htt_peer_map_v2 = false,
-+
-+		.spectral = {
-+			.fft_sz = 0,
-+			.fft_pad_sz = 0,
-+			.summary_pad_sz = 0,
-+			.fft_hdr_len = 0,
-+			.max_fft_bins = 0,
-+			.fragment_160mhz = false,
-+		},
-+
-+		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
-+					BIT(NL80211_IFTYPE_AP),
-+		.supports_monitor = false,
-+		.full_monitor_mode = false,
-+		.supports_shadow_regs = true,
-+		.idle_ps = true,
-+		.supports_sta_ps = true,
-+		.coldboot_cal_mm = false,
-+		.coldboot_cal_ftm = false,
-+		.cbcal_restart_fw = false,
-+		.fw_mem_mode = 0,
-+		.num_vdevs = 2 + 1,
-+		.num_peers = 512,
-+		.supports_suspend = true,
-+		.hal_desc_sz = sizeof(struct hal_rx_desc_wcn6855),
-+		.supports_regdb = true,
-+		.fix_l1ss = false,
-+		.credit_flow = true,
-+		.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,
-+		.hal_params = &ath11k_hw_hal_params_qca6390,
-+		.supports_dynamic_smps_6ghz = false,
-+		.alloc_cacheable_memory = false,
-+		.supports_rssi_stats = true,
-+		.fw_wmi_diag_event = true,
-+		.current_cc_support = true,
-+		.dbr_debug_support = false,
-+		.global_reset = true,
-+		.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,
-+		.m3_fw_support = true,
-+		.fixed_bdf_addr = false,
-+		.fixed_mem_region = false,
-+		.static_window_map = false,
-+		.hybrid_bus_type = false,
-+		.fixed_fw_mem = false,
-+		.support_off_channel_tx = true,
-+		.supports_multi_bssid = true,
-+
-+		.sram_dump = {
-+			.start = 0x01400000,
-+			.end = 0x0177ffff,
-+		},
-+
-+		.tcl_ring_retry = true,
-+		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
-+		.smp2p_wow_exit = false,
-+		.support_fw_mac_sequence = true,
-+	},
- };
- 
- static inline struct ath11k_pdev *ath11k_core_get_single_pdev(struct ath11k_base *ab)
---- a/drivers/net/wireless/ath/ath11k/core.h
-+++ b/drivers/net/wireless/ath/ath11k/core.h
-@@ -144,6 +144,7 @@ enum ath11k_hw_rev {
- 	ATH11K_HW_WCN6855_HW21,
- 	ATH11K_HW_WCN6750_HW10,
- 	ATH11K_HW_IPQ5018_HW10,
-+	ATH11K_HW_QCA2066_HW21,
- };
- 
- enum ath11k_firmware_mode {
---- a/drivers/net/wireless/ath/ath11k/mhi.c
-+++ b/drivers/net/wireless/ath/ath11k/mhi.c
-@@ -437,6 +437,7 @@ int ath11k_mhi_register(struct ath11k_pc
- 	case ATH11K_HW_QCA6390_HW20:
- 	case ATH11K_HW_WCN6855_HW20:
- 	case ATH11K_HW_WCN6855_HW21:
-+	case ATH11K_HW_QCA2066_HW21:
- 		ath11k_mhi_config = &ath11k_mhi_config_qca6390;
- 		break;
- 	default:
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -28,6 +28,8 @@
- #define QCN9074_DEVICE_ID		0x1104
- #define WCN6855_DEVICE_ID		0x1103
- 
-+#define TCSR_SOC_HW_SUB_VER	0x1910010
-+
- static const struct pci_device_id ath11k_pci_id_table[] = {
- 	{ PCI_VDEVICE(QCOM, QCA6390_DEVICE_ID) },
- 	{ PCI_VDEVICE(QCOM, WCN6855_DEVICE_ID) },
-@@ -730,6 +732,7 @@ static int ath11k_pci_probe(struct pci_d
- 	struct ath11k_pci *ab_pci;
- 	u32 soc_hw_version_major, soc_hw_version_minor, addr;
- 	int ret;
-+	u32 sub_version;
- 
- 	ab = ath11k_core_alloc(&pdev->dev, sizeof(*ab_pci), ATH11K_BUS_PCI);
- 
-@@ -820,7 +823,19 @@ static int ath11k_pci_probe(struct pci_d
- 				break;
- 			case 0x10:
- 			case 0x11:
--				ab->hw_rev = ATH11K_HW_WCN6855_HW21;
-+				sub_version = ath11k_pcic_read32(ab, TCSR_SOC_HW_SUB_VER);
-+				ath11k_dbg(ab, ATH11K_DBG_PCI, "sub_version 0x%x\n",
-+					   sub_version);
-+				switch (sub_version) {
-+				case 0x1019A0E1:
-+				case 0x1019B0E1:
-+				case 0x1019C0E1:
-+				case 0x1019D0E1:
-+					ab->hw_rev = ATH11K_HW_QCA2066_HW21;
-+					break;
-+				default:
-+					ab->hw_rev = ATH11K_HW_WCN6855_HW21;
-+				}
- 				break;
- 			default:
- 				goto unsupported_wcn6855_soc;
---- a/drivers/net/wireless/ath/ath11k/pcic.c
-+++ b/drivers/net/wireless/ath/ath11k/pcic.c
-@@ -115,6 +115,17 @@ static const struct ath11k_msi_config at
- 		},
- 		.hw_rev = ATH11K_HW_WCN6750_HW10,
- 	},
-+	{
-+		.total_vectors = 32,
-+		.total_users = 4,
-+		.users = (struct ath11k_msi_user[]) {
-+			{ .name = "MHI", .num_vectors = 3, .base_vector = 0 },
-+			{ .name = "CE", .num_vectors = 10, .base_vector = 3 },
-+			{ .name = "WAKE", .num_vectors = 1, .base_vector = 13 },
-+			{ .name = "DP", .num_vectors = 18, .base_vector = 14 },
-+		},
-+		.hw_rev = ATH11K_HW_QCA2066_HW21,
-+	},
- };
- 
- int ath11k_pcic_init_msi_config(struct ath11k_base *ab)
diff --git a/package/kernel/mac80211/patches/ath11k/100-wifi-ath11k-use-unique-QRTR-instance-ID.patch b/package/kernel/mac80211/patches/ath11k/100-wifi-ath11k-use-unique-QRTR-instance-ID.patch
index fa6b9b31..27287628 100644
--- a/package/kernel/mac80211/patches/ath11k/100-wifi-ath11k-use-unique-QRTR-instance-ID.patch
+++ b/package/kernel/mac80211/patches/ath11k/100-wifi-ath11k-use-unique-QRTR-instance-ID.patch
@@ -49,7 +49,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
 
 --- a/drivers/net/wireless/ath/ath11k/mhi.c
 +++ b/drivers/net/wireless/ath/ath11k/mhi.c
-@@ -294,6 +294,34 @@ static void ath11k_mhi_op_runtime_put(st
+@@ -239,6 +239,34 @@ static void ath11k_mhi_op_runtime_put(st
  {
  }
  
@@ -84,7 +84,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  static char *ath11k_mhi_op_callback_to_str(enum mhi_callback reason)
  {
  	switch (reason) {
-@@ -315,6 +343,8 @@ static char *ath11k_mhi_op_callback_to_s
+@@ -260,6 +288,8 @@ static char *ath11k_mhi_op_callback_to_s
  		return "MHI_CB_FATAL_ERROR";
  	case MHI_CB_BW_REQ:
  		return "MHI_CB_BW_REQ";
@@ -93,9 +93,9 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  	default:
  		return "UNKNOWN";
  	}
-@@ -337,27 +367,14 @@ static void ath11k_mhi_op_status_cb(stru
- 		if (!(test_bit(ATH11K_FLAG_UNREGISTERING, &ab->dev_flags)))
+@@ -290,6 +320,9 @@ static void ath11k_mhi_op_status_cb(stru
  			queue_work(ab->workqueue_aux, &ab->reset_work);
+ 
  		break;
 +	case MHI_CB_EE_SBL_MODE:
 +		ath11k_mhi_qrtr_instance_set(mhi_cntrl);
@@ -103,6 +103,8 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  	default:
  		break;
  	}
+@@ -297,22 +330,6 @@ static void ath11k_mhi_op_status_cb(stru
+ 	ab_pci->mhi_pre_cb = cb;
  }
  
 -static int ath11k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,
@@ -126,7 +128,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  	struct device_node *np;
 --- a/drivers/net/wireless/ath/ath11k/mhi.h
 +++ b/drivers/net/wireless/ath/ath11k/mhi.h
-@@ -16,6 +16,9 @@
+@@ -17,6 +17,9 @@
  #define MHICTRL					0x38
  #define MHICTRL_RESET_MASK			0x2
  
@@ -138,7 +140,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  int ath11k_mhi_register(struct ath11k_pci *ar_pci);
 --- a/drivers/net/wireless/ath/ath11k/pci.c
 +++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -373,13 +373,20 @@ static void ath11k_pci_sw_reset(struct a
+@@ -374,13 +374,20 @@ static void ath11k_pci_sw_reset(struct a
  static void ath11k_pci_init_qmi_ce_config(struct ath11k_base *ab)
  {
  	struct ath11k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;
diff --git a/package/kernel/mac80211/patches/ath11k/900-ath11k-control-thermal-support-via-symbol.patch b/package/kernel/mac80211/patches/ath11k/900-ath11k-control-thermal-support-via-symbol.patch
index 60720a72..6a0e4ff7 100644
--- a/package/kernel/mac80211/patches/ath11k/900-ath11k-control-thermal-support-via-symbol.patch
+++ b/package/kernel/mac80211/patches/ath11k/900-ath11k-control-thermal-support-via-symbol.patch
@@ -21,7 +21,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
 
 --- a/drivers/net/wireless/ath/ath11k/Kconfig
 +++ b/drivers/net/wireless/ath/ath11k/Kconfig
-@@ -61,3 +61,10 @@ config ATH11K_SPECTRAL
+@@ -62,3 +62,10 @@ config ATH11K_SPECTRAL
  	  Enable ath11k spectral scan support
  
  	  Say Y to enable access to the FFT/spectral data via debugfs.
@@ -34,7 +34,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
 +	  Enable ath11k thermal sensors and throttling support.
 --- a/drivers/net/wireless/ath/ath11k/Makefile
 +++ b/drivers/net/wireless/ath/ath11k/Makefile
-@@ -22,7 +22,7 @@ ath11k-y += core.o \
+@@ -24,7 +24,7 @@ ath11k-y += core.o \
  ath11k-$(CPTCFG_ATH11K_DEBUGFS) += debugfs.o debugfs_htt_stats.o debugfs_sta.o
  ath11k-$(CPTCFG_NL80211_TESTMODE) += testmode.o
  ath11k-$(CPTCFG_ATH11K_TRACING) += trace.o
@@ -45,22 +45,22 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  
 --- a/drivers/net/wireless/ath/ath11k/thermal.h
 +++ b/drivers/net/wireless/ath/ath11k/thermal.h
-@@ -25,7 +25,7 @@ struct ath11k_thermal {
+@@ -26,7 +26,7 @@ struct ath11k_thermal {
  	int temperature;
  };
  
 -#if IS_REACHABLE(CONFIG_THERMAL)
 +#if IS_REACHABLE(CPTCFG_ATH11K_THERMAL)
- int ath11k_thermal_register(struct ath11k_base *sc);
- void ath11k_thermal_unregister(struct ath11k_base *sc);
+ int ath11k_thermal_register(struct ath11k_base *ab);
+ void ath11k_thermal_unregister(struct ath11k_base *ab);
  int ath11k_thermal_set_throttling(struct ath11k *ar, u32 throttle_state);
 --- a/local-symbols
 +++ b/local-symbols
-@@ -174,6 +174,7 @@ ATH11K_DEBUG=
+@@ -168,6 +168,7 @@ ATH11K_DEBUG=
  ATH11K_DEBUGFS=
  ATH11K_TRACING=
  ATH11K_SPECTRAL=
 +ATH11K_THERMAL=
- WLAN_VENDOR_ATMEL=
- ATMEL=
- PCI_ATMEL=
+ ATH12K=
+ ATH12K_DEBUG=
+ ATH12K_DEBUGFS=
diff --git a/package/kernel/mac80211/patches/ath11k/901-wifi-ath11k-pci-fix-compilation-in-5.16-and-older.patch b/package/kernel/mac80211/patches/ath11k/901-wifi-ath11k-pci-fix-compilation-in-5.16-and-older.patch
deleted file mode 100644
index aeefb069..00000000
--- a/package/kernel/mac80211/patches/ath11k/901-wifi-ath11k-pci-fix-compilation-in-5.16-and-older.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From 04178918e7f6b5f34dde81ec79ee8a1ccace3be3 Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Mon, 17 Oct 2022 11:45:03 +0200
-Subject: [PATCH] wifi: ath11k: pci: fix compilation in 5.16 and older
-
-Commit ("genirq/msi, treewide: Use a named struct for PCI/MSI attributes")
-changed the msi_desc structure a bit, however that is only available in
-kernels 5.17 and newer, so check for kernel version to allow compilation
-in 5.16 and older.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- drivers/net/wireless/ath/ath11k/pci.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/drivers/net/wireless/ath/ath11k/pci.c
-+++ b/drivers/net/wireless/ath/ath11k/pci.c
-@@ -461,7 +461,11 @@ static int ath11k_pci_alloc_msi(struct a
- 	pci_read_config_dword(pci_dev, pci_dev->msi_cap + PCI_MSI_ADDRESS_LO,
- 			      &ab->pci.msi.addr_lo);
- 
-+#if (LINUX_VERSION_CODE > KERNEL_VERSION(5, 17, 0))
- 	if (msi_desc->pci.msi_attrib.is_64) {
-+#else
-+	if (msi_desc->msi_attrib.is_64) {
-+#endif
- 		pci_read_config_dword(pci_dev, pci_dev->msi_cap + PCI_MSI_ADDRESS_HI,
- 				      &ab->pci.msi.addr_hi);
- 	} else {
diff --git a/package/kernel/mac80211/patches/ath11k/902-ath11k-Disable-coldboot-calibration-for-IPQ8074.patch b/package/kernel/mac80211/patches/ath11k/902-ath11k-Disable-coldboot-calibration-for-IPQ8074.patch
deleted file mode 100644
index 0c92fa91..00000000
--- a/package/kernel/mac80211/patches/ath11k/902-ath11k-Disable-coldboot-calibration-for-IPQ8074.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From dd3b9c59cfa1e9e0b73a575f4646be905691eaef Mon Sep 17 00:00:00 2001
-From: Robert Marko <robimarko@gmail.com>
-Date: Sat, 16 Oct 2021 19:34:10 +0200
-Subject: [PATCH 241/241] ath11k: Disable coldboot calibration for IPQ8074
-
-There is a bug with the remoteproc reset after coldboot calibration,
-so until that is resolved disabled it to allow using the radio.
-
-Signed-off-by: Robert Marko <robimarko@gmail.com>
----
- drivers/net/wireless/ath/ath11k/core.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -86,8 +86,8 @@ static const struct ath11k_hw_params ath
- 		.supports_shadow_regs = false,
- 		.idle_ps = false,
- 		.supports_sta_ps = false,
--		.coldboot_cal_mm = true,
--		.coldboot_cal_ftm = true,
-+		.coldboot_cal_mm = false,
-+		.coldboot_cal_ftm = false,
- 		.cbcal_restart_fw = true,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
diff --git a/package/kernel/mac80211/patches/ath11k/903-ath11k-support-setting-FW-memory-mode-via-DT.patch b/package/kernel/mac80211/patches/ath11k/903-ath11k-support-setting-FW-memory-mode-via-DT.patch
index c7244380..1250147e 100644
--- a/package/kernel/mac80211/patches/ath11k/903-ath11k-support-setting-FW-memory-mode-via-DT.patch
+++ b/package/kernel/mac80211/patches/ath11k/903-ath11k-support-setting-FW-memory-mode-via-DT.patch
@@ -22,7 +22,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
 
 --- a/drivers/net/wireless/ath/ath11k/core.c
 +++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -36,7 +36,7 @@ bool ath11k_ftm_mode;
+@@ -37,7 +37,7 @@ bool ath11k_ftm_mode;
  module_param_named(ftm_mode, ath11k_ftm_mode, bool, 0444);
  MODULE_PARM_DESC(ftm_mode, "Boots up in factory test mode");
  
@@ -31,7 +31,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  	{
  		.hw_rev = ATH11K_HW_IPQ8074,
  		.name = "ipq8074 hw2.0",
-@@ -2125,7 +2125,8 @@ static void ath11k_core_reset(struct wor
+@@ -2147,7 +2147,8 @@ static void ath11k_core_reset(struct wor
  static int ath11k_init_hw_params(struct ath11k_base *ab)
  {
  	const struct ath11k_hw_params *hw_params = NULL;
@@ -41,7 +41,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  
  	for (i = 0; i < ARRAY_SIZE(ath11k_hw_params); i++) {
  		hw_params = &ath11k_hw_params[i];
-@@ -2141,7 +2142,31 @@ static int ath11k_init_hw_params(struct
+@@ -2163,7 +2164,31 @@ static int ath11k_init_hw_params(struct
  
  	ab->hw_params = *hw_params;
  
diff --git a/package/kernel/mac80211/patches/ath11k/905-ath11k-remove-intersection-support-for-regulatory-ru.patch b/package/kernel/mac80211/patches/ath11k/905-ath11k-remove-intersection-support-for-regulatory-ru.patch
index b0ceb00b..f30e0347 100644
--- a/package/kernel/mac80211/patches/ath11k/905-ath11k-remove-intersection-support-for-regulatory-ru.patch
+++ b/package/kernel/mac80211/patches/ath11k/905-ath11k-remove-intersection-support-for-regulatory-ru.patch
@@ -23,7 +23,7 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
 
 --- a/drivers/net/wireless/ath/ath11k/reg.c
 +++ b/drivers/net/wireless/ath/ath11k/reg.c
-@@ -352,129 +352,6 @@ static u32 ath11k_map_fw_reg_flags(u16 r
+@@ -361,134 +361,6 @@ static u32 ath11k_map_fw_phy_flags(u32 p
  	return flags;
  }
  
@@ -89,6 +89,11 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
 -	/* Use the flags of both the rules */
 -	new_rule->flags = rule1->flags | rule2->flags;
 -
+-	if ((rule1->flags & NL80211_RRF_PSD) && (rule2->flags & NL80211_RRF_PSD))
+-		new_rule->psd = min_t(s8, rule1->psd, rule2->psd);
+-	else
+-		new_rule->flags &= ~NL80211_RRF_PSD;
+-
 -	/* To be safe, lts use the max cac timeout of both rules */
 -	new_rule->dfs_cac_ms = max_t(u32, rule1->dfs_cac_ms,
 -				     rule2->dfs_cac_ms);
@@ -153,20 +158,22 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
  static const char *
  ath11k_reg_get_regdom_str(enum nl80211_dfs_regions dfs_region)
  {
-@@ -609,9 +486,9 @@ ath11k_reg_update_weather_radar_band(str
+@@ -639,11 +511,11 @@ ath11k_reg_ap_pwr_convert(enum ieee80211
  
  struct ieee80211_regdomain *
  ath11k_reg_build_regd(struct ath11k_base *ab,
--		      struct cur_regulatory_info *reg_info, bool intersect)
-+		      struct cur_regulatory_info *reg_info)
+-		      struct cur_regulatory_info *reg_info, bool intersect,
++		      struct cur_regulatory_info *reg_info,
+ 		      enum wmi_vdev_type vdev_type,
+ 		      enum ieee80211_ap_reg_power power_type)
  {
 -	struct ieee80211_regdomain *tmp_regd, *default_regd, *new_regd = NULL;
 +	struct ieee80211_regdomain *new_regd = NULL;
- 	struct cur_reg_rule *reg_rule;
+ 	struct cur_reg_rule *reg_rule, *reg_rule_6ghz;
  	u8 i = 0, j = 0, k = 0;
  	u8 num_rules;
-@@ -628,26 +505,26 @@ ath11k_reg_build_regd(struct ath11k_base
- 		num_rules += reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP];
+@@ -686,26 +558,26 @@ ath11k_reg_build_regd(struct ath11k_base
+ 	}
  
  	if (!num_rules)
 -		goto ret;
@@ -199,16 +206,16 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
  		   reg_info->dfs_region, num_rules);
  	/* Update reg_rules[] below. Firmware is expected to
  	 * send these rules in order(2 GHz rules first and then 5 GHz)
-@@ -686,7 +563,7 @@ ath11k_reg_build_regd(struct ath11k_base
- 
+@@ -744,7 +616,7 @@ ath11k_reg_build_regd(struct ath11k_base
  		flags |= ath11k_map_fw_reg_flags(reg_rule->flags);
+ 		flags |= ath11k_map_fw_phy_flags(reg_info->phybitmap);
  
 -		ath11k_reg_update_rule(tmp_regd->reg_rules + i,
 +		ath11k_reg_update_rule(new_regd->reg_rules + i,
  				       reg_rule->start_freq,
  				       reg_rule->end_freq, max_bw,
  				       reg_rule->ant_gain, reg_rule->reg_power,
-@@ -701,7 +578,7 @@ ath11k_reg_build_regd(struct ath11k_base
+@@ -759,7 +631,7 @@ ath11k_reg_build_regd(struct ath11k_base
  		    reg_info->dfs_region == ATH11K_DFS_REG_ETSI &&
  		    (reg_rule->end_freq > ETSI_WEATHER_RADAR_BAND_LOW &&
  		    reg_rule->start_freq < ETSI_WEATHER_RADAR_BAND_HIGH)){
@@ -217,7 +224,7 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
  							     reg_rule, &i,
  							     flags, max_bw);
  			continue;
-@@ -712,37 +589,20 @@ ath11k_reg_build_regd(struct ath11k_base
+@@ -770,51 +642,23 @@ ath11k_reg_build_regd(struct ath11k_base
  				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d) (%d, %d)\n",
  				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
  				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
@@ -236,7 +243,8 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
  	}
  
 -	tmp_regd->n_reg_rules = i;
--
++	new_regd->n_reg_rules = i;
+ 
 -	if (intersect) {
 -		default_regd = ab->default_regd[reg_info->phy_id];
 -
@@ -252,29 +260,11 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
 -	} else {
 -		new_regd = tmp_regd;
 -	}
-+	new_regd->n_reg_rules = i;
- 
+-
 -ret:
  	return new_regd;
  }
  
---- a/drivers/net/wireless/ath/ath11k/reg.h
-+++ b/drivers/net/wireless/ath/ath11k/reg.h
-@@ -30,7 +30,7 @@ void ath11k_reg_free(struct ath11k_base
- void ath11k_regd_update_work(struct work_struct *work);
- struct ieee80211_regdomain *
- ath11k_reg_build_regd(struct ath11k_base *ab,
--		      struct cur_regulatory_info *reg_info, bool intersect);
-+		      struct cur_regulatory_info *reg_info);
- int ath11k_regd_update(struct ath11k *ar);
- int ath11k_reg_update_chan_list(struct ath11k *ar, bool wait);
- #endif
---- a/drivers/net/wireless/ath/ath11k/wmi.c
-+++ b/drivers/net/wireless/ath/ath11k/wmi.c
-@@ -6996,24 +6996,12 @@ static void ath11k_wmi_htc_tx_complete(s
- 		wake_up(&wmi->tx_ce_desc_wq);
- }
- 
 -static bool ath11k_reg_is_world_alpha(char *alpha)
 -{
 -	if (alpha[0] == '0' && alpha[1] == '0')
@@ -286,19 +276,20 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
 -	return false;
 -}
 -
- static int ath11k_reg_chan_list_event(struct ath11k_base *ab,
- 				      struct sk_buff *skb,
- 				      enum wmi_reg_chan_list_cmd_type id)
+ static enum wmi_vdev_type ath11k_reg_get_ar_vdev_type(struct ath11k *ar)
+ {
+ 	struct ath11k_vif *arvif;
+@@ -837,7 +681,6 @@ int ath11k_reg_handle_chan_list(struct a
+ 				enum ieee80211_ap_reg_power power_type)
  {
- 	struct cur_regulatory_info *reg_info = NULL;
- 	struct ieee80211_regdomain *regd = NULL;
+ 	struct ieee80211_regdomain *regd;
 -	bool intersect = false;
- 	int ret = 0, pdev_idx, i, j;
+ 	int pdev_idx;
  	struct ath11k *ar;
- 
-@@ -7075,17 +7063,7 @@ static int ath11k_reg_chan_list_event(st
+ 	enum wmi_vdev_type vdev_type;
+@@ -889,24 +732,14 @@ int ath11k_reg_handle_chan_list(struct a
  		    (char *)reg_info->alpha2, 2))
- 		goto mem_free;
+ 		goto retfail;
  
 -	/* Intersect new rules with default regd if a new country setting was
 -	 * requested, i.e a default regd was already set during initialization
@@ -310,8 +301,28 @@ Signed-off-by: Aditya Kumar Singh <quic_adisi@quicinc.com>
 -	    !ath11k_reg_is_world_alpha((char *)reg_info->alpha2))
 -		intersect = true;
 -
--	regd = ath11k_reg_build_regd(ab, reg_info, intersect);
-+	regd = ath11k_reg_build_regd(ab, reg_info);
+ 	ar = ab->pdevs[pdev_idx].ar;
+ 	vdev_type = ath11k_reg_get_ar_vdev_type(ar);
+ 
+ 	ath11k_dbg(ab, ATH11K_DBG_WMI,
+-		   "wmi handle chan list power type %d vdev type %d intersect %d\n",
+-		   power_type, vdev_type, intersect);
++		   "wmi handle chan list power type %d vdev type %d\n",
++		   power_type, vdev_type);
+ 
+-	regd = ath11k_reg_build_regd(ab, reg_info, intersect, vdev_type, power_type);
++	regd = ath11k_reg_build_regd(ab, reg_info, vdev_type, power_type);
  	if (!regd) {
  		ath11k_warn(ab, "failed to build regd from reg_info\n");
  		goto fallback;
+--- a/drivers/net/wireless/ath/ath11k/reg.h
++++ b/drivers/net/wireless/ath/ath11k/reg.h
+@@ -35,7 +35,7 @@ void ath11k_reg_free(struct ath11k_base
+ void ath11k_regd_update_work(struct work_struct *work);
+ struct ieee80211_regdomain *
+ ath11k_reg_build_regd(struct ath11k_base *ab,
+-		      struct cur_regulatory_info *reg_info, bool intersect,
++		      struct cur_regulatory_info *reg_info,
+ 		      enum wmi_vdev_type vdev_type,
+ 		      enum ieee80211_ap_reg_power power_type);
+ int ath11k_regd_update(struct ath11k *ar);
diff --git a/package/kernel/mac80211/patches/ath11k/906-ath11k-Disable-coldboot-calibration-for-IPQ6018.patch b/package/kernel/mac80211/patches/ath11k/906-ath11k-Disable-coldboot-calibration-for-IPQ6018.patch
deleted file mode 100644
index 39a11d72..00000000
--- a/package/kernel/mac80211/patches/ath11k/906-ath11k-Disable-coldboot-calibration-for-IPQ6018.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/drivers/net/wireless/ath/ath11k/core.c
-+++ b/drivers/net/wireless/ath/ath11k/core.c
-@@ -168,8 +168,8 @@ static struct ath11k_hw_params ath11k_hw
- 		.supports_shadow_regs = false,
- 		.idle_ps = false,
- 		.supports_sta_ps = false,
--		.coldboot_cal_mm = true,
--		.coldboot_cal_ftm = true,
-+		.coldboot_cal_mm = false,
-+		.coldboot_cal_ftm = false,
- 		.cbcal_restart_fw = true,
- 		.fw_mem_mode = 0,
- 		.num_vdevs = 16 + 1,
diff --git a/package/kernel/mac80211/patches/ath11k/910-ath11k-kernel_6.6-support.patch b/package/kernel/mac80211/patches/ath11k/910-ath11k-kernel_6.6-support.patch
deleted file mode 100644
index 526339cc..00000000
--- a/package/kernel/mac80211/patches/ath11k/910-ath11k-kernel_6.6-support.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/drivers/net/wireless/ath/ath11k/ahb.c
-+++ b/drivers/net/wireless/ath/ath11k/ahb.c
-@@ -1008,17 +1008,29 @@ static int ath11k_ahb_fw_resources_init(
- 		goto err_iommu_free;
- 	}
- 
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
- 	ret = iommu_map(iommu_dom, ab_ahb->fw.msa_paddr,
- 			ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size,
- 			IOMMU_READ | IOMMU_WRITE);
-+#else
-+	ret = iommu_map(iommu_dom, ab_ahb->fw.msa_paddr,
-+			ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size,
-+			IOMMU_READ | IOMMU_WRITE, GFP_KERNEL);
-+#endif
- 	if (ret) {
- 		ath11k_err(ab, "failed to map firmware region: %d\n", ret);
- 		goto err_iommu_detach;
- 	}
- 
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
- 	ret = iommu_map(iommu_dom, ab_ahb->fw.ce_paddr,
- 			ab_ahb->fw.ce_paddr, ab_ahb->fw.ce_size,
- 			IOMMU_READ | IOMMU_WRITE);
-+#else
-+	ret = iommu_map(iommu_dom, ab_ahb->fw.ce_paddr,
-+			ab_ahb->fw.ce_paddr, ab_ahb->fw.ce_size,
-+			IOMMU_READ | IOMMU_WRITE, GFP_KERNEL);
-+#endif
- 	if (ret) {
- 		ath11k_err(ab, "failed to map firmware CE region: %d\n", ret);
- 		goto err_iommu_unmap;
diff --git a/package/kernel/mac80211/patches/ath5k/432-ath5k_add_pciids.patch b/package/kernel/mac80211/patches/ath5k/432-ath5k_add_pciids.patch
deleted file mode 100644
index bd0e6707..00000000
--- a/package/kernel/mac80211/patches/ath5k/432-ath5k_add_pciids.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -47,6 +47,8 @@ static const struct pci_device_id ath5k_
- 	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
- 	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
- 	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
-+	{ PCI_VDEVICE(ATHEROS, 0xff16) }, /* 2413,2414 sx76x on lantiq_danube */
-+	{ PCI_VDEVICE(ATHEROS, 0xff1a) }, /* 2417 arv45xx on lantiq_danube */
- 	{ PCI_VDEVICE(ATHEROS, 0xff1b) }, /* AR5BXB63 */
- 	{ 0 }
- };
diff --git a/package/kernel/mac80211/patches/ath5k/440-ath5k_channel_bw_debugfs.patch b/package/kernel/mac80211/patches/ath5k/440-ath5k_channel_bw_debugfs.patch
index a63f0c88..6ff95f95 100644
--- a/package/kernel/mac80211/patches/ath5k/440-ath5k_channel_bw_debugfs.patch
+++ b/package/kernel/mac80211/patches/ath5k/440-ath5k_channel_bw_debugfs.patch
@@ -109,7 +109,7 @@ drivers/net/wireless/ath/ath5k/debug.c |   86 ++++++++++++++++++++++++++++++++
  
  /* debugfs: queues etc */
  
-@@ -997,6 +1088,8 @@ ath5k_debug_init_device(struct ath5k_hw
+@@ -995,6 +1086,8 @@ ath5k_debug_init_device(struct ath5k_hw
  	debugfs_create_file("queue", 0600, phydir, ah, &fops_queue);
  	debugfs_create_bool("32khz_clock", 0600, phydir,
  			    &ah->ah_use_32khz_clock);
diff --git a/package/kernel/mac80211/patches/ath9k/351-ath9k_hw-issue-external-reset-for-QCA955x.patch b/package/kernel/mac80211/patches/ath9k/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
index 53b7ba08..aac7e139 100644
--- a/package/kernel/mac80211/patches/ath9k/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
+++ b/package/kernel/mac80211/patches/ath9k/351-ath9k_hw-issue-external-reset-for-QCA955x.patch
@@ -75,7 +75,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +	ath_dbg(ath9k_hw_common(ah), RESET,
 +		"reset MAC via external reset\n");
  
--		REG_WRITE(ah, AR_RTC_RESET, 1);
+-		REG_WRITE(ah, AR_RTC_RESET(ah), 1);
 +	err = ah->external_reset();
 +	if (err) {
 +		ath_err(ath9k_hw_common(ah),
@@ -84,11 +84,11 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	}
  
 +	if (AR_SREV_9550(ah)) {
-+		REG_WRITE(ah, AR_RTC_RESET, 0);
++		REG_WRITE(ah, AR_RTC_RESET(ah), 0);
 +		udelay(10);
 +	}
 +
-+	REG_WRITE(ah, AR_RTC_RESET, 1);
++	REG_WRITE(ah, AR_RTC_RESET(ah), 1);
 +	udelay(10);
 +
  	return true;
@@ -124,6 +124,6 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +	if (AR_SREV_9300(ah) || AR_SREV_9580(ah))
 +		REG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
 +
- 	REG_WRITE(ah, AR_RTC_RC, rst_flags);
+ 	REG_WRITE(ah, AR_RTC_RC(ah), rst_flags);
  
  	REGWRITE_BUFFER_FLUSH(ah);
diff --git a/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch b/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
index 385eea01..9016da96 100644
--- a/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
+++ b/package/kernel/mac80211/patches/ath9k/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
@@ -8,7 +8,7 @@ This reverts commit 71f5137bf010c6faffab50c0ec15374c59c4a411.
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2977,7 +2977,8 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2975,7 +2975,8 @@ void ath9k_hw_apply_txpower(struct ath_h
  {
  	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
  	struct ieee80211_channel *channel;
@@ -18,7 +18,7 @@ This reverts commit 71f5137bf010c6faffab50c0ec15374c59c4a411.
  	u16 ctl = NO_CTL;
  
  	if (!chan)
-@@ -2989,9 +2990,14 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2987,9 +2988,14 @@ void ath9k_hw_apply_txpower(struct ath_h
  	channel = chan->chan;
  	chan_pwr = min_t(int, channel->max_power * 2, MAX_COMBINED_POWER);
  	new_pwr = min_t(int, chan_pwr, reg->power_limit);
diff --git a/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch b/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
index 0c3edc12..5e5f3e4f 100644
--- a/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
+++ b/package/kernel/mac80211/patches/ath9k/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2996,6 +2996,10 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2994,6 +2994,10 @@ void ath9k_hw_apply_txpower(struct ath_h
  	if (ant_gain > max_gain)
  		ant_reduction = ant_gain - max_gain;
  
diff --git a/package/kernel/mac80211/patches/ath9k/500-ath9k_eeprom_debugfs.patch b/package/kernel/mac80211/patches/ath9k/500-ath9k_eeprom_debugfs.patch
index e2bbb4a1..f1431526 100644
--- a/package/kernel/mac80211/patches/ath9k/500-ath9k_eeprom_debugfs.patch
+++ b/package/kernel/mac80211/patches/ath9k/500-ath9k_eeprom_debugfs.patch
@@ -1,14 +1,24 @@
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1413,6 +1413,53 @@ void ath9k_deinit_debug(struct ath_softc
- 	ath9k_cmn_spectral_deinit_debug(&sc->spec_priv);
- }
+@@ -1429,6 +1429,7 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 
+ 	ath9k_cmn_debug_base_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
+ 	ath9k_cmn_debug_modal_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
++	ath9k_cmn_debug_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
  
+ 	debugfs_create_u32("gpio_mask", 0600,
+ 			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);
+--- a/drivers/net/wireless/ath/ath9k/common-debug.c
++++ b/drivers/net/wireless/ath/ath9k/common-debug.c
+@@ -260,3 +260,58 @@ void ath9k_cmn_debug_phy_err(struct dent
+ 			    &fops_phy_err);
+ }
+ EXPORT_SYMBOL(ath9k_cmn_debug_phy_err);
++
 +static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
 +			     size_t count, loff_t *ppos)
 +{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
++	struct ath_hw *ah = file->private_data;
 +	struct ath_common *common = ath9k_hw_common(ah);
 +	int bytes = 0;
 +	int pos = *ppos;
@@ -39,7 +49,8 @@
 +		} else {
 +			bytes = 2;
 +		}
-+		copy_to_user(user_buf, from, bytes);
++		if (copy_to_user(user_buf, from, bytes))
++			return -EFAULT;
 +		user_buf += bytes;
 +	}
 +	return *ppos - pos;
@@ -51,15 +62,31 @@
 +	.owner = THIS_MODULE
 +};
 +
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1432,6 +1479,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	ath9k_tx99_init_debug(sc);
- 	ath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);
- 
-+	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
++void ath9k_cmn_debug_eeprom(struct dentry *debugfs_phy,
++			    struct ath_hw *ah)
++{
++	debugfs_create_file("eeprom", S_IRUSR, debugfs_phy, ah,
 +			    &fops_eeprom);
- 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
- 				    read_file_dma);
- 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
++}
++EXPORT_SYMBOL(ath9k_cmn_debug_eeprom);
+--- a/drivers/net/wireless/ath/ath9k/common-debug.h
++++ b/drivers/net/wireless/ath/ath9k/common-debug.h
+@@ -69,6 +69,8 @@ void ath9k_cmn_debug_modal_eeprom(struct
+ 				  struct ath_hw *ah);
+ void ath9k_cmn_debug_base_eeprom(struct dentry *debugfs_phy,
+ 				 struct ath_hw *ah);
++void ath9k_cmn_debug_eeprom(struct dentry *debugfs_phy,
++			    struct ath_hw *ah);
+ void ath9k_cmn_debug_stat_rx(struct ath_rx_stats *rxstats,
+ 			     struct ath_rx_status *rs);
+ void ath9k_cmn_debug_recv(struct dentry *debugfs_phy,
+--- a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
++++ b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
+@@ -512,6 +512,7 @@ int ath9k_htc_init_debug(struct ath_hw *
+ 
+ 	ath9k_cmn_debug_base_eeprom(priv->debug.debugfs_phy, priv->ah);
+ 	ath9k_cmn_debug_modal_eeprom(priv->debug.debugfs_phy, priv->ah);
++	ath9k_cmn_debug_eeprom(priv->debug.debugfs_phy, priv->ah);
+ 
+ 	return 0;
+ }
diff --git a/package/kernel/mac80211/patches/ath9k/511-ath9k_reduce_rxbuf.patch b/package/kernel/mac80211/patches/ath9k/511-ath9k_reduce_rxbuf.patch
index 15b8d7b8..d8067828 100644
--- a/package/kernel/mac80211/patches/ath9k/511-ath9k_reduce_rxbuf.patch
+++ b/package/kernel/mac80211/patches/ath9k/511-ath9k_reduce_rxbuf.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -88,7 +88,7 @@ int ath_descdma_setup(struct ath_softc *
+@@ -90,7 +90,7 @@ int ath_descdma_setup(struct ath_softc *
  		(_l) &= ((_sz) - 1);		\
  	} while (0)
  
diff --git a/package/kernel/mac80211/patches/ath9k/512-ath9k_channelbw_debugfs.patch b/package/kernel/mac80211/patches/ath9k/512-ath9k_channelbw_debugfs.patch
index 0c8b6920..87d18626 100644
--- a/package/kernel/mac80211/patches/ath9k/512-ath9k_channelbw_debugfs.patch
+++ b/package/kernel/mac80211/patches/ath9k/512-ath9k_channelbw_debugfs.patch
@@ -1,70 +1,16 @@
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1460,6 +1460,52 @@ static const struct file_operations fops
- 	.owner = THIS_MODULE
- };
+@@ -1430,6 +1430,7 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 	ath9k_cmn_debug_base_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
+ 	ath9k_cmn_debug_modal_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
+ 	ath9k_cmn_debug_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
++	ath9k_cmn_debug_chanbw(sc->debug.debugfs_phy, sc->sc_ah);
  
-+
-+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-+	unsigned long chan_bw;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (kstrtoul(buf, 0, &chan_bw))
-+		return -EINVAL;
-+
-+	common->chan_bw = chan_bw;
-+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
-+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_chanbw = {
-+	.read = read_file_chan_bw,
-+	.write = write_file_chan_bw,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1481,6 +1527,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 
- 	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_eeprom);
-+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_chanbw);
- 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
- 				    read_file_dma);
- 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
+ 	debugfs_create_u32("gpio_mask", 0600,
+ 			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);
 --- a/drivers/net/wireless/ath/ath.h
 +++ b/drivers/net/wireless/ath/ath.h
-@@ -149,6 +149,7 @@ struct ath_common {
+@@ -151,6 +151,7 @@ struct ath_common {
  	int debug_mask;
  	enum ath_device_state state;
  	unsigned long op_flags;
@@ -72,6 +18,14 @@
  
  	struct ath_ani ani;
  
+@@ -181,6 +182,7 @@ struct ath_common {
+ 	const struct ath_ops *ops;
+ 	const struct ath_bus_ops *bus_ops;
+ 	const struct ath_ps_ops *ps_ops;
++	const struct ieee80211_ops *ieee_ops;
+ 
+ 	bool btcoex_enabled;
+ 	bool disable_ani;
 --- a/drivers/net/wireless/ath/ath9k/common.c
 +++ b/drivers/net/wireless/ath/ath9k/common.c
 @@ -297,11 +297,13 @@ EXPORT_SYMBOL(ath9k_cmn_get_hw_crypto_ke
@@ -123,3 +77,115 @@
  
  	return channel;
  }
+--- a/drivers/net/wireless/ath/ath9k/common-debug.c
++++ b/drivers/net/wireless/ath/ath9k/common-debug.c
+@@ -315,3 +315,55 @@ void ath9k_cmn_debug_eeprom(struct dentr
+ 			    &fops_eeprom);
+ }
+ EXPORT_SYMBOL(ath9k_cmn_debug_eeprom);
++
++static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
++			     size_t count, loff_t *ppos)
++{
++	struct ath_hw *ah = file->private_data;
++	struct ath_common *common = ath9k_hw_common(ah);
++	char buf[32];
++	unsigned int len;
++
++	len = sprintf(buf, "0x%08x\n", common->chan_bw);
++	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
++}
++
++static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
++			     size_t count, loff_t *ppos)
++{
++	struct ath_hw *ah = file->private_data;
++	struct ath_common *common = ath9k_hw_common(ah);
++	unsigned long chan_bw;
++	char buf[32];
++	ssize_t len;
++
++	len = min(count, sizeof(buf) - 1);
++	if (copy_from_user(buf, user_buf, len))
++		return -EFAULT;
++
++	buf[len] = '\0';
++	if (kstrtoul(buf, 0, &chan_bw))
++		return -EINVAL;
++
++	common->chan_bw = chan_bw;
++	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
++		common->ieee_ops->config(ah->hw, IEEE80211_CONF_CHANGE_CHANNEL);
++
++	return count;
++}
++
++static const struct file_operations fops_chanbw = {
++	.read = read_file_chan_bw,
++	.write = write_file_chan_bw,
++	.open = simple_open,
++	.owner = THIS_MODULE,
++	.llseek = default_llseek,
++};
++
++void ath9k_cmn_debug_chanbw(struct dentry *debugfs_phy,
++			    struct ath_hw *ah)
++{
++	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, debugfs_phy, ah,
++			    &fops_chanbw);
++}
++EXPORT_SYMBOL(ath9k_cmn_debug_chanbw);
+--- a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
++++ b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
+@@ -513,6 +513,7 @@ int ath9k_htc_init_debug(struct ath_hw *
+ 	ath9k_cmn_debug_base_eeprom(priv->debug.debugfs_phy, priv->ah);
+ 	ath9k_cmn_debug_modal_eeprom(priv->debug.debugfs_phy, priv->ah);
+ 	ath9k_cmn_debug_eeprom(priv->debug.debugfs_phy, priv->ah);
++	ath9k_cmn_debug_chanbw(priv->debug.debugfs_phy, priv->ah);
+ 
+ 	return 0;
+ }
+--- a/drivers/net/wireless/ath/ath9k/common-debug.h
++++ b/drivers/net/wireless/ath/ath9k/common-debug.h
+@@ -71,6 +71,8 @@ void ath9k_cmn_debug_base_eeprom(struct
+ 				 struct ath_hw *ah);
+ void ath9k_cmn_debug_eeprom(struct dentry *debugfs_phy,
+ 			    struct ath_hw *ah);
++void ath9k_cmn_debug_chanbw(struct dentry *debugfs_phy,
++			    struct ath_hw *ah);
+ void ath9k_cmn_debug_stat_rx(struct ath_rx_stats *rxstats,
+ 			     struct ath_rx_status *rs);
+ void ath9k_cmn_debug_recv(struct dentry *debugfs_phy,
+--- a/drivers/net/wireless/ath/ath9k/htc_drv_init.c
++++ b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
+@@ -631,6 +631,7 @@ static int ath9k_init_priv(struct ath9k_
+ 	priv->ah = ah;
+ 
+ 	common = ath9k_hw_common(ah);
++	common->ieee_ops = &ath9k_htc_ops;
+ 	common->ops = &ah->reg_ops;
+ 	common->ps_ops = &ath9k_htc_ps_ops;
+ 	common->bus_ops = &ath9k_usb_bus_ops;
+@@ -746,9 +747,9 @@ static void ath9k_set_hw_capab(struct at
+ 
+ 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN |
+ 			    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |
+-			    WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+-
+-	hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
++			    WIPHY_FLAG_HAS_CHANNEL_SWITCH |
++			    WIPHY_FLAG_SUPPORTS_5_10_MHZ |
++			    WIPHY_FLAG_SUPPORTS_TDLS;
+ 
+ 	hw->queues = 4;
+ 	hw->max_listen_interval = 1;
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -733,6 +733,7 @@ static int ath9k_init_softc(u16 devid, s
+ 	if (!ath9k_is_chanctx_enabled())
+ 		sc->cur_chan->hw_queue_base = 0;
+ 
++	common->ieee_ops = &ath9k_ops;
+ 	common->ops = &ah->reg_ops;
+ 	common->bus_ops = bus_ops;
+ 	common->ps_ops = &ath9k_ps_ops;
diff --git a/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch b/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
index a085e3a1..6b60d3c0 100644
--- a/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
+++ b/package/kernel/mac80211/patches/ath9k/513-ath9k_add_pci_ids.patch
@@ -20,7 +20,7 @@
  #define AR9160_DEVID_PCI	0x0027
 --- a/drivers/net/wireless/ath/ath9k/pci.c
 +++ b/drivers/net/wireless/ath/ath9k/pci.c
-@@ -774,6 +774,7 @@ static const struct pci_device_id ath_pc
+@@ -772,6 +772,7 @@ static const struct pci_device_id ath_pc
  	  .driver_data = ATH9K_PCI_BT_ANT_DIV },
  #endif
  
diff --git a/package/kernel/mac80211/patches/ath9k/530-ath9k_extra_leds.patch b/package/kernel/mac80211/patches/ath9k/530-ath9k_extra_leds.patch
index 1fe00410..4bb27d55 100644
--- a/package/kernel/mac80211/patches/ath9k/530-ath9k_extra_leds.patch
+++ b/package/kernel/mac80211/patches/ath9k/530-ath9k_extra_leds.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -843,6 +843,9 @@ static inline int ath9k_dump_btcoex(stru
+@@ -845,6 +845,9 @@ static inline int ath9k_dump_btcoex(stru
  #ifdef CPTCFG_MAC80211_LEDS
  void ath_init_leds(struct ath_softc *sc);
  void ath_deinit_leds(struct ath_softc *sc);
@@ -10,7 +10,7 @@
  #else
  static inline void ath_init_leds(struct ath_softc *sc)
  {
-@@ -979,6 +982,13 @@ void ath_ant_comb_scan(struct ath_softc
+@@ -981,6 +984,13 @@ void ath_ant_comb_scan(struct ath_softc
  
  #define ATH9K_NUM_CHANCTX  2 /* supports 2 operating channels */
  
@@ -24,7 +24,7 @@
  struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
-@@ -1032,9 +1042,8 @@ struct ath_softc {
+@@ -1034,9 +1044,8 @@ struct ath_softc {
  	spinlock_t chan_lock;
  
  #ifdef CPTCFG_MAC80211_LEDS
@@ -181,7 +181,7 @@
  
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1088,7 +1088,7 @@ int ath9k_init_device(u16 devid, struct
+@@ -1089,7 +1089,7 @@ int ath9k_init_device(u16 devid, struct
  
  #ifdef CPTCFG_MAC80211_LEDS
  	/* must be initialized before ieee80211_register_hw */
@@ -192,9 +192,9 @@
  #endif
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1505,6 +1505,61 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
+@@ -123,6 +123,61 @@ static const struct file_operations fops
+ 
+ #define DMA_BUF_LEN 1024
  
 +#ifdef CONFIG_MAC80211_LEDS
 +
@@ -252,12 +252,12 @@
 +#endif
 +
  
- int ath9k_init_debug(struct ath_hw *ah)
- {
-@@ -1529,6 +1584,10 @@ int ath9k_init_debug(struct ath_hw *ah)
- 			    &fops_eeprom);
- 	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
- 			    sc, &fops_chanbw);
+ static ssize_t read_file_ani(struct file *file, char __user *user_buf,
+ 			     size_t count, loff_t *ppos)
+@@ -1390,6 +1445,10 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 	ath9k_tx99_init_debug(sc);
+ 	ath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);
+ 
 +#ifdef CONFIG_MAC80211_LEDS
 +	debugfs_create_file("gpio_led", S_IWUSR,
 +			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
diff --git a/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch b/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
index 8ed7ad8a..1055bd33 100644
--- a/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
+++ b/package/kernel/mac80211/patches/ath9k/531-ath9k_extra_platform_leds.patch
@@ -1,15 +1,3 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -46,6 +46,9 @@ struct ath9k_platform_data {
- 	int (*external_reset)(void);
- 
- 	bool use_eeprom;
-+
-+	int num_leds;
-+	const struct gpio_led *leds;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
 --- a/drivers/net/wireless/ath/ath9k/gpio.c
 +++ b/drivers/net/wireless/ath/ath9k/gpio.c
 @@ -15,6 +15,7 @@
diff --git a/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch b/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
index 70f7ee36..f08301c7 100644
--- a/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
+++ b/package/kernel/mac80211/patches/ath9k/542-ath9k_debugfs_diag.patch
@@ -1,8 +1,8 @@
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1561,6 +1561,50 @@ static const struct file_operations fops
- #endif
- 
+@@ -1428,6 +1428,50 @@ void ath9k_deinit_debug(struct ath_softc
+ 	ath9k_cmn_spectral_deinit_debug(&sc->spec_priv);
+ }
  
 +static ssize_t read_file_diag(struct file *file, char __user *user_buf,
 +			     size_t count, loff_t *ppos)
@@ -51,7 +51,7 @@
  int ath9k_init_debug(struct ath_hw *ah)
  {
  	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1588,6 +1632,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1449,6 +1493,8 @@ int ath9k_init_debug(struct ath_hw *ah)
  	debugfs_create_file("gpio_led", S_IWUSR,
  			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
  #endif
@@ -125,7 +125,7 @@
  		REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
 --- a/drivers/net/wireless/ath/ath9k/main.c
 +++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -538,6 +538,11 @@ irqreturn_t ath_isr(int irq, void *dev)
+@@ -537,6 +537,11 @@ irqreturn_t ath_isr(int irq, void *dev)
  		return IRQ_HANDLED;
  	}
  
diff --git a/package/kernel/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch b/package/kernel/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
index 6acc864d..0fedc712 100644
--- a/package/kernel/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
+++ b/package/kernel/mac80211/patches/ath9k/543-ath9k_entropy_from_adc.patch
@@ -18,7 +18,7 @@
  	void (*spectral_scan_trigger)(struct ath_hw *ah);
 --- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
 +++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -1918,6 +1918,26 @@ void ar9003_hw_init_rate_txpower(struct
+@@ -1915,6 +1915,26 @@ void ar9003_hw_init_rate_txpower(struct
  	}
  }
  
@@ -26,9 +26,9 @@
 +{
 +	int i, j;
 +
-+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
-+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
-+	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
++	REG_RMW_FIELD(ah, AR_PHY_TEST(ah), AR_PHY_TEST_BBB_OBS_SEL, 1);
++	REG_CLR_BIT(ah, AR_PHY_TEST(ah), AR_PHY_TEST_RX_OBS_SEL_BIT5);
++	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS(ah), AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
 +
 +	memset(buf, 0, len);
 +	for (i = 0; i < len; i++) {
@@ -45,7 +45,7 @@
  void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
  {
  	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
-@@ -1954,6 +1974,7 @@ void ar9003_hw_attach_phy_ops(struct ath
+@@ -1951,6 +1971,7 @@ void ar9003_hw_attach_phy_ops(struct ath
  	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
  	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
  
@@ -55,7 +55,7 @@
  	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -870,7 +870,8 @@ static void ath9k_init_txpower_limits(st
+@@ -871,7 +871,8 @@ static void ath9k_init_txpower_limits(st
  	if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
  		ath9k_init_band_txpower(sc, NL80211_BAND_5GHZ);
  
@@ -65,7 +65,7 @@
  }
  
  static const struct ieee80211_iface_limit if_limits[] = {
-@@ -1048,6 +1049,18 @@ static void ath9k_set_hw_capab(struct at
+@@ -1049,6 +1050,18 @@ static void ath9k_set_hw_capab(struct at
  	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);
  }
  
@@ -84,7 +84,7 @@
  int ath9k_init_device(u16 devid, struct ath_softc *sc,
  		    const struct ath_bus_ops *bus_ops)
  {
-@@ -1095,6 +1108,8 @@ int ath9k_init_device(u16 devid, struct
+@@ -1096,6 +1109,8 @@ int ath9k_init_device(u16 devid, struct
  
  	wiphy_read_of_freq_limits(hw->wiphy);
  
diff --git a/package/kernel/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch b/package/kernel/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
index d3bf07ff..6027741c 100644
--- a/package/kernel/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
+++ b/package/kernel/mac80211/patches/ath9k/545-ath9k_ani_ws_detect.patch
@@ -79,7 +79,7 @@
  static const u8 ofdm2pwr[] = {
  	ALL_TARGET_LEGACY_6_24,
  	ALL_TARGET_LEGACY_6_24,
-@@ -1068,11 +1054,6 @@ static bool ar9003_hw_ani_control(struct
+@@ -1065,11 +1051,6 @@ static bool ar9003_hw_ani_control(struct
  	struct ath_common *common = ath9k_hw_common(ah);
  	struct ath9k_channel *chan = ah->curchan;
  	struct ar5416AniState *aniState = &ah->ani;
@@ -91,7 +91,7 @@
  	s32 value, value2;
  
  	switch (cmd & ah->ani_function) {
-@@ -1086,61 +1067,6 @@ static bool ar9003_hw_ani_control(struct
+@@ -1083,61 +1064,6 @@ static bool ar9003_hw_ani_control(struct
  		 */
  		u32 on = param ? 1 : 0;
  
diff --git a/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch b/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
index 78206d28..9fb549cc 100644
--- a/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
+++ b/package/kernel/mac80211/patches/ath9k/548-ath9k_enable_gpio_chip.patch
@@ -10,7 +10,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 ---
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -24,6 +24,7 @@
+@@ -25,6 +25,7 @@
  #include <linux/completion.h>
  #include <linux/time.h>
  #include <linux/hw_random.h>
@@ -18,7 +18,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  #include "common.h"
  #include "debug.h"
-@@ -989,6 +990,14 @@ struct ath_led {
+@@ -991,6 +992,14 @@ struct ath_led {
  	struct led_classdev cdev;
  };
  
@@ -33,7 +33,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
-@@ -1044,6 +1053,9 @@ struct ath_softc {
+@@ -1046,6 +1055,9 @@ struct ath_softc {
  #ifdef CPTCFG_MAC80211_LEDS
  	const char *led_default_trigger;
  	struct list_head leds;
@@ -45,7 +45,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  #ifdef CPTCFG_ATH9K_DEBUGFS
 --- a/drivers/net/wireless/ath/ath9k/gpio.c
 +++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -16,13 +16,139 @@
+@@ -16,13 +16,135 @@
  
  #include "ath9k.h"
  #include <linux/ath9k_platform.h>
@@ -91,7 +91,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +						  gchip);
 +	struct ath_hw *ah = gc->sc->sc_ah;
 +
-+	return !((REG_READ(ah, AR_GPIO_OE_OUT) >> (offset * 2)) & 3);
++	return !((REG_READ(ah, AR_GPIO_OE_OUT(ah)) >> (offset * 2)) & 3);
 +}
 +
 +/* gpio_chip handler : get GPIO pin value */
@@ -127,11 +127,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 +	snprintf(gc->label, sizeof(gc->label), "ath9k-%s",
 +		 wiphy_name(sc->hw->wiphy));
 +#ifdef CONFIG_OF
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
 +	gc->gchip.parent = sc->dev;
-+#else
-+	gc->gchip.dev = sc->dev;
-+#endif
 +#endif
 +	gc->gchip.label = gc->label;
 +	gc->gchip.base = -1;	/* determine base automatically */
@@ -187,7 +183,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  static void ath_fill_led_pin(struct ath_softc *sc)
  {
  	struct ath_hw *ah = sc->sc_ah;
-@@ -80,6 +206,12 @@ static int ath_add_led(struct ath_softc
+@@ -80,6 +202,12 @@ static int ath_add_led(struct ath_softc
  	else
  		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
  
@@ -200,7 +196,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	return 0;
  }
  
-@@ -136,17 +268,24 @@ void ath_deinit_leds(struct ath_softc *s
+@@ -136,17 +264,24 @@ void ath_deinit_leds(struct ath_softc *s
  
  	while (!list_empty(&sc->leds)) {
  		led = list_first_entry(&sc->leds, struct ath_led, list);
@@ -225,7 +221,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	char led_name[32];
  	const char *trigger;
  	int i;
-@@ -156,6 +295,15 @@ void ath_init_leds(struct ath_softc *sc)
+@@ -156,6 +291,15 @@ void ath_init_leds(struct ath_softc *sc)
  	if (AR_SREV_9100(sc->sc_ah))
  		return;
  
@@ -241,7 +237,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	ath_fill_led_pin(sc);
  
  	if (pdata && pdata->leds && pdata->num_leds)
-@@ -180,6 +328,7 @@ void ath_init_leds(struct ath_softc *sc)
+@@ -180,6 +324,7 @@ void ath_init_leds(struct ath_softc *sc)
  	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger,
  			   !sc->sc_ah->config.led_active_high);
  }
diff --git a/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch b/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
index 716e09f3..d164d890 100644
--- a/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
+++ b/package/kernel/mac80211/patches/ath9k/549-ath9k_enable_gpio_buttons.patch
@@ -10,7 +10,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 ---
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -1055,6 +1055,7 @@ struct ath_softc {
+@@ -1057,6 +1057,7 @@ struct ath_softc {
  	struct list_head leds;
  #ifdef CONFIG_GPIOLIB
  	struct ath9k_gpio_chip *gpiochip;
@@ -29,7 +29,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  #ifdef CPTCFG_MAC80211_LEDS
  
-@@ -133,6 +135,67 @@ static void ath9k_unregister_gpio_chip(s
+@@ -129,6 +131,67 @@ static void ath9k_unregister_gpio_chip(s
  	sc->gpiochip = NULL;
  }
  
@@ -97,7 +97,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  #else /* CONFIG_GPIOLIB */
  
  static inline void ath9k_register_gpio_chip(struct ath_softc *sc)
-@@ -143,6 +206,14 @@ static inline void ath9k_unregister_gpio
+@@ -139,6 +202,14 @@ static inline void ath9k_unregister_gpio
  {
  }
  
@@ -112,7 +112,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  #endif /* CONFIG_GPIOLIB */
  
  /********************************/
-@@ -266,6 +337,7 @@ void ath_deinit_leds(struct ath_softc *s
+@@ -262,6 +333,7 @@ void ath_deinit_leds(struct ath_softc *s
  {
  	struct ath_led *led;
  
@@ -120,7 +120,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  	while (!list_empty(&sc->leds)) {
  		led = list_first_entry(&sc->leds, struct ath_led, list);
  #ifdef CONFIG_GPIOLIB
-@@ -305,6 +377,7 @@ void ath_init_leds(struct ath_softc *sc)
+@@ -301,6 +373,7 @@ void ath_init_leds(struct ath_softc *sc)
  	}
  
  	ath_fill_led_pin(sc);
@@ -128,16 +128,3 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  	if (pdata && pdata->leds && pdata->num_leds)
  		for (i = 0; i < pdata->num_leds; i++) {
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -49,6 +49,10 @@ struct ath9k_platform_data {
- 
- 	int num_leds;
- 	const struct gpio_led *leds;
-+
-+	unsigned num_btns;
-+	const struct gpio_keys_button *btns;
-+	unsigned btn_poll_interval;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
diff --git a/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch b/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
index efc4b918..3ccd3fc4 100644
--- a/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
+++ b/package/kernel/mac80211/patches/ath9k/551-ath9k_ubnt_uap_plus_hsr.patch
@@ -339,7 +339,7 @@
  
  static void ath9k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
  			u32 queues, bool drop);
-@@ -659,6 +660,7 @@ void ath_reset_work(struct work_struct *
+@@ -658,6 +659,7 @@ void ath_reset_work(struct work_struct *
  static int ath9k_start(struct ieee80211_hw *hw)
  {
  	struct ath_softc *sc = hw->priv;
@@ -347,7 +347,7 @@
  	struct ath_hw *ah = sc->sc_ah;
  	struct ath_common *common = ath9k_hw_common(ah);
  	struct ieee80211_channel *curchan = sc->cur_chan->chandef.chan;
-@@ -737,6 +739,11 @@ static int ath9k_start(struct ieee80211_
+@@ -736,6 +738,11 @@ static int ath9k_start(struct ieee80211_
  					  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
  	}
  
@@ -371,7 +371,7 @@
  
 --- a/local-symbols
 +++ b/local-symbols
-@@ -129,6 +129,7 @@ ATH9K_WOW=
+@@ -123,6 +123,7 @@ ATH9K_WOW=
  ATH9K_RFKILL=
  ATH9K_CHANNEL_CONTEXT=
  ATH9K_PCOEM=
@@ -400,4 +400,4 @@
 +
  config ATH9K_DEBUGFS
  	bool "Atheros ath9k debugging"
- 	depends on ATH9K && DEBUG_FS
+ 	depends on ATH9K && DEBUG_FS && MAC80211_DEBUGFS
diff --git a/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch b/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
index 57eef54e..3adc8bb8 100644
--- a/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
+++ b/package/kernel/mac80211/patches/ath9k/552-ath9k-ahb_of.patch
@@ -16,7 +16,7 @@
  
  static const struct platform_device_id ath9k_platform_id_table[] = {
  	{
-@@ -69,6 +77,236 @@ static const struct ath_bus_ops ath_ahb_
+@@ -69,6 +77,192 @@ static const struct ath_bus_ops ath_ahb_
  	.eeprom_read = ath_ahb_eeprom_read,
  };
  
@@ -25,47 +25,6 @@
 +#define QCA955X_DDR_CTL_CONFIG          0x108
 +#define QCA955X_DDR_CTL_CONFIG_ACT_WMAC BIT(23)
 +
-+static int of_get_wifi_cal(struct device_node *np, struct ath9k_platform_data *pdata)
-+{
-+#ifdef CONFIG_MTD
-+	struct device_node *mtd_np = NULL;
-+	size_t retlen;
-+	int size, ret;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+
-+	list = of_get_property(np, "mtd-cal-data", &size);
-+	if (!list)
-+		return 0;
-+
-+	if (size != (2 * sizeof(*list)))
-+		return 1;
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+
-+	if (!mtd_np)
-+		return 1;
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd))
-+		return 1;
-+
-+	ret = mtd_read(mtd, be32_to_cpup(list), sizeof(pdata->eeprom_data),
-+			&retlen, (u8*)pdata->eeprom_data);
-+	put_mtd_device(mtd);
-+
-+#endif
-+	return 0;
-+}
-+
 +static int ar913x_wmac_reset(void)
 +{
 +	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
@@ -243,9 +202,6 @@
 +
 +	pdata->get_mac_revision = data->soc_revision;
 +
-+	if (of_get_wifi_cal(pdev->dev.of_node, pdata))
-+		dev_err(&pdev->dev, "failed to load calibration data from mtd device\n");
-+
 +	return data->dev_id;
 +}
 +#endif
@@ -253,7 +209,7 @@
  static int ath_ahb_probe(struct platform_device *pdev)
  {
  	void __iomem *mem;
-@@ -80,6 +318,17 @@ static int ath_ahb_probe(struct platform
+@@ -80,6 +274,17 @@ static int ath_ahb_probe(struct platform
  	int ret = 0;
  	struct ath_hw *ah;
  	char hw_name[64];
@@ -271,7 +227,7 @@
  
  	if (!dev_get_platdata(&pdev->dev)) {
  		dev_err(&pdev->dev, "no platform data specified\n");
-@@ -118,13 +367,16 @@ static int ath_ahb_probe(struct platform
+@@ -118,17 +323,23 @@ static int ath_ahb_probe(struct platform
  	sc->mem = mem;
  	sc->irq = irq;
  
@@ -289,18 +245,15 @@
  	if (ret) {
  		dev_err(&pdev->dev, "failed to initialize device\n");
  		goto err_irq;
-@@ -155,6 +407,9 @@ static int ath_ahb_remove(struct platfor
- 		free_irq(sc->irq, sc);
- 		ieee80211_free_hw(sc->hw);
  	}
 +#ifdef CONFIG_OF
 +	pdev->dev.platform_data = NULL;
 +#endif
  
- 	return 0;
- }
-@@ -164,6 +419,9 @@ static struct platform_driver ath_ahb_dr
- 	.remove     = ath_ahb_remove,
+ 	ah = sc->sc_ah;
+ 	ath9k_hw_name(ah, hw_name, sizeof(hw_name));
+@@ -162,6 +373,9 @@ static struct platform_driver ath_ahb_dr
+ 	.remove_new = ath_ahb_remove,
  	.driver		= {
  		.name	= "ath9k",
 +#ifdef CONFIG_OF
@@ -311,7 +264,7 @@
  };
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -25,6 +25,7 @@
+@@ -26,6 +26,7 @@
  #include <linux/time.h>
  #include <linux/hw_random.h>
  #include <linux/gpio/driver.h>
@@ -319,7 +272,7 @@
  
  #include "common.h"
  #include "debug.h"
-@@ -1011,6 +1012,9 @@ struct ath_softc {
+@@ -1013,6 +1014,9 @@ struct ath_softc {
  	struct ath_hw *sc_ah;
  	void __iomem *mem;
  	int irq;
diff --git a/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch b/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
index 6d1820ec..752a4980 100644
--- a/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
+++ b/package/kernel/mac80211/patches/ath9k/553-ath9k_of_gpio_mask.patch
@@ -13,7 +13,7 @@
  static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
  			    const struct ath_bus_ops *bus_ops)
  {
-@@ -803,6 +809,9 @@ static int ath9k_init_softc(u16 devid, s
+@@ -804,6 +810,9 @@ static int ath9k_init_softc(u16 devid, s
  	if (ret)
  		goto err_hw;
  
diff --git a/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch b/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch
index 09ef5052..295a4cca 100644
--- a/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch
+++ b/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch
@@ -22,7 +22,7 @@
  static int modparam_bad_frames_preempt;
  module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
  MODULE_PARM_DESC(bad_frames_preempt,
-@@ -2869,10 +2874,10 @@ static int b43_gpio_init(struct b43_wlde
+@@ -2870,10 +2875,10 @@ static int b43_gpio_init(struct b43_wlde
  	u32 mask, set;
  
  	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
diff --git a/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch b/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch
index 22b67c49..e9f915d2 100644
--- a/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch
+++ b/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch
@@ -9,7 +9,7 @@
  	antenna = b43_antenna_to_phyctl(antenna);
  	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
  	/* We can't send beacons with short preamble. Would get PHY errors. */
-@@ -3284,8 +3284,8 @@ static int b43_chip_init(struct b43_wlde
+@@ -3285,8 +3285,8 @@ static int b43_chip_init(struct b43_wlde
  
  	/* Select the antennae */
  	if (phy->ops->set_rx_antenna)
@@ -20,7 +20,7 @@
  
  	if (phy->type == B43_PHYTYPE_B) {
  		value16 = b43_read16(dev, 0x005E);
-@@ -3986,7 +3986,6 @@ static int b43_op_config(struct ieee8021
+@@ -3988,7 +3988,6 @@ static int b43_op_config(struct ieee8021
  	struct b43_wldev *dev = wl->current_dev;
  	struct b43_phy *phy = &dev->phy;
  	struct ieee80211_conf *conf = &hw->conf;
@@ -28,7 +28,7 @@
  	int err = 0;
  
  	mutex_lock(&wl->mutex);
-@@ -4029,11 +4028,9 @@ static int b43_op_config(struct ieee8021
+@@ -4031,11 +4030,9 @@ static int b43_op_config(struct ieee8021
  	}
  
  	/* Antennas for RX and management frame TX. */
@@ -42,7 +42,7 @@
  
  	if (wl->radio_enabled != phy->radio_on) {
  		if (wl->radio_enabled) {
-@@ -5176,6 +5173,47 @@ static int b43_op_get_survey(struct ieee
+@@ -5178,6 +5175,47 @@ static int b43_op_get_survey(struct ieee
  	return 0;
  }
  
@@ -88,9 +88,9 @@
 +}
 +
  static const struct ieee80211_ops b43_hw_ops = {
- 	.tx			= b43_op_tx,
- 	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
-@@ -5198,6 +5236,8 @@ static const struct ieee80211_ops b43_hw
+ 	.add_chanctx = ieee80211_emulate_add_chanctx,
+ 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
+@@ -5204,6 +5242,8 @@ static const struct ieee80211_ops b43_hw
  	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
  	.get_survey		= b43_op_get_survey,
  	.rfkill_poll		= b43_rfkill_poll,
@@ -99,7 +99,7 @@
  };
  
  /* Hard-reset the chip. Do not call this directly.
-@@ -5499,6 +5539,8 @@ static int b43_one_core_attach(struct b4
+@@ -5505,6 +5545,8 @@ static int b43_one_core_attach(struct b4
  	if (!wldev)
  		goto out;
  
@@ -108,7 +108,7 @@
  	wldev->use_pio = b43_modparam_pio;
  	wldev->dev = dev;
  	wldev->wl = wl;
-@@ -5590,6 +5632,9 @@ static struct b43_wl *b43_wireless_init(
+@@ -5596,6 +5638,9 @@ static struct b43_wl *b43_wireless_init(
  
  	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
  
diff --git a/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch b/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch
index 9cb0a32f..f7aa4132 100644
--- a/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch
+++ b/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/broadcom/b43/main.c
 +++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2886,6 +2886,14 @@ static int b43_gpio_init(struct b43_wlde
+@@ -2887,6 +2887,14 @@ static int b43_gpio_init(struct b43_wlde
  	} else if (dev->dev->chip_id == 0x5354) {
  		/* Don't allow overtaking buttons GPIOs */
  		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
diff --git a/package/kernel/mac80211/patches/brcm/860-brcmfmac-register-wiphy-s-during-module_init.patch b/package/kernel/mac80211/patches/brcm/860-brcmfmac-register-wiphy-s-during-module_init.patch
deleted file mode 100644
index 9d0f3e20..00000000
--- a/package/kernel/mac80211/patches/brcm/860-brcmfmac-register-wiphy-s-during-module_init.patch
+++ /dev/null
@@ -1,64 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Mon, 8 Jun 2015 16:11:40 +0200
-Subject: [PATCH] brcmfmac: register wiphy(s) during module_init
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This is needed by OpenWrt which expects all PHYs to be created after
-module loads successfully.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
-@@ -459,6 +459,7 @@ struct brcmf_fw {
- 	u32 curpos;
- 	unsigned int board_index;
- 	void (*done)(struct device *dev, int err, struct brcmf_fw_request *req);
-+	struct completion *completion;
- };
- 
- #ifdef CONFIG_EFI
-@@ -686,6 +687,8 @@ static void brcmf_fw_request_done(const
- 		fwctx->req = NULL;
- 	}
- 	fwctx->done(fwctx->dev, ret, fwctx->req);
-+	if (fwctx->completion)
-+		complete(fwctx->completion);
- 	kfree(fwctx);
- }
- 
-@@ -751,6 +754,8 @@ int brcmf_fw_get_firmwares(struct device
- {
- 	struct brcmf_fw_item *first = &req->items[0];
- 	struct brcmf_fw *fwctx;
-+	struct completion completion;
-+	unsigned long time_left;
- 	char *alt_path = NULL;
- 	int ret;
- 
-@@ -768,6 +773,9 @@ int brcmf_fw_get_firmwares(struct device
- 	fwctx->dev = dev;
- 	fwctx->req = req;
- 	fwctx->done = fw_cb;
-+ 
-+	init_completion(&completion);
-+	fwctx->completion = &completion;
- 
- 	/* First try alternative board-specific path if any */
- 	if (fwctx->req->board_types[0])
-@@ -787,6 +795,12 @@ int brcmf_fw_get_firmwares(struct device
- 	if (ret < 0)
- 		brcmf_fw_request_done(NULL, fwctx);
- 
-+
-+	time_left = wait_for_completion_timeout(&completion,
-+						msecs_to_jiffies(5000));
-+	if (!time_left && fwctx)
-+		fwctx->completion = NULL;
-+
- 	return 0;
- }
- 
diff --git a/package/kernel/mac80211/patches/brcm/861-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch b/package/kernel/mac80211/patches/brcm/861-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch
index b82b442a..84b989d8 100644
--- a/package/kernel/mac80211/patches/brcm/861-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch
+++ b/package/kernel/mac80211/patches/brcm/861-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch
@@ -10,7 +10,7 @@ Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
 
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -713,8 +713,36 @@ static struct wireless_dev *brcmf_cfg802
+@@ -980,8 +980,36 @@ static struct wireless_dev *brcmf_cfg802
  	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
  	struct brcmf_pub *drvr = cfg->pub;
  	struct wireless_dev *wdev;
diff --git a/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch b/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch
index 080ab8f7..3472ff6a 100644
--- a/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch
+++ b/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch
@@ -14,7 +14,7 @@ Signed-off-by: Phil Elwell <phil@raspberrypi.org>
 
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2976,6 +2976,10 @@ brcmf_cfg80211_set_power_mgmt(struct wip
+@@ -3314,6 +3314,10 @@ brcmf_cfg80211_set_power_mgmt(struct wip
  	 * preference in cfg struct to apply this to
  	 * FW later while initializing the dongle
  	 */
diff --git a/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch b/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch
index 25191b64..1f0609e3 100644
--- a/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch
+++ b/package/kernel/mac80211/patches/brcm/863-brcmfmac-add-in-driver-tables-with-country-codes.patch
@@ -49,9 +49,9 @@ Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
  void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
  		    struct brcmf_mp_device *settings)
  {
-@@ -106,6 +136,8 @@ void brcmf_of_probe(struct device *dev,
- 		of_node_put(root);
+@@ -113,6 +143,8 @@ void brcmf_of_probe(struct device *dev,
  	}
+ 	of_node_put(root);
  
 +	brcmf_of_probe_cc(dev, settings);
 +
diff --git a/package/kernel/mac80211/patches/brcm/865-brcmfmac-Read-alternative-firmware-names-from-DT.patch b/package/kernel/mac80211/patches/brcm/865-brcmfmac-Read-alternative-firmware-names-from-DT.patch
deleted file mode 100644
index 8ed81f60..00000000
--- a/package/kernel/mac80211/patches/brcm/865-brcmfmac-Read-alternative-firmware-names-from-DT.patch
+++ /dev/null
@@ -1,187 +0,0 @@
-From 4e32024cbb14230af3048e249e84f8c2b25ce45a Mon Sep 17 00:00:00 2001
-From: Phil Elwell <phil@raspberrypi.com>
-Date: Thu, 28 Oct 2021 15:03:16 +0100
-Subject: [PATCH] brcmfmac: Read alternative firmware names from DT
-
-Add the ability to load the names of alternative firmwares from the
-Device Tree node. This permits separate firmwares for 43436s and 43438
-and allows downstream firmwares to coexist with upstream.
-
-Signed-off-by: Phil Elwell <phil@raspberrypi.com>
----
- .../wireless/broadcom/brcm80211/brcmfmac/of.c | 36 ++++++++++++++
- .../wireless/broadcom/brcm80211/brcmfmac/of.h |  7 +++
- .../broadcom/brcm80211/brcmfmac/sdio.c        | 47 +++++++++++++++++--
- 3 files changed, 87 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
-@@ -11,6 +11,7 @@
- #include "debug.h"
- #include "core.h"
- #include "common.h"
-+#include "firmware.h"
- #include "of.h"
- 
- static int brcmf_of_get_country_codes(struct device *dev,
-@@ -168,3 +169,38 @@ void brcmf_of_probe(struct device *dev,
- 	sdio->oob_irq_nr = irq;
- 	sdio->oob_irq_flags = irqf;
- }
-+
-+struct brcmf_firmware_mapping *
-+brcmf_of_fwnames(struct device *dev, u32 *fwname_count)
-+{
-+	struct device_node *np = dev->of_node;
-+	struct brcmf_firmware_mapping *fwnames;
-+	struct device_node *map_np, *fw_np;
-+	int of_count;
-+	int count = 0;
-+
-+	map_np = of_get_child_by_name(np, "firmwares");
-+	of_count = of_get_child_count(map_np);
-+	if (!of_count)
-+		return NULL;
-+
-+	fwnames = devm_kcalloc(dev, of_count,
-+			       sizeof(struct brcmf_firmware_mapping),
-+			       GFP_KERNEL);
-+
-+	for_each_child_of_node(map_np, fw_np)
-+	{
-+		struct brcmf_firmware_mapping *cur = &fwnames[count];
-+
-+		if (of_property_read_u32(fw_np, "chipid", &cur->chipid) ||
-+		    of_property_read_u32(fw_np, "revmask", &cur->revmask))
-+			continue;
-+		cur->fw_base = of_get_property(fw_np, "fw_base", NULL);
-+		if (cur->fw_base)
-+			count++;
-+	}
-+
-+	*fwname_count = count;
-+
-+	return count ? fwnames : NULL;
-+}
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.h
-@@ -5,9 +5,16 @@
- #ifdef CONFIG_OF
- void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
- 		    struct brcmf_mp_device *settings);
-+struct brcmf_firmware_mapping *
-+brcmf_of_fwnames(struct device *dev, u32 *map_count);
- #else
- static void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
- 			   struct brcmf_mp_device *settings)
- {
- }
-+static struct brcmf_firmware_mapping *
-+brcmf_of_fwnames(struct device *dev, u32 *map_count)
-+{
-+	return NULL;
-+}
- #endif /* CONFIG_OF */
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-@@ -35,6 +35,7 @@
- #include "core.h"
- #include "common.h"
- #include "bcdc.h"
-+#include "of.h"
- 
- #define DCMD_RESP_TIMEOUT	msecs_to_jiffies(2500)
- #define CTL_DONE_TIMEOUT	msecs_to_jiffies(2500)
-@@ -634,7 +635,7 @@ MODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH "b
- /* per-board firmware binaries */
- MODULE_FIRMWARE(BRCMF_FW_DEFAULT_PATH "brcmfmac*-sdio.*.bin");
- 
--static const struct brcmf_firmware_mapping brcmf_sdio_fwnames[] = {
-+static const struct brcmf_firmware_mapping sdio_fwnames[] = {
- 	BRCMF_FW_ENTRY(BRCM_CC_43143_CHIP_ID, 0xFFFFFFFF, 43143),
- 	BRCMF_FW_ENTRY(BRCM_CC_43241_CHIP_ID, 0x0000001F, 43241B0),
- 	BRCMF_FW_ENTRY(BRCM_CC_43241_CHIP_ID, 0x00000020, 43241B4),
-@@ -662,6 +663,9 @@ static const struct brcmf_firmware_mappi
- 	BRCMF_FW_ENTRY(CY_CC_43752_CHIP_ID, 0xFFFFFFFF, 43752)
- };
- 
-+static const struct brcmf_firmware_mapping *brcmf_sdio_fwnames = sdio_fwnames;
-+static u32 brcmf_sdio_fwnames_count = ARRAY_SIZE(sdio_fwnames);
-+
- #define TXCTL_CREDITS	2
- 
- static void pkt_align(struct sk_buff *p, int len, int align)
-@@ -4193,6 +4197,9 @@ static const struct brcmf_bus_ops brcmf_
- #define BRCMF_SDIO_FW_NVRAM	1
- #define BRCMF_SDIO_FW_CLM	2
- 
-+static struct brcmf_fw_request *
-+brcmf_sdio_prepare_fw_request(struct brcmf_sdio *bus);
-+
- static void brcmf_sdio_firmware_callback(struct device *dev, int err,
- 					 struct brcmf_fw_request *fwreq)
- {
-@@ -4208,6 +4215,22 @@ static void brcmf_sdio_firmware_callback
- 
- 	brcmf_dbg(TRACE, "Enter: dev=%s, err=%d\n", dev_name(dev), err);
- 
-+	if (err && brcmf_sdio_fwnames != sdio_fwnames) {
-+		/* Try again with the standard firmware names */
-+		brcmf_sdio_fwnames = sdio_fwnames;
-+		brcmf_sdio_fwnames_count = ARRAY_SIZE(sdio_fwnames);
-+		kfree(fwreq);
-+		fwreq = brcmf_sdio_prepare_fw_request(bus);
-+		if (!fwreq) {
-+			err = -ENOMEM;
-+			goto fail;
-+		}
-+		err = brcmf_fw_get_firmwares(dev, fwreq,
-+					     brcmf_sdio_firmware_callback);
-+		if (!err)
-+			return;
-+	}
-+
- 	if (err)
- 		goto fail;
- 
-@@ -4418,7 +4441,7 @@ brcmf_sdio_prepare_fw_request(struct brc
- 
- 	fwreq = brcmf_fw_alloc_request(bus->ci->chip, bus->ci->chiprev,
- 				       brcmf_sdio_fwnames,
--				       ARRAY_SIZE(brcmf_sdio_fwnames),
-+				       brcmf_sdio_fwnames_count,
- 				       fwnames, ARRAY_SIZE(fwnames));
- 	if (!fwreq)
- 		return NULL;
-@@ -4438,6 +4461,9 @@ struct brcmf_sdio *brcmf_sdio_probe(stru
- 	struct brcmf_sdio *bus;
- 	struct workqueue_struct *wq;
- 	struct brcmf_fw_request *fwreq;
-+	struct brcmf_firmware_mapping *of_fwnames, *fwnames = NULL;
-+	const int fwname_size = sizeof(struct brcmf_firmware_mapping);
-+	u32 of_fw_count;
- 
- 	brcmf_dbg(TRACE, "Enter\n");
- 
-@@ -4520,6 +4546,21 @@ struct brcmf_sdio *brcmf_sdio_probe(stru
- 
- 	brcmf_dbg(INFO, "completed!!\n");
- 
-+	of_fwnames = brcmf_of_fwnames(sdiodev->dev, &of_fw_count);
-+	if (of_fwnames)
-+		fwnames = devm_kcalloc(sdiodev->dev,
-+				       of_fw_count + brcmf_sdio_fwnames_count,
-+				       fwname_size, GFP_KERNEL);
-+
-+	if (fwnames) {
-+		/* The array is scanned in order, so overrides come first */
-+		memcpy(fwnames, of_fwnames, of_fw_count * fwname_size);
-+		memcpy(fwnames + of_fw_count, sdio_fwnames,
-+		       brcmf_sdio_fwnames_count * fwname_size);
-+		brcmf_sdio_fwnames = fwnames;
-+		brcmf_sdio_fwnames_count += of_fw_count;
-+	}
-+
- 	fwreq = brcmf_sdio_prepare_fw_request(bus);
- 	if (!fwreq) {
- 		ret = -ENOMEM;
diff --git a/package/kernel/mac80211/patches/build/001-fix_build.patch b/package/kernel/mac80211/patches/build/001-fix_build.patch
index 8f63d36e..085eae3c 100644
--- a/package/kernel/mac80211/patches/build/001-fix_build.patch
+++ b/package/kernel/mac80211/patches/build/001-fix_build.patch
@@ -27,7 +27,7 @@
  	@set -e ; test -f local-symbols || (						\
  	echo "/--------------"								;\
  	echo "| You shouldn't run make in the backports tree, but only in"		;\
-@@ -60,58 +62,62 @@ mrproper:
+@@ -60,57 +62,62 @@ mrproper:
  	echo "| (that isn't currently running.)"					;\
  	echo "\\--"									;\
  	false)
@@ -56,13 +56,12 @@
 -			done								\
 -		) > Kconfig.kernel							;\
 -		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
--			kernelversion |	sed 's/^\(\([3-5]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
+-			kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
 -		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
 -		test "$$kver" != ""							;\
--		kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
--		kvers="$$kvers $$(seq 0 19 | sed 's/^/3./')"				;\
 -		kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
--		kvers="$$kvers $$(seq 0 99 | sed 's/^/5./')"				;\
+-		kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
+-		kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
 -		print=0									;\
 -		for v in $$kvers ; do							\
 -			if [ "$$print" = "1" ] ; then					\
@@ -112,14 +111,13 @@
 +	@echo " done."
 +
 +Kconfig.versions: Kconfig.kernel
-+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR) \
-+		kernelversion |	sed 's/^\(\([3-5]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
++	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
++		kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
 +	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
 +	test "$$kver" != ""							;\
-+	kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
-+	kvers="$$kvers $$(seq 0 19 | sed 's/^/3./')"				;\
 +	kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
-+	kvers="$$kvers $$(seq 0 99 | sed 's/^/5./')"				;\
++	kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
++	kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
 +	print=0									;\
 +	for v in $$kvers ; do							\
 +		if [ "$$print" = "1" ] ; then					\
@@ -127,8 +125,9 @@
 +			echo "    def_bool y"					;\
 +		fi								;\
 +		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-+	done > $@
-+	@RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
++	done > Kconfig.versions							;\
++	# RHEL as well, sadly we need to grep for it				;\
++	RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
 +				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
 +	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
 +				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
diff --git a/package/kernel/mac80211/patches/build/050-lib80211_option.patch b/package/kernel/mac80211/patches/build/050-lib80211_option.patch
deleted file mode 100644
index c1b1bc75..00000000
--- a/package/kernel/mac80211/patches/build/050-lib80211_option.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -188,7 +188,7 @@ config CFG80211_WEXT_EXPORT
- endif # CFG80211
- 
- config LIB80211
--	tristate
-+	tristate "lib80211"
- 	depends on m
- 	default n
- 	help
-@@ -198,19 +198,19 @@ config LIB80211
- 	  Drivers should select this themselves if needed.
- 
- config LIB80211_CRYPT_WEP
--	tristate
-+	tristate "lib80211 WEP support"
- 	depends on m
- 	select BPAUTO_CRYPTO_LIB_ARC4
- 
- config LIB80211_CRYPT_CCMP
--	tristate
-+	tristate "lib80211 CCMP support"
- 	depends on m
- 	depends on CRYPTO
- 	depends on CRYPTO_AES
- 	depends on CRYPTO_CCM
- 
- config LIB80211_CRYPT_TKIP
--	tristate
-+	tristate "lib80211 TKIP support"
- 	depends on m
- 	select BPAUTO_CRYPTO_LIB_ARC4
- 
diff --git a/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch b/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch
deleted file mode 100644
index 4ad2ac08..00000000
--- a/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch
+++ /dev/null
@@ -1,314 +0,0 @@
---- a/local-symbols
-+++ b/local-symbols
-@@ -470,43 +470,6 @@ USB_VL600=
- USB_NET_CH9200=
- USB_NET_AQC111=
- USB_RTL8153_ECM=
--SSB_POSSIBLE=
--SSB=
--SSB_SPROM=
--SSB_BLOCKIO=
--SSB_PCIHOST_POSSIBLE=
--SSB_PCIHOST=
--SSB_B43_PCI_BRIDGE=
--SSB_PCMCIAHOST_POSSIBLE=
--SSB_PCMCIAHOST=
--SSB_SDIOHOST_POSSIBLE=
--SSB_SDIOHOST=
--SSB_HOST_SOC=
--SSB_SERIAL=
--SSB_DRIVER_PCICORE_POSSIBLE=
--SSB_DRIVER_PCICORE=
--SSB_PCICORE_HOSTMODE=
--SSB_DRIVER_MIPS=
--SSB_SFLASH=
--SSB_EMBEDDED=
--SSB_DRIVER_EXTIF=
--SSB_DRIVER_GIGE=
--SSB_DRIVER_GPIO=
--BCMA_POSSIBLE=
--BCMA=
--BCMA_BLOCKIO=
--BCMA_HOST_PCI_POSSIBLE=
--BCMA_HOST_PCI=
--BCMA_HOST_SOC=
--BCMA_DRIVER_PCI=
--BCMA_DRIVER_PCI_HOSTMODE=
--BCMA_DRIVER_MIPS=
--BCMA_PFLASH=
--BCMA_SFLASH=
--BCMA_NFLASH=
--BCMA_DRIVER_GMAC_CMN=
--BCMA_DRIVER_GPIO=
--BCMA_DEBUG=
- USB_ACM=
- USB_PRINTER=
- USB_WDM=
---- a/drivers/net/wireless/broadcom/b43/Kconfig
-+++ b/drivers/net/wireless/broadcom/b43/Kconfig
-@@ -63,21 +63,21 @@ endchoice
- config B43_PCI_AUTOSELECT
- 	bool
- 	depends on B43 && SSB_PCIHOST_POSSIBLE
--	select SSB_PCIHOST
--	select SSB_B43_PCI_BRIDGE
-+	depends on SSB_PCIHOST
-+	depends on SSB_B43_PCI_BRIDGE
- 	default y
- 
- # Auto-select SSB PCICORE driver, if possible
- config B43_PCICORE_AUTOSELECT
- 	bool
- 	depends on B43 && SSB_DRIVER_PCICORE_POSSIBLE
--	select SSB_DRIVER_PCICORE
-+	depends on SSB_DRIVER_PCICORE
- 	default y
- 
- config B43_SDIO
- 	bool "Broadcom 43xx SDIO device support"
- 	depends on B43 && B43_SSB && SSB_SDIOHOST_POSSIBLE
--	select SSB_SDIOHOST
-+	depends on SSB_SDIOHOST
- 	help
- 	  Broadcom 43xx device support for Soft-MAC SDIO devices.
- 
-@@ -96,13 +96,13 @@ config B43_SDIO
- config B43_BCMA_PIO
- 	bool
- 	depends on B43 && B43_BCMA
--	select BCMA_BLOCKIO
-+	depends on BCMA_BLOCKIO
- 	default y
- 
- config B43_PIO
- 	bool
- 	depends on B43 && B43_SSB
--	select SSB_BLOCKIO
-+	depends on SSB_BLOCKIO
- 	default y
- 
- config B43_PHY_G
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2853,7 +2853,7 @@ static struct ssb_device *b43_ssb_gpio_d
- {
- 	struct ssb_bus *bus = dev->dev->sdev->bus;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
- #else
- 	return bus->chipco.dev;
-@@ -4871,7 +4871,7 @@ static int b43_wireless_core_init(struct
- 	}
- 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
- 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
--#if defined(CPTCFG_B43_SSB) && defined(CPTCFG_SSB_DRIVER_PCICORE)
-+#if defined(CPTCFG_B43_SSB) && defined(CONFIG_SSB_DRIVER_PCICORE)
- 	if (dev->dev->bus_type == B43_BUS_SSB &&
- 	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
- 	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
---- a/drivers/net/wireless/broadcom/b43legacy/Kconfig
-+++ b/drivers/net/wireless/broadcom/b43legacy/Kconfig
-@@ -3,7 +3,7 @@ config B43LEGACY
- 	tristate "Broadcom 43xx-legacy wireless support (mac80211 stack)"
- 	depends on m
- 	depends on SSB_POSSIBLE && MAC80211 && HAS_DMA
--	select SSB
-+	depends on SSB
- 	depends on FW_LOADER
- 	help
- 	  b43legacy is a driver for 802.11b devices from Broadcom (BCM4301 and
-@@ -25,15 +25,15 @@ config B43LEGACY
- config B43LEGACY_PCI_AUTOSELECT
- 	bool
- 	depends on B43LEGACY && SSB_PCIHOST_POSSIBLE
--	select SSB_PCIHOST
--	select SSB_B43_PCI_BRIDGE
-+	depends on SSB_PCIHOST
-+	depends on SSB_B43_PCI_BRIDGE
- 	default y
- 
- # Auto-select SSB PCICORE driver, if possible
- config B43LEGACY_PCICORE_AUTOSELECT
- 	bool
- 	depends on B43LEGACY && SSB_DRIVER_PCICORE_POSSIBLE
--	select SSB_DRIVER_PCICORE
-+	depends on SSB_DRIVER_PCICORE
- 	default y
- 
- # LED support
---- a/drivers/net/wireless/broadcom/b43legacy/main.c
-+++ b/drivers/net/wireless/broadcom/b43legacy/main.c
-@@ -1907,7 +1907,7 @@ static int b43legacy_gpio_init(struct b4
- 	if (dev->dev->id.revision >= 2)
- 		mask  |= 0x0010; /* FIXME: This is redundant. */
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
-@@ -1926,7 +1926,7 @@ static void b43legacy_gpio_cleanup(struc
- 	struct ssb_bus *bus = dev->dev->bus;
- 	struct ssb_device *gpiodev, *pcidev = NULL;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
---- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
-+++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
-@@ -8,7 +8,7 @@ config BRCMSMAC
- 	depends on m
- 	depends on MAC80211
- 	depends on BCMA_POSSIBLE
--	select BCMA
-+	depends on BCMA
- 	select BRCMUTIL
- 	depends on FW_LOADER
- 	depends on CORDIC
---- a/Kconfig.local
-+++ b/Kconfig.local
-@@ -1414,117 +1414,6 @@ config BACKPORTED_USB_NET_AQC111
- config BACKPORTED_USB_RTL8153_ECM
- 	tristate
- 	default USB_RTL8153_ECM
--config BACKPORTED_SSB_POSSIBLE
--	tristate
--	default SSB_POSSIBLE
--config BACKPORTED_SSB
--	tristate
--	default SSB
--config BACKPORTED_SSB_SPROM
--	tristate
--	default SSB_SPROM
--config BACKPORTED_SSB_BLOCKIO
--	tristate
--	default SSB_BLOCKIO
--config BACKPORTED_SSB_PCIHOST_POSSIBLE
--	tristate
--	default SSB_PCIHOST_POSSIBLE
--config BACKPORTED_SSB_PCIHOST
--	tristate
--	default SSB_PCIHOST
--config BACKPORTED_SSB_B43_PCI_BRIDGE
--	tristate
--	default SSB_B43_PCI_BRIDGE
--config BACKPORTED_SSB_PCMCIAHOST_POSSIBLE
--	tristate
--	default SSB_PCMCIAHOST_POSSIBLE
--config BACKPORTED_SSB_PCMCIAHOST
--	tristate
--	default SSB_PCMCIAHOST
--config BACKPORTED_SSB_SDIOHOST_POSSIBLE
--	tristate
--	default SSB_SDIOHOST_POSSIBLE
--config BACKPORTED_SSB_SDIOHOST
--	tristate
--	default SSB_SDIOHOST
--config BACKPORTED_SSB_HOST_SOC
--	tristate
--	default SSB_HOST_SOC
--config BACKPORTED_SSB_SERIAL
--	tristate
--	default SSB_SERIAL
--config BACKPORTED_SSB_DRIVER_PCICORE_POSSIBLE
--	tristate
--	default SSB_DRIVER_PCICORE_POSSIBLE
--config BACKPORTED_SSB_DRIVER_PCICORE
--	tristate
--	default SSB_DRIVER_PCICORE
--config BACKPORTED_SSB_PCICORE_HOSTMODE
--	tristate
--	default SSB_PCICORE_HOSTMODE
--config BACKPORTED_SSB_DRIVER_MIPS
--	tristate
--	default SSB_DRIVER_MIPS
--config BACKPORTED_SSB_SFLASH
--	tristate
--	default SSB_SFLASH
--config BACKPORTED_SSB_EMBEDDED
--	tristate
--	default SSB_EMBEDDED
--config BACKPORTED_SSB_DRIVER_EXTIF
--	tristate
--	default SSB_DRIVER_EXTIF
--config BACKPORTED_SSB_DRIVER_GIGE
--	tristate
--	default SSB_DRIVER_GIGE
--config BACKPORTED_SSB_DRIVER_GPIO
--	tristate
--	default SSB_DRIVER_GPIO
--config BACKPORTED_BCMA_POSSIBLE
--	tristate
--	default BCMA_POSSIBLE
--config BACKPORTED_BCMA
--	tristate
--	default BCMA
--config BACKPORTED_BCMA_BLOCKIO
--	tristate
--	default BCMA_BLOCKIO
--config BACKPORTED_BCMA_HOST_PCI_POSSIBLE
--	tristate
--	default BCMA_HOST_PCI_POSSIBLE
--config BACKPORTED_BCMA_HOST_PCI
--	tristate
--	default BCMA_HOST_PCI
--config BACKPORTED_BCMA_HOST_SOC
--	tristate
--	default BCMA_HOST_SOC
--config BACKPORTED_BCMA_DRIVER_PCI
--	tristate
--	default BCMA_DRIVER_PCI
--config BACKPORTED_BCMA_DRIVER_PCI_HOSTMODE
--	tristate
--	default BCMA_DRIVER_PCI_HOSTMODE
--config BACKPORTED_BCMA_DRIVER_MIPS
--	tristate
--	default BCMA_DRIVER_MIPS
--config BACKPORTED_BCMA_PFLASH
--	tristate
--	default BCMA_PFLASH
--config BACKPORTED_BCMA_SFLASH
--	tristate
--	default BCMA_SFLASH
--config BACKPORTED_BCMA_NFLASH
--	tristate
--	default BCMA_NFLASH
--config BACKPORTED_BCMA_DRIVER_GMAC_CMN
--	tristate
--	default BCMA_DRIVER_GMAC_CMN
--config BACKPORTED_BCMA_DRIVER_GPIO
--	tristate
--	default BCMA_DRIVER_GPIO
--config BACKPORTED_BCMA_DEBUG
--	tristate
--	default BCMA_DEBUG
- config BACKPORTED_USB_ACM
- 	tristate
- 	default USB_ACM
---- a/Kconfig.sources
-+++ b/Kconfig.sources
-@@ -10,9 +10,6 @@ source "$BACKPORT_DIR/drivers/soc/qcom/K
- source "$BACKPORT_DIR/drivers/net/wireless/Kconfig"
- source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
- 
--source "$BACKPORT_DIR/drivers/ssb/Kconfig"
--source "$BACKPORT_DIR/drivers/bcma/Kconfig"
--
- source "$BACKPORT_DIR/drivers/usb/class/Kconfig"
- 
- source "$BACKPORT_DIR/drivers/staging/Kconfig"
---- a/Makefile.kernel
-+++ b/Makefile.kernel
-@@ -43,8 +43,6 @@ obj-$(CPTCFG_QRTR) += net/qrtr/
- obj-$(CPTCFG_QCOM_QMI_HELPERS) += drivers/soc/qcom/
- obj-$(CPTCFG_MHI_BUS) += drivers/bus/mhi/
- obj-$(CPTCFG_WLAN) += drivers/net/wireless/
--obj-$(CPTCFG_SSB) += drivers/ssb/
--obj-$(CPTCFG_BCMA) += drivers/bcma/
- obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
- 
- obj-$(CPTCFG_USB_WDM) += drivers/usb/class/
diff --git a/package/kernel/mac80211/patches/build/070-remove-broken-wext-select.patch b/package/kernel/mac80211/patches/build/070-remove-broken-wext-select.patch
deleted file mode 100644
index 121b7faa..00000000
--- a/package/kernel/mac80211/patches/build/070-remove-broken-wext-select.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/staging/rtl8723bs/Kconfig
-+++ b/drivers/staging/rtl8723bs/Kconfig
-@@ -5,7 +5,6 @@ config RTL8723BS
- 	depends on m
- 	depends on WLAN && MMC && CFG80211
- 	depends on m
--	select CFG80211_WEXT
- 	depends on CRYPTO
- 	select BPAUTO_CRYPTO_LIB_ARC4
- 	help
diff --git a/package/kernel/mac80211/patches/build/080-resv_start_op.patch b/package/kernel/mac80211/patches/build/080-resv_start_op.patch
deleted file mode 100644
index 40b8e94a..00000000
--- a/package/kernel/mac80211/patches/build/080-resv_start_op.patch
+++ /dev/null
@@ -1,24 +0,0 @@
---- a/drivers/net/wireless/mac80211_hwsim.c
-+++ b/drivers/net/wireless/mac80211_hwsim.c
-@@ -5363,7 +5363,9 @@ static struct genl_family hwsim_genl_fam
- 	.module = THIS_MODULE,
- 	.small_ops = hwsim_ops,
- 	.n_small_ops = ARRAY_SIZE(hwsim_ops),
-+#if LINUX_VERSION_IS_GEQ(6,1,0)
- 	.resv_start_op = HWSIM_CMD_DEL_MAC_ADDR + 1,
-+#endif
- 	.mcgrps = hwsim_mcgrps,
- 	.n_mcgrps = ARRAY_SIZE(hwsim_mcgrps),
- };
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -17233,7 +17233,9 @@ static struct genl_family nl80211_fam __
- 	.n_ops = ARRAY_SIZE(nl80211_ops),
- 	.small_ops = nl80211_small_ops,
- 	.n_small_ops = ARRAY_SIZE(nl80211_small_ops),
-+#if LINUX_VERSION_IS_GEQ(6,1,0)
- 	.resv_start_op = NL80211_CMD_REMOVE_LINK_STA + 1,
-+#endif
- 	.mcgrps = nl80211_mcgrps,
- 	.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),
- 	.parallel_ops = true,
diff --git a/package/kernel/mac80211/patches/build/090-bcma-otp.patch b/package/kernel/mac80211/patches/build/090-bcma-otp.patch
deleted file mode 100644
index 39747761..00000000
--- a/package/kernel/mac80211/patches/build/090-bcma-otp.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- /dev/null
-+++ b/backport-include/linux/bcma/bcma_driver_chipcommon.h
-@@ -0,0 +1,10 @@
-+#ifndef __BACKPORT_BCMA_DRIVER_CHIPCOMMON_H
-+#define __BACKPORT_BCMA_DRIVER_CHIPCOMMON_H
-+
-+#include_next <linux/bcma/bcma_driver_chipcommon.h>
-+
-+#ifndef BCMA_CC_SROM_CONTROL_OTP_PRESENT
-+#define BCMA_CC_SROM_CONTROL_OTP_PRESENT 0x00000020
-+#endif
-+
-+#endif
diff --git a/package/kernel/mac80211/patches/build/099-netlink-range.patch b/package/kernel/mac80211/patches/build/099-netlink-range.patch
deleted file mode 100644
index 0df2b38f..00000000
--- a/package/kernel/mac80211/patches/build/099-netlink-range.patch
+++ /dev/null
@@ -1,91 +0,0 @@
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -421,8 +421,13 @@ static const struct nla_policy
- nl80211_fils_discovery_policy[NL80211_FILS_DISCOVERY_ATTR_MAX + 1] = {
- 	[NL80211_FILS_DISCOVERY_ATTR_INT_MIN] = NLA_POLICY_MAX(NLA_U32, 10000),
- 	[NL80211_FILS_DISCOVERY_ATTR_INT_MAX] = NLA_POLICY_MAX(NLA_U32, 10000),
-+#if LINUX_VERSION_IS_GEQ(5,10,0)
- 	[NL80211_FILS_DISCOVERY_ATTR_TMPL] =
- 			NLA_POLICY_BINARY_RANGE(NL80211_FILS_DISCOVERY_TMPL_MIN_LEN, IEEE80211_MAX_DATA_LEN),
-+#else
-+	[NL80211_FILS_DISCOVERY_ATTR_TMPL] = { .type = NLA_BINARY,
-+					       .len = IEEE80211_MAX_DATA_LEN },
-+#endif
- };
- 
- static const struct nla_policy
-@@ -533,7 +538,11 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_MPATH_NEXT_HOP] = NLA_POLICY_ETH_ADDR_COMPAT,
- 
- 	/* allow 3 for NUL-termination, we used to declare this NLA_STRING */
-+#if LINUX_VERSION_IS_GEQ(5,10,0)
- 	[NL80211_ATTR_REG_ALPHA2] = NLA_POLICY_BINARY_RANGE(2, 3),
-+#else
-+	[NL80211_ATTR_REG_ALPHA2] = { .type = NLA_STRING, .len = 2 },
-+#endif
- 	[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },
- 
- 	[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },
-@@ -679,14 +688,24 @@ static const struct nla_policy nl80211_p
- 	 * The value of the Length field of the Supported Operating
- 	 * Classes element is between 2 and 253.
- 	 */
-+#if LINUX_VERSION_IS_GEQ(5,10,0)
- 	[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] =
- 		NLA_POLICY_BINARY_RANGE(2, 253),
-+#else
-+	[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] =
-+		{ .type = NLA_BINARY },
-+#endif
- 		[NL80211_ATTR_HANDLE_DFS] = { .type = NLA_FLAG },
- 		[NL80211_ATTR_OPMODE_NOTIF] = { .type = NLA_U8 },
- 		[NL80211_ATTR_VENDOR_ID] = { .type = NLA_U32 },
- 		[NL80211_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },
- 		[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },
-+#if LINUX_VERSION_IS_GEQ(5,10,0)
- 		[NL80211_ATTR_QOS_MAP] = NLA_POLICY_BINARY_RANGE(IEEE80211_QOS_MAP_LEN_MIN, IEEE80211_QOS_MAP_LEN_MAX),
-+#else
-+		[NL80211_ATTR_QOS_MAP] = { .type = NLA_BINARY,
-+					   .len = IEEE80211_QOS_MAP_LEN_MAX },
-+#endif
- 		[NL80211_ATTR_MAC_HINT] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),
- 		[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },
- 		[NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },
-@@ -741,9 +760,14 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_TXQ_LIMIT] = { .type = NLA_U32 },
- 	[NL80211_ATTR_TXQ_MEMORY_LIMIT] = { .type = NLA_U32 },
- 	[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },
-+#if LINUX_VERSION_IS_GEQ(5,10,0)
- 	[NL80211_ATTR_HE_CAPABILITY] =
- 		NLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_he_capa,
- 				       NL80211_HE_MAX_CAPABILITY_LEN),
-+#else
-+	[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,
-+					 .len = NL80211_HE_MAX_CAPABILITY_LEN },
-+#endif
- 	[NL80211_ATTR_FTM_RESPONDER] =
- 		NLA_POLICY_NESTED(nl80211_ftm_responder_policy),
- 	[NL80211_ATTR_TIMEOUT] = NLA_POLICY_MIN(NLA_U32, 1),
-@@ -16392,9 +16416,11 @@ static const struct genl_ops nl80211_ops
- 		/* can be retrieved by unprivileged users */
- 		.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),
- 	},
-+#if LINUX_VERSION_IS_GEQ(5,10,0)
- };
- 
- static const struct genl_small_ops nl80211_small_ops[] = {
-+#endif
- 	{
- 		.cmd = NL80211_CMD_SET_WIPHY,
- 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
-@@ -17231,8 +17257,10 @@ static struct genl_family nl80211_fam __
- 	.module = THIS_MODULE,
- 	.ops = nl80211_ops,
- 	.n_ops = ARRAY_SIZE(nl80211_ops),
-+#if LINUX_VERSION_IS_GEQ(5,10,0)
- 	.small_ops = nl80211_small_ops,
- 	.n_small_ops = ARRAY_SIZE(nl80211_small_ops),
-+#endif
- #if LINUX_VERSION_IS_GEQ(6,1,0)
- 	.resv_start_op = NL80211_CMD_REMOVE_LINK_STA + 1,
- #endif
diff --git a/package/kernel/mac80211/patches/build/100-backports-drop-QRTR-and-MHI.patch b/package/kernel/mac80211/patches/build/100-backports-drop-QRTR-and-MHI.patch
index b017a0ce..f4dc5508 100644
--- a/package/kernel/mac80211/patches/build/100-backports-drop-QRTR-and-MHI.patch
+++ b/package/kernel/mac80211/patches/build/100-backports-drop-QRTR-and-MHI.patch
@@ -32,7 +32,7 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
  source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
 --- a/Makefile.kernel
 +++ b/Makefile.kernel
-@@ -39,9 +39,7 @@ obj-y += compat/
+@@ -38,9 +38,7 @@ obj-y += compat/
  
  obj-$(CPTCFG_CFG80211) += net/wireless/
  obj-$(CPTCFG_MAC80211) += net/mac80211/
@@ -54,12 +54,12 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
 +	depends on MHI_BUS
 +	depends on QRTR
 +	depends on QRTR_MHI
+ 	select PCI_PWRCTL_PWRSEQ if HAVE_PWRCTL
  	help
  	  This module adds support for PCIE bus
- 
 --- a/local-symbols
 +++ b/local-symbols
-@@ -65,14 +65,6 @@ MAC80211_MESH_PS_DEBUG=
+@@ -59,14 +59,6 @@ MAC80211_MESH_PS_DEBUG=
  MAC80211_TDLS_DEBUG=
  MAC80211_DEBUG_COUNTERS=
  MAC80211_STA_HASH_MAX_SIZE=
@@ -73,4 +73,4 @@ Signed-off-by: Robert Marko <robimarko@gmail.com>
 -MHI_BUS_EP=
  QCOM_AOSS_QMP=
  QCOM_COMMAND_DB=
- QCOM_CPR=
+ QCOM_GENI_SE=
diff --git a/package/kernel/mac80211/patches/build/110-backport_napi_build_skb.patch b/package/kernel/mac80211/patches/build/110-backport_napi_build_skb.patch
deleted file mode 100644
index 1e152fec..00000000
--- a/package/kernel/mac80211/patches/build/110-backport_napi_build_skb.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/backport-include/linux/skbuff.h
-+++ b/backport-include/linux/skbuff.h
-@@ -144,4 +144,8 @@ static inline u64 skb_get_kcov_handle(st
- #define napi_build_skb build_skb
- #endif
- 
-+#if LINUX_VERSION_IS_LESS(5,11,0)
-+#define napi_build_skb build_skb
-+#endif
-+
- #endif /* __BACKPORT_SKBUFF_H */
diff --git a/package/kernel/mac80211/patches/build/236-fix-genlmsg_multicast_allns-build-error.patch b/package/kernel/mac80211/patches/build/236-fix-genlmsg_multicast_allns-build-error.patch
deleted file mode 100644
index 345415a1..00000000
--- a/package/kernel/mac80211/patches/build/236-fix-genlmsg_multicast_allns-build-error.patch
+++ /dev/null
@@ -1,177 +0,0 @@
-From e0f83d268974dab0361d11904dfc9acec53f96a6 Mon Sep 17 00:00:00 2001
-From: Eric Dumazet <edumazet@google.com>
-Date: Fri, 11 Oct 2024 17:12:17 +0000
-Subject: [PATCH] genetlink: hold RCU in genlmsg_mcast()
-
-[ Upstream commit 56440d7ec28d60f8da3bfa09062b3368ff9b16db ]
-
-While running net selftests with CONFIG_PROVE_RCU_LIST=y I saw
-one lockdep splat [1].
-
-genlmsg_mcast() uses for_each_net_rcu(), and must therefore hold RCU.
-
-Instead of letting all callers guard genlmsg_multicast_allns()
-with a rcu_read_lock()/rcu_read_unlock() pair, do it in genlmsg_mcast().
-
-This also means the @flags parameter is useless, we need to always use
-GFP_ATOMIC.
-
-[1]
-[10882.424136] =============================
-[10882.424166] WARNING: suspicious RCU usage
-[10882.424309] 6.12.0-rc2-virtme #1156 Not tainted
-[10882.424400] -----------------------------
-[10882.424423] net/netlink/genetlink.c:1940 RCU-list traversed in non-reader section!!
-[10882.424469]
-other info that might help us debug this:
-
-[10882.424500]
-rcu_scheduler_active = 2, debug_locks = 1
-[10882.424744] 2 locks held by ip/15677:
-[10882.424791] #0: ffffffffb6b491b0 (cb_lock){++++}-{3:3}, at: genl_rcv (net/netlink/genetlink.c:1219)
-[10882.426334] #1: ffffffffb6b49248 (genl_mutex){+.+.}-{3:3}, at: genl_rcv_msg (net/netlink/genetlink.c:61 net/netlink/genetlink.c:57 net/netlink/genetlink.c:1209)
-[10882.426465]
-stack backtrace:
-[10882.426805] CPU: 14 UID: 0 PID: 15677 Comm: ip Not tainted 6.12.0-rc2-virtme #1156
-[10882.426919] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
-[10882.427046] Call Trace:
-[10882.427131]  <TASK>
-[10882.427244] dump_stack_lvl (lib/dump_stack.c:123)
-[10882.427335] lockdep_rcu_suspicious (kernel/locking/lockdep.c:6822)
-[10882.427387] genlmsg_multicast_allns (net/netlink/genetlink.c:1940 (discriminator 7) net/netlink/genetlink.c:1977 (discriminator 7))
-[10882.427436] l2tp_tunnel_notify.constprop.0 (net/l2tp/l2tp_netlink.c:119) l2tp_netlink
-[10882.427683] l2tp_nl_cmd_tunnel_create (net/l2tp/l2tp_netlink.c:253) l2tp_netlink
-[10882.427748] genl_family_rcv_msg_doit (net/netlink/genetlink.c:1115)
-[10882.427834] genl_rcv_msg (net/netlink/genetlink.c:1195 net/netlink/genetlink.c:1210)
-[10882.427877] ? __pfx_l2tp_nl_cmd_tunnel_create (net/l2tp/l2tp_netlink.c:186) l2tp_netlink
-[10882.427927] ? __pfx_genl_rcv_msg (net/netlink/genetlink.c:1201)
-[10882.427959] netlink_rcv_skb (net/netlink/af_netlink.c:2551)
-[10882.428069] genl_rcv (net/netlink/genetlink.c:1220)
-[10882.428095] netlink_unicast (net/netlink/af_netlink.c:1332 net/netlink/af_netlink.c:1357)
-[10882.428140] netlink_sendmsg (net/netlink/af_netlink.c:1901)
-[10882.428210] ____sys_sendmsg (net/socket.c:729 (discriminator 1) net/socket.c:744 (discriminator 1) net/socket.c:2607 (discriminator 1))
-
-Fixes: 33f72e6f0c67 ("l2tp : multicast notification to the registered listeners")
-Signed-off-by: Eric Dumazet <edumazet@google.com>
-Cc: James Chapman <jchapman@katalix.com>
-Cc: Tom Parkin <tparkin@katalix.com>
-Cc: Johannes Berg <johannes.berg@intel.com>
-Link: https://patch.msgid.link/20241011171217.3166614-1-edumazet@google.com
-Signed-off-by: Jakub Kicinski <kuba@kernel.org>
-Signed-off-by: Sasha Levin <sashal@kernel.org>
----
- drivers/target/target_core_user.c |  2 +-
- include/net/genetlink.h           |  3 +--
- net/l2tp/l2tp_netlink.c           |  4 ++--
- net/netlink/genetlink.c           | 28 ++++++++++++++--------------
- net/wireless/nl80211.c            |  8 ++------
- 5 files changed, 20 insertions(+), 25 deletions(-)
-
---- a/backport-include/net/genetlink.h
-+++ b/backport-include/net/genetlink.h
-@@ -199,7 +199,7 @@ int genlmsg_multicast(const struct genl_
- #define genlmsg_multicast_allns LINUX_BACKPORT(genlmsg_multicast_allns)
- int backport_genlmsg_multicast_allns(const struct genl_family *family,
- 				     struct sk_buff *skb, u32 portid,
--				     unsigned int group, gfp_t flags);
-+				     unsigned int group);
- 
- #define genl_family_attrbuf LINUX_BACKPORT(genl_family_attrbuf)
- static inline struct nlattr **genl_family_attrbuf(struct genl_family *family)
---- a/compat/backport-genetlink.c
-+++ b/compat/backport-genetlink.c
-@@ -364,23 +364,23 @@ int genlmsg_multicast(const struct genl_
- }
- EXPORT_SYMBOL_GPL(genlmsg_multicast);
- 
--static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,
--			 gfp_t flags)
-+static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group)
- {
- 	struct sk_buff *tmp;
- 	struct net *net, *prev = NULL;
- 	bool delivered = false;
- 	int err;
- 
-+	rcu_read_lock();
- 	for_each_net_rcu(net) {
- 		if (prev) {
--			tmp = skb_clone(skb, flags);
-+			tmp = skb_clone(skb, GFP_ATOMIC);
- 			if (!tmp) {
- 				err = -ENOMEM;
- 				goto error;
- 			}
- 			err = nlmsg_multicast(prev->genl_sock, tmp,
--					      portid, group, flags);
-+					      portid, group, GFP_ATOMIC);
- 			if (!err)
- 				delivered = true;
- 			else if (err != -ESRCH)
-@@ -389,25 +389,29 @@ static int genlmsg_mcast(struct sk_buff
- 
- 		prev = net;
- 	}
-+	err = nlmsg_multicast(prev->genl_sock, skb, portid, group, GFP_ATOMIC);
-+
-+	rcu_read_unlock();
- 
--	err = nlmsg_multicast(prev->genl_sock, skb, portid, group, flags);
- 	if (!err)
- 		delivered = true;
- 	else if (err != -ESRCH)
- 		return err;
- 	return delivered ? 0 : -ESRCH;
-  error:
-+	rcu_read_unlock();
-+
- 	kfree_skb(skb);
- 	return err;
- }
- 
- int backport_genlmsg_multicast_allns(const struct genl_family *family,
- 				     struct sk_buff *skb, u32 portid,
--				     unsigned int group, gfp_t flags)
-+				     unsigned int group)
- {
- 	group = __backport_genl_group(family, group);
- 	if (group == INVALID_GROUP)
- 		return -EINVAL;
--	return genlmsg_mcast(skb, portid, group, flags);
-+	return genlmsg_mcast(skb, portid, group);
- }
- EXPORT_SYMBOL_GPL(backport_genlmsg_multicast_allns);
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -17567,10 +17567,15 @@ void nl80211_common_reg_change_event(enu
- 
- 	genlmsg_end(msg, hdr);
- 
-+#if LINUX_VERSION_IS_GEQ(6,6,59) || LINUX_VERSION_IS_GEQ(6,1,115) || LINUX_VERSION_IS_GEQ(5,10,230) || LINUX_VERSION_IS_GEQ(5,4,283)
-+	genlmsg_multicast_allns(&nl80211_fam, msg, 0,
-+				NL80211_MCGRP_REGULATORY);
-+#else
- 	rcu_read_lock();
- 	genlmsg_multicast_allns(&nl80211_fam, msg, 0,
- 				NL80211_MCGRP_REGULATORY, GFP_ATOMIC);
- 	rcu_read_unlock();
-+#endif
- 
- 	return;
- 
-@@ -18188,10 +18193,15 @@ void nl80211_send_beacon_hint_event(stru
- 
- 	genlmsg_end(msg, hdr);
- 
-+#if LINUX_VERSION_IS_GEQ(6,6,59) || LINUX_VERSION_IS_GEQ(6,1,115) || LINUX_VERSION_IS_GEQ(5,10,230) || LINUX_VERSION_IS_GEQ(5,4,283)
-+	genlmsg_multicast_allns(&nl80211_fam, msg, 0,
-+				NL80211_MCGRP_REGULATORY);
-+#else
- 	rcu_read_lock();
- 	genlmsg_multicast_allns(&nl80211_fam, msg, 0,
- 				NL80211_MCGRP_REGULATORY, GFP_ATOMIC);
- 	rcu_read_unlock();
-+#endif
- 
- 	return;
- 
diff --git a/package/kernel/mac80211/patches/build/990-add_kernel_6.6_support.patch b/package/kernel/mac80211/patches/build/990-add_kernel_6.6_support.patch
deleted file mode 100644
index 070317f3..00000000
--- a/package/kernel/mac80211/patches/build/990-add_kernel_6.6_support.patch
+++ /dev/null
@@ -1,127 +0,0 @@
---- a/net/wireless/sysfs.c
-+++ b/net/wireless/sysfs.c
-@@ -148,12 +148,21 @@ static SIMPLE_DEV_PM_OPS(wiphy_pm_ops, w
- #define WIPHY_PM_OPS NULL
- #endif
- 
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-+static const void *wiphy_namespace(const struct device *d)
-+{
-+	struct wiphy *wiphy = container_of(d, struct wiphy, dev);
-+
-+	return wiphy_net(wiphy);
-+}
-+#else
- static const void *wiphy_namespace(struct device *d)
- {
- 	struct wiphy *wiphy = container_of(d, struct wiphy, dev);
- 
- 	return wiphy_net(wiphy);
- }
-+#endif
- 
- struct class ieee80211_class = {
- 	.name = "ieee80211",
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -16158,8 +16158,14 @@ static u32 nl80211_internal_flags[] = {
- #undef SELECTOR
- };
- 
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-+static int nl80211_pre_doit(const struct genl_split_ops *ops,
-+			    struct sk_buff *skb,
-+			    struct genl_info *info)
-+#else
- static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
- 			    struct genl_info *info)
-+#endif
- {
- 	struct cfg80211_registered_device *rdev = NULL;
- 	struct wireless_dev *wdev = NULL;
-@@ -16259,8 +16265,14 @@ out_unlock:
- 	return err;
- }
- 
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-+static void nl80211_post_doit(const struct genl_split_ops *ops,
-+			      struct sk_buff *skb,
-+			      struct genl_info *info)
-+#else
- static void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
- 			      struct genl_info *info)
-+#endif
- {
- 	u32 internal_flags = nl80211_internal_flags[ops->internal_flags];
- 
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -27,6 +27,10 @@
- #include <asm/unaligned.h>
- #include <net/fq_impl.h>
- 
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-+#include <net/gso.h>
-+#endif
-+
- #include "ieee80211_i.h"
- #include "driver-ops.h"
- #include "led.h"
---- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
-+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
-@@ -10,6 +10,10 @@
- #include <net/ip.h>
- #include <net/ipv6.h>
- 
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
-+#include <net/gso.h>
-+#endif
-+
- #include "iwl-trans.h"
- #include "iwl-eeprom-parse.h"
- #include "mvm.h"
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1435,6 +1435,7 @@ enum mac80211_rx_encoding {
- 	RX_ENC_HT,
- 	RX_ENC_VHT,
- 	RX_ENC_HE,
-+	RX_ENC_EHT,
- };
- 
- /**
-@@ -1497,8 +1498,18 @@ struct ieee80211_rx_status {
- 	u32 flag;
- 	u16 freq: 13, freq_offset: 1;
- 	u8 enc_flags;
--	u8 encoding:2, bw:3, he_ru:3;
--	u8 he_gi:2, he_dcm:1;
-+	u8 encoding:3, bw:4;
-+	union {
-+		struct {
-+			u8 he_ru:3;
-+			u8 he_gi:2;
-+			u8 he_dcm:1;
-+		};
-+		struct {
-+			u8 ru:4;
-+			u8 gi:2;
-+		} eht;
-+	};
- 	u8 rate_idx;
- 	u8 nss;
- 	u8 rx_flags;
---- a/drivers/net/wireless/mac80211_hwsim.c
-+++ b/drivers/net/wireless/mac80211_hwsim.c
-@@ -5749,7 +5749,11 @@ static int __init init_mac80211_hwsim(vo
- 	if (err)
- 		goto out_exit_netlink;
- 
-+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0))
-+	hwsim_class = class_create("mac80211_hwsim");
-+#else
- 	hwsim_class = class_create(THIS_MODULE, "mac80211_hwsim");
-+#endif
- 	if (IS_ERR(hwsim_class)) {
- 		err = PTR_ERR(hwsim_class);
- 		goto out_exit_virtio;
diff --git a/package/kernel/mac80211/patches/build/991-add_kernel_6.12_support.patch b/package/kernel/mac80211/patches/build/991-add_kernel_6.12_support.patch
deleted file mode 100644
index 8f6d7878..00000000
--- a/package/kernel/mac80211/patches/build/991-add_kernel_6.12_support.patch
+++ /dev/null
@@ -1,90 +0,0 @@
---- a/backport-include/asm/unaligned.h
-+++ b/backport-include/asm/unaligned.h
-@@ -1,6 +1,11 @@
- #ifndef __BACKPORT_ASM_GENERIC_UNALIGNED_H
- #define __BACKPORT_ASM_GENERIC_UNALIGNED_H
-+
-+#if LINUX_VERSION_IS_LESS(6,11,0)
- #include_next <asm/unaligned.h>
-+#else
-+#include_next <linux/unaligned.h>
-+#endif
- 
- #if LINUX_VERSION_IS_LESS(5,7,0)
- static inline u32 __get_unaligned_be24(const u8 *p)
---- a/net/wireless/core.c
-+++ b/net/wireless/core.c
-@@ -164,11 +164,19 @@ int cfg80211_switch_netns(struct cfg8021
- 	list_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {
- 		if (!wdev->netdev)
- 			continue;
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
-+		wdev->netdev->netns_local = false;
-+#else
- 		wdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
-+#endif
- 		err = dev_change_net_namespace(wdev->netdev, net, "wlan%d");
- 		if (err)
- 			break;
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
-+		wdev->netdev->netns_local = true;
-+#else
- 		wdev->netdev->features |= NETIF_F_NETNS_LOCAL;
-+#endif
- 	}
- 
- 	if (err) {
-@@ -180,11 +188,19 @@ int cfg80211_switch_netns(struct cfg8021
- 						     list) {
- 			if (!wdev->netdev)
- 				continue;
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
-+			wdev->netdev->netns_local = false;
-+#else
- 			wdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
-+#endif
- 			err = dev_change_net_namespace(wdev->netdev, net,
- 							"wlan%d");
- 			WARN_ON(err);
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
-+			wdev->netdev->netns_local = true;
-+#else
- 			wdev->netdev->features |= NETIF_F_NETNS_LOCAL;
-+#endif
- 		}
- 
- 		return err;
-@@ -1428,7 +1444,11 @@ static int cfg80211_netdev_notifier_call
- 		SET_NETDEV_DEVTYPE(dev, &wiphy_type);
- 		wdev->netdev = dev;
- 		/* can only change netns with wiphy */
-+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
-+		dev->netns_local = true;
-+#else
- 		dev->features |= NETIF_F_NETNS_LOCAL;
-+#endif
- 
- 		cfg80211_init_wdev(wdev);
- 		break;
---- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
-+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
-@@ -187,7 +187,9 @@ static const struct file_operations mins
- 	.open = minstrel_ht_stats_open,
- 	.read = minstrel_stats_read,
- 	.release = minstrel_stats_release,
-+#if LINUX_VERSION_IS_LESS(6,11,0)
- 	.llseek = no_llseek,
-+#endif
- };
- 
- static char *
-@@ -323,7 +325,9 @@ static const struct file_operations mins
- 	.open = minstrel_ht_stats_csv_open,
- 	.read = minstrel_stats_read,
- 	.release = minstrel_stats_release,
-+#if LINUX_VERSION_IS_LESS(6,11,0)
- 	.llseek = no_llseek,
-+#endif
- };
- 
- void
diff --git a/package/kernel/mac80211/patches/build/992-fix-tasklet_setup-build-kernel-5.4.patch b/package/kernel/mac80211/patches/build/992-fix-tasklet_setup-build-kernel-5.4.patch
deleted file mode 100644
index bb1e79db..00000000
--- a/package/kernel/mac80211/patches/build/992-fix-tasklet_setup-build-kernel-5.4.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/backport-include/linux/interrupt.h
-+++ b/backport-include/linux/interrupt.h
-@@ -43,7 +43,7 @@
- 
- #endif
- 
--#if LINUX_VERSION_IS_LESS(5,9,0)
-+#if LINUX_VERSION_IS_LESS(5,4,291)
- 
- static inline void
- tasklet_setup(struct tasklet_struct *t,
diff --git a/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch b/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch
index 11536651..cfb7dcf7 100644
--- a/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch
+++ b/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/mwl8k.c
 +++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -5703,6 +5703,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
+@@ -5712,6 +5712,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
  MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
  
  static const struct pci_device_id mwl8k_pci_id_table[] = {
diff --git a/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch b/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch
index 1dbcb1bf..e6111871 100644
--- a/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch
+++ b/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/libertas/cfg.c
 +++ b/drivers/net/wireless/marvell/libertas/cfg.c
-@@ -2052,6 +2052,8 @@ struct wireless_dev *lbs_cfg_alloc(struc
+@@ -2102,6 +2102,8 @@ struct wireless_dev *lbs_cfg_alloc(struc
  		goto err_wiphy_new;
  	}
  
diff --git a/package/kernel/mac80211/patches/mwl/802-libertas-set-wireless-macaddr.patch b/package/kernel/mac80211/patches/mwl/802-libertas-set-wireless-macaddr.patch
index b47aee54..97ddd66b 100644
--- a/package/kernel/mac80211/patches/mwl/802-libertas-set-wireless-macaddr.patch
+++ b/package/kernel/mac80211/patches/mwl/802-libertas-set-wireless-macaddr.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/libertas/cfg.c
 +++ b/drivers/net/wireless/marvell/libertas/cfg.c
-@@ -2128,6 +2128,8 @@ int lbs_cfg_register(struct lbs_private
+@@ -2179,6 +2179,8 @@ int lbs_cfg_register(struct lbs_private
  	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
  	wdev->wiphy->reg_notifier = lbs_reg_notifier;
  
diff --git a/package/kernel/mac80211/patches/mwl/900-mwifiex-increase-the-global-limit-up-to-4-SSID.patch b/package/kernel/mac80211/patches/mwl/900-mwifiex-increase-the-global-limit-up-to-4-SSID.patch
index caa139a2..484b37bf 100644
--- a/package/kernel/mac80211/patches/mwl/900-mwifiex-increase-the-global-limit-up-to-4-SSID.patch
+++ b/package/kernel/mac80211/patches/mwl/900-mwifiex-increase-the-global-limit-up-to-4-SSID.patch
@@ -30,7 +30,7 @@ the card-specific structure.
  
  #define MWIFIEX_DMA_ALIGN_SZ	    64
  #define MWIFIEX_RX_HEADROOM	    64
-@@ -100,7 +100,7 @@
+@@ -123,7 +123,7 @@
  #define MWIFIEX_RATE_INDEX_OFDM0   4
  
  #define MWIFIEX_MAX_STA_NUM		3
diff --git a/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch
index c8d24283..d09cfac4 100644
--- a/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch
+++ b/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/mwl8k.c
 +++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -6289,6 +6289,8 @@ static int mwl8k_probe(struct pci_dev *p
+@@ -6298,6 +6298,8 @@ static int mwl8k_probe(struct pci_dev *p
  
  	priv->running_bsses = 0;
  
@@ -9,7 +9,7 @@
  	return rc;
  
  err_stop_firmware:
-@@ -6322,8 +6324,6 @@ static void mwl8k_remove(struct pci_dev
+@@ -6331,8 +6333,6 @@ static void mwl8k_remove(struct pci_dev
  		return;
  	priv = hw->priv;
  
diff --git a/package/kernel/mac80211/patches/mwl/950-mwifiex-Print-stringified-name-of-command-in-error-l.patch b/package/kernel/mac80211/patches/mwl/950-mwifiex-Print-stringified-name-of-command-in-error-l.patch
index 98ed9e60..93a21326 100644
--- a/package/kernel/mac80211/patches/mwl/950-mwifiex-Print-stringified-name-of-command-in-error-l.patch
+++ b/package/kernel/mac80211/patches/mwl/950-mwifiex-Print-stringified-name-of-command-in-error-l.patch
@@ -116,7 +116,7 @@ Signed-off-by: Pali Rohár <pali@kernel.org>
  		mwifiex_recycle_cmd_node(adapter, cmd_node);
  		queue_work(adapter->workqueue, &adapter->main_work);
  		return -1;
-@@ -653,8 +732,8 @@ int mwifiex_send_cmd(struct mwifiex_priv
+@@ -655,8 +734,8 @@ int mwifiex_send_cmd(struct mwifiex_priv
  	/* Return error, since the command preparation failed */
  	if (ret) {
  		mwifiex_dbg(adapter, ERROR,
@@ -127,7 +127,7 @@ Signed-off-by: Pali Rohár <pali@kernel.org>
  		mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
  		return -1;
  	}
-@@ -902,8 +981,9 @@ int mwifiex_process_cmdresp(struct mwifi
+@@ -904,8 +983,9 @@ int mwifiex_process_cmdresp(struct mwifi
  	if (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {
  		if (ret) {
  			mwifiex_dbg(adapter, ERROR,
@@ -139,7 +139,7 @@ Signed-off-by: Pali Rohár <pali@kernel.org>
  			mwifiex_init_fw_complete(adapter);
  			return -1;
  		} else if (adapter->last_init_cmd == cmdresp_no)
-@@ -1273,8 +1353,8 @@ mwifiex_process_sleep_confirm_resp(struc
+@@ -1287,8 +1367,8 @@ mwifiex_process_sleep_confirm_resp(struc
  
  	if (command != HostCmd_CMD_802_11_PS_MODE_ENH) {
  		mwifiex_dbg(adapter, ERROR,
@@ -152,7 +152,7 @@ Signed-off-by: Pali Rohár <pali@kernel.org>
  
 --- a/drivers/net/wireless/marvell/mwifiex/main.h
 +++ b/drivers/net/wireless/marvell/mwifiex/main.h
-@@ -1099,6 +1099,8 @@ void mwifiex_cancel_all_pending_cmd(stru
+@@ -1100,6 +1100,8 @@ void mwifiex_cancel_all_pending_cmd(stru
  void mwifiex_cancel_pending_scan_cmd(struct mwifiex_adapter *adapter);
  void mwifiex_cancel_scan(struct mwifiex_adapter *adapter);
  
@@ -177,7 +177,7 @@ Signed-off-by: Pali Rohár <pali@kernel.org>
  		adapter->cmd_wait_q.status = -1;
 --- a/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
 +++ b/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
-@@ -794,7 +794,8 @@ int mwifiex_uap_prepare_cmd(struct mwifi
+@@ -964,7 +964,8 @@ int mwifiex_uap_prepare_cmd(struct mwifi
  		break;
  	default:
  		mwifiex_dbg(priv->adapter, ERROR,
diff --git a/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch b/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch
deleted file mode 100644
index ab0fa367..00000000
--- a/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch
+++ /dev/null
@@ -1,296 +0,0 @@
---- a/local-symbols
-+++ b/local-symbols
-@@ -347,6 +347,7 @@ RT2X00_LIB_FIRMWARE=
- RT2X00_LIB_CRYPTO=
- RT2X00_LIB_LEDS=
- RT2X00_LIB_DEBUGFS=
-+RT2X00_LIB_EEPROM=
- RT2X00_DEBUG=
- WLAN_VENDOR_REALTEK=
- RTL8180=
---- a/drivers/net/wireless/ralink/rt2x00/Kconfig
-+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -70,6 +70,7 @@ config RT2800PCI
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_PCI
- 	select RT2X00_LIB_FIRMWARE
-+	select RT2X00_LIB_EEPROM
- 	select RT2X00_LIB_CRYPTO
- 	depends on CRC_CCITT
- 	depends on EEPROM_93CX6
-@@ -216,6 +217,7 @@ config RT2800SOC
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_CRYPTO
- 	select RT2X00_LIB_FIRMWARE
-+	select RT2X00_LIB_EEPROM
- 	select RT2800_LIB
- 	select RT2800_LIB_MMIO
- 	help
-@@ -266,6 +268,9 @@ config RT2X00_LIB_FIRMWARE
- config RT2X00_LIB_CRYPTO
- 	bool
- 
-+config RT2X00_LIB_EEPROM
-+	bool
-+
- config RT2X00_LIB_LEDS
- 	bool
- 	default y if (RT2X00_LIB=y && LEDS_CLASS=y) || (RT2X00_LIB=m && LEDS_CLASS!=n)
---- a/drivers/net/wireless/ralink/rt2x00/Makefile
-+++ b/drivers/net/wireless/ralink/rt2x00/Makefile
-@@ -8,6 +8,7 @@ rt2x00lib-$(CPTCFG_RT2X00_LIB_DEBUGFS)	+
- rt2x00lib-$(CPTCFG_RT2X00_LIB_CRYPTO)	+= rt2x00crypto.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_FIRMWARE)	+= rt2x00firmware.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_LEDS)	+= rt2x00leds.o
-+rt2x00lib-$(CPTCFG_RT2X00_LIB_EEPROM)	+= rt2x00eeprom.o
- 
- obj-$(CPTCFG_RT2X00_LIB)		+= rt2x00lib.o
- obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -47,6 +47,8 @@ struct rt2800_drv_data {
- 	struct ieee80211_sta *wcid_to_sta[STA_IDS_SIZE];
- };
- 
-+#include "rt2800.h"
-+
- struct rt2800_ops {
- 	u32 (*register_read)(struct rt2x00_dev *rt2x00dev,
- 			      const unsigned int offset);
-@@ -145,6 +147,15 @@ static inline int rt2800_read_eeprom(str
- {
- 	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
- 
-+	if (rt2x00dev->eeprom_file) {
-+		memcpy(rt2x00dev->eeprom, rt2x00dev->eeprom_file->data,
-+		       EEPROM_SIZE);
-+		return 0;
-+	}
-+
-+	if (!rt2800ops->read_eeprom)
-+		return -EINVAL;
-+
- 	return rt2800ops->read_eeprom(rt2x00dev);
- }
- 
---- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -90,19 +90,6 @@ static int rt2800soc_set_device_state(st
- 	return retval;
- }
- 
--static int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)
--{
--	void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
--
--	if (!base_addr)
--		return -ENOMEM;
--
--	memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
--
--	iounmap(base_addr);
--	return 0;
--}
--
- /* Firmware functions */
- static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
- {
-@@ -168,7 +155,6 @@ static const struct rt2800_ops rt2800soc
- 	.register_multiread	= rt2x00mmio_register_multiread,
- 	.register_multiwrite	= rt2x00mmio_register_multiwrite,
- 	.regbusy_read		= rt2x00mmio_regbusy_read,
--	.read_eeprom		= rt2800soc_read_eeprom,
- 	.hwcrypt_disabled	= rt2800soc_hwcrypt_disabled,
- 	.drv_write_firmware	= rt2800soc_write_firmware,
- 	.drv_init_registers	= rt2800mmio_init_registers,
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -703,6 +703,7 @@ enum rt2x00_capability_flags {
- 	REQUIRE_HT_TX_DESC,
- 	REQUIRE_PS_AUTOWAKE,
- 	REQUIRE_DELAYED_RFKILL,
-+	REQUIRE_EEPROM_FILE,
- 
- 	/*
- 	 * Capabilities
-@@ -980,6 +981,11 @@ struct rt2x00_dev {
- 	const struct firmware *fw;
- 
- 	/*
-+	 * EEPROM image.
-+	 */
-+	const struct firmware *eeprom_file;
-+
-+	/*
- 	 * FIFO for storing tx status reports between isr and tasklet.
- 	 */
- 	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1419,6 +1419,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
- 	INIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);
- 	INIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);
- 
-+	retval = rt2x00lib_load_eeprom_file(rt2x00dev);
-+	if (retval)
-+		goto exit;
-+
- 	/*
- 	 * Let the driver probe the device to detect the capabilities.
- 	 */
-@@ -1559,6 +1563,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
- 	 * Free the driver data.
- 	 */
- 	kfree(rt2x00dev->drv_data);
-+
-+	/*
-+	 * Free EEPROM image.
-+	 */
-+	rt2x00lib_free_eeprom_file(rt2x00dev);
- }
- EXPORT_SYMBOL_GPL(rt2x00lib_remove_dev);
- 
---- /dev/null
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-@@ -0,0 +1,106 @@
-+/*
-+	Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
-+	Copyright (C) 2004 - 2009 Gertjan van Wingerde <gwingerde@gmail.com>
-+	<http://rt2x00.serialmonkey.com>
-+
-+	This program is free software; you can redistribute it and/or modify
-+	it under the terms of the GNU General Public License as published by
-+	the Free Software Foundation; either version 2 of the License, or
-+	(at your option) any later version.
-+
-+	This program is distributed in the hope that it will be useful,
-+	but WITHOUT ANY WARRANTY; without even the implied warranty of
-+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-+	GNU General Public License for more details.
-+
-+	You should have received a copy of the GNU General Public License
-+	along with this program; if not, write to the
-+	Free Software Foundation, Inc.,
-+	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-+ */
-+
-+/*
-+	Module: rt2x00lib
-+	Abstract: rt2x00 eeprom file loading routines.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+
-+#include "rt2x00.h"
-+#include "rt2x00lib.h"
-+
-+static const char *
-+rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+
-+	if (pdata && pdata->eeprom_file_name)
-+		return pdata->eeprom_file_name;
-+
-+	return NULL;
-+}
-+
-+static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	const struct firmware *ee;
-+	const char *ee_name;
-+	int retval;
-+
-+	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
-+	if (!ee_name && test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags)) {
-+		rt2x00_err(rt2x00dev, "Required EEPROM name is missing.");
-+		return -EINVAL;
-+	}
-+
-+	if (!ee_name)
-+		return 0;
-+
-+	rt2x00_info(rt2x00dev, "Loading EEPROM data from '%s'.\n", ee_name);
-+
-+	retval = request_firmware(&ee, ee_name, rt2x00dev->dev);
-+	if (retval) {
-+		rt2x00_err(rt2x00dev, "Failed to request EEPROM.\n");
-+		return retval;
-+	}
-+
-+	if (!ee || !ee->size || !ee->data) {
-+		rt2x00_err(rt2x00dev, "Failed to read EEPROM file.\n");
-+		retval = -ENOENT;
-+		goto err_exit;
-+	}
-+
-+	if (ee->size != rt2x00dev->ops->eeprom_size) {
-+		rt2x00_err(rt2x00dev,
-+			   "EEPROM file size is invalid, it should be %d bytes\n",
-+			   rt2x00dev->ops->eeprom_size);
-+		retval = -EINVAL;
-+		goto err_release_ee;
-+	}
-+
-+	rt2x00dev->eeprom_file = ee;
-+	return 0;
-+
-+err_release_ee:
-+	release_firmware(ee);
-+err_exit:
-+	return retval;
-+}
-+
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	int retval;
-+
-+	retval = rt2x00lib_request_eeprom_file(rt2x00dev);
-+	if (retval)
-+		return retval;
-+
-+	return 0;
-+}
-+
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	if (rt2x00dev->eeprom_file && rt2x00dev->eeprom_file->size)
-+		release_firmware(rt2x00dev->eeprom_file);
-+	rt2x00dev->eeprom_file = NULL;
-+}
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00lib.h
-@@ -286,6 +286,22 @@ static inline void rt2x00lib_free_firmwa
- #endif /* CPTCFG_RT2X00_LIB_FIRMWARE */
- 
- /*
-+ * EEPROM file handlers.
-+ */
-+#ifdef CPTCFG_RT2X00_LIB_EEPROM
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+#else
-+static inline int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	return 0;
-+}
-+static inline void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+}
-+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
-+
-+/*
-  * Debugfs handlers.
-  */
- #ifdef CPTCFG_RT2X00_LIB_DEBUGFS
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
-@@ -86,6 +86,7 @@ int rt2x00soc_probe(struct platform_devi
- 	if (IS_ERR(rt2x00dev->clk))
- 		rt2x00dev->clk = NULL;
- 
-+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
- 	rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
- 
- 	retval = rt2x00soc_alloc_reg(rt2x00dev);
diff --git a/package/kernel/mac80211/patches/rt2x00/603-rt2x00-of_load_eeprom_filename.patch b/package/kernel/mac80211/patches/rt2x00/603-rt2x00-of_load_eeprom_filename.patch
deleted file mode 100644
index 431e0902..00000000
--- a/package/kernel/mac80211/patches/rt2x00/603-rt2x00-of_load_eeprom_filename.patch
+++ /dev/null
@@ -1,31 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-@@ -26,6 +26,7 @@
- 
- #include <linux/kernel.h>
- #include <linux/module.h>
-+#include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00lib.h"
-@@ -34,10 +35,20 @@ static const char *
- rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
- {
- 	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+#ifdef CONFIG_OF
-+	struct device_node *np;
-+	const char *eep;
-+#endif
- 
- 	if (pdata && pdata->eeprom_file_name)
- 		return pdata->eeprom_file_name;
- 
-+#ifdef CONFIG_OF
-+	np = rt2x00dev->dev->of_node;
-+	if (np && of_property_read_string(np, "ralink,eeprom", &eep) == 0)
-+	    return eep;
-+#endif
-+
- 	return NULL;
- }
- 
diff --git a/package/kernel/mac80211/patches/rt2x00/604-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch b/package/kernel/mac80211/patches/rt2x00/604-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
deleted file mode 100644
index 7338eb15..00000000
--- a/package/kernel/mac80211/patches/rt2x00/604-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
+++ /dev/null
@@ -1,113 +0,0 @@
-From 339fe73f340161a624cc08e738d2244814852c3e Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 17 Mar 2013 00:55:04 +0100
-Subject: [PATCH] rt2x00: load eeprom on SoC from a mtd device defines inside
- OF
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/Kconfig        |  1 +
- drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c | 65 +++++++++++++++++++++++
- 2 files changed, 66 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/Kconfig
-+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -220,6 +220,7 @@ config RT2800SOC
- 	select RT2X00_LIB_EEPROM
- 	select RT2800_LIB
- 	select RT2800_LIB_MMIO
-+	select MTD if SOC_RT288X || SOC_RT305X
- 	help
- 	  This adds support for Ralink WiSoC devices.
- 	  Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-@@ -26,11 +26,76 @@
- 
- #include <linux/kernel.h>
- #include <linux/module.h>
-+#if IS_ENABLED(CONFIG_MTD)
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
-+#endif
- #include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00lib.h"
- 
-+#if IS_ENABLED(CONFIG_MTD)
-+static int rt2800lib_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
-+{
-+	int ret = -EINVAL;
-+#ifdef CONFIG_OF
-+	static struct firmware mtd_fw;
-+	struct device_node *np = rt2x00dev->dev->of_node, *mtd_np = NULL;
-+	size_t retlen, len = rt2x00dev->ops->eeprom_size;
-+	int i, size, offset = 0;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+
-+	list = of_get_property(np, "ralink,mtd-eeprom", &size);
-+	if (!list)
-+		return -ENOENT;
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+	if (!mtd_np) {
-+		dev_err(rt2x00dev->dev, "failed to load mtd phandle\n");
-+		return -EINVAL;
-+	}
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd)) {
-+		dev_err(rt2x00dev->dev, "failed to get mtd device \"%s\"\n", part);
-+		return PTR_ERR(mtd);
-+	}
-+
-+	if (size > sizeof(*list))
-+		offset = be32_to_cpup(list);
-+
-+	ret = mtd_read(mtd, offset, len, &retlen, (u_char *) rt2x00dev->eeprom);
-+	put_mtd_device(mtd);
-+
-+	if ((retlen != rt2x00dev->ops->eeprom_size) || ret) {
-+		dev_err(rt2x00dev->dev, "failed to load eeprom from device \"%s\"\n", part);
-+		return ret;
-+	}
-+
-+	if (of_find_property(np, "ralink,mtd-eeprom-swap", NULL))
-+		for (i = 0; i < len/sizeof(u16); i++)
-+			rt2x00dev->eeprom[i] = swab16(rt2x00dev->eeprom[i]);
-+
-+	rt2x00dev->eeprom_file = &mtd_fw;
-+	mtd_fw.data = (const u8 *) rt2x00dev->eeprom;
-+
-+	dev_info(rt2x00dev->dev, "loaded eeprom from mtd device \"%s\"\n", part);
-+#endif
-+
-+	return ret;
-+}
-+#endif
-+
- static const char *
- rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
- {
-@@ -58,6 +123,11 @@ static int rt2x00lib_request_eeprom_file
- 	const char *ee_name;
- 	int retval;
- 
-+#if IS_ENABLED(CONFIG_MTD)
-+	if (!rt2800lib_read_eeprom_mtd(rt2x00dev))
-+		return 0;
-+#endif
-+
- 	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
- 	if (!ee_name && test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags)) {
- 		rt2x00_err(rt2x00dev, "Required EEPROM name is missing.");
diff --git a/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch b/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch
index ffee2189..a554707b 100644
--- a/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch
+++ b/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch
@@ -12,7 +12,7 @@
  #endif /* _RT2X00_PLATFORM_H */
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1007,6 +1007,22 @@ static int rt2x00lib_probe_hw_modes(stru
+@@ -1008,6 +1008,22 @@ static int rt2x00lib_probe_hw_modes(stru
  	unsigned int num_rates;
  	unsigned int i;
  
@@ -37,7 +37,7 @@
  		num_rates += 4;
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -408,6 +408,7 @@ struct hw_mode_spec {
+@@ -398,6 +398,7 @@ struct hw_mode_spec {
  	unsigned int supported_bands;
  #define SUPPORT_BAND_2GHZ	0x00000001
  #define SUPPORT_BAND_5GHZ	0x00000002
diff --git a/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch b/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch
index 37553bb8..79f99ffd 100644
--- a/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch
+++ b/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -989,6 +989,12 @@ static void rt2x00lib_rate(struct ieee80
+@@ -990,6 +990,12 @@ static void rt2x00lib_rate(struct ieee80
  
  void rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr)
  {
diff --git a/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch b/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch
index 6211809c..31f2f026 100644
--- a/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch
+++ b/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1012,6 +1012,16 @@ static int rt2x00lib_probe_hw_modes(stru
+@@ -1013,6 +1013,16 @@ static int rt2x00lib_probe_hw_modes(stru
  	struct ieee80211_rate *rates;
  	unsigned int num_rates;
  	unsigned int i;
diff --git a/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch b/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
index 8964f8bf..de2cf2dc 100644
--- a/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
+++ b/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
@@ -13,7 +13,7 @@ Signed-off-by: John Crispin <blogic@openwrt.org>
 
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -225,10 +225,17 @@ static int rt2800soc_probe(struct platfo
+@@ -230,10 +230,17 @@ static int rt2800soc_probe(struct platfo
  	return rt2x00soc_probe(pdev, &rt2800soc_ops);
  }
  
diff --git a/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch b/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch
index acc8a8ed..4a819039 100644
--- a/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch
+++ b/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch
@@ -8,7 +8,7 @@
  
  #include "rt2x00.h"
  #include "rt2800lib.h"
-@@ -11131,6 +11132,17 @@ static int rt2800_init_eeprom(struct rt2
+@@ -11282,6 +11283,17 @@ static int rt2800_init_eeprom(struct rt2
  	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
  	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
  
diff --git a/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch b/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch
index 5ef5fc8d..9564f02e 100644
--- a/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch
+++ b/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1358,7 +1358,7 @@ static inline void rt2x00lib_set_if_comb
+@@ -1362,7 +1362,7 @@ static inline void rt2x00lib_set_if_comb
  	 */
  	if_limit = &rt2x00dev->if_limits_ap;
  	if_limit->max = rt2x00dev->ops->max_ap_intf;
diff --git a/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
index deaa03be..88a72fd0 100644
--- a/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
+++ b/package/kernel/mac80211/patches/rt2x00/994-rt2x00-import-support-for-external-LNA-on-MT7620.patch
@@ -27,7 +27,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
 
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -304,6 +304,24 @@ static void rt2800_rf_write(struct rt2x0
+@@ -305,6 +305,24 @@ static void rt2800_rf_write(struct rt2x0
  	mutex_unlock(&rt2x00dev->csr_mutex);
  }
  
@@ -52,67 +52,27 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  static const unsigned int rt2800_eeprom_map[EEPROM_WORD_COUNT] = {
  	[EEPROM_CHIP_ID]		= 0x0000,
  	[EEPROM_VERSION]		= 0x0001,
-@@ -4469,6 +4487,29 @@ static void rt2800_config_channel(struct
- 			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN,
- 					      0x6C6C6B6C);
- 		}
-+
-+		if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
-+			reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
-+			reg |= 0x00000101;
-+			rt2800_register_write(rt2x00dev, RF_CONTROL3, reg);
-+
-+			reg = rt2800_register_read(rt2x00dev, RF_BYPASS3);
-+			reg |= 0x00000101;
-+			rt2800_register_write(rt2x00dev, RF_BYPASS3, reg);
-+
-+			rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
-+			rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
-+			rt2800_rfcsr_write_chanreg(rt2x00dev, 18, 0x42);
-+			rt2800_bbp_write(rt2x00dev, 75, 0x68);
-+			rt2800_bbp_write(rt2x00dev, 76, 0x4C);
-+			rt2800_bbp_write(rt2x00dev, 79, 0x1C);
-+			rt2800_bbp_write(rt2x00dev, 80, 0x0C);
-+			rt2800_bbp_write(rt2x00dev, 82, 0xB6);
-+			/* bank 0 RF reg 42 and glrt BBP reg 141 will be set in
-+			 * config channel function in dependence of channel and
-+			 * HT20/HT40 so don't touch it
-+			 */
-+		}
- 	}
- 
- 	bbp = rt2800_bbp_read(rt2x00dev, 4);
-@@ -10583,6 +10624,7 @@ static void rt2800_init_rfcsr_6352(struc
- 	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
- 	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+@@ -10428,8 +10446,10 @@ static void rt2800_restore_rf_bbp_rt6352
+ static void rt2800_calibration_rt6352_stage1(struct rt2x00_dev *rt2x00dev)
+ {
+ 	if (rt2x00_has_cap_external_pa(rt2x00dev) ||
+-	    rt2x00_has_cap_external_lna_bg(rt2x00dev))
++	    rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
++		rt6352_enable_pa_pin(rt2x00dev, 0);
+ 		rt2800_restore_rf_bbp_rt6352(rt2x00dev);
++	}
  
-+	rt6352_enable_pa_pin(rt2x00dev, 0);
  	rt2800_r_calibration(rt2x00dev);
- 	rt2800_rf_self_txdc_cal(rt2x00dev);
- 	rt2800_rxdcoc_calibration(rt2x00dev);
-@@ -10590,6 +10632,22 @@ static void rt2800_init_rfcsr_6352(struc
- 	rt2800_bw_filter_calibration(rt2x00dev, false);
- 	rt2800_loft_iq_calibration(rt2x00dev);
- 	rt2800_rxiq_calibration(rt2x00dev);
-+	rt6352_enable_pa_pin(rt2x00dev, 1);
-+
-+	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
-+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
-+		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
-+		rt2800_rfcsr_write_chanreg(rt2x00dev, 18, 0x42);
-+		rt2800_bbp_write(rt2x00dev, 75, 0x68);
-+		rt2800_bbp_write(rt2x00dev, 76, 0x4C);
-+		rt2800_bbp_write(rt2x00dev, 79, 0x1C);
-+		rt2800_bbp_write(rt2x00dev, 80, 0x0C);
-+		rt2800_bbp_write(rt2x00dev, 82, 0xB6);
-+		/* bank 0 RF reg 42 and glrt BBP reg 141 will be set in config
-+		 * channel function in dependence of channel and HT20/HT40,
-+		 * so don't touch them here.
-+		 */
-+	}
  }
+@@ -10453,6 +10473,8 @@ static void rt2800_calibration_rt6352_st
+ 	    !rt2x00_has_cap_external_lna_bg(rt2x00dev))
+ 		return;
  
- static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
++	rt6352_enable_pa_pin(rt2x00dev, 1);
++
+ 	if (rt2x00_has_cap_external_pa(rt2x00dev)) {
+ 		reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
+ 		reg |= 0x00000101;
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 @@ -28,6 +28,7 @@
@@ -123,7 +83,7 @@ Signed-off-by: Daniel Golle <daniel@makrotopia.org>
  #include <linux/rt2x00_platform.h>
  
  #include <net/mac80211.h>
-@@ -1029,6 +1030,11 @@ struct rt2x00_dev {
+@@ -1017,6 +1018,11 @@ struct rt2x00_dev {
  
  	/* Clock for System On Chip devices. */
  	struct clk *clk;
diff --git a/package/kernel/mac80211/patches/rt2x00/995-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch b/package/kernel/mac80211/patches/rt2x00/995-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch
index 97a56de2..cb7a3617 100644
--- a/package/kernel/mac80211/patches/rt2x00/995-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch
+++ b/package/kernel/mac80211/patches/rt2x00/995-rt2x00-mt7620-introduce-accessors-for-CHIP_VER-register.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -78,6 +78,9 @@ struct rt2800_ops {
+@@ -76,6 +76,9 @@ struct rt2800_ops {
  	int (*drv_init_registers)(struct rt2x00_dev *rt2x00dev);
  	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
  	unsigned int (*drv_get_dma_done)(struct data_queue *queue);
@@ -10,7 +10,7 @@
  };
  
  static inline u32 rt2800_register_read(struct rt2x00_dev *rt2x00dev,
-@@ -195,6 +198,27 @@ static inline unsigned int rt2800_drv_ge
+@@ -184,6 +187,27 @@ static inline unsigned int rt2800_drv_ge
  	return rt2800ops->drv_get_dma_done(queue);
  }
  
@@ -40,7 +40,7 @@
  			const u8 arg0, const u8 arg1);
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
-@@ -286,6 +286,10 @@ static int rt2800pci_read_eeprom(struct
+@@ -289,6 +289,10 @@ static int rt2800pci_read_eeprom(struct
  	return retval;
  }
  
@@ -49,9 +49,9 @@
 +static int rt2800pci_get_chipeco(void) { return 0; }
 +
  static const struct ieee80211_ops rt2800pci_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
- 	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
-@@ -329,6 +333,9 @@ static const struct rt2800_ops rt2800pci
+ 	.add_chanctx = ieee80211_emulate_add_chanctx,
+ 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
+@@ -336,6 +340,9 @@ static const struct rt2800_ops rt2800pci
  	.drv_init_registers	= rt2800mmio_init_registers,
  	.drv_get_txwi		= rt2800mmio_get_txwi,
  	.drv_get_dma_done	= rt2800mmio_get_dma_done,
@@ -102,9 +102,9 @@
 +#endif
 +
  static const struct ieee80211_ops rt2800soc_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
- 	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
-@@ -160,6 +187,9 @@ static const struct rt2800_ops rt2800soc
+ 	.add_chanctx = ieee80211_emulate_add_chanctx,
+ 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
+@@ -165,6 +192,9 @@ static const struct rt2800_ops rt2800soc
  	.drv_init_registers	= rt2800mmio_init_registers,
  	.drv_get_txwi		= rt2800mmio_get_txwi,
  	.drv_get_dma_done	= rt2800mmio_get_dma_done,
@@ -125,9 +125,9 @@
 +static int rt2800usb_get_chipeco(void) { return 0; }
 +
  static const struct ieee80211_ops rt2800usb_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
- 	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
-@@ -672,6 +676,9 @@ static const struct rt2800_ops rt2800usb
+ 	.add_chanctx = ieee80211_emulate_add_chanctx,
+ 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
+@@ -676,6 +680,9 @@ static const struct rt2800_ops rt2800usb
  	.drv_init_registers	= rt2800usb_init_registers,
  	.drv_get_txwi		= rt2800usb_get_txwi,
  	.drv_get_dma_done	= rt2800usb_get_dma_done,
diff --git a/package/kernel/mac80211/patches/rt2x00/996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch b/package/kernel/mac80211/patches/rt2x00/996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
index dab6e05f..eb0237a3 100644
--- a/package/kernel/mac80211/patches/rt2x00/996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
+++ b/package/kernel/mac80211/patches/rt2x00/996-rt2x00-mt7620-differentiate-based-on-SoC-CHIP_VER.patch
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -1044,6 +1044,11 @@
+@@ -1056,6 +1056,11 @@
  #define MIMO_PS_CFG_RX_STBY_POL		FIELD32(0x00000010)
  #define MIMO_PS_CFG_RX_RX_STBY0		FIELD32(0x00000020)
  
@@ -14,13 +14,13 @@
   */
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3778,14 +3778,16 @@ static void rt2800_config_channel_rf7620
+@@ -3842,14 +3842,16 @@ static void rt2800_config_channel_rf7620
  	rt2x00_set_field8(&rfcsr, RFCSR19_K, rf->rf4);
  	rt2800_rfcsr_write(rt2x00dev, 19, rfcsr);
  
 -	/* Default: XO=20MHz , SDM mode */
 -	rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
--	rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 0x80);
+-	rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 4);
 -	rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
 -
 -	rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
@@ -29,7 +29,7 @@
 +	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
 +		/* Default: XO=20MHz , SDM mode */
 +		rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
-+		rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 0x80);
++		rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 4);
 +		rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
 +
 +		rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
@@ -39,7 +39,7 @@
  
  	rfcsr = rt2800_rfcsr_read(rt2x00dev, 1);
  	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_EN_MT7620,
-@@ -3819,18 +3821,23 @@ static void rt2800_config_channel_rf7620
+@@ -3883,18 +3885,23 @@ static void rt2800_config_channel_rf7620
  		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x20);
  	}
  
@@ -73,7 +73,7 @@
  
  	if (!test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags)) {
  		if (conf_is_ht40(conf)) {
-@@ -3929,25 +3936,29 @@ static void rt2800_config_alc(struct rt2
+@@ -4008,25 +4015,29 @@ static void rt2800_config_alc_rt6352(str
  	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
  		rt2x00_warn(rt2x00dev, "RF busy while configuring ALC\n");
  
@@ -121,7 +121,17 @@
  	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, mac_sys_ctrl);
  
  	rt2800_vco_calibration(rt2x00dev);
-@@ -6011,18 +6022,33 @@ static int rt2800_init_registers(struct
+@@ -4524,7 +4535,8 @@ static void rt2800_config_channel(struct
+ 	if (rt2x00_rt(rt2x00dev, RT6352)) {
+ 		/* BBP for GLRT BW */
+ 		bbp = conf_is_ht40(conf) ?
+-		      0x10 : rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
++		      0x10 : !rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
++		      0x1a : rt2800_hw_get_chippkg(rt2x00dev) == 1 ?
+ 		      0x15 : 0x1a;
+ 		rt2800_bbp_glrt_write(rt2x00dev, 141, bbp);
+ 
+@@ -6042,18 +6054,34 @@ static int rt2800_init_registers(struct
  	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
  		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
  	} else if (rt2x00_rt(rt2x00dev, RT6352)) {
@@ -152,7 +162,8 @@
 +			rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
 +			rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
 +			rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
-+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
++			rt2800_register_write(rt2x00dev, TX_PIN_CFG, 0x00150f0f);
++			rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x06060606);
 +			rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
 +			rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
 +			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN,
@@ -167,7 +178,7 @@
  		reg = rt2800_register_read(rt2x00dev, TX_ALC_CFG_1);
  		rt2x00_set_field32(&reg, TX_ALC_CFG_1_ROS_BUSY_EN, 0);
  		rt2800_register_write(rt2x00dev, TX_ALC_CFG_1, reg);
-@@ -7127,14 +7153,16 @@ static void rt2800_init_bbp_6352(struct
+@@ -7160,14 +7188,16 @@ static void rt2800_init_bbp_6352(struct
  	rt2800_bbp_write(rt2x00dev, 188, 0x00);
  	rt2800_bbp_write(rt2x00dev, 189, 0x00);
  
@@ -192,7 +203,27 @@
  
  	/* BBP for G band GLRT function (BBP_128 ~ BBP_221) */
  	rt2800_bbp_glrt_write(rt2x00dev, 0, 0x00);
-@@ -10408,31 +10436,36 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -10404,6 +10434,9 @@ static void rt2800_restore_rf_bbp_rt6352
+ 		rt2800_register_write(rt2x00dev, RF_BYPASS3, 0x0);
+ 	}
+ 
++	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
++		return;
++
+ 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
+ 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
+ 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
+@@ -10485,6 +10518,9 @@ static void rt2800_calibration_rt6352_st
+ 		rt2800_register_write(rt2x00dev, RF_BYPASS3, reg);
+ 	}
+ 
++	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
++		return;
++
+ 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
+ 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
+ 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
+@@ -10575,31 +10611,36 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write(rt2x00dev, 42, 0x5B);
  	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
  
@@ -254,7 +285,7 @@
  
  	/* Initialize RF channel register to default value */
  	rt2800_rfcsr_write_chanreg(rt2x00dev, 0, 0x03);
-@@ -10498,63 +10531,71 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -10665,63 +10706,71 @@ static void rt2800_init_rfcsr_6352(struc
  
  	rt2800_rfcsr_write_bank(rt2x00dev, 6, 45, 0xC5);
  
@@ -288,33 +319,6 @@
 -	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
 -	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
 -	rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
--
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
--
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
--
--	/* Initialize RF channel register for DRQFN */
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
--	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
 +	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
 +		rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
 +		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
@@ -347,7 +351,16 @@
 +		rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
 +		rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
 +	}
-+
+ 
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
 +	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
 +	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
 +		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
@@ -367,7 +380,23 @@
 +		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
 +		rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
 +	}
-+
+ 
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
+-
+-	/* Initialize RF channel register for DRQFN */
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
+-	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
 +	if (rt2800_hw_get_chippkg(rt2x00dev) == 0 &&
 +	    rt2800_hw_get_chipver(rt2x00dev) == 1) {
 +		/* Initialize RF channel register for DRQFN */
@@ -383,7 +412,7 @@
  
  	/* Initialize RF DC calibration register to default value */
  	rt2800_rfcsr_write_dccal(rt2x00dev, 0, 0x47);
-@@ -10617,12 +10658,17 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -10784,12 +10833,17 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write_dccal(rt2x00dev, 62, 0x00);
  	rt2800_rfcsr_write_dccal(rt2x00dev, 63, 0x00);
  
@@ -403,6 +432,6 @@
 +		rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
 +		rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
 +	}
+ }
  
- 	rt6352_enable_pa_pin(rt2x00dev, 0);
- 	rt2800_r_calibration(rt2x00dev);
+ static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
diff --git a/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch b/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch
index 4d4a2a8f..68534f4e 100644
--- a/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch
+++ b/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch
@@ -9,11 +9,16 @@ Used for AP+STA support in OpenWrt - preserve AP mode keys across STA reconnect
 
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -1519,7 +1519,6 @@ static int ieee80211_stop_ap(struct wiph
- 	link_conf->bssid_indicator = 0;
+@@ -1649,12 +1649,6 @@ static int ieee80211_stop_ap(struct wiph
  
- 	__sta_info_flush(sdata, true);
--	ieee80211_free_keys(sdata, true);
+ 	__sta_info_flush(sdata, true, link_id);
  
+-	ieee80211_remove_link_keys(link, &keys);
+-	if (!list_empty(&keys)) {
+-		synchronize_net();
+-		ieee80211_free_key_list(local, &keys);
+-	}
+-
  	link_conf->enable_beacon = false;
  	sdata->beacon_rate_set = false;
+ 	sdata->vif.cfg.ssid_len = 0;
diff --git a/package/kernel/mac80211/patches/subsys/210-ap_scan.patch b/package/kernel/mac80211/patches/subsys/210-ap_scan.patch
index 10b842d9..ca4ac8ad 100644
--- a/package/kernel/mac80211/patches/subsys/210-ap_scan.patch
+++ b/package/kernel/mac80211/patches/subsys/210-ap_scan.patch
@@ -8,7 +8,7 @@ Subject: [PATCH] mac80211: allow scans in access point mode (for site survey)
 
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -2727,6 +2727,8 @@ static int ieee80211_scan(struct wiphy *
+@@ -2863,6 +2863,8 @@ static int ieee80211_scan(struct wiphy *
  		 */
  		fallthrough;
  	case NL80211_IFTYPE_AP:
diff --git a/package/kernel/mac80211/patches/subsys/301-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch b/package/kernel/mac80211/patches/subsys/301-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
index 63b21774..edec97cc 100644
--- a/package/kernel/mac80211/patches/subsys/301-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
+++ b/package/kernel/mac80211/patches/subsys/301-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
@@ -28,11 +28,11 @@ Signed-off-by: Johannes Berg <johannes.berg@intel.com>
 
 --- a/net/mac80211/sta_info.c
 +++ b/net/mac80211/sta_info.c
-@@ -554,6 +554,7 @@ __sta_info_alloc(struct ieee80211_sub_if
+@@ -565,6 +565,7 @@ __sta_info_alloc(struct ieee80211_sub_if
+ 	spin_lock_init(&sta->ps_lock);
  	INIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);
- 	INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
- 	mutex_init(&sta->ampdu_mlme.mtx);
-+	sta->ampdu_mlme.dialog_token_allocator = prandom_u32_max(U8_MAX);
+ 	wiphy_work_init(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
++	sta->ampdu_mlme.dialog_token_allocator = get_random_u32_below(U8_MAX);
  #ifdef CPTCFG_MAC80211_MESH
  	if (ieee80211_vif_is_mesh(&sdata->vif)) {
  		sta->mesh = kzalloc(sizeof(*sta->mesh), gfp);
diff --git a/package/kernel/mac80211/patches/subsys/305-mac80211-increase-quantum-for-airtime-scheduler.patch b/package/kernel/mac80211/patches/subsys/305-mac80211-increase-quantum-for-airtime-scheduler.patch
index e2c10b6c..6cf46ce7 100644
--- a/package/kernel/mac80211/patches/subsys/305-mac80211-increase-quantum-for-airtime-scheduler.patch
+++ b/package/kernel/mac80211/patches/subsys/305-mac80211-increase-quantum-for-airtime-scheduler.patch
@@ -12,9 +12,9 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
 
 --- a/net/mac80211/ieee80211_i.h
 +++ b/net/mac80211/ieee80211_i.h
-@@ -90,6 +90,8 @@ extern const u8 ieee80211_ac_to_qos_mask
-  */
- #define AIRTIME_ACTIVE_DURATION (HZ / 10)
+@@ -103,6 +103,8 @@ ieee80211_sta_keep_active(struct sta_inf
+ 	return time_before_eq(jiffies, sta->airtime[ac].last_active + HZ / 10);
+ }
  
 +#define AIRTIME_QUANTUM_SHIFT	3
 +
@@ -23,7 +23,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
 --- a/net/mac80211/tx.c
 +++ b/net/mac80211/tx.c
-@@ -3988,7 +3988,7 @@ struct ieee80211_txq *ieee80211_next_txq
+@@ -4081,7 +4081,7 @@ struct ieee80211_txq *ieee80211_next_txq
  
  		if (deficit < 0)
  			sta->airtime[txqi->txq.ac].deficit +=
@@ -32,7 +32,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  
  		if (deficit < 0 || !aql_check) {
  			list_move_tail(&txqi->schedule_order,
-@@ -4131,7 +4131,8 @@ bool ieee80211_txq_may_transmit(struct i
+@@ -4224,7 +4224,8 @@ bool ieee80211_txq_may_transmit(struct i
  		}
  		sta = container_of(iter->txq.sta, struct sta_info, sta);
  		if (ieee80211_sta_deficit(sta, ac) < 0)
@@ -42,7 +42,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
  	}
  
-@@ -4139,7 +4140,7 @@ bool ieee80211_txq_may_transmit(struct i
+@@ -4232,7 +4233,7 @@ bool ieee80211_txq_may_transmit(struct i
  	if (sta->airtime[ac].deficit >= 0)
  		goto out;
  
diff --git a/package/kernel/mac80211/patches/subsys/306-01-v6.2-wifi-mac80211-add-internal-handler-for-wake_tx_queue.patch b/package/kernel/mac80211/patches/subsys/306-01-v6.2-wifi-mac80211-add-internal-handler-for-wake_tx_queue.patch
deleted file mode 100644
index c7ac38a7..00000000
--- a/package/kernel/mac80211/patches/subsys/306-01-v6.2-wifi-mac80211-add-internal-handler-for-wake_tx_queue.patch
+++ /dev/null
@@ -1,183 +0,0 @@
-From: Alexander Wetzel <alexander@wetzel-home.de>
-Date: Sun, 9 Oct 2022 18:30:38 +0200
-Subject: [PATCH] wifi: mac80211: add internal handler for wake_tx_queue
-
-Start to align the TX handling to only use internal TX queues (iTXQs):
-
-Provide a handler for drivers not having a custom wake_tx_queue
-callback and update the documentation.
-
-Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -89,15 +89,13 @@
- /**
-  * DOC: mac80211 software tx queueing
-  *
-- * mac80211 provides an optional intermediate queueing implementation designed
-- * to allow the driver to keep hardware queues short and provide some fairness
-- * between different stations/interfaces.
-- * In this model, the driver pulls data frames from the mac80211 queue instead
-- * of letting mac80211 push them via drv_tx().
-- * Other frames (e.g. control or management) are still pushed using drv_tx().
-+ * mac80211 uses an intermediate queueing implementation, designed to allow the
-+ * driver to keep hardware queues short and to provide some fairness between
-+ * different stations/interfaces.
-  *
-- * Drivers indicate that they use this model by implementing the .wake_tx_queue
-- * driver operation.
-+ * Drivers must provide the .wake_tx_queue driver operation by either
-+ * linking it to ieee80211_handle_wake_tx_queue() or implementing a custom
-+ * handler.
-  *
-  * Intermediate queues (struct ieee80211_txq) are kept per-sta per-tid, with
-  * another per-sta for non-data/non-mgmt and bufferable management frames, and
-@@ -106,9 +104,12 @@
-  * The driver is expected to initialize its private per-queue data for stations
-  * and interfaces in the .add_interface and .sta_add ops.
-  *
-- * The driver can't access the queue directly. To dequeue a frame from a
-- * txq, it calls ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a
-- * queue, it calls the .wake_tx_queue driver op.
-+ * The driver can't access the internal TX queues (iTXQs) directly.
-+ * Whenever mac80211 adds a new frame to a queue, it calls the .wake_tx_queue
-+ * driver op.
-+ * Drivers implementing a custom .wake_tx_queue op can get them by calling
-+ * ieee80211_tx_dequeue(). Drivers using ieee80211_handle_wake_tx_queue() will
-+ * simply get the individual frames pushed via the .tx driver operation.
-  *
-  * Drivers can optionally delegate responsibility for scheduling queues to
-  * mac80211, to take advantage of airtime fairness accounting. In this case, to
-@@ -2259,8 +2260,8 @@ struct ieee80211_link_sta {
-  *	For non MLO STA it will point to the deflink data. For MLO STA
-  *	ieee80211_sta_recalc_aggregates() must be called to update it.
-  * @support_p2p_ps: indicates whether the STA supports P2P PS mechanism or not.
-- * @txq: per-TID data TX queues (if driver uses the TXQ abstraction); note that
-- *	the last entry (%IEEE80211_NUM_TIDS) is used for non-data frames
-+ * @txq: per-TID data TX queues; note that the last entry (%IEEE80211_NUM_TIDS)
-+ *	is used for non-data frames
-  * @deflink: This holds the default link STA information, for non MLO STA all link
-  *	specific STA information is accessed through @deflink or through
-  *	link[0] which points to address of @deflink. For MLO Link STA
-@@ -5698,7 +5699,7 @@ void ieee80211_key_replay(struct ieee802
-  * @hw: pointer as obtained from ieee80211_alloc_hw().
-  * @queue: queue number (counted from zero).
-  *
-- * Drivers should use this function instead of netif_wake_queue.
-+ * Drivers must use this function instead of netif_wake_queue.
-  */
- void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);
- 
-@@ -5707,7 +5708,7 @@ void ieee80211_wake_queue(struct ieee802
-  * @hw: pointer as obtained from ieee80211_alloc_hw().
-  * @queue: queue number (counted from zero).
-  *
-- * Drivers should use this function instead of netif_stop_queue.
-+ * Drivers must use this function instead of netif_stop_queue.
-  */
- void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);
- 
-@@ -5716,7 +5717,7 @@ void ieee80211_stop_queue(struct ieee802
-  * @hw: pointer as obtained from ieee80211_alloc_hw().
-  * @queue: queue number (counted from zero).
-  *
-- * Drivers should use this function instead of netif_stop_queue.
-+ * Drivers must use this function instead of netif_queue_stopped.
-  *
-  * Return: %true if the queue is stopped. %false otherwise.
-  */
-@@ -5727,7 +5728,7 @@ int ieee80211_queue_stopped(struct ieee8
-  * ieee80211_stop_queues - stop all queues
-  * @hw: pointer as obtained from ieee80211_alloc_hw().
-  *
-- * Drivers should use this function instead of netif_stop_queue.
-+ * Drivers must use this function instead of netif_tx_stop_all_queues.
-  */
- void ieee80211_stop_queues(struct ieee80211_hw *hw);
- 
-@@ -5735,7 +5736,7 @@ void ieee80211_stop_queues(struct ieee80
-  * ieee80211_wake_queues - wake all queues
-  * @hw: pointer as obtained from ieee80211_alloc_hw().
-  *
-- * Drivers should use this function instead of netif_wake_queue.
-+ * Drivers must use this function instead of netif_tx_wake_all_queues.
-  */
- void ieee80211_wake_queues(struct ieee80211_hw *hw);
- 
-@@ -6957,6 +6958,18 @@ static inline struct sk_buff *ieee80211_
- }
- 
- /**
-+ * ieee80211_handle_wake_tx_queue - mac80211 handler for wake_tx_queue callback
-+ *
-+ * @hw: pointer as obtained from wake_tx_queue() callback().
-+ * @txq: pointer as obtained from wake_tx_queue() callback().
-+ *
-+ * Drivers can use this function for the mandatory mac80211 wake_tx_queue
-+ * callback in struct ieee80211_ops. They should not call this function.
-+ */
-+void ieee80211_handle_wake_tx_queue(struct ieee80211_hw *hw,
-+				    struct ieee80211_txq *txq);
-+
-+/**
-  * ieee80211_next_txq - get next tx queue to pull packets from
-  *
-  * @hw: pointer as obtained from ieee80211_alloc_hw()
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -288,6 +288,52 @@ __le16 ieee80211_ctstoself_duration(stru
- }
- EXPORT_SYMBOL(ieee80211_ctstoself_duration);
- 
-+static void wake_tx_push_queue(struct ieee80211_local *local,
-+			       struct ieee80211_sub_if_data *sdata,
-+			       struct ieee80211_txq *queue)
-+{
-+	int q = sdata->vif.hw_queue[queue->ac];
-+	struct ieee80211_tx_control control = {
-+		.sta = queue->sta,
-+	};
-+	struct sk_buff *skb;
-+	unsigned long flags;
-+	bool q_stopped;
-+
-+	while (1) {
-+		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-+		q_stopped = local->queue_stop_reasons[q];
-+		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-+
-+		if (q_stopped)
-+			break;
-+
-+		skb = ieee80211_tx_dequeue(&local->hw, queue);
-+		if (!skb)
-+			break;
-+
-+		drv_tx(local, &control, skb);
-+	}
-+}
-+
-+/* wake_tx_queue handler for driver not implementing a custom one*/
-+void ieee80211_handle_wake_tx_queue(struct ieee80211_hw *hw,
-+				    struct ieee80211_txq *txq)
-+{
-+	struct ieee80211_local *local = hw_to_local(hw);
-+	struct ieee80211_sub_if_data *sdata = vif_to_sdata(txq->vif);
-+	struct ieee80211_txq *queue;
-+
-+	/* Use ieee80211_next_txq() for airtime fairness accounting */
-+	ieee80211_txq_schedule_start(hw, txq->ac);
-+	while ((queue = ieee80211_next_txq(hw, txq->ac))) {
-+		wake_tx_push_queue(local, sdata, queue);
-+		ieee80211_return_txq(hw, queue, false);
-+	}
-+	ieee80211_txq_schedule_end(hw, txq->ac);
-+}
-+EXPORT_SYMBOL(ieee80211_handle_wake_tx_queue);
-+
- static void __ieee80211_wake_txqs(struct ieee80211_sub_if_data *sdata, int ac)
- {
- 	struct ieee80211_local *local = sdata->local;
diff --git a/package/kernel/mac80211/patches/subsys/306-02-v6.2-wifi-mac80211-add-wake_tx_queue-callback-to-drivers.patch b/package/kernel/mac80211/patches/subsys/306-02-v6.2-wifi-mac80211-add-wake_tx_queue-callback-to-drivers.patch
deleted file mode 100644
index fee038d9..00000000
--- a/package/kernel/mac80211/patches/subsys/306-02-v6.2-wifi-mac80211-add-wake_tx_queue-callback-to-drivers.patch
+++ /dev/null
@@ -1,396 +0,0 @@
-From: Alexander Wetzel <alexander@wetzel-home.de>
-Date: Sun, 9 Oct 2022 18:30:39 +0200
-Subject: [PATCH] wifi: mac80211: add wake_tx_queue callback to drivers
-
-mac80211 is fully switching over to the internal TX queue (iTXQ)
-implementation. Update all drivers not yet providing the now mandatory
-wake_tx_queue() callback.
-
-As an side effect the netdev interfaces of all updated drivers will
-switch to the noqueue qdisc.
-
-Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
-[add staging drivers]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/drivers/net/wireless/admtek/adm8211.c
-+++ b/drivers/net/wireless/admtek/adm8211.c
-@@ -1760,6 +1760,7 @@ static int adm8211_alloc_rings(struct ie
- 
- static const struct ieee80211_ops adm8211_ops = {
- 	.tx			= adm8211_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= adm8211_start,
- 	.stop			= adm8211_stop,
- 	.add_interface		= adm8211_add_interface,
---- a/drivers/net/wireless/ath/ar5523/ar5523.c
-+++ b/drivers/net/wireless/ath/ar5523/ar5523.c
-@@ -1361,6 +1361,7 @@ static const struct ieee80211_ops ar5523
- 	.start			= ar5523_start,
- 	.stop			= ar5523_stop,
- 	.tx			= ar5523_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.set_rts_threshold	= ar5523_set_rts_threshold,
- 	.add_interface		= ar5523_add_interface,
- 	.remove_interface	= ar5523_remove_interface,
---- a/drivers/net/wireless/ath/ath11k/mac.c
-+++ b/drivers/net/wireless/ath/ath11k/mac.c
-@@ -8587,6 +8587,7 @@ err_fallback:
- 
- static const struct ieee80211_ops ath11k_ops = {
- 	.tx				= ath11k_mac_op_tx,
-+	.wake_tx_queue			= ieee80211_handle_wake_tx_queue,
- 	.start                          = ath11k_mac_op_start,
- 	.stop                           = ath11k_mac_op_stop,
- 	.reconfig_complete              = ath11k_mac_op_reconfig_complete,
---- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -781,6 +781,7 @@ static int ath5k_set_ringparam(struct ie
- 
- const struct ieee80211_ops ath5k_hw_ops = {
- 	.tx			= ath5k_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= ath5k_start,
- 	.stop			= ath5k_stop,
- 	.add_interface		= ath5k_add_interface,
---- a/drivers/net/wireless/ath/ath9k/htc_drv_main.c
-+++ b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
-@@ -1870,6 +1870,7 @@ static void ath9k_htc_channel_switch_bea
- 
- struct ieee80211_ops ath9k_htc_ops = {
- 	.tx                 = ath9k_htc_tx,
-+	.wake_tx_queue      = ieee80211_handle_wake_tx_queue,
- 	.start              = ath9k_htc_start,
- 	.stop               = ath9k_htc_stop,
- 	.add_interface      = ath9k_htc_add_interface,
---- a/drivers/net/wireless/ath/carl9170/main.c
-+++ b/drivers/net/wireless/ath/carl9170/main.c
-@@ -1715,6 +1715,7 @@ static const struct ieee80211_ops carl91
- 	.start			= carl9170_op_start,
- 	.stop			= carl9170_op_stop,
- 	.tx			= carl9170_op_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.flush			= carl9170_op_flush,
- 	.add_interface		= carl9170_op_add_interface,
- 	.remove_interface	= carl9170_op_remove_interface,
---- a/drivers/net/wireless/ath/wcn36xx/main.c
-+++ b/drivers/net/wireless/ath/wcn36xx/main.c
-@@ -1362,6 +1362,7 @@ static const struct ieee80211_ops wcn36x
- 	.prepare_multicast	= wcn36xx_prepare_multicast,
- 	.configure_filter       = wcn36xx_configure_filter,
- 	.tx			= wcn36xx_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.set_key		= wcn36xx_set_key,
- 	.hw_scan		= wcn36xx_hw_scan,
- 	.cancel_hw_scan		= wcn36xx_cancel_hw_scan,
---- a/drivers/net/wireless/atmel/at76c50x-usb.c
-+++ b/drivers/net/wireless/atmel/at76c50x-usb.c
-@@ -2187,6 +2187,7 @@ static int at76_set_key(struct ieee80211
- 
- static const struct ieee80211_ops at76_ops = {
- 	.tx = at76_mac80211_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.add_interface = at76_add_interface,
- 	.remove_interface = at76_remove_interface,
- 	.config = at76_config,
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -5171,6 +5171,7 @@ static int b43_op_get_survey(struct ieee
- 
- static const struct ieee80211_ops b43_hw_ops = {
- 	.tx			= b43_op_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.conf_tx		= b43_op_conf_tx,
- 	.add_interface		= b43_op_add_interface,
- 	.remove_interface	= b43_op_remove_interface,
---- a/drivers/net/wireless/broadcom/b43legacy/main.c
-+++ b/drivers/net/wireless/broadcom/b43legacy/main.c
-@@ -3532,6 +3532,7 @@ static int b43legacy_op_get_survey(struc
- 
- static const struct ieee80211_ops b43legacy_hw_ops = {
- 	.tx			= b43legacy_op_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.conf_tx		= b43legacy_op_conf_tx,
- 	.add_interface		= b43legacy_op_add_interface,
- 	.remove_interface	= b43legacy_op_remove_interface,
---- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c
-@@ -962,6 +962,7 @@ static int brcms_ops_beacon_set_tim(stru
- 
- static const struct ieee80211_ops brcms_ops = {
- 	.tx = brcms_ops_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.start = brcms_ops_start,
- 	.stop = brcms_ops_stop,
- 	.add_interface = brcms_ops_add_interface,
---- a/drivers/net/wireless/intel/iwlegacy/3945-mac.c
-+++ b/drivers/net/wireless/intel/iwlegacy/3945-mac.c
-@@ -3439,6 +3439,7 @@ static const struct attribute_group il39
- 
- static struct ieee80211_ops il3945_mac_ops __ro_after_init = {
- 	.tx = il3945_mac_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.start = il3945_mac_start,
- 	.stop = il3945_mac_stop,
- 	.add_interface = il_mac_add_interface,
---- a/drivers/net/wireless/intel/iwlegacy/4965-mac.c
-+++ b/drivers/net/wireless/intel/iwlegacy/4965-mac.c
-@@ -6308,6 +6308,7 @@ il4965_tx_queue_set_status(struct il_pri
- 
- static const struct ieee80211_ops il4965_mac_ops = {
- 	.tx = il4965_mac_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.start = il4965_mac_start,
- 	.stop = il4965_mac_stop,
- 	.add_interface = il_mac_add_interface,
---- a/drivers/net/wireless/intel/iwlwifi/dvm/mac80211.c
-+++ b/drivers/net/wireless/intel/iwlwifi/dvm/mac80211.c
-@@ -1571,6 +1571,7 @@ static void iwlagn_mac_sta_notify(struct
- 
- const struct ieee80211_ops iwlagn_hw_ops = {
- 	.tx = iwlagn_mac_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.start = iwlagn_mac_start,
- 	.stop = iwlagn_mac_stop,
- #ifdef CONFIG_PM_SLEEP
---- a/drivers/net/wireless/intersil/p54/main.c
-+++ b/drivers/net/wireless/intersil/p54/main.c
-@@ -705,6 +705,7 @@ static void p54_set_coverage_class(struc
- 
- static const struct ieee80211_ops p54_ops = {
- 	.tx			= p54_tx_80211,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= p54_start,
- 	.stop			= p54_stop,
- 	.add_interface		= p54_add_interface,
---- a/drivers/net/wireless/mac80211_hwsim.c
-+++ b/drivers/net/wireless/mac80211_hwsim.c
-@@ -3109,6 +3109,7 @@ static int mac80211_hwsim_change_sta_lin
- 
- #define HWSIM_COMMON_OPS					\
- 	.tx = mac80211_hwsim_tx,				\
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,	\
- 	.start = mac80211_hwsim_start,				\
- 	.stop = mac80211_hwsim_stop,				\
- 	.add_interface = mac80211_hwsim_add_interface,		\
---- a/drivers/net/wireless/marvell/libertas_tf/main.c
-+++ b/drivers/net/wireless/marvell/libertas_tf/main.c
-@@ -474,6 +474,7 @@ static int lbtf_op_get_survey(struct iee
- 
- static const struct ieee80211_ops lbtf_ops = {
- 	.tx			= lbtf_op_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= lbtf_op_start,
- 	.stop			= lbtf_op_stop,
- 	.add_interface		= lbtf_op_add_interface,
---- a/drivers/net/wireless/marvell/mwl8k.c
-+++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -5611,6 +5611,7 @@ static void mwl8k_sw_scan_complete(struc
- 
- static const struct ieee80211_ops mwl8k_ops = {
- 	.tx			= mwl8k_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= mwl8k_start,
- 	.stop			= mwl8k_stop,
- 	.add_interface		= mwl8k_add_interface,
---- a/drivers/net/wireless/mediatek/mt7601u/main.c
-+++ b/drivers/net/wireless/mediatek/mt7601u/main.c
-@@ -406,6 +406,7 @@ out:
- 
- const struct ieee80211_ops mt7601u_ops = {
- 	.tx = mt7601u_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.start = mt7601u_start,
- 	.stop = mt7601u_stop,
- 	.add_interface = mt7601u_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt2400pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2400pci.c
-@@ -1706,6 +1706,7 @@ static int rt2400pci_tx_last_beacon(stru
- 
- static const struct ieee80211_ops rt2400pci_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt2500pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2500pci.c
-@@ -2004,6 +2004,7 @@ static int rt2500pci_tx_last_beacon(stru
- 
- static const struct ieee80211_ops rt2500pci_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt2500usb.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2500usb.c
-@@ -1795,6 +1795,7 @@ static int rt2500usb_probe_hw(struct rt2
- 
- static const struct ieee80211_ops rt2500usb_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
-@@ -288,6 +288,7 @@ static int rt2800pci_read_eeprom(struct
- 
- static const struct ieee80211_ops rt2800pci_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -133,6 +133,7 @@ static int rt2800soc_write_firmware(stru
- 
- static const struct ieee80211_ops rt2800soc_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
-@@ -630,6 +630,7 @@ static int rt2800usb_probe_hw(struct rt2
- 
- static const struct ieee80211_ops rt2800usb_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt61pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt61pci.c
-@@ -2873,6 +2873,7 @@ static u64 rt61pci_get_tsf(struct ieee80
- 
- static const struct ieee80211_ops rt61pci_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/ralink/rt2x00/rt73usb.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt73usb.c
-@@ -2292,6 +2292,7 @@ static u64 rt73usb_get_tsf(struct ieee80
- 
- static const struct ieee80211_ops rt73usb_mac80211_ops = {
- 	.tx			= rt2x00mac_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rt2x00mac_start,
- 	.stop			= rt2x00mac_stop,
- 	.add_interface		= rt2x00mac_add_interface,
---- a/drivers/net/wireless/realtek/rtl818x/rtl8180/dev.c
-+++ b/drivers/net/wireless/realtek/rtl818x/rtl8180/dev.c
-@@ -1608,6 +1608,7 @@ static void rtl8180_configure_filter(str
- 
- static const struct ieee80211_ops rtl8180_ops = {
- 	.tx			= rtl8180_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rtl8180_start,
- 	.stop			= rtl8180_stop,
- 	.add_interface		= rtl8180_add_interface,
---- a/drivers/net/wireless/realtek/rtl818x/rtl8187/dev.c
-+++ b/drivers/net/wireless/realtek/rtl818x/rtl8187/dev.c
-@@ -1378,6 +1378,7 @@ static int rtl8187_conf_tx(struct ieee80
- 
- static const struct ieee80211_ops rtl8187_ops = {
- 	.tx			= rtl8187_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= rtl8187_start,
- 	.stop			= rtl8187_stop,
- 	.add_interface		= rtl8187_add_interface,
---- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
-+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
-@@ -6548,6 +6548,7 @@ static void rtl8xxxu_stop(struct ieee802
- 
- static const struct ieee80211_ops rtl8xxxu_ops = {
- 	.tx = rtl8xxxu_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.add_interface = rtl8xxxu_add_interface,
- 	.remove_interface = rtl8xxxu_remove_interface,
- 	.config = rtl8xxxu_config,
---- a/drivers/net/wireless/realtek/rtlwifi/core.c
-+++ b/drivers/net/wireless/realtek/rtlwifi/core.c
-@@ -1912,6 +1912,7 @@ const struct ieee80211_ops rtl_ops = {
- 	.start = rtl_op_start,
- 	.stop = rtl_op_stop,
- 	.tx = rtl_op_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.add_interface = rtl_op_add_interface,
- 	.remove_interface = rtl_op_remove_interface,
- 	.change_interface = rtl_op_change_interface,
---- a/drivers/net/wireless/realtek/rtw88/mac80211.c
-+++ b/drivers/net/wireless/realtek/rtw88/mac80211.c
-@@ -896,6 +896,7 @@ static void rtw_ops_sta_rc_update(struct
- 
- const struct ieee80211_ops rtw_ops = {
- 	.tx			= rtw_ops_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.wake_tx_queue		= rtw_ops_wake_tx_queue,
- 	.start			= rtw_ops_start,
- 	.stop			= rtw_ops_stop,
---- a/drivers/net/wireless/realtek/rtw89/mac80211.c
-+++ b/drivers/net/wireless/realtek/rtw89/mac80211.c
-@@ -918,6 +918,7 @@ static int rtw89_ops_set_tid_config(stru
- 
- const struct ieee80211_ops rtw89_ops = {
- 	.tx			= rtw89_ops_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.wake_tx_queue		= rtw89_ops_wake_tx_queue,
- 	.start			= rtw89_ops_start,
- 	.stop			= rtw89_ops_stop,
---- a/drivers/net/wireless/rsi/rsi_91x_mac80211.c
-+++ b/drivers/net/wireless/rsi/rsi_91x_mac80211.c
-@@ -1958,6 +1958,7 @@ static int rsi_mac80211_resume(struct ie
- 
- static const struct ieee80211_ops mac80211_ops = {
- 	.tx = rsi_mac80211_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.start = rsi_mac80211_start,
- 	.stop = rsi_mac80211_stop,
- 	.add_interface = rsi_mac80211_add_interface,
---- a/drivers/net/wireless/st/cw1200/main.c
-+++ b/drivers/net/wireless/st/cw1200/main.c
-@@ -209,6 +209,7 @@ static const struct ieee80211_ops cw1200
- 	.remove_interface	= cw1200_remove_interface,
- 	.change_interface	= cw1200_change_interface,
- 	.tx			= cw1200_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.hw_scan		= cw1200_hw_scan,
- 	.set_tim		= cw1200_set_tim,
- 	.sta_notify		= cw1200_sta_notify,
---- a/drivers/net/wireless/ti/wl1251/main.c
-+++ b/drivers/net/wireless/ti/wl1251/main.c
-@@ -1359,6 +1359,7 @@ static const struct ieee80211_ops wl1251
- 	.prepare_multicast = wl1251_op_prepare_multicast,
- 	.configure_filter = wl1251_op_configure_filter,
- 	.tx = wl1251_op_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.set_key = wl1251_op_set_key,
- 	.hw_scan = wl1251_op_hw_scan,
- 	.bss_info_changed = wl1251_op_bss_info_changed,
---- a/drivers/net/wireless/ti/wlcore/main.c
-+++ b/drivers/net/wireless/ti/wlcore/main.c
-@@ -5942,6 +5942,7 @@ static const struct ieee80211_ops wl1271
- 	.prepare_multicast = wl1271_op_prepare_multicast,
- 	.configure_filter = wl1271_op_configure_filter,
- 	.tx = wl1271_op_tx,
-+	.wake_tx_queue = ieee80211_handle_wake_tx_queue,
- 	.set_key = wlcore_op_set_key,
- 	.hw_scan = wl1271_op_hw_scan,
- 	.cancel_hw_scan = wl1271_op_cancel_hw_scan,
---- a/drivers/net/wireless/zydas/zd1211rw/zd_mac.c
-+++ b/drivers/net/wireless/zydas/zd1211rw/zd_mac.c
-@@ -1344,6 +1344,7 @@ static u64 zd_op_get_tsf(struct ieee8021
- 
- static const struct ieee80211_ops zd_ops = {
- 	.tx			= zd_op_tx,
-+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.start			= zd_op_start,
- 	.stop			= zd_op_stop,
- 	.add_interface		= zd_op_add_interface,
diff --git a/package/kernel/mac80211/patches/subsys/306-03-v6.2-wifi-mac80211-Drop-support-for-TX-push-path.patch b/package/kernel/mac80211/patches/subsys/306-03-v6.2-wifi-mac80211-Drop-support-for-TX-push-path.patch
deleted file mode 100644
index 716b1097..00000000
--- a/package/kernel/mac80211/patches/subsys/306-03-v6.2-wifi-mac80211-Drop-support-for-TX-push-path.patch
+++ /dev/null
@@ -1,683 +0,0 @@
-From: Alexander Wetzel <alexander@wetzel-home.de>
-Date: Sun, 9 Oct 2022 18:30:40 +0200
-Subject: [PATCH] wifi: mac80211: Drop support for TX push path
-
-All drivers are now using mac80211 internal queues (iTXQs).
-Drop mac80211 internal support for the old push path.
-
-Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -4346,9 +4346,6 @@ static int ieee80211_get_txq_stats(struc
- 	struct ieee80211_sub_if_data *sdata;
- 	int ret = 0;
- 
--	if (!local->ops->wake_tx_queue)
--		return 1;
--
- 	spin_lock_bh(&local->fq.lock);
- 	rcu_read_lock();
- 
---- a/net/mac80211/debugfs.c
-+++ b/net/mac80211/debugfs.c
-@@ -663,9 +663,7 @@ void debugfs_hw_add(struct ieee80211_loc
- 	DEBUGFS_ADD_MODE(force_tx_status, 0600);
- 	DEBUGFS_ADD_MODE(aql_enable, 0600);
- 	DEBUGFS_ADD(aql_pending);
--
--	if (local->ops->wake_tx_queue)
--		DEBUGFS_ADD_MODE(aqm, 0600);
-+	DEBUGFS_ADD_MODE(aqm, 0600);
- 
- 	DEBUGFS_ADD_MODE(airtime_flags, 0600);
- 
---- a/net/mac80211/debugfs_netdev.c
-+++ b/net/mac80211/debugfs_netdev.c
-@@ -677,8 +677,7 @@ static void add_common_files(struct ieee
- 	DEBUGFS_ADD(rc_rateidx_vht_mcs_mask_5ghz);
- 	DEBUGFS_ADD(hw_queues);
- 
--	if (sdata->local->ops->wake_tx_queue &&
--	    sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&
-+	if (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&
- 	    sdata->vif.type != NL80211_IFTYPE_NAN)
- 		DEBUGFS_ADD(aqm);
- }
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -1057,10 +1057,8 @@ void ieee80211_sta_debugfs_add(struct st
- 	DEBUGFS_ADD_COUNTER(rx_fragments, deflink.rx_stats.fragments);
- 	DEBUGFS_ADD_COUNTER(tx_filtered, deflink.status_stats.filtered);
- 
--	if (local->ops->wake_tx_queue) {
--		DEBUGFS_ADD(aqm);
--		DEBUGFS_ADD(airtime);
--	}
-+	DEBUGFS_ADD(aqm);
-+	DEBUGFS_ADD(airtime);
- 
- 	if (wiphy_ext_feature_isset(local->hw.wiphy,
- 				    NL80211_EXT_FEATURE_AQL))
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -2294,7 +2294,6 @@ void ieee80211_wake_queue_by_reason(stru
- void ieee80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,
- 				    enum queue_stop_reason reason,
- 				    bool refcounted);
--void ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue);
- void ieee80211_add_pending_skb(struct ieee80211_local *local,
- 			       struct sk_buff *skb);
- void ieee80211_add_pending_skbs(struct ieee80211_local *local,
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -460,12 +460,6 @@ static void ieee80211_do_stop(struct iee
- 	if (cancel_scan)
- 		ieee80211_scan_cancel(local);
- 
--	/*
--	 * Stop TX on this interface first.
--	 */
--	if (!local->ops->wake_tx_queue && sdata->dev)
--		netif_tx_stop_all_queues(sdata->dev);
--
- 	ieee80211_roc_purge(local, sdata);
- 
- 	switch (sdata->vif.type) {
-@@ -813,13 +807,6 @@ static void ieee80211_uninit(struct net_
- 	ieee80211_teardown_sdata(IEEE80211_DEV_TO_SUB_IF(dev));
- }
- 
--static u16 ieee80211_netdev_select_queue(struct net_device *dev,
--					 struct sk_buff *skb,
--					 struct net_device *sb_dev)
--{
--	return ieee80211_select_queue(IEEE80211_DEV_TO_SUB_IF(dev), skb);
--}
--
- static void
- ieee80211_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
- {
-@@ -833,7 +820,6 @@ static const struct net_device_ops ieee8
- 	.ndo_start_xmit		= ieee80211_subif_start_xmit,
- 	.ndo_set_rx_mode	= ieee80211_set_multicast_list,
- 	.ndo_set_mac_address 	= ieee80211_change_mac,
--	.ndo_select_queue	= ieee80211_netdev_select_queue,
- 	.ndo_get_stats64	= ieee80211_get_stats64,
- };
- 
-@@ -941,7 +927,6 @@ static const struct net_device_ops ieee8
- 	.ndo_start_xmit		= ieee80211_subif_start_xmit_8023,
- 	.ndo_set_rx_mode	= ieee80211_set_multicast_list,
- 	.ndo_set_mac_address	= ieee80211_change_mac,
--	.ndo_select_queue	= ieee80211_netdev_select_queue,
- 	.ndo_get_stats64	= ieee80211_get_stats64,
- 	.ndo_fill_forward_path	= ieee80211_netdev_fill_forward_path,
- };
-@@ -1443,35 +1428,6 @@ int ieee80211_do_open(struct wireless_de
- 
- 	ieee80211_recalc_ps(local);
- 
--	if (sdata->vif.type == NL80211_IFTYPE_MONITOR ||
--	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
--	    local->ops->wake_tx_queue) {
--		/* XXX: for AP_VLAN, actually track AP queues */
--		if (dev)
--			netif_tx_start_all_queues(dev);
--	} else if (dev) {
--		unsigned long flags;
--		int n_acs = IEEE80211_NUM_ACS;
--		int ac;
--
--		if (local->hw.queues < IEEE80211_NUM_ACS)
--			n_acs = 1;
--
--		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
--		if (sdata->vif.cab_queue == IEEE80211_INVAL_HW_QUEUE ||
--		    (local->queue_stop_reasons[sdata->vif.cab_queue] == 0 &&
--		     skb_queue_empty(&local->pending[sdata->vif.cab_queue]))) {
--			for (ac = 0; ac < n_acs; ac++) {
--				int ac_queue = sdata->vif.hw_queue[ac];
--
--				if (local->queue_stop_reasons[ac_queue] == 0 &&
--				    skb_queue_empty(&local->pending[ac_queue]))
--					netif_start_subqueue(dev, ac);
--			}
--		}
--		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
--	}
--
- 	set_bit(SDATA_STATE_RUNNING, &sdata->state);
- 
- 	return 0;
-@@ -1501,17 +1457,12 @@ static void ieee80211_if_setup(struct ne
- {
- 	ether_setup(dev);
- 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
-+	dev->priv_flags |= IFF_NO_QUEUE;
- 	dev->netdev_ops = &ieee80211_dataif_ops;
- 	dev->needs_free_netdev = true;
- 	dev->priv_destructor = ieee80211_if_free;
- }
- 
--static void ieee80211_if_setup_no_queue(struct net_device *dev)
--{
--	ieee80211_if_setup(dev);
--	dev->priv_flags |= IFF_NO_QUEUE;
--}
--
- static void ieee80211_iface_process_skb(struct ieee80211_local *local,
- 					struct ieee80211_sub_if_data *sdata,
- 					struct sk_buff *skb)
-@@ -2096,9 +2047,7 @@ int ieee80211_if_add(struct ieee80211_lo
- 	struct net_device *ndev = NULL;
- 	struct ieee80211_sub_if_data *sdata = NULL;
- 	struct txq_info *txqi;
--	void (*if_setup)(struct net_device *dev);
- 	int ret, i;
--	int txqs = 1;
- 
- 	ASSERT_RTNL();
- 
-@@ -2121,30 +2070,18 @@ int ieee80211_if_add(struct ieee80211_lo
- 				 sizeof(void *));
- 		int txq_size = 0;
- 
--		if (local->ops->wake_tx_queue &&
--		    type != NL80211_IFTYPE_AP_VLAN &&
-+		if (type != NL80211_IFTYPE_AP_VLAN &&
- 		    (type != NL80211_IFTYPE_MONITOR ||
- 		     (params->flags & MONITOR_FLAG_ACTIVE)))
- 			txq_size += sizeof(struct txq_info) +
- 				    local->hw.txq_data_size;
- 
--		if (local->ops->wake_tx_queue) {
--			if_setup = ieee80211_if_setup_no_queue;
--		} else {
--			if_setup = ieee80211_if_setup;
--			if (local->hw.queues >= IEEE80211_NUM_ACS)
--				txqs = IEEE80211_NUM_ACS;
--		}
--
- 		ndev = alloc_netdev_mqs(size + txq_size,
- 					name, name_assign_type,
--					if_setup, txqs, 1);
-+					ieee80211_if_setup, 1, 1);
- 		if (!ndev)
- 			return -ENOMEM;
- 
--		if (!local->ops->wake_tx_queue && local->hw.wiphy->tx_queue_len)
--			ndev->tx_queue_len = local->hw.wiphy->tx_queue_len;
--
- 		dev_net_set(ndev, wiphy_net(local->hw.wiphy));
- 
- 		ndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -630,7 +630,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 
- 	if (WARN_ON(!ops->tx || !ops->start || !ops->stop || !ops->config ||
- 		    !ops->add_interface || !ops->remove_interface ||
--		    !ops->configure_filter))
-+		    !ops->configure_filter || !ops->wake_tx_queue))
- 		return NULL;
- 
- 	if (WARN_ON(ops->sta_state && (ops->sta_add || ops->sta_remove)))
-@@ -719,9 +719,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 	if (!ops->set_key)
- 		wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
- 
--	if (ops->wake_tx_queue)
--		wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_TXQS);
--
-+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_TXQS);
- 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_RRM);
- 
- 	wiphy->bss_priv_size = sizeof(struct ieee80211_bss);
-@@ -834,10 +832,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 		atomic_set(&local->agg_queue_stop[i], 0);
- 	}
- 	tasklet_setup(&local->tx_pending_tasklet, ieee80211_tx_pending);
--
--	if (ops->wake_tx_queue)
--		tasklet_setup(&local->wake_txqs_tasklet, ieee80211_wake_txqs);
--
-+	tasklet_setup(&local->wake_txqs_tasklet, ieee80211_wake_txqs);
- 	tasklet_setup(&local->tasklet, ieee80211_tasklet_handler);
- 
- 	skb_queue_head_init(&local->skb_queue);
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -1571,9 +1571,6 @@ static void sta_ps_start(struct sta_info
- 
- 	ieee80211_clear_fast_xmit(sta);
- 
--	if (!sta->sta.txq[0])
--		return;
--
- 	for (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {
- 		struct ieee80211_txq *txq = sta->sta.txq[tid];
- 		struct txq_info *txqi = to_txq_info(txq);
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -140,17 +140,15 @@ static void __cleanup_single_sta(struct
- 		atomic_dec(&ps->num_sta_ps);
- 	}
- 
--	if (sta->sta.txq[0]) {
--		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
--			struct txq_info *txqi;
-+	for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
-+		struct txq_info *txqi;
- 
--			if (!sta->sta.txq[i])
--				continue;
-+		if (!sta->sta.txq[i])
-+			continue;
- 
--			txqi = to_txq_info(sta->sta.txq[i]);
-+		txqi = to_txq_info(sta->sta.txq[i]);
- 
--			ieee80211_txq_purge(local, txqi);
--		}
-+		ieee80211_txq_purge(local, txqi);
- 	}
- 
- 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-@@ -425,8 +423,7 @@ void sta_info_free(struct ieee80211_loca
- 
- 	sta_dbg(sta->sdata, "Destroyed STA %pM\n", sta->sta.addr);
- 
--	if (sta->sta.txq[0])
--		kfree(to_txq_info(sta->sta.txq[0]));
-+	kfree(to_txq_info(sta->sta.txq[0]));
- 	kfree(rcu_dereference_raw(sta->sta.rates));
- #ifdef CPTCFG_MAC80211_MESH
- 	kfree(sta->mesh);
-@@ -527,6 +524,8 @@ __sta_info_alloc(struct ieee80211_sub_if
- 	struct ieee80211_local *local = sdata->local;
- 	struct ieee80211_hw *hw = &local->hw;
- 	struct sta_info *sta;
-+	void *txq_data;
-+	int size;
- 	int i;
- 
- 	sta = kzalloc(sizeof(*sta) + hw->sta_data_size, gfp);
-@@ -597,21 +596,18 @@ __sta_info_alloc(struct ieee80211_sub_if
- 
- 	sta->last_connected = ktime_get_seconds();
- 
--	if (local->ops->wake_tx_queue) {
--		void *txq_data;
--		int size = sizeof(struct txq_info) +
--			   ALIGN(hw->txq_data_size, sizeof(void *));
-+	size = sizeof(struct txq_info) +
-+	       ALIGN(hw->txq_data_size, sizeof(void *));
- 
--		txq_data = kcalloc(ARRAY_SIZE(sta->sta.txq), size, gfp);
--		if (!txq_data)
--			goto free;
-+	txq_data = kcalloc(ARRAY_SIZE(sta->sta.txq), size, gfp);
-+	if (!txq_data)
-+		goto free;
- 
--		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
--			struct txq_info *txq = txq_data + i * size;
-+	for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
-+		struct txq_info *txq = txq_data + i * size;
- 
--			/* might not do anything for the bufferable MMPDU TXQ */
--			ieee80211_txq_init(sdata, sta, txq, i);
--		}
-+		/* might not do anything for the (bufferable) MMPDU TXQ */
-+		ieee80211_txq_init(sdata, sta, txq, i);
- 	}
- 
- 	if (sta_prepare_rate_control(local, sta, gfp))
-@@ -685,8 +681,7 @@ __sta_info_alloc(struct ieee80211_sub_if
- 	return sta;
- 
- free_txq:
--	if (sta->sta.txq[0])
--		kfree(to_txq_info(sta->sta.txq[0]));
-+	kfree(to_txq_info(sta->sta.txq[0]));
- free:
- 	sta_info_free_link(&sta->deflink);
- #ifdef CPTCFG_MAC80211_MESH
-@@ -1960,9 +1955,6 @@ ieee80211_sta_ps_deliver_response(struct
- 		 * TIM recalculation.
- 		 */
- 
--		if (!sta->sta.txq[0])
--			return;
--
- 		for (tid = 0; tid < ARRAY_SIZE(sta->sta.txq); tid++) {
- 			if (!sta->sta.txq[tid] ||
- 			    !(driver_release_tids & BIT(tid)) ||
-@@ -2447,7 +2439,7 @@ static void sta_set_tidstats(struct sta_
- 		tidstats->tx_msdu_failed = sta->deflink.status_stats.msdu_failed[tid];
- 	}
- 
--	if (local->ops->wake_tx_queue && tid < IEEE80211_NUM_TIDS) {
-+	if (tid < IEEE80211_NUM_TIDS) {
- 		spin_lock_bh(&local->fq.lock);
- 		rcu_read_lock();
- 
-@@ -2775,9 +2767,6 @@ unsigned long ieee80211_sta_last_active(
- 
- static void sta_update_codel_params(struct sta_info *sta, u32 thr)
- {
--	if (!sta->sdata->local->ops->wake_tx_queue)
--		return;
--
- 	if (thr && thr < STA_SLOW_THRESHOLD * sta->local->num_sta) {
- 		sta->cparams.target = MS2TIME(50);
- 		sta->cparams.interval = MS2TIME(300);
---- a/net/mac80211/tdls.c
-+++ b/net/mac80211/tdls.c
-@@ -1016,7 +1016,6 @@ ieee80211_tdls_prep_mgmt_packet(struct w
- 		skb->priority = 256 + 5;
- 		break;
- 	}
--	skb_set_queue_mapping(skb, ieee80211_select_queue(sdata, skb));
- 
- 	/*
- 	 * Set the WLAN_TDLS_TEARDOWN flag to indicate a teardown in progress.
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1604,9 +1604,6 @@ int ieee80211_txq_setup_flows(struct iee
- 	bool supp_vht = false;
- 	enum nl80211_band band;
- 
--	if (!local->ops->wake_tx_queue)
--		return 0;
--
- 	ret = fq_init(fq, 4096);
- 	if (ret)
- 		return ret;
-@@ -1654,9 +1651,6 @@ void ieee80211_txq_teardown_flows(struct
- {
- 	struct fq *fq = &local->fq;
- 
--	if (!local->ops->wake_tx_queue)
--		return;
--
- 	kfree(local->cvars);
- 	local->cvars = NULL;
- 
-@@ -1673,8 +1667,7 @@ static bool ieee80211_queue_skb(struct i
- 	struct ieee80211_vif *vif;
- 	struct txq_info *txqi;
- 
--	if (!local->ops->wake_tx_queue ||
--	    sdata->vif.type == NL80211_IFTYPE_MONITOR)
-+	if (sdata->vif.type == NL80211_IFTYPE_MONITOR)
- 		return false;
- 
- 	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
-@@ -4197,12 +4190,7 @@ void __ieee80211_subif_start_xmit(struct
- 	if (IS_ERR(sta))
- 		sta = NULL;
- 
--	if (local->ops->wake_tx_queue) {
--		u16 queue = __ieee80211_select_queue(sdata, sta, skb);
--		skb_set_queue_mapping(skb, queue);
--		skb_get_hash(skb);
--	}
--
-+	skb_set_queue_mapping(skb, ieee80211_select_queue(sdata, sta, skb));
- 	ieee80211_aggr_check(sdata, sta, skb);
- 
- 	sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
-@@ -4513,11 +4501,7 @@ static void ieee80211_8023_xmit(struct i
- 	struct tid_ampdu_tx *tid_tx;
- 	u8 tid;
- 
--	if (local->ops->wake_tx_queue) {
--		u16 queue = __ieee80211_select_queue(sdata, sta, skb);
--		skb_set_queue_mapping(skb, queue);
--		skb_get_hash(skb);
--	}
-+	skb_set_queue_mapping(skb, ieee80211_select_queue(sdata, sta, skb));
- 
- 	if (unlikely(test_bit(SCAN_SW_SCANNING, &local->scanning)) &&
- 	    test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))
-@@ -4771,9 +4755,6 @@ void ieee80211_tx_pending(struct tasklet
- 			if (!txok)
- 				break;
- 		}
--
--		if (skb_queue_empty(&local->pending[i]))
--			ieee80211_propagate_queue_wake(local, i);
- 	}
- 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
- 
-@@ -5966,10 +5947,9 @@ int ieee80211_tx_control_port(struct wip
- 	}
- 
- 	if (!IS_ERR(sta)) {
--		u16 queue = __ieee80211_select_queue(sdata, sta, skb);
-+		u16 queue = ieee80211_select_queue(sdata, sta, skb);
- 
- 		skb_set_queue_mapping(skb, queue);
--		skb_get_hash(skb);
- 
- 		/*
- 		 * for MLO STA, the SA should be the AP MLD address, but
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -444,39 +444,6 @@ void ieee80211_wake_txqs(struct tasklet_
- 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
- }
- 
--void ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue)
--{
--	struct ieee80211_sub_if_data *sdata;
--	int n_acs = IEEE80211_NUM_ACS;
--
--	if (local->ops->wake_tx_queue)
--		return;
--
--	if (local->hw.queues < IEEE80211_NUM_ACS)
--		n_acs = 1;
--
--	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
--		int ac;
--
--		if (!sdata->dev)
--			continue;
--
--		if (sdata->vif.cab_queue != IEEE80211_INVAL_HW_QUEUE &&
--		    local->queue_stop_reasons[sdata->vif.cab_queue] != 0)
--			continue;
--
--		for (ac = 0; ac < n_acs; ac++) {
--			int ac_queue = sdata->vif.hw_queue[ac];
--
--			if (ac_queue == queue ||
--			    (sdata->vif.cab_queue == queue &&
--			     local->queue_stop_reasons[ac_queue] == 0 &&
--			     skb_queue_empty(&local->pending[ac_queue])))
--				netif_wake_subqueue(sdata->dev, ac);
--		}
--	}
--}
--
- static void __ieee80211_wake_queue(struct ieee80211_hw *hw, int queue,
- 				   enum queue_stop_reason reason,
- 				   bool refcounted,
-@@ -507,11 +474,7 @@ static void __ieee80211_wake_queue(struc
- 		/* someone still has this queue stopped */
- 		return;
- 
--	if (skb_queue_empty(&local->pending[queue])) {
--		rcu_read_lock();
--		ieee80211_propagate_queue_wake(local, queue);
--		rcu_read_unlock();
--	} else
-+	if (!skb_queue_empty(&local->pending[queue]))
- 		tasklet_schedule(&local->tx_pending_tasklet);
- 
- 	/*
-@@ -521,12 +484,10 @@ static void __ieee80211_wake_queue(struc
- 	 * release someone's lock, but it is fine because all the callers of
- 	 * __ieee80211_wake_queue call it right before releasing the lock.
- 	 */
--	if (local->ops->wake_tx_queue) {
--		if (reason == IEEE80211_QUEUE_STOP_REASON_DRIVER)
--			tasklet_schedule(&local->wake_txqs_tasklet);
--		else
--			_ieee80211_wake_txqs(local, flags);
--	}
-+	if (reason == IEEE80211_QUEUE_STOP_REASON_DRIVER)
-+		tasklet_schedule(&local->wake_txqs_tasklet);
-+	else
-+		_ieee80211_wake_txqs(local, flags);
- }
- 
- void ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,
-@@ -554,8 +515,6 @@ static void __ieee80211_stop_queue(struc
- 				   bool refcounted)
- {
- 	struct ieee80211_local *local = hw_to_local(hw);
--	struct ieee80211_sub_if_data *sdata;
--	int n_acs = IEEE80211_NUM_ACS;
- 
- 	trace_stop_queue(local, queue, reason);
- 
-@@ -567,27 +526,7 @@ static void __ieee80211_stop_queue(struc
- 	else
- 		local->q_stop_reasons[queue][reason]++;
- 
--	if (__test_and_set_bit(reason, &local->queue_stop_reasons[queue]))
--		return;
--
--	if (local->hw.queues < IEEE80211_NUM_ACS)
--		n_acs = 1;
--
--	rcu_read_lock();
--	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
--		int ac;
--
--		if (!sdata->dev)
--			continue;
--
--		for (ac = 0; ac < n_acs; ac++) {
--			if (!local->ops->wake_tx_queue &&
--			    (sdata->vif.hw_queue[ac] == queue ||
--			     sdata->vif.cab_queue == queue))
--				netif_stop_subqueue(sdata->dev, ac);
--		}
--	}
--	rcu_read_unlock();
-+	set_bit(reason, &local->queue_stop_reasons[queue]);
- }
- 
- void ieee80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,
---- a/net/mac80211/wme.c
-+++ b/net/mac80211/wme.c
-@@ -122,6 +122,9 @@ u16 ieee80211_select_queue_80211(struct
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
- 	u8 *p;
- 
-+	/* Ensure hash is set prior to potential SW encryption */
-+	skb_get_hash(skb);
-+
- 	if ((info->control.flags & IEEE80211_TX_CTRL_DONT_REORDER) ||
- 	    local->hw.queues < IEEE80211_NUM_ACS)
- 		return 0;
-@@ -141,13 +144,16 @@ u16 ieee80211_select_queue_80211(struct
- 	return ieee80211_downgrade_queue(sdata, NULL, skb);
- }
- 
--u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
--			     struct sta_info *sta, struct sk_buff *skb)
-+u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
-+			   struct sta_info *sta, struct sk_buff *skb)
- {
- 	const struct ethhdr *eth = (void *)skb->data;
- 	struct mac80211_qos_map *qos_map;
- 	bool qos;
- 
-+	/* Ensure hash is set prior to potential SW encryption */
-+	skb_get_hash(skb);
-+
- 	/* all mesh/ocb stations are required to support WME */
- 	if ((sdata->vif.type == NL80211_IFTYPE_MESH_POINT &&
- 	    !is_multicast_ether_addr(eth->h_dest)) ||
-@@ -178,59 +184,6 @@ u16 __ieee80211_select_queue(struct ieee
- 	return ieee80211_downgrade_queue(sdata, sta, skb);
- }
- 
--
--/* Indicate which queue to use. */
--u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
--			   struct sk_buff *skb)
--{
--	struct ieee80211_local *local = sdata->local;
--	struct sta_info *sta = NULL;
--	const u8 *ra = NULL;
--	u16 ret;
--
--	/* when using iTXQ, we can do this later */
--	if (local->ops->wake_tx_queue)
--		return 0;
--
--	if (local->hw.queues < IEEE80211_NUM_ACS || skb->len < 6) {
--		skb->priority = 0; /* required for correct WPA/11i MIC */
--		return 0;
--	}
--
--	rcu_read_lock();
--	switch (sdata->vif.type) {
--	case NL80211_IFTYPE_AP_VLAN:
--		sta = rcu_dereference(sdata->u.vlan.sta);
--		if (sta)
--			break;
--		fallthrough;
--	case NL80211_IFTYPE_AP:
--		ra = skb->data;
--		break;
--	case NL80211_IFTYPE_STATION:
--		/* might be a TDLS station */
--		sta = sta_info_get(sdata, skb->data);
--		if (sta)
--			break;
--
--		ra = sdata->deflink.u.mgd.bssid;
--		break;
--	case NL80211_IFTYPE_ADHOC:
--		ra = skb->data;
--		break;
--	default:
--		break;
--	}
--
--	if (!sta && ra && !is_multicast_ether_addr(ra))
--		sta = sta_info_get(sdata, ra);
--
--	ret = __ieee80211_select_queue(sdata, sta, skb);
--
--	rcu_read_unlock();
--	return ret;
--}
--
- /**
-  * ieee80211_set_qos_hdr - Fill in the QoS header if there is one.
-  *
---- a/net/mac80211/wme.h
-+++ b/net/mac80211/wme.h
-@@ -13,10 +13,8 @@
- u16 ieee80211_select_queue_80211(struct ieee80211_sub_if_data *sdata,
- 				 struct sk_buff *skb,
- 				 struct ieee80211_hdr *hdr);
--u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
--			     struct sta_info *sta, struct sk_buff *skb);
- u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
--			   struct sk_buff *skb);
-+			   struct sta_info *sta, struct sk_buff *skb);
- void ieee80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,
- 			   struct sk_buff *skb);
- 
diff --git a/package/kernel/mac80211/patches/subsys/306-04-v6.2-wifi-realtek-remove-duplicated-wake_tx_queue.patch b/package/kernel/mac80211/patches/subsys/306-04-v6.2-wifi-realtek-remove-duplicated-wake_tx_queue.patch
deleted file mode 100644
index f0dfc75a..00000000
--- a/package/kernel/mac80211/patches/subsys/306-04-v6.2-wifi-realtek-remove-duplicated-wake_tx_queue.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Mon, 10 Oct 2022 19:17:46 +0200
-Subject: [PATCH] wifi: realtek: remove duplicated wake_tx_queue
-
-By accident, the previous patch duplicated the initialization
-of the wake_tx_queue callback. Fix that by removing the new
-initializations.
-
-Fixes: a790cc3a4fad ("wifi: mac80211: add wake_tx_queue callback to drivers")
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/drivers/net/wireless/realtek/rtw88/mac80211.c
-+++ b/drivers/net/wireless/realtek/rtw88/mac80211.c
-@@ -896,7 +896,6 @@ static void rtw_ops_sta_rc_update(struct
- 
- const struct ieee80211_ops rtw_ops = {
- 	.tx			= rtw_ops_tx,
--	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.wake_tx_queue		= rtw_ops_wake_tx_queue,
- 	.start			= rtw_ops_start,
- 	.stop			= rtw_ops_stop,
---- a/drivers/net/wireless/realtek/rtw89/mac80211.c
-+++ b/drivers/net/wireless/realtek/rtw89/mac80211.c
-@@ -918,7 +918,6 @@ static int rtw89_ops_set_tid_config(stru
- 
- const struct ieee80211_ops rtw89_ops = {
- 	.tx			= rtw89_ops_tx,
--	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
- 	.wake_tx_queue		= rtw89_ops_wake_tx_queue,
- 	.start			= rtw89_ops_start,
- 	.stop			= rtw89_ops_stop,
diff --git a/package/kernel/mac80211/patches/subsys/310-v6.2-mac80211-add-support-for-restricting-netdev-features.patch b/package/kernel/mac80211/patches/subsys/310-v6.2-mac80211-add-support-for-restricting-netdev-features.patch
deleted file mode 100644
index 0a93fafb..00000000
--- a/package/kernel/mac80211/patches/subsys/310-v6.2-mac80211-add-support-for-restricting-netdev-features.patch
+++ /dev/null
@@ -1,506 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 9 Oct 2022 20:15:46 +0200
-Subject: [PATCH] mac80211: add support for restricting netdev features per vif
-
-This can be used to selectively disable feature flags for checksum offload,
-scatter/gather or GSO by changing vif->netdev_features.
-Removing features from vif->netdev_features does not affect the netdev
-features themselves, but instead fixes up skbs in the tx path so that the
-offloads are not needed in the driver.
-
-Aside from making it easier to deal with vif type based hardware limitations,
-this also makes it possible to optimize performance on hardware without native
-GSO support by declaring GSO support in hw->netdev_features and removing it
-from vif->netdev_features. This allows mac80211 to handle GSO segmentation
-after the sta lookup, but before itxq enqueue, thus reducing the number of
-unnecessary sta lookups, as well as some other per-packet processing.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/fq_impl.h
-+++ b/include/net/fq_impl.h
-@@ -200,6 +200,7 @@ static void fq_tin_enqueue(struct fq *fq
- 			   fq_skb_free_t free_func)
- {
- 	struct fq_flow *flow;
-+	struct sk_buff *next;
- 	bool oom;
- 
- 	lockdep_assert_held(&fq->lock);
-@@ -214,11 +215,15 @@ static void fq_tin_enqueue(struct fq *fq
- 	}
- 
- 	flow->tin = tin;
--	flow->backlog += skb->len;
--	tin->backlog_bytes += skb->len;
--	tin->backlog_packets++;
--	fq->memory_usage += skb->truesize;
--	fq->backlog++;
-+	skb_list_walk_safe(skb, skb, next) {
-+		skb_mark_not_on_list(skb);
-+		flow->backlog += skb->len;
-+		tin->backlog_bytes += skb->len;
-+		tin->backlog_packets++;
-+		fq->memory_usage += skb->truesize;
-+		fq->backlog++;
-+		__skb_queue_tail(&flow->queue, skb);
-+	}
- 
- 	if (list_empty(&flow->flowchain)) {
- 		flow->deficit = fq->quantum;
-@@ -226,7 +231,6 @@ static void fq_tin_enqueue(struct fq *fq
- 			      &tin->new_flows);
- 	}
- 
--	__skb_queue_tail(&flow->queue, skb);
- 	oom = (fq->memory_usage > fq->memory_limit);
- 	while (fq->backlog > fq->limit || oom) {
- 		flow = fq_find_fattest_flow(fq);
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1818,6 +1818,10 @@ struct ieee80211_vif_cfg {
-  * @addr: address of this interface
-  * @p2p: indicates whether this AP or STA interface is a p2p
-  *	interface, i.e. a GO or p2p-sta respectively
-+ * @netdev_features: tx netdev features supported by the hardware for this
-+ *	vif. mac80211 initializes this to hw->netdev_features, and the driver
-+ *	can mask out specific tx features. mac80211 will handle software fixup
-+ *	for masked offloads (GSO, CSUM)
-  * @driver_flags: flags/capabilities the driver has for this interface,
-  *	these need to be set (or cleared) when the interface is added
-  *	or, if supported by the driver, the interface type is changed
-@@ -1857,6 +1861,7 @@ struct ieee80211_vif {
- 
- 	struct ieee80211_txq *txq;
- 
-+	netdev_features_t netdev_features;
- 	u32 driver_flags;
- 	u32 offload_flags;
- 
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -2181,6 +2181,7 @@ int ieee80211_if_add(struct ieee80211_lo
- 		ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
- 		ndev->hw_features |= ndev->features &
- 					MAC80211_SUPPORTED_FEATURES_TX;
-+		sdata->vif.netdev_features = local->hw.netdev_features;
- 
- 		netdev_set_default_ethtool_ops(ndev, &ieee80211_ethtool_ops);
- 
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1360,7 +1360,11 @@ static struct txq_info *ieee80211_get_tx
- 
- static void ieee80211_set_skb_enqueue_time(struct sk_buff *skb)
- {
--	IEEE80211_SKB_CB(skb)->control.enqueue_time = codel_get_time();
-+	struct sk_buff *next;
-+	codel_time_t now = codel_get_time();
-+
-+	skb_list_walk_safe(skb, skb, next)
-+		IEEE80211_SKB_CB(skb)->control.enqueue_time = now;
- }
- 
- static u32 codel_skb_len_func(const struct sk_buff *skb)
-@@ -3583,55 +3587,79 @@ ieee80211_xmit_fast_finish(struct ieee80
- 	return TX_CONTINUE;
- }
- 
--static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
--				struct sta_info *sta,
--				struct ieee80211_fast_tx *fast_tx,
--				struct sk_buff *skb)
-+static netdev_features_t
-+ieee80211_sdata_netdev_features(struct ieee80211_sub_if_data *sdata)
- {
--	struct ieee80211_local *local = sdata->local;
--	u16 ethertype = (skb->data[12] << 8) | skb->data[13];
--	int extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);
--	int hw_headroom = sdata->local->hw.extra_tx_headroom;
--	struct ethhdr eth;
--	struct ieee80211_tx_info *info;
--	struct ieee80211_hdr *hdr = (void *)fast_tx->hdr;
--	struct ieee80211_tx_data tx;
--	ieee80211_tx_result r;
--	struct tid_ampdu_tx *tid_tx = NULL;
--	u8 tid = IEEE80211_NUM_TIDS;
-+	if (sdata->vif.type != NL80211_IFTYPE_AP_VLAN)
-+		return sdata->vif.netdev_features;
- 
--	/* control port protocol needs a lot of special handling */
--	if (cpu_to_be16(ethertype) == sdata->control_port_protocol)
--		return false;
-+	if (!sdata->bss)
-+		return 0;
- 
--	/* only RFC 1042 SNAP */
--	if (ethertype < ETH_P_802_3_MIN)
--		return false;
-+	sdata = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);
-+	return sdata->vif.netdev_features;
-+}
- 
--	/* don't handle TX status request here either */
--	if (skb->sk && skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)
--		return false;
-+static struct sk_buff *
-+ieee80211_tx_skb_fixup(struct sk_buff *skb, netdev_features_t features)
-+{
-+	if (skb_is_gso(skb)) {
-+		struct sk_buff *segs;
- 
--	if (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {
--		tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
--		tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
--		if (tid_tx) {
--			if (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))
--				return false;
--			if (tid_tx->timeout)
--				tid_tx->last_tx = jiffies;
--		}
-+		segs = skb_gso_segment(skb, features);
-+		if (!segs)
-+			return skb;
-+		if (IS_ERR(segs))
-+			goto free;
-+
-+		consume_skb(skb);
-+		return segs;
- 	}
- 
--	/* after this point (skb is modified) we cannot return false */
-+	if (skb_needs_linearize(skb, features) && __skb_linearize(skb))
-+		goto free;
-+
-+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-+		int ofs = skb_checksum_start_offset(skb);
-+
-+		if (skb->encapsulation)
-+			skb_set_inner_transport_header(skb, ofs);
-+		else
-+			skb_set_transport_header(skb, ofs);
-+
-+		if (skb_csum_hwoffload_help(skb, features))
-+			goto free;
-+	}
-+
-+	skb_mark_not_on_list(skb);
-+	return skb;
-+
-+free:
-+	kfree_skb(skb);
-+	return NULL;
-+}
-+
-+static void __ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
-+				  struct sta_info *sta,
-+				  struct ieee80211_fast_tx *fast_tx,
-+				  struct sk_buff *skb, u8 tid, bool ampdu)
-+{
-+	struct ieee80211_local *local = sdata->local;
-+	struct ieee80211_hdr *hdr = (void *)fast_tx->hdr;
-+	struct ieee80211_tx_info *info;
-+	struct ieee80211_tx_data tx;
-+	ieee80211_tx_result r;
-+	int hw_headroom = sdata->local->hw.extra_tx_headroom;
-+	int extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);
-+	struct ethhdr eth;
- 
- 	skb = skb_share_check(skb, GFP_ATOMIC);
- 	if (unlikely(!skb))
--		return true;
-+		return;
- 
- 	if ((hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) &&
- 	    ieee80211_amsdu_aggregate(sdata, sta, fast_tx, skb))
--		return true;
-+		return;
- 
- 	/* will not be crypto-handled beyond what we do here, so use false
- 	 * as the may-encrypt argument for the resize to not account for
-@@ -3640,10 +3668,8 @@ static bool ieee80211_xmit_fast(struct i
- 	if (unlikely(ieee80211_skb_resize(sdata, skb,
- 					  max_t(int, extra_head + hw_headroom -
- 						     skb_headroom(skb), 0),
--					  ENCRYPT_NO))) {
--		kfree_skb(skb);
--		return true;
--	}
-+					  ENCRYPT_NO)))
-+		goto free;
- 
- 	memcpy(&eth, skb->data, ETH_HLEN - 2);
- 	hdr = skb_push(skb, extra_head);
-@@ -3657,7 +3683,7 @@ static bool ieee80211_xmit_fast(struct i
- 	info->control.vif = &sdata->vif;
- 	info->flags = IEEE80211_TX_CTL_FIRST_FRAGMENT |
- 		      IEEE80211_TX_CTL_DONTFRAG |
--		      (tid_tx ? IEEE80211_TX_CTL_AMPDU : 0);
-+		      (ampdu ? IEEE80211_TX_CTL_AMPDU : 0);
- 	info->control.flags = IEEE80211_TX_CTRL_FAST_XMIT |
- 			      u32_encode_bits(IEEE80211_LINK_UNSPECIFIED,
- 					      IEEE80211_TX_CTRL_MLO_LINK);
-@@ -3681,16 +3707,14 @@ static bool ieee80211_xmit_fast(struct i
- 	tx.key = fast_tx->key;
- 
- 	if (ieee80211_queue_skb(local, sdata, sta, skb))
--		return true;
-+		return;
- 
- 	tx.skb = skb;
- 	r = ieee80211_xmit_fast_finish(sdata, sta, fast_tx->pn_offs,
- 				       fast_tx->key, &tx);
- 	tx.skb = NULL;
--	if (r == TX_DROP) {
--		kfree_skb(skb);
--		return true;
--	}
-+	if (r == TX_DROP)
-+		goto free;
- 
- 	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
- 		sdata = container_of(sdata->bss,
-@@ -3698,6 +3722,56 @@ static bool ieee80211_xmit_fast(struct i
- 
- 	__skb_queue_tail(&tx.skbs, skb);
- 	ieee80211_tx_frags(local, &sdata->vif, sta, &tx.skbs, false);
-+	return;
-+
-+free:
-+	kfree_skb(skb);
-+}
-+
-+static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
-+				struct sta_info *sta,
-+				struct ieee80211_fast_tx *fast_tx,
-+				struct sk_buff *skb)
-+{
-+	u16 ethertype = (skb->data[12] << 8) | skb->data[13];
-+	struct ieee80211_hdr *hdr = (void *)fast_tx->hdr;
-+	struct tid_ampdu_tx *tid_tx = NULL;
-+	struct sk_buff *next;
-+	u8 tid = IEEE80211_NUM_TIDS;
-+
-+	/* control port protocol needs a lot of special handling */
-+	if (cpu_to_be16(ethertype) == sdata->control_port_protocol)
-+		return false;
-+
-+	/* only RFC 1042 SNAP */
-+	if (ethertype < ETH_P_802_3_MIN)
-+		return false;
-+
-+	/* don't handle TX status request here either */
-+	if (skb->sk && skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)
-+		return false;
-+
-+	if (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {
-+		tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
-+		tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
-+		if (tid_tx) {
-+			if (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))
-+				return false;
-+			if (tid_tx->timeout)
-+				tid_tx->last_tx = jiffies;
-+		}
-+	}
-+
-+	/* after this point (skb is modified) we cannot return false */
-+	skb = ieee80211_tx_skb_fixup(skb, ieee80211_sdata_netdev_features(sdata));
-+	if (!skb)
-+		return true;
-+
-+	skb_list_walk_safe(skb, skb, next) {
-+		skb_mark_not_on_list(skb);
-+		__ieee80211_xmit_fast(sdata, sta, fast_tx, skb, tid, tid_tx);
-+	}
-+
- 	return true;
- }
- 
-@@ -4205,31 +4279,14 @@ void __ieee80211_subif_start_xmit(struct
- 			goto out;
- 	}
- 
--	if (skb_is_gso(skb)) {
--		struct sk_buff *segs;
--
--		segs = skb_gso_segment(skb, 0);
--		if (IS_ERR(segs)) {
--			goto out_free;
--		} else if (segs) {
--			consume_skb(skb);
--			skb = segs;
--		}
--	} else {
--		/* we cannot process non-linear frames on this path */
--		if (skb_linearize(skb))
--			goto out_free;
--
--		/* the frame could be fragmented, software-encrypted, and other
--		 * things so we cannot really handle checksum offload with it -
--		 * fix it up in software before we handle anything else.
--		 */
--		if (skb->ip_summed == CHECKSUM_PARTIAL) {
--			skb_set_transport_header(skb,
--						 skb_checksum_start_offset(skb));
--			if (skb_checksum_help(skb))
--				goto out_free;
--		}
-+	/* the frame could be fragmented, software-encrypted, and other
-+	 * things so we cannot really handle checksum or GSO offload.
-+	 * fix it up in software before we handle anything else.
-+	 */
-+	skb = ieee80211_tx_skb_fixup(skb, 0);
-+	if (!skb) {
-+		len = 0;
-+		goto out;
- 	}
- 
- 	skb_list_walk_safe(skb, skb, next) {
-@@ -4447,9 +4504,11 @@ normal:
- 	return NETDEV_TX_OK;
- }
- 
--static bool ieee80211_tx_8023(struct ieee80211_sub_if_data *sdata,
--			      struct sk_buff *skb, struct sta_info *sta,
--			      bool txpending)
-+
-+
-+static bool __ieee80211_tx_8023(struct ieee80211_sub_if_data *sdata,
-+				struct sk_buff *skb, struct sta_info *sta,
-+				bool txpending)
- {
- 	struct ieee80211_local *local = sdata->local;
- 	struct ieee80211_tx_control control = {};
-@@ -4458,14 +4517,6 @@ static bool ieee80211_tx_8023(struct iee
- 	unsigned long flags;
- 	int q = info->hw_queue;
- 
--	if (sta)
--		sk_pacing_shift_update(skb->sk, local->hw.tx_sk_pacing_shift);
--
--	ieee80211_tpt_led_trig_tx(local, skb->len);
--
--	if (ieee80211_queue_skb(local, sdata, sta, skb))
--		return true;
--
- 	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
- 
- 	if (local->queue_stop_reasons[q] ||
-@@ -4492,6 +4543,26 @@ static bool ieee80211_tx_8023(struct iee
- 	return true;
- }
- 
-+static bool ieee80211_tx_8023(struct ieee80211_sub_if_data *sdata,
-+			      struct sk_buff *skb, struct sta_info *sta,
-+			      bool txpending)
-+{
-+	struct ieee80211_local *local = sdata->local;
-+	struct sk_buff *next;
-+	bool ret = true;
-+
-+	if (ieee80211_queue_skb(local, sdata, sta, skb))
-+		return true;
-+
-+	skb_list_walk_safe(skb, skb, next) {
-+		skb_mark_not_on_list(skb);
-+		if (!__ieee80211_tx_8023(sdata, skb, sta, txpending))
-+			ret = false;
-+	}
-+
-+	return ret;
-+}
-+
- static void ieee80211_8023_xmit(struct ieee80211_sub_if_data *sdata,
- 				struct net_device *dev, struct sta_info *sta,
- 				struct ieee80211_key *key, struct sk_buff *skb)
-@@ -4499,9 +4570,13 @@ static void ieee80211_8023_xmit(struct i
- 	struct ieee80211_tx_info *info;
- 	struct ieee80211_local *local = sdata->local;
- 	struct tid_ampdu_tx *tid_tx;
-+	struct sk_buff *seg, *next;
-+	unsigned int skbs = 0, len = 0;
-+	u16 queue;
- 	u8 tid;
- 
--	skb_set_queue_mapping(skb, ieee80211_select_queue(sdata, sta, skb));
-+	queue = ieee80211_select_queue(sdata, sta, skb);
-+	skb_set_queue_mapping(skb, queue);
- 
- 	if (unlikely(test_bit(SCAN_SW_SCANNING, &local->scanning)) &&
- 	    test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))
-@@ -4511,9 +4586,6 @@ static void ieee80211_8023_xmit(struct i
- 	if (unlikely(!skb))
- 		return;
- 
--	info = IEEE80211_SKB_CB(skb);
--	memset(info, 0, sizeof(*info));
--
- 	ieee80211_aggr_check(sdata, sta, skb);
- 
- 	tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
-@@ -4527,22 +4599,20 @@ static void ieee80211_8023_xmit(struct i
- 			return;
- 		}
- 
--		info->flags |= IEEE80211_TX_CTL_AMPDU;
- 		if (tid_tx->timeout)
- 			tid_tx->last_tx = jiffies;
- 	}
- 
--	if (unlikely(skb->sk &&
--		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))
--		info->ack_frame_id = ieee80211_store_ack_skb(local, skb,
--							     &info->flags, NULL);
-+	skb = ieee80211_tx_skb_fixup(skb, ieee80211_sdata_netdev_features(sdata));
-+	if (!skb)
-+		return;
- 
--	info->hw_queue = sdata->vif.hw_queue[skb_get_queue_mapping(skb)];
-+	info = IEEE80211_SKB_CB(skb);
-+	memset(info, 0, sizeof(*info));
-+	if (tid_tx)
-+		info->flags |= IEEE80211_TX_CTL_AMPDU;
- 
--	dev_sw_netstats_tx_add(dev, 1, skb->len);
--
--	sta->deflink.tx_stats.bytes[skb_get_queue_mapping(skb)] += skb->len;
--	sta->deflink.tx_stats.packets[skb_get_queue_mapping(skb)]++;
-+	info->hw_queue = sdata->vif.hw_queue[queue];
- 
- 	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
- 		sdata = container_of(sdata->bss,
-@@ -4554,6 +4624,24 @@ static void ieee80211_8023_xmit(struct i
- 	if (key)
- 		info->control.hw_key = &key->conf;
- 
-+	skb_list_walk_safe(skb, seg, next) {
-+		skbs++;
-+		len += seg->len;
-+		if (seg != skb)
-+			memcpy(IEEE80211_SKB_CB(seg), info, sizeof(*info));
-+	}
-+
-+	if (unlikely(skb->sk &&
-+		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))
-+		info->ack_frame_id = ieee80211_store_ack_skb(local, skb,
-+							     &info->flags, NULL);
-+
-+	dev_sw_netstats_tx_add(dev, skbs, len);
-+	sta->deflink.tx_stats.packets[queue] += skbs;
-+	sta->deflink.tx_stats.bytes[queue] += len;
-+
-+	ieee80211_tpt_led_trig_tx(local, len);
-+
- 	ieee80211_tx_8023(sdata, skb, sta, false);
- 
- 	return;
-@@ -4595,6 +4683,7 @@ netdev_tx_t ieee80211_subif_start_xmit_8
- 		    key->conf.cipher == WLAN_CIPHER_SUITE_TKIP))
- 		goto skip_offload;
- 
-+	sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
- 	ieee80211_8023_xmit(sdata, dev, sta, key, skb);
- 	goto out;
- 
diff --git a/package/kernel/mac80211/patches/subsys/311-v6.2-wifi-mac80211-fix-and-simplify-unencrypted-drop-chec.patch b/package/kernel/mac80211/patches/subsys/311-v6.2-wifi-mac80211-fix-and-simplify-unencrypted-drop-chec.patch
deleted file mode 100644
index 804b02eb..00000000
--- a/package/kernel/mac80211/patches/subsys/311-v6.2-wifi-mac80211-fix-and-simplify-unencrypted-drop-chec.patch
+++ /dev/null
@@ -1,87 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 1 Dec 2022 14:57:30 +0100
-Subject: [PATCH] wifi: mac80211: fix and simplify unencrypted drop check for
- mesh
-
-ieee80211_drop_unencrypted is called from ieee80211_rx_h_mesh_fwding and
-ieee80211_frame_allowed.
-
-Since ieee80211_rx_h_mesh_fwding can forward packets for other mesh nodes
-and is called earlier, it needs to check the decryptions status and if the
-packet is using the control protocol on its own, instead of deferring to
-the later call from ieee80211_frame_allowed.
-
-Because of that, ieee80211_drop_unencrypted has a mesh specific check
-that skips over the mesh header in order to check the payload protocol.
-This code is invalid when called from ieee80211_frame_allowed, since that
-happens after the 802.11->802.3 conversion.
-
-Fix this by moving the mesh specific check directly into
-ieee80211_rx_h_mesh_fwding.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Link: https://lore.kernel.org/r/20221201135730.19723-1-nbd@nbd.name
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2403,7 +2403,6 @@ static int ieee80211_802_1x_port_control
- 
- static int ieee80211_drop_unencrypted(struct ieee80211_rx_data *rx, __le16 fc)
- {
--	struct ieee80211_hdr *hdr = (void *)rx->skb->data;
- 	struct sk_buff *skb = rx->skb;
- 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
- 
-@@ -2414,31 +2413,6 @@ static int ieee80211_drop_unencrypted(st
- 	if (status->flag & RX_FLAG_DECRYPTED)
- 		return 0;
- 
--	/* check mesh EAPOL frames first */
--	if (unlikely(rx->sta && ieee80211_vif_is_mesh(&rx->sdata->vif) &&
--		     ieee80211_is_data(fc))) {
--		struct ieee80211s_hdr *mesh_hdr;
--		u16 hdr_len = ieee80211_hdrlen(fc);
--		u16 ethertype_offset;
--		__be16 ethertype;
--
--		if (!ether_addr_equal(hdr->addr1, rx->sdata->vif.addr))
--			goto drop_check;
--
--		/* make sure fixed part of mesh header is there, also checks skb len */
--		if (!pskb_may_pull(rx->skb, hdr_len + 6))
--			goto drop_check;
--
--		mesh_hdr = (struct ieee80211s_hdr *)(skb->data + hdr_len);
--		ethertype_offset = hdr_len + ieee80211_get_mesh_hdrlen(mesh_hdr) +
--				   sizeof(rfc1042_header);
--
--		if (skb_copy_bits(rx->skb, ethertype_offset, &ethertype, 2) == 0 &&
--		    ethertype == rx->sdata->control_port_protocol)
--			return 0;
--	}
--
--drop_check:
- 	/* Drop unencrypted frames if key is set. */
- 	if (unlikely(!ieee80211_has_protected(fc) &&
- 		     !ieee80211_is_any_nullfunc(fc) &&
-@@ -2892,8 +2866,16 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
- 	hdr = (struct ieee80211_hdr *) skb->data;
- 	mesh_hdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
- 
--	if (ieee80211_drop_unencrypted(rx, hdr->frame_control))
--		return RX_DROP_MONITOR;
-+	if (ieee80211_drop_unencrypted(rx, hdr->frame_control)) {
-+		int offset = hdrlen + ieee80211_get_mesh_hdrlen(mesh_hdr) +
-+			     sizeof(rfc1042_header);
-+		__be16 ethertype;
-+
-+		if (!ether_addr_equal(hdr->addr1, rx->sdata->vif.addr) ||
-+		    skb_copy_bits(rx->skb, offset, &ethertype, 2) != 0 ||
-+		    ethertype != rx->sdata->control_port_protocol)
-+			return RX_DROP_MONITOR;
-+	}
- 
- 	/* frame is in RMC, don't forward */
- 	if (ieee80211_is_data(hdr->frame_control) &&
diff --git a/package/kernel/mac80211/patches/subsys/312-v6.3-wifi-cfg80211-move-A-MSDU-check-in-ieee80211_data_to.patch b/package/kernel/mac80211/patches/subsys/312-v6.3-wifi-cfg80211-move-A-MSDU-check-in-ieee80211_data_to.patch
deleted file mode 100644
index f668905c..00000000
--- a/package/kernel/mac80211/patches/subsys/312-v6.3-wifi-cfg80211-move-A-MSDU-check-in-ieee80211_data_to.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 2 Dec 2022 13:53:11 +0100
-Subject: [PATCH] wifi: cfg80211: move A-MSDU check in
- ieee80211_data_to_8023_exthdr
-
-When parsing the outer A-MSDU header, don't check for inner bridge tunnel
-or RFC1042 headers. This is handled by ieee80211_amsdu_to_8023s already.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/wireless/util.c
-+++ b/net/wireless/util.c
-@@ -631,8 +631,9 @@ int ieee80211_data_to_8023_exthdr(struct
- 		break;
- 	}
- 
--	if (likely(skb_copy_bits(skb, hdrlen, &payload, sizeof(payload)) == 0 &&
--	           ((!is_amsdu && ether_addr_equal(payload.hdr, rfc1042_header) &&
-+	if (likely(!is_amsdu &&
-+		   skb_copy_bits(skb, hdrlen, &payload, sizeof(payload)) == 0 &&
-+	           ((ether_addr_equal(payload.hdr, rfc1042_header) &&
- 		     payload.proto != htons(ETH_P_AARP) &&
- 		     payload.proto != htons(ETH_P_IPX)) ||
- 		    ether_addr_equal(payload.hdr, bridge_tunnel_header)))) {
diff --git a/package/kernel/mac80211/patches/subsys/313-v6.3-wifi-cfg80211-factor-out-bridge-tunnel-RFC1042-heade.patch b/package/kernel/mac80211/patches/subsys/313-v6.3-wifi-cfg80211-factor-out-bridge-tunnel-RFC1042-heade.patch
deleted file mode 100644
index 86410578..00000000
--- a/package/kernel/mac80211/patches/subsys/313-v6.3-wifi-cfg80211-factor-out-bridge-tunnel-RFC1042-heade.patch
+++ /dev/null
@@ -1,76 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 2 Dec 2022 13:54:15 +0100
-Subject: [PATCH] wifi: cfg80211: factor out bridge tunnel / RFC1042 header
- check
-
-The same check is done in multiple places, unify it.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/wireless/util.c
-+++ b/net/wireless/util.c
-@@ -542,6 +542,21 @@ unsigned int ieee80211_get_mesh_hdrlen(s
- }
- EXPORT_SYMBOL(ieee80211_get_mesh_hdrlen);
- 
-+static bool ieee80211_get_8023_tunnel_proto(const void *hdr, __be16 *proto)
-+{
-+	const __be16 *hdr_proto = hdr + ETH_ALEN;
-+
-+	if (!(ether_addr_equal(hdr, rfc1042_header) &&
-+	      *hdr_proto != htons(ETH_P_AARP) &&
-+	      *hdr_proto != htons(ETH_P_IPX)) &&
-+	    !ether_addr_equal(hdr, bridge_tunnel_header))
-+		return false;
-+
-+	*proto = *hdr_proto;
-+
-+	return true;
-+}
-+
- int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,
- 				  const u8 *addr, enum nl80211_iftype iftype,
- 				  u8 data_offset, bool is_amsdu)
-@@ -633,14 +648,9 @@ int ieee80211_data_to_8023_exthdr(struct
- 
- 	if (likely(!is_amsdu &&
- 		   skb_copy_bits(skb, hdrlen, &payload, sizeof(payload)) == 0 &&
--	           ((ether_addr_equal(payload.hdr, rfc1042_header) &&
--		     payload.proto != htons(ETH_P_AARP) &&
--		     payload.proto != htons(ETH_P_IPX)) ||
--		    ether_addr_equal(payload.hdr, bridge_tunnel_header)))) {
--		/* remove RFC1042 or Bridge-Tunnel encapsulation and
--		 * replace EtherType */
-+		   ieee80211_get_8023_tunnel_proto(&payload, &tmp.h_proto))) {
-+		/* remove RFC1042 or Bridge-Tunnel encapsulation */
- 		hdrlen += ETH_ALEN + 2;
--		tmp.h_proto = payload.proto;
- 		skb_postpull_rcsum(skb, &payload, ETH_ALEN + 2);
- 	} else {
- 		tmp.h_proto = htons(skb->len - hdrlen);
-@@ -756,8 +766,6 @@ void ieee80211_amsdu_to_8023s(struct sk_
- {
- 	unsigned int hlen = ALIGN(extra_headroom, 4);
- 	struct sk_buff *frame = NULL;
--	u16 ethertype;
--	u8 *payload;
- 	int offset = 0, remaining;
- 	struct ethhdr eth;
- 	bool reuse_frag = skb->head_frag && !skb_has_frag_list(skb);
-@@ -811,14 +819,8 @@ void ieee80211_amsdu_to_8023s(struct sk_
- 		frame->dev = skb->dev;
- 		frame->priority = skb->priority;
- 
--		payload = frame->data;
--		ethertype = (payload[6] << 8) | payload[7];
--		if (likely((ether_addr_equal(payload, rfc1042_header) &&
--			    ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
--			   ether_addr_equal(payload, bridge_tunnel_header))) {
--			eth.h_proto = htons(ethertype);
-+		if (likely(ieee80211_get_8023_tunnel_proto(frame->data, &eth.h_proto)))
- 			skb_pull(frame, ETH_ALEN + 2);
--		}
- 
- 		memcpy(skb_push(frame, sizeof(eth)), &eth, sizeof(eth));
- 		__skb_queue_tail(list, frame);
diff --git a/package/kernel/mac80211/patches/subsys/314-v6.3-wifi-mac80211-remove-mesh-forwarding-congestion-chec.patch b/package/kernel/mac80211/patches/subsys/314-v6.3-wifi-mac80211-remove-mesh-forwarding-congestion-chec.patch
deleted file mode 100644
index 515176f0..00000000
--- a/package/kernel/mac80211/patches/subsys/314-v6.3-wifi-mac80211-remove-mesh-forwarding-congestion-chec.patch
+++ /dev/null
@@ -1,54 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 2 Dec 2022 17:01:46 +0100
-Subject: [PATCH] wifi: mac80211: remove mesh forwarding congestion check
-
-Now that all drivers use iTXQ, it does not make sense to check to drop
-tx forwarding packets when the driver has stopped the queues.
-fq_codel will take care of dropping packets when the queues fill up
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/debugfs_netdev.c
-+++ b/net/mac80211/debugfs_netdev.c
-@@ -603,8 +603,6 @@ IEEE80211_IF_FILE(fwded_mcast, u.mesh.ms
- IEEE80211_IF_FILE(fwded_unicast, u.mesh.mshstats.fwded_unicast, DEC);
- IEEE80211_IF_FILE(fwded_frames, u.mesh.mshstats.fwded_frames, DEC);
- IEEE80211_IF_FILE(dropped_frames_ttl, u.mesh.mshstats.dropped_frames_ttl, DEC);
--IEEE80211_IF_FILE(dropped_frames_congestion,
--		  u.mesh.mshstats.dropped_frames_congestion, DEC);
- IEEE80211_IF_FILE(dropped_frames_no_route,
- 		  u.mesh.mshstats.dropped_frames_no_route, DEC);
- 
-@@ -740,7 +738,6 @@ static void add_mesh_stats(struct ieee80
- 	MESHSTATS_ADD(fwded_frames);
- 	MESHSTATS_ADD(dropped_frames_ttl);
- 	MESHSTATS_ADD(dropped_frames_no_route);
--	MESHSTATS_ADD(dropped_frames_congestion);
- #undef MESHSTATS_ADD
- }
- 
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -329,7 +329,6 @@ struct mesh_stats {
- 	__u32 fwded_frames;		/* Mesh total forwarded frames */
- 	__u32 dropped_frames_ttl;	/* Not transmitted since mesh_ttl == 0*/
- 	__u32 dropped_frames_no_route;	/* Not transmitted, no route found */
--	__u32 dropped_frames_congestion;/* Not forwarded due to congestion */
- };
- 
- #define PREQ_Q_F_START		0x1
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2926,11 +2926,6 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
- 		return RX_CONTINUE;
- 
- 	ac = ieee802_1d_to_ac[skb->priority];
--	q = sdata->vif.hw_queue[ac];
--	if (ieee80211_queue_stopped(&local->hw, q)) {
--		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_congestion);
--		return RX_DROP_MONITOR;
--	}
- 	skb_set_queue_mapping(skb, ac);
- 
- 	if (!--mesh_hdr->ttl) {
diff --git a/package/kernel/mac80211/patches/subsys/315-v6.3-wifi-mac80211-fix-receiving-A-MSDU-frames-on-mesh-in.patch b/package/kernel/mac80211/patches/subsys/315-v6.3-wifi-mac80211-fix-receiving-A-MSDU-frames-on-mesh-in.patch
deleted file mode 100644
index 59b799b6..00000000
--- a/package/kernel/mac80211/patches/subsys/315-v6.3-wifi-mac80211-fix-receiving-A-MSDU-frames-on-mesh-in.patch
+++ /dev/null
@@ -1,762 +0,0 @@
-From 986e43b19ae9176093da35e0a844e65c8bf9ede7 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 13 Feb 2023 11:08:54 +0100
-Subject: [PATCH] wifi: mac80211: fix receiving A-MSDU frames on mesh
- interfaces
-
-The current mac80211 mesh A-MSDU receive path fails to parse A-MSDU packets
-on mesh interfaces, because it assumes that the Mesh Control field is always
-directly after the 802.11 header.
-802.11-2020 9.3.2.2.2 Figure 9-70 shows that the Mesh Control field is
-actually part of the A-MSDU subframe header.
-This makes more sense, since it allows packets for multiple different
-destinations to be included in the same A-MSDU, as long as RA and TID are
-still the same.
-Another issue is the fact that the A-MSDU subframe length field was apparently
-accidentally defined as little-endian in the standard.
-
-In order to fix this, the mesh forwarding path needs happen at a different
-point in the receive path.
-
-ieee80211_data_to_8023_exthdr is changed to ignore the mesh control field
-and leave it in after the ethernet header. This also affects the source/dest
-MAC address fields, which now in the case of mesh point to the mesh SA/DA.
-
-ieee80211_amsdu_to_8023s is changed to deal with the endian difference and
-to add the Mesh Control length to the subframe length, since it's not covered
-by the MSDU length field.
-
-With these changes, the mac80211 will get the same packet structure for
-converted regular data packets and unpacked A-MSDU subframes.
-
-The mesh forwarding checks are now only performed after the A-MSDU decap.
-For locally received packets, the Mesh Control header is stripped away.
-For forwarded packets, a new 802.11 header gets added.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Link: https://lore.kernel.org/r/20230213100855.34315-4-nbd@nbd.name
-[fix fortify build error]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
- .../wireless/marvell/mwifiex/11n_rxreorder.c  |   2 +-
- include/net/cfg80211.h                        |  27 +-
- net/mac80211/rx.c                             | 350 ++++++++++--------
- net/wireless/util.c                           | 120 +++---
- 4 files changed, 297 insertions(+), 202 deletions(-)
-
---- a/drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c
-+++ b/drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c
-@@ -33,7 +33,7 @@ static int mwifiex_11n_dispatch_amsdu_pk
- 		skb_trim(skb, le16_to_cpu(local_rx_pd->rx_pkt_length));
- 
- 		ieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,
--					 priv->wdev.iftype, 0, NULL, NULL);
-+					 priv->wdev.iftype, 0, NULL, NULL, false);
- 
- 		while (!skb_queue_empty(&list)) {
- 			struct rx_packet_hdr *rx_hdr;
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -6208,11 +6208,36 @@ static inline int ieee80211_data_to_8023
-  * @extra_headroom: The hardware extra headroom for SKBs in the @list.
-  * @check_da: DA to check in the inner ethernet header, or NULL
-  * @check_sa: SA to check in the inner ethernet header, or NULL
-+ * @mesh_control: A-MSDU subframe header includes the mesh control field
-  */
- void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
- 			      const u8 *addr, enum nl80211_iftype iftype,
- 			      const unsigned int extra_headroom,
--			      const u8 *check_da, const u8 *check_sa);
-+			      const u8 *check_da, const u8 *check_sa,
-+			      bool mesh_control);
-+
-+/**
-+ * ieee80211_get_8023_tunnel_proto - get RFC1042 or bridge tunnel encap protocol
-+ *
-+ * Check for RFC1042 or bridge tunnel header and fetch the encapsulated
-+ * protocol.
-+ *
-+ * @hdr: pointer to the MSDU payload
-+ * @proto: destination pointer to store the protocol
-+ * Return: true if encapsulation was found
-+ */
-+bool ieee80211_get_8023_tunnel_proto(const void *hdr, __be16 *proto);
-+
-+/**
-+ * ieee80211_strip_8023_mesh_hdr - strip mesh header from converted 802.3 frames
-+ *
-+ * Strip the mesh header, which was left in by ieee80211_data_to_8023 as part
-+ * of the MSDU data. Also move any source/destination addresses from the mesh
-+ * header to the ethernet header (if present).
-+ *
-+ * @skb: The 802.3 frame with embedded mesh header
-+ */
-+int ieee80211_strip_8023_mesh_hdr(struct sk_buff *skb);
- 
- /**
-  * cfg80211_classify8021d - determine the 802.1p/1d tag for a data frame
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2720,6 +2720,174 @@ ieee80211_deliver_skb(struct ieee80211_r
- 	}
- }
- 
-+static ieee80211_rx_result
-+ieee80211_rx_mesh_data(struct ieee80211_sub_if_data *sdata, struct sta_info *sta,
-+		       struct sk_buff *skb)
-+{
-+#ifdef CPTCFG_MAC80211_MESH
-+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
-+	struct ieee80211_local *local = sdata->local;
-+	uint16_t fc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA;
-+	struct ieee80211_hdr hdr = {
-+		.frame_control = cpu_to_le16(fc)
-+	};
-+	struct ieee80211_hdr *fwd_hdr;
-+	struct ieee80211s_hdr *mesh_hdr;
-+	struct ieee80211_tx_info *info;
-+	struct sk_buff *fwd_skb;
-+	struct ethhdr *eth;
-+	bool multicast;
-+	int tailroom = 0;
-+	int hdrlen, mesh_hdrlen;
-+	u8 *qos;
-+
-+	if (!ieee80211_vif_is_mesh(&sdata->vif))
-+		return RX_CONTINUE;
-+
-+	if (!pskb_may_pull(skb, sizeof(*eth) + 6))
-+		return RX_DROP_MONITOR;
-+
-+	mesh_hdr = (struct ieee80211s_hdr *)(skb->data + sizeof(*eth));
-+	mesh_hdrlen = ieee80211_get_mesh_hdrlen(mesh_hdr);
-+
-+	if (!pskb_may_pull(skb, sizeof(*eth) + mesh_hdrlen))
-+		return RX_DROP_MONITOR;
-+
-+	eth = (struct ethhdr *)skb->data;
-+	multicast = is_multicast_ether_addr(eth->h_dest);
-+
-+	mesh_hdr = (struct ieee80211s_hdr *)(eth + 1);
-+	if (!mesh_hdr->ttl)
-+		return RX_DROP_MONITOR;
-+
-+	/* frame is in RMC, don't forward */
-+	if (is_multicast_ether_addr(eth->h_dest) &&
-+	    mesh_rmc_check(sdata, eth->h_source, mesh_hdr))
-+		return RX_DROP_MONITOR;
-+
-+	/* Frame has reached destination.  Don't forward */
-+	if (ether_addr_equal(sdata->vif.addr, eth->h_dest))
-+		goto rx_accept;
-+
-+	if (!ifmsh->mshcfg.dot11MeshForwarding) {
-+		if (is_multicast_ether_addr(eth->h_dest))
-+			goto rx_accept;
-+
-+		return RX_DROP_MONITOR;
-+	}
-+
-+	/* forward packet */
-+	if (sdata->crypto_tx_tailroom_needed_cnt)
-+		tailroom = IEEE80211_ENCRYPT_TAILROOM;
-+
-+	if (!--mesh_hdr->ttl) {
-+		if (multicast)
-+			goto rx_accept;
-+
-+		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_ttl);
-+		return RX_DROP_MONITOR;
-+	}
-+
-+	if (mesh_hdr->flags & MESH_FLAGS_AE) {
-+		struct mesh_path *mppath;
-+		char *proxied_addr;
-+
-+		if (multicast)
-+			proxied_addr = mesh_hdr->eaddr1;
-+		else if ((mesh_hdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6)
-+			/* has_a4 already checked in ieee80211_rx_mesh_check */
-+			proxied_addr = mesh_hdr->eaddr2;
-+		else
-+			return RX_DROP_MONITOR;
-+
-+		rcu_read_lock();
-+		mppath = mpp_path_lookup(sdata, proxied_addr);
-+		if (!mppath) {
-+			mpp_path_add(sdata, proxied_addr, eth->h_source);
-+		} else {
-+			spin_lock_bh(&mppath->state_lock);
-+			if (!ether_addr_equal(mppath->mpp, eth->h_source))
-+				memcpy(mppath->mpp, eth->h_source, ETH_ALEN);
-+			mppath->exp_time = jiffies;
-+			spin_unlock_bh(&mppath->state_lock);
-+		}
-+		rcu_read_unlock();
-+	}
-+
-+	skb_set_queue_mapping(skb, ieee802_1d_to_ac[skb->priority]);
-+
-+	ieee80211_fill_mesh_addresses(&hdr, &hdr.frame_control,
-+				      eth->h_dest, eth->h_source);
-+	hdrlen = ieee80211_hdrlen(hdr.frame_control);
-+	if (multicast) {
-+		int extra_head = sizeof(struct ieee80211_hdr) - sizeof(*eth);
-+
-+		fwd_skb = skb_copy_expand(skb, local->tx_headroom + extra_head +
-+					       IEEE80211_ENCRYPT_HEADROOM,
-+					  tailroom, GFP_ATOMIC);
-+		if (!fwd_skb)
-+			goto rx_accept;
-+	} else {
-+		fwd_skb = skb;
-+		skb = NULL;
-+
-+		if (skb_cow_head(fwd_skb, hdrlen - sizeof(struct ethhdr)))
-+			return RX_DROP_UNUSABLE;
-+	}
-+
-+	fwd_hdr = skb_push(fwd_skb, hdrlen - sizeof(struct ethhdr));
-+	memcpy(fwd_hdr, &hdr, hdrlen - 2);
-+	qos = ieee80211_get_qos_ctl(fwd_hdr);
-+	qos[0] = qos[1] = 0;
-+
-+	skb_reset_mac_header(fwd_skb);
-+	hdrlen += mesh_hdrlen;
-+	if (ieee80211_get_8023_tunnel_proto(fwd_skb->data + hdrlen,
-+					    &fwd_skb->protocol))
-+		hdrlen += ETH_ALEN;
-+	else
-+		fwd_skb->protocol = htons(fwd_skb->len - hdrlen);
-+	skb_set_network_header(fwd_skb, hdrlen);
-+
-+	info = IEEE80211_SKB_CB(fwd_skb);
-+	memset(info, 0, sizeof(*info));
-+	info->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;
-+	info->control.vif = &sdata->vif;
-+	info->control.jiffies = jiffies;
-+	if (multicast) {
-+		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_mcast);
-+		memcpy(fwd_hdr->addr2, sdata->vif.addr, ETH_ALEN);
-+		/* update power mode indication when forwarding */
-+		ieee80211_mps_set_frame_flags(sdata, NULL, fwd_hdr);
-+	} else if (!mesh_nexthop_lookup(sdata, fwd_skb)) {
-+		/* mesh power mode flags updated in mesh_nexthop_lookup */
-+		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_unicast);
-+	} else {
-+		/* unable to resolve next hop */
-+		if (sta)
-+			mesh_path_error_tx(sdata, ifmsh->mshcfg.element_ttl,
-+					   hdr.addr3, 0,
-+					   WLAN_REASON_MESH_PATH_NOFORWARD,
-+					   sta->sta.addr);
-+		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_no_route);
-+		kfree_skb(fwd_skb);
-+		goto rx_accept;
-+	}
-+
-+	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);
-+	fwd_skb->dev = sdata->dev;
-+	ieee80211_add_pending_skb(local, fwd_skb);
-+
-+rx_accept:
-+	if (!skb)
-+		return RX_QUEUED;
-+
-+	ieee80211_strip_8023_mesh_hdr(skb);
-+#endif
-+
-+	return RX_CONTINUE;
-+}
-+
- static ieee80211_rx_result debug_noinline
- __ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx, u8 data_offset)
- {
-@@ -2728,8 +2896,10 @@ __ieee80211_rx_h_amsdu(struct ieee80211_
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
- 	__le16 fc = hdr->frame_control;
- 	struct sk_buff_head frame_list;
-+	static ieee80211_rx_result res;
- 	struct ethhdr ethhdr;
- 	const u8 *check_da = ethhdr.h_dest, *check_sa = ethhdr.h_source;
-+	bool mesh = false;
- 
- 	if (unlikely(ieee80211_has_a4(hdr->frame_control))) {
- 		check_da = NULL;
-@@ -2746,6 +2916,8 @@ __ieee80211_rx_h_amsdu(struct ieee80211_
- 			break;
- 		case NL80211_IFTYPE_MESH_POINT:
- 			check_sa = NULL;
-+			check_da = NULL;
-+			mesh = true;
- 			break;
- 		default:
- 			break;
-@@ -2763,17 +2935,29 @@ __ieee80211_rx_h_amsdu(struct ieee80211_
- 	ieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,
- 				 rx->sdata->vif.type,
- 				 rx->local->hw.extra_tx_headroom,
--				 check_da, check_sa);
-+				 check_da, check_sa, mesh);
- 
- 	while (!skb_queue_empty(&frame_list)) {
- 		rx->skb = __skb_dequeue(&frame_list);
- 
--		if (!ieee80211_frame_allowed(rx, fc)) {
--			dev_kfree_skb(rx->skb);
-+		res = ieee80211_rx_mesh_data(rx->sdata, rx->sta, rx->skb);
-+		switch (res) {
-+		case RX_QUEUED:
- 			continue;
-+		case RX_CONTINUE:
-+			break;
-+		default:
-+			goto free;
- 		}
- 
-+		if (!ieee80211_frame_allowed(rx, fc))
-+			goto free;
-+
- 		ieee80211_deliver_skb(rx);
-+		continue;
-+
-+free:
-+		dev_kfree_skb(rx->skb);
- 	}
- 
- 	return RX_QUEUED;
-@@ -2806,6 +2990,8 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
- 			if (!rx->sdata->u.mgd.use_4addr)
- 				return RX_DROP_UNUSABLE;
- 			break;
-+		case NL80211_IFTYPE_MESH_POINT:
-+			break;
- 		default:
- 			return RX_DROP_UNUSABLE;
- 		}
-@@ -2834,155 +3020,6 @@ ieee80211_rx_h_amsdu(struct ieee80211_rx
- 	return __ieee80211_rx_h_amsdu(rx, 0);
- }
- 
--#ifdef CPTCFG_MAC80211_MESH
--static ieee80211_rx_result
--ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)
--{
--	struct ieee80211_hdr *fwd_hdr, *hdr;
--	struct ieee80211_tx_info *info;
--	struct ieee80211s_hdr *mesh_hdr;
--	struct sk_buff *skb = rx->skb, *fwd_skb;
--	struct ieee80211_local *local = rx->local;
--	struct ieee80211_sub_if_data *sdata = rx->sdata;
--	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
--	u16 ac, q, hdrlen;
--	int tailroom = 0;
--
--	hdr = (struct ieee80211_hdr *) skb->data;
--	hdrlen = ieee80211_hdrlen(hdr->frame_control);
--
--	/* make sure fixed part of mesh header is there, also checks skb len */
--	if (!pskb_may_pull(rx->skb, hdrlen + 6))
--		return RX_DROP_MONITOR;
--
--	mesh_hdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
--
--	/* make sure full mesh header is there, also checks skb len */
--	if (!pskb_may_pull(rx->skb,
--			   hdrlen + ieee80211_get_mesh_hdrlen(mesh_hdr)))
--		return RX_DROP_MONITOR;
--
--	/* reload pointers */
--	hdr = (struct ieee80211_hdr *) skb->data;
--	mesh_hdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
--
--	if (ieee80211_drop_unencrypted(rx, hdr->frame_control)) {
--		int offset = hdrlen + ieee80211_get_mesh_hdrlen(mesh_hdr) +
--			     sizeof(rfc1042_header);
--		__be16 ethertype;
--
--		if (!ether_addr_equal(hdr->addr1, rx->sdata->vif.addr) ||
--		    skb_copy_bits(rx->skb, offset, &ethertype, 2) != 0 ||
--		    ethertype != rx->sdata->control_port_protocol)
--			return RX_DROP_MONITOR;
--	}
--
--	/* frame is in RMC, don't forward */
--	if (ieee80211_is_data(hdr->frame_control) &&
--	    is_multicast_ether_addr(hdr->addr1) &&
--	    mesh_rmc_check(rx->sdata, hdr->addr3, mesh_hdr))
--		return RX_DROP_MONITOR;
--
--	if (!ieee80211_is_data(hdr->frame_control))
--		return RX_CONTINUE;
--
--	if (!mesh_hdr->ttl)
--		return RX_DROP_MONITOR;
--
--	if (mesh_hdr->flags & MESH_FLAGS_AE) {
--		struct mesh_path *mppath;
--		char *proxied_addr;
--		char *mpp_addr;
--
--		if (is_multicast_ether_addr(hdr->addr1)) {
--			mpp_addr = hdr->addr3;
--			proxied_addr = mesh_hdr->eaddr1;
--		} else if ((mesh_hdr->flags & MESH_FLAGS_AE) ==
--			    MESH_FLAGS_AE_A5_A6) {
--			/* has_a4 already checked in ieee80211_rx_mesh_check */
--			mpp_addr = hdr->addr4;
--			proxied_addr = mesh_hdr->eaddr2;
--		} else {
--			return RX_DROP_MONITOR;
--		}
--
--		rcu_read_lock();
--		mppath = mpp_path_lookup(sdata, proxied_addr);
--		if (!mppath) {
--			mpp_path_add(sdata, proxied_addr, mpp_addr);
--		} else {
--			spin_lock_bh(&mppath->state_lock);
--			if (!ether_addr_equal(mppath->mpp, mpp_addr))
--				memcpy(mppath->mpp, mpp_addr, ETH_ALEN);
--			mppath->exp_time = jiffies;
--			spin_unlock_bh(&mppath->state_lock);
--		}
--		rcu_read_unlock();
--	}
--
--	/* Frame has reached destination.  Don't forward */
--	if (!is_multicast_ether_addr(hdr->addr1) &&
--	    ether_addr_equal(sdata->vif.addr, hdr->addr3))
--		return RX_CONTINUE;
--
--	ac = ieee802_1d_to_ac[skb->priority];
--	skb_set_queue_mapping(skb, ac);
--
--	if (!--mesh_hdr->ttl) {
--		if (!is_multicast_ether_addr(hdr->addr1))
--			IEEE80211_IFSTA_MESH_CTR_INC(ifmsh,
--						     dropped_frames_ttl);
--		goto out;
--	}
--
--	if (!ifmsh->mshcfg.dot11MeshForwarding)
--		goto out;
--
--	if (sdata->crypto_tx_tailroom_needed_cnt)
--		tailroom = IEEE80211_ENCRYPT_TAILROOM;
--
--	fwd_skb = skb_copy_expand(skb, local->tx_headroom +
--				       IEEE80211_ENCRYPT_HEADROOM,
--				  tailroom, GFP_ATOMIC);
--	if (!fwd_skb)
--		goto out;
--
--	fwd_skb->dev = sdata->dev;
--	fwd_hdr =  (struct ieee80211_hdr *) fwd_skb->data;
--	fwd_hdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_RETRY);
--	info = IEEE80211_SKB_CB(fwd_skb);
--	memset(info, 0, sizeof(*info));
--	info->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;
--	info->control.vif = &rx->sdata->vif;
--	info->control.jiffies = jiffies;
--	if (is_multicast_ether_addr(fwd_hdr->addr1)) {
--		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_mcast);
--		memcpy(fwd_hdr->addr2, sdata->vif.addr, ETH_ALEN);
--		/* update power mode indication when forwarding */
--		ieee80211_mps_set_frame_flags(sdata, NULL, fwd_hdr);
--	} else if (!mesh_nexthop_lookup(sdata, fwd_skb)) {
--		/* mesh power mode flags updated in mesh_nexthop_lookup */
--		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_unicast);
--	} else {
--		/* unable to resolve next hop */
--		mesh_path_error_tx(sdata, ifmsh->mshcfg.element_ttl,
--				   fwd_hdr->addr3, 0,
--				   WLAN_REASON_MESH_PATH_NOFORWARD,
--				   fwd_hdr->addr2);
--		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_no_route);
--		kfree_skb(fwd_skb);
--		return RX_DROP_MONITOR;
--	}
--
--	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);
--	ieee80211_add_pending_skb(local, fwd_skb);
-- out:
--	if (is_multicast_ether_addr(hdr->addr1))
--		return RX_CONTINUE;
--	return RX_DROP_MONITOR;
--}
--#endif
--
- static ieee80211_rx_result debug_noinline
- ieee80211_rx_h_data(struct ieee80211_rx_data *rx)
- {
-@@ -2991,6 +3028,7 @@ ieee80211_rx_h_data(struct ieee80211_rx_
- 	struct net_device *dev = sdata->dev;
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
- 	__le16 fc = hdr->frame_control;
-+	static ieee80211_rx_result res;
- 	bool port_control;
- 	int err;
- 
-@@ -3017,6 +3055,10 @@ ieee80211_rx_h_data(struct ieee80211_rx_
- 	if (unlikely(err))
- 		return RX_DROP_UNUSABLE;
- 
-+	res = ieee80211_rx_mesh_data(rx->sdata, rx->sta, rx->skb);
-+	if (res != RX_CONTINUE)
-+		return res;
-+
- 	if (!ieee80211_frame_allowed(rx, fc))
- 		return RX_DROP_MONITOR;
- 
-@@ -3987,10 +4029,6 @@ static void ieee80211_rx_handlers(struct
- 		CALL_RXH(ieee80211_rx_h_defragment);
- 		CALL_RXH(ieee80211_rx_h_michael_mic_verify);
- 		/* must be after MMIC verify so header is counted in MPDU mic */
--#ifdef CPTCFG_MAC80211_MESH
--		if (ieee80211_vif_is_mesh(&rx->sdata->vif))
--			CALL_RXH(ieee80211_rx_h_mesh_fwding);
--#endif
- 		CALL_RXH(ieee80211_rx_h_amsdu);
- 		CALL_RXH(ieee80211_rx_h_data);
- 
---- a/net/wireless/util.c
-+++ b/net/wireless/util.c
-@@ -542,7 +542,7 @@ unsigned int ieee80211_get_mesh_hdrlen(s
- }
- EXPORT_SYMBOL(ieee80211_get_mesh_hdrlen);
- 
--static bool ieee80211_get_8023_tunnel_proto(const void *hdr, __be16 *proto)
-+bool ieee80211_get_8023_tunnel_proto(const void *hdr, __be16 *proto)
- {
- 	const __be16 *hdr_proto = hdr + ETH_ALEN;
- 
-@@ -556,6 +556,49 @@ static bool ieee80211_get_8023_tunnel_pr
- 
- 	return true;
- }
-+EXPORT_SYMBOL(ieee80211_get_8023_tunnel_proto);
-+
-+int ieee80211_strip_8023_mesh_hdr(struct sk_buff *skb)
-+{
-+	const void *mesh_addr;
-+	struct {
-+		struct ethhdr eth;
-+		u8 flags;
-+	} payload;
-+	int hdrlen;
-+	int ret;
-+
-+	ret = skb_copy_bits(skb, 0, &payload, sizeof(payload));
-+	if (ret)
-+		return ret;
-+
-+	hdrlen = sizeof(payload.eth) + __ieee80211_get_mesh_hdrlen(payload.flags);
-+
-+	if (likely(pskb_may_pull(skb, hdrlen + 8) &&
-+		   ieee80211_get_8023_tunnel_proto(skb->data + hdrlen,
-+						   &payload.eth.h_proto)))
-+		hdrlen += ETH_ALEN + 2;
-+	else if (!pskb_may_pull(skb, hdrlen))
-+		return -EINVAL;
-+
-+	mesh_addr = skb->data + sizeof(payload.eth) + ETH_ALEN;
-+	switch (payload.flags & MESH_FLAGS_AE) {
-+	case MESH_FLAGS_AE_A4:
-+		memcpy(&payload.eth.h_source, mesh_addr, ETH_ALEN);
-+		break;
-+	case MESH_FLAGS_AE_A5_A6:
-+		memcpy(&payload.eth, mesh_addr, 2 * ETH_ALEN);
-+		break;
-+	default:
-+		break;
-+	}
-+
-+	pskb_pull(skb, hdrlen - sizeof(payload.eth));
-+	memcpy(skb->data, &payload.eth, sizeof(payload.eth));
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(ieee80211_strip_8023_mesh_hdr);
- 
- int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,
- 				  const u8 *addr, enum nl80211_iftype iftype,
-@@ -568,7 +611,6 @@ int ieee80211_data_to_8023_exthdr(struct
- 	} payload;
- 	struct ethhdr tmp;
- 	u16 hdrlen;
--	u8 mesh_flags = 0;
- 
- 	if (unlikely(!ieee80211_is_data_present(hdr->frame_control)))
- 		return -1;
-@@ -589,12 +631,6 @@ int ieee80211_data_to_8023_exthdr(struct
- 	memcpy(tmp.h_dest, ieee80211_get_DA(hdr), ETH_ALEN);
- 	memcpy(tmp.h_source, ieee80211_get_SA(hdr), ETH_ALEN);
- 
--	if (iftype == NL80211_IFTYPE_MESH_POINT &&
--	    skb_copy_bits(skb, hdrlen, &mesh_flags, 1) < 0)
--		return -1;
--
--	mesh_flags &= MESH_FLAGS_AE;
--
- 	switch (hdr->frame_control &
- 		cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) {
- 	case cpu_to_le16(IEEE80211_FCTL_TODS):
-@@ -608,17 +644,6 @@ int ieee80211_data_to_8023_exthdr(struct
- 			     iftype != NL80211_IFTYPE_AP_VLAN &&
- 			     iftype != NL80211_IFTYPE_STATION))
- 			return -1;
--		if (iftype == NL80211_IFTYPE_MESH_POINT) {
--			if (mesh_flags == MESH_FLAGS_AE_A4)
--				return -1;
--			if (mesh_flags == MESH_FLAGS_AE_A5_A6 &&
--			    skb_copy_bits(skb, hdrlen +
--					  offsetof(struct ieee80211s_hdr, eaddr1),
--					  tmp.h_dest, 2 * ETH_ALEN) < 0)
--				return -1;
--
--			hdrlen += __ieee80211_get_mesh_hdrlen(mesh_flags);
--		}
- 		break;
- 	case cpu_to_le16(IEEE80211_FCTL_FROMDS):
- 		if ((iftype != NL80211_IFTYPE_STATION &&
-@@ -627,16 +652,6 @@ int ieee80211_data_to_8023_exthdr(struct
- 		    (is_multicast_ether_addr(tmp.h_dest) &&
- 		     ether_addr_equal(tmp.h_source, addr)))
- 			return -1;
--		if (iftype == NL80211_IFTYPE_MESH_POINT) {
--			if (mesh_flags == MESH_FLAGS_AE_A5_A6)
--				return -1;
--			if (mesh_flags == MESH_FLAGS_AE_A4 &&
--			    skb_copy_bits(skb, hdrlen +
--					  offsetof(struct ieee80211s_hdr, eaddr1),
--					  tmp.h_source, ETH_ALEN) < 0)
--				return -1;
--			hdrlen += __ieee80211_get_mesh_hdrlen(mesh_flags);
--		}
- 		break;
- 	case cpu_to_le16(0):
- 		if (iftype != NL80211_IFTYPE_ADHOC &&
-@@ -646,7 +661,7 @@ int ieee80211_data_to_8023_exthdr(struct
- 		break;
- 	}
- 
--	if (likely(!is_amsdu &&
-+	if (likely(!is_amsdu && iftype != NL80211_IFTYPE_MESH_POINT &&
- 		   skb_copy_bits(skb, hdrlen, &payload, sizeof(payload)) == 0 &&
- 		   ieee80211_get_8023_tunnel_proto(&payload, &tmp.h_proto))) {
- 		/* remove RFC1042 or Bridge-Tunnel encapsulation */
-@@ -722,7 +737,8 @@ __ieee80211_amsdu_copy_frag(struct sk_bu
- 
- static struct sk_buff *
- __ieee80211_amsdu_copy(struct sk_buff *skb, unsigned int hlen,
--		       int offset, int len, bool reuse_frag)
-+		       int offset, int len, bool reuse_frag,
-+		       int min_len)
- {
- 	struct sk_buff *frame;
- 	int cur_len = len;
-@@ -736,7 +752,7 @@ __ieee80211_amsdu_copy(struct sk_buff *s
- 	 * in the stack later.
- 	 */
- 	if (reuse_frag)
--		cur_len = min_t(int, len, 32);
-+		cur_len = min_t(int, len, min_len);
- 
- 	/*
- 	 * Allocate and reserve two bytes more for payload
-@@ -746,6 +762,7 @@ __ieee80211_amsdu_copy(struct sk_buff *s
- 	if (!frame)
- 		return NULL;
- 
-+	frame->priority = skb->priority;
- 	skb_reserve(frame, hlen + sizeof(struct ethhdr) + 2);
- 	skb_copy_bits(skb, offset, skb_put(frame, cur_len), cur_len);
- 
-@@ -762,23 +779,37 @@ __ieee80211_amsdu_copy(struct sk_buff *s
- void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
- 			      const u8 *addr, enum nl80211_iftype iftype,
- 			      const unsigned int extra_headroom,
--			      const u8 *check_da, const u8 *check_sa)
-+			      const u8 *check_da, const u8 *check_sa,
-+			      bool mesh_control)
- {
- 	unsigned int hlen = ALIGN(extra_headroom, 4);
- 	struct sk_buff *frame = NULL;
- 	int offset = 0, remaining;
--	struct ethhdr eth;
-+	struct {
-+		struct ethhdr eth;
-+		uint8_t flags;
-+	} hdr;
- 	bool reuse_frag = skb->head_frag && !skb_has_frag_list(skb);
- 	bool reuse_skb = false;
- 	bool last = false;
-+	int copy_len = sizeof(hdr.eth);
-+
-+	if (iftype == NL80211_IFTYPE_MESH_POINT)
-+		copy_len = sizeof(hdr);
- 
- 	while (!last) {
- 		unsigned int subframe_len;
--		int len;
-+		int len, mesh_len = 0;
- 		u8 padding;
- 
--		skb_copy_bits(skb, offset, &eth, sizeof(eth));
--		len = ntohs(eth.h_proto);
-+		skb_copy_bits(skb, offset, &hdr, copy_len);
-+		if (iftype == NL80211_IFTYPE_MESH_POINT)
-+			mesh_len = __ieee80211_get_mesh_hdrlen(hdr.flags);
-+		if (mesh_control)
-+			len = le16_to_cpu(*(__le16 *)&hdr.eth.h_proto) + mesh_len;
-+		else
-+			len = ntohs(hdr.eth.h_proto);
-+
- 		subframe_len = sizeof(struct ethhdr) + len;
- 		padding = (4 - subframe_len) & 0x3;
- 
-@@ -787,16 +818,16 @@ void ieee80211_amsdu_to_8023s(struct sk_
- 		if (subframe_len > remaining)
- 			goto purge;
- 		/* mitigate A-MSDU aggregation injection attacks */
--		if (ether_addr_equal(eth.h_dest, rfc1042_header))
-+		if (ether_addr_equal(hdr.eth.h_dest, rfc1042_header))
- 			goto purge;
- 
- 		offset += sizeof(struct ethhdr);
- 		last = remaining <= subframe_len + padding;
- 
- 		/* FIXME: should we really accept multicast DA? */
--		if ((check_da && !is_multicast_ether_addr(eth.h_dest) &&
--		     !ether_addr_equal(check_da, eth.h_dest)) ||
--		    (check_sa && !ether_addr_equal(check_sa, eth.h_source))) {
-+		if ((check_da && !is_multicast_ether_addr(hdr.eth.h_dest) &&
-+		     !ether_addr_equal(check_da, hdr.eth.h_dest)) ||
-+		    (check_sa && !ether_addr_equal(check_sa, hdr.eth.h_source))) {
- 			offset += len + padding;
- 			continue;
- 		}
-@@ -808,7 +839,7 @@ void ieee80211_amsdu_to_8023s(struct sk_
- 			reuse_skb = true;
- 		} else {
- 			frame = __ieee80211_amsdu_copy(skb, hlen, offset, len,
--						       reuse_frag);
-+						       reuse_frag, 32 + mesh_len);
- 			if (!frame)
- 				goto purge;
- 
-@@ -819,10 +850,11 @@ void ieee80211_amsdu_to_8023s(struct sk_
- 		frame->dev = skb->dev;
- 		frame->priority = skb->priority;
- 
--		if (likely(ieee80211_get_8023_tunnel_proto(frame->data, &eth.h_proto)))
-+		if (likely(iftype != NL80211_IFTYPE_MESH_POINT &&
-+			   ieee80211_get_8023_tunnel_proto(frame->data, &hdr.eth.h_proto)))
- 			skb_pull(frame, ETH_ALEN + 2);
- 
--		memcpy(skb_push(frame, sizeof(eth)), &eth, sizeof(eth));
-+		memcpy(skb_push(frame, sizeof(hdr.eth)), &hdr.eth, sizeof(hdr.eth));
- 		__skb_queue_tail(list, frame);
- 	}
- 
diff --git a/package/kernel/mac80211/patches/subsys/316-v6.3-wifi-mac80211-add-a-workaround-for-receiving-non-sta.patch b/package/kernel/mac80211/patches/subsys/316-v6.3-wifi-mac80211-add-a-workaround-for-receiving-non-sta.patch
deleted file mode 100644
index 6dc98ae1..00000000
--- a/package/kernel/mac80211/patches/subsys/316-v6.3-wifi-mac80211-add-a-workaround-for-receiving-non-sta.patch
+++ /dev/null
@@ -1,145 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 9 Dec 2022 21:15:04 +0100
-Subject: [PATCH] wifi: mac80211: add a workaround for receiving
- non-standard mesh A-MSDU
-
-At least ath10k and ath11k supported hardware (maybe more) does not implement
-mesh A-MSDU aggregation in a standard compliant way.
-802.11-2020 9.3.2.2.2 declares that the Mesh Control field is part of the
-A-MSDU header. As such, its length must not be included in the subframe
-length field.
-Hardware affected by this bug treats the mesh control field as part of the
-MSDU data and sets the length accordingly.
-In order to avoid packet loss, keep track of which stations are affected
-by this and take it into account when converting A-MSDU to 802.3 + mesh control
-packets.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -6194,6 +6194,19 @@ static inline int ieee80211_data_to_8023
- }
- 
- /**
-+ * ieee80211_is_valid_amsdu - check if subframe lengths of an A-MSDU are valid
-+ *
-+ * This is used to detect non-standard A-MSDU frames, e.g. the ones generated
-+ * by ath10k and ath11k, where the subframe length includes the length of the
-+ * mesh control field.
-+ *
-+ * @skb: The input A-MSDU frame without any headers.
-+ * @mesh_hdr: use standard compliant mesh A-MSDU subframe header
-+ * Returns: true if subframe header lengths are valid for the @mesh_hdr mode
-+ */
-+bool ieee80211_is_valid_amsdu(struct sk_buff *skb, bool mesh_hdr);
-+
-+/**
-  * ieee80211_amsdu_to_8023s - decode an IEEE 802.11n A-MSDU frame
-  *
-  * Decode an IEEE 802.11 A-MSDU and convert it to a list of 802.3 frames.
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2899,7 +2899,6 @@ __ieee80211_rx_h_amsdu(struct ieee80211_
- 	static ieee80211_rx_result res;
- 	struct ethhdr ethhdr;
- 	const u8 *check_da = ethhdr.h_dest, *check_sa = ethhdr.h_source;
--	bool mesh = false;
- 
- 	if (unlikely(ieee80211_has_a4(hdr->frame_control))) {
- 		check_da = NULL;
-@@ -2917,7 +2916,6 @@ __ieee80211_rx_h_amsdu(struct ieee80211_
- 		case NL80211_IFTYPE_MESH_POINT:
- 			check_sa = NULL;
- 			check_da = NULL;
--			mesh = true;
- 			break;
- 		default:
- 			break;
-@@ -2932,10 +2930,21 @@ __ieee80211_rx_h_amsdu(struct ieee80211_
- 					  data_offset, true))
- 		return RX_DROP_UNUSABLE;
- 
-+	if (rx->sta && rx->sta->amsdu_mesh_control < 0) {
-+		bool valid_std = ieee80211_is_valid_amsdu(skb, true);
-+		bool valid_nonstd = ieee80211_is_valid_amsdu(skb, false);
-+
-+		if (valid_std && !valid_nonstd)
-+			rx->sta->amsdu_mesh_control = 1;
-+		else if (valid_nonstd && !valid_std)
-+			rx->sta->amsdu_mesh_control = 0;
-+	}
-+
- 	ieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,
- 				 rx->sdata->vif.type,
- 				 rx->local->hw.extra_tx_headroom,
--				 check_da, check_sa, mesh);
-+				 check_da, check_sa,
-+				 rx->sta->amsdu_mesh_control);
- 
- 	while (!skb_queue_empty(&frame_list)) {
- 		rx->skb = __skb_dequeue(&frame_list);
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -591,6 +591,9 @@ __sta_info_alloc(struct ieee80211_sub_if
- 
- 	sta->sta_state = IEEE80211_STA_NONE;
- 
-+	if (sdata->vif.type == NL80211_IFTYPE_MESH_POINT)
-+		sta->amsdu_mesh_control = -1;
-+
- 	/* Mark TID as unreserved */
- 	sta->reserved_tid = IEEE80211_TID_UNRESERVED;
- 
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -702,6 +702,7 @@ struct sta_info {
- 	struct codel_params cparams;
- 
- 	u8 reserved_tid;
-+	s8 amsdu_mesh_control;
- 
- 	struct cfg80211_chan_def tdls_chandef;
- 
---- a/net/wireless/util.c
-+++ b/net/wireless/util.c
-@@ -776,6 +776,38 @@ __ieee80211_amsdu_copy(struct sk_buff *s
- 	return frame;
- }
- 
-+bool ieee80211_is_valid_amsdu(struct sk_buff *skb, bool mesh_hdr)
-+{
-+	int offset = 0, remaining, subframe_len, padding;
-+
-+	for (offset = 0; offset < skb->len; offset += subframe_len + padding) {
-+		struct {
-+		    __be16 len;
-+		    u8 mesh_flags;
-+		} hdr;
-+		u16 len;
-+
-+		if (skb_copy_bits(skb, offset + 2 * ETH_ALEN, &hdr, sizeof(hdr)) < 0)
-+			return false;
-+
-+		if (mesh_hdr)
-+			len = le16_to_cpu(*(__le16 *)&hdr.len) +
-+			      __ieee80211_get_mesh_hdrlen(hdr.mesh_flags);
-+		else
-+			len = ntohs(hdr.len);
-+
-+		subframe_len = sizeof(struct ethhdr) + len;
-+		padding = (4 - subframe_len) & 0x3;
-+		remaining = skb->len - offset;
-+
-+		if (subframe_len > remaining)
-+			return false;
-+	}
-+
-+	return true;
-+}
-+EXPORT_SYMBOL(ieee80211_is_valid_amsdu);
-+
- void ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,
- 			      const u8 *addr, enum nl80211_iftype iftype,
- 			      const unsigned int extra_headroom,
diff --git a/package/kernel/mac80211/patches/subsys/318-wifi-mac80211-fix-race-in-mesh-sequence-number-assig.patch b/package/kernel/mac80211/patches/subsys/318-wifi-mac80211-fix-race-in-mesh-sequence-number-assig.patch
deleted file mode 100644
index 7d01ffdf..00000000
--- a/package/kernel/mac80211/patches/subsys/318-wifi-mac80211-fix-race-in-mesh-sequence-number-assig.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Wed, 15 Feb 2023 15:21:37 +0100
-Subject: [PATCH] wifi: mac80211: fix race in mesh sequence number
- assignment
-
-Since the sequence number is shared across different tx queues, it needs
-to be atomic in order to avoid accidental duplicate assignment
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -696,7 +696,7 @@ struct ieee80211_if_mesh {
- 	struct mesh_stats mshstats;
- 	struct mesh_config mshcfg;
- 	atomic_t estab_plinks;
--	u32 mesh_seqnum;
-+	atomic_t mesh_seqnum;
- 	bool accepting_plinks;
- 	int num_gates;
- 	struct beacon_data __rcu *beacon;
---- a/net/mac80211/mesh.c
-+++ b/net/mac80211/mesh.c
-@@ -752,10 +752,8 @@ unsigned int ieee80211_new_mesh_header(s
- 
- 	meshhdr->ttl = sdata->u.mesh.mshcfg.dot11MeshTTL;
- 
--	/* FIXME: racy -- TX on multiple queues can be concurrent */
--	put_unaligned(cpu_to_le32(sdata->u.mesh.mesh_seqnum), &meshhdr->seqnum);
--	sdata->u.mesh.mesh_seqnum++;
--
-+	put_unaligned_le32(atomic_inc_return(&sdata->u.mesh.mesh_seqnum),
-+			   &meshhdr->seqnum);
- 	if (addr4or5 && !addr6) {
- 		meshhdr->flags |= MESH_FLAGS_AE_A4;
- 		memcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);
diff --git a/package/kernel/mac80211/patches/subsys/319-wifi-mac80211-mesh-fast-xmit-support.patch b/package/kernel/mac80211/patches/subsys/319-wifi-mac80211-mesh-fast-xmit-support.patch
deleted file mode 100644
index bbca773f..00000000
--- a/package/kernel/mac80211/patches/subsys/319-wifi-mac80211-mesh-fast-xmit-support.patch
+++ /dev/null
@@ -1,850 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 26 Feb 2023 13:53:08 +0100
-Subject: [PATCH] wifi: mac80211: mesh fast xmit support
-
-Previously, fast xmit only worked on interface types where initially a
-sta lookup is performed, and a cached header can be attached to the sta,
-requiring only some fields to be updated at runtime.
-
-This technique is not directly applicable for a mesh device type due
-to the dynamic nature of the topology and protocol. There are more
-addresses that need to be filled, and there is an extra header with a
-dynamic length based on the addressing mode.
-
-Change the code to cache entries contain a copy of the mesh subframe header +
-bridge tunnel header, as well as an embedded struct ieee80211_fast_tx, which
-contains the information for building the 802.11 header.
-
-Add a mesh specific early fast xmit call, which looks up a cached entry and
-adds only the mesh subframe header, before passing it over to the generic
-fast xmit code.
-
-To ensure the changes in network are reflected in these cached headers,
-flush affected cached entries on path changes, as well as other conditions
-that currently trigger a fast xmit check in other modes (key changes etc.)
-
-This code is loosely based on a previous implementation by:
-Sriram R <quic_srirrama@quicinc.com>
-
-Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -37,6 +37,7 @@
- extern const struct cfg80211_ops mac80211_config_ops;
- 
- struct ieee80211_local;
-+struct ieee80211_mesh_fast_tx;
- 
- /* Maximum number of broadcast/multicast frames to buffer when some of the
-  * associated stations are using power saving. */
-@@ -656,6 +657,19 @@ struct mesh_table {
- 	atomic_t entries;		/* Up to MAX_MESH_NEIGHBOURS */
- };
- 
-+/**
-+ * struct mesh_tx_cache - mesh fast xmit header cache
-+ *
-+ * @rht: hash table containing struct ieee80211_mesh_fast_tx, using skb DA as key
-+ * @walk_head: linked list containing all ieee80211_mesh_fast_tx objects
-+ * @walk_lock: lock protecting walk_head and rht
-+ */
-+struct mesh_tx_cache {
-+	struct rhashtable rht;
-+	struct hlist_head walk_head;
-+	spinlock_t walk_lock;
-+};
-+
- struct ieee80211_if_mesh {
- 	struct timer_list housekeeping_timer;
- 	struct timer_list mesh_path_timer;
-@@ -734,6 +748,7 @@ struct ieee80211_if_mesh {
- 	struct mesh_table mpp_paths; /* Store paths for MPP&MAP */
- 	int mesh_paths_generation;
- 	int mpp_paths_generation;
-+	struct mesh_tx_cache tx_cache;
- };
- 
- #ifdef CPTCFG_MAC80211_MESH
-@@ -2002,6 +2017,11 @@ int ieee80211_tx_control_port(struct wip
- 			      int link_id, u64 *cookie);
- int ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,
- 			      const u8 *buf, size_t len);
-+void __ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
-+			   struct sta_info *sta,
-+			   struct ieee80211_fast_tx *fast_tx,
-+			   struct sk_buff *skb, bool ampdu,
-+			   const u8 *da, const u8 *sa);
- 
- /* HT */
- void ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/mesh.c
-+++ b/net/mac80211/mesh.c
-@@ -10,6 +10,7 @@
- #include <asm/unaligned.h>
- #include "ieee80211_i.h"
- #include "mesh.h"
-+#include "wme.h"
- #include "driver-ops.h"
- 
- static int mesh_allocated;
-@@ -698,6 +699,95 @@ ieee80211_mesh_update_bss_params(struct
- 			__le32_to_cpu(he_oper->he_oper_params);
- }
- 
-+bool ieee80211_mesh_xmit_fast(struct ieee80211_sub_if_data *sdata,
-+			      struct sk_buff *skb, u32 ctrl_flags)
-+{
-+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
-+	struct ieee80211_mesh_fast_tx *entry;
-+	struct ieee80211s_hdr *meshhdr;
-+	u8 sa[ETH_ALEN] __aligned(2);
-+	struct tid_ampdu_tx *tid_tx;
-+	struct sta_info *sta;
-+	bool copy_sa = false;
-+	u16 ethertype;
-+	u8 tid;
-+
-+	if (ctrl_flags & IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP)
-+		return false;
-+
-+	if (ifmsh->mshcfg.dot11MeshNolearn)
-+		return false;
-+
-+	/* Add support for these cases later */
-+	if (ifmsh->ps_peers_light_sleep || ifmsh->ps_peers_deep_sleep)
-+		return false;
-+
-+	if (is_multicast_ether_addr(skb->data))
-+		return false;
-+
-+	ethertype = (skb->data[12] << 8) | skb->data[13];
-+	if (ethertype < ETH_P_802_3_MIN)
-+		return false;
-+
-+	if (skb->sk && skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)
-+		return false;
-+
-+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-+		skb_set_transport_header(skb, skb_checksum_start_offset(skb));
-+		if (skb_checksum_help(skb))
-+			return false;
-+	}
-+
-+	entry = mesh_fast_tx_get(sdata, skb->data);
-+	if (!entry)
-+		return false;
-+
-+	if (skb_headroom(skb) < entry->hdrlen + entry->fast_tx.hdr_len)
-+		return false;
-+
-+	sta = rcu_dereference(entry->mpath->next_hop);
-+	if (!sta)
-+		return false;
-+
-+	tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
-+	tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
-+	if (tid_tx) {
-+		if (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))
-+			return false;
-+		if (tid_tx->timeout)
-+			tid_tx->last_tx = jiffies;
-+	}
-+
-+	skb = skb_share_check(skb, GFP_ATOMIC);
-+	if (!skb)
-+		return true;
-+
-+	skb_set_queue_mapping(skb, ieee80211_select_queue(sdata, sta, skb));
-+
-+	meshhdr = (struct ieee80211s_hdr *)entry->hdr;
-+	if ((meshhdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6) {
-+		/* preserve SA from eth header for 6-addr frames */
-+		ether_addr_copy(sa, skb->data + ETH_ALEN);
-+		copy_sa = true;
-+	}
-+
-+	memcpy(skb_push(skb, entry->hdrlen - 2 * ETH_ALEN), entry->hdr,
-+	       entry->hdrlen);
-+
-+	meshhdr = (struct ieee80211s_hdr *)skb->data;
-+	put_unaligned_le32(atomic_inc_return(&sdata->u.mesh.mesh_seqnum),
-+			   &meshhdr->seqnum);
-+	meshhdr->ttl = sdata->u.mesh.mshcfg.dot11MeshTTL;
-+	if (copy_sa)
-+	    ether_addr_copy(meshhdr->eaddr2, sa);
-+
-+	skb_push(skb, 2 * ETH_ALEN);
-+	__ieee80211_xmit_fast(sdata, sta, &entry->fast_tx, skb, tid_tx,
-+			      entry->mpath->dst, sdata->vif.addr);
-+
-+	return true;
-+}
-+
- /**
-  * ieee80211_fill_mesh_addresses - fill addresses of a locally originated mesh frame
-  * @hdr:	802.11 frame header
-@@ -780,6 +870,8 @@ static void ieee80211_mesh_housekeeping(
- 	changed = mesh_accept_plinks_update(sdata);
- 	ieee80211_mbss_info_change_notify(sdata, changed);
- 
-+	mesh_fast_tx_gc(sdata);
-+
- 	mod_timer(&ifmsh->housekeeping_timer,
- 		  round_jiffies(jiffies +
- 				IEEE80211_MESH_HOUSEKEEPING_INTERVAL));
---- a/net/mac80211/mesh.h
-+++ b/net/mac80211/mesh.h
-@@ -122,11 +122,41 @@ struct mesh_path {
- 	u8 rann_snd_addr[ETH_ALEN];
- 	u32 rann_metric;
- 	unsigned long last_preq_to_root;
-+	unsigned long fast_tx_check;
- 	bool is_root;
- 	bool is_gate;
- 	u32 path_change_count;
- };
- 
-+#define MESH_FAST_TX_CACHE_MAX_SIZE		512
-+#define MESH_FAST_TX_CACHE_THRESHOLD_SIZE	384
-+#define MESH_FAST_TX_CACHE_TIMEOUT		8000 /* msecs */
-+
-+/**
-+ * struct ieee80211_mesh_fast_tx - cached mesh fast tx entry
-+ * @rhash: rhashtable pointer
-+ * @addr_key: The Ethernet DA which is the key for this entry
-+ * @fast_tx: base fast_tx data
-+ * @hdr: cached mesh and rfc1042 headers
-+ * @hdrlen: length of mesh + rfc1042
-+ * @walk_list: list containing all the fast tx entries
-+ * @mpath: mesh path corresponding to the Mesh DA
-+ * @mppath: MPP entry corresponding to this DA
-+ * @timestamp: Last used time of this entry
-+ */
-+struct ieee80211_mesh_fast_tx {
-+	struct rhash_head rhash;
-+	u8 addr_key[ETH_ALEN] __aligned(2);
-+
-+	struct ieee80211_fast_tx fast_tx;
-+	u8 hdr[sizeof(struct ieee80211s_hdr) + sizeof(rfc1042_header)];
-+	u16 hdrlen;
-+
-+	struct mesh_path *mpath, *mppath;
-+	struct hlist_node walk_list;
-+	unsigned long timestamp;
-+};
-+
- /* Recent multicast cache */
- /* RMC_BUCKETS must be a power of 2, maximum 256 */
- #define RMC_BUCKETS		256
-@@ -298,6 +328,20 @@ void mesh_path_discard_frame(struct ieee
- void mesh_path_tx_root_frame(struct ieee80211_sub_if_data *sdata);
- 
- bool mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt);
-+struct ieee80211_mesh_fast_tx *
-+mesh_fast_tx_get(struct ieee80211_sub_if_data *sdata, const u8 *addr);
-+bool ieee80211_mesh_xmit_fast(struct ieee80211_sub_if_data *sdata,
-+			      struct sk_buff *skb, u32 ctrl_flags);
-+void mesh_fast_tx_cache(struct ieee80211_sub_if_data *sdata,
-+			struct sk_buff *skb, struct mesh_path *mpath);
-+void mesh_fast_tx_gc(struct ieee80211_sub_if_data *sdata);
-+void mesh_fast_tx_flush_addr(struct ieee80211_sub_if_data *sdata,
-+			     const u8 *addr);
-+void mesh_fast_tx_flush_mpath(struct mesh_path *mpath);
-+void mesh_fast_tx_flush_sta(struct ieee80211_sub_if_data *sdata,
-+			    struct sta_info *sta);
-+void mesh_path_refresh(struct ieee80211_sub_if_data *sdata,
-+		       struct mesh_path *mpath, const u8 *addr);
- 
- #ifdef CPTCFG_MAC80211_MESH
- static inline
---- a/net/mac80211/mesh_hwmp.c
-+++ b/net/mac80211/mesh_hwmp.c
-@@ -394,6 +394,7 @@ static u32 hwmp_route_info_get(struct ie
- 	u32 orig_sn, orig_metric;
- 	unsigned long orig_lifetime, exp_time;
- 	u32 last_hop_metric, new_metric;
-+	bool flush_mpath = false;
- 	bool process = true;
- 	u8 hopcount;
- 
-@@ -491,8 +492,10 @@ static u32 hwmp_route_info_get(struct ie
- 		}
- 
- 		if (fresh_info) {
--			if (rcu_access_pointer(mpath->next_hop) != sta)
-+			if (rcu_access_pointer(mpath->next_hop) != sta) {
- 				mpath->path_change_count++;
-+				flush_mpath = true;
-+			}
- 			mesh_path_assign_nexthop(mpath, sta);
- 			mpath->flags |= MESH_PATH_SN_VALID;
- 			mpath->metric = new_metric;
-@@ -502,6 +505,8 @@ static u32 hwmp_route_info_get(struct ie
- 			mpath->hop_count = hopcount;
- 			mesh_path_activate(mpath);
- 			spin_unlock_bh(&mpath->state_lock);
-+			if (flush_mpath)
-+				mesh_fast_tx_flush_mpath(mpath);
- 			ewma_mesh_fail_avg_init(&sta->mesh->fail_avg);
- 			/* init it at a low value - 0 start is tricky */
- 			ewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);
-@@ -539,8 +544,10 @@ static u32 hwmp_route_info_get(struct ie
- 		}
- 
- 		if (fresh_info) {
--			if (rcu_access_pointer(mpath->next_hop) != sta)
-+			if (rcu_access_pointer(mpath->next_hop) != sta) {
- 				mpath->path_change_count++;
-+				flush_mpath = true;
-+			}
- 			mesh_path_assign_nexthop(mpath, sta);
- 			mpath->metric = last_hop_metric;
- 			mpath->exp_time = time_after(mpath->exp_time, exp_time)
-@@ -548,6 +555,8 @@ static u32 hwmp_route_info_get(struct ie
- 			mpath->hop_count = 1;
- 			mesh_path_activate(mpath);
- 			spin_unlock_bh(&mpath->state_lock);
-+			if (flush_mpath)
-+				mesh_fast_tx_flush_mpath(mpath);
- 			ewma_mesh_fail_avg_init(&sta->mesh->fail_avg);
- 			/* init it at a low value - 0 start is tricky */
- 			ewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);
-@@ -1215,6 +1224,20 @@ static int mesh_nexthop_lookup_nolearn(s
- 	return 0;
- }
- 
-+void mesh_path_refresh(struct ieee80211_sub_if_data *sdata,
-+		       struct mesh_path *mpath, const u8 *addr)
-+{
-+	if (mpath->flags & (MESH_PATH_REQ_QUEUED | MESH_PATH_FIXED |
-+			    MESH_PATH_RESOLVING))
-+		return;
-+
-+	if (time_after(jiffies,
-+		       mpath->exp_time -
-+		       msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time)) &&
-+	    (!addr || ether_addr_equal(sdata->vif.addr, addr)))
-+		mesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);
-+}
-+
- /**
-  * mesh_nexthop_lookup - put the appropriate next hop on a mesh frame. Calling
-  * this function is considered "using" the associated mpath, so preempt a path
-@@ -1242,19 +1265,15 @@ int mesh_nexthop_lookup(struct ieee80211
- 	if (!mpath || !(mpath->flags & MESH_PATH_ACTIVE))
- 		return -ENOENT;
- 
--	if (time_after(jiffies,
--		       mpath->exp_time -
--		       msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time)) &&
--	    ether_addr_equal(sdata->vif.addr, hdr->addr4) &&
--	    !(mpath->flags & MESH_PATH_RESOLVING) &&
--	    !(mpath->flags & MESH_PATH_FIXED))
--		mesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);
-+	mesh_path_refresh(sdata, mpath, hdr->addr4);
- 
- 	next_hop = rcu_dereference(mpath->next_hop);
- 	if (next_hop) {
- 		memcpy(hdr->addr1, next_hop->sta.addr, ETH_ALEN);
- 		memcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);
- 		ieee80211_mps_set_frame_flags(sdata, next_hop, hdr);
-+		if (ieee80211_hw_check(&sdata->local->hw, SUPPORT_FAST_XMIT))
-+			mesh_fast_tx_cache(sdata, skb, mpath);
- 		return 0;
- 	}
- 
---- a/net/mac80211/mesh_pathtbl.c
-+++ b/net/mac80211/mesh_pathtbl.c
-@@ -14,6 +14,7 @@
- #include "wme.h"
- #include "ieee80211_i.h"
- #include "mesh.h"
-+#include <linux/rhashtable.h>
- 
- static void mesh_path_free_rcu(struct mesh_table *tbl, struct mesh_path *mpath);
- 
-@@ -32,6 +33,41 @@ static const struct rhashtable_params me
- 	.hashfn = mesh_table_hash,
- };
- 
-+static const struct rhashtable_params fast_tx_rht_params = {
-+	.nelem_hint = 10,
-+	.automatic_shrinking = true,
-+	.key_len = ETH_ALEN,
-+	.key_offset = offsetof(struct ieee80211_mesh_fast_tx, addr_key),
-+	.head_offset = offsetof(struct ieee80211_mesh_fast_tx, rhash),
-+	.hashfn = mesh_table_hash,
-+};
-+
-+static void __mesh_fast_tx_entry_free(void *ptr, void *tblptr)
-+{
-+	struct ieee80211_mesh_fast_tx *entry = ptr;
-+
-+	kfree_rcu(entry, fast_tx.rcu_head);
-+}
-+
-+static void mesh_fast_tx_deinit(struct ieee80211_sub_if_data *sdata)
-+{
-+	struct mesh_tx_cache *cache;
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	rhashtable_free_and_destroy(&cache->rht,
-+				    __mesh_fast_tx_entry_free, NULL);
-+}
-+
-+static void mesh_fast_tx_init(struct ieee80211_sub_if_data *sdata)
-+{
-+	struct mesh_tx_cache *cache;
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	rhashtable_init(&cache->rht, &fast_tx_rht_params);
-+	INIT_HLIST_HEAD(&cache->walk_head);
-+	spin_lock_init(&cache->walk_lock);
-+}
-+
- static inline bool mpath_expired(struct mesh_path *mpath)
- {
- 	return (mpath->flags & MESH_PATH_ACTIVE) &&
-@@ -381,6 +417,243 @@ struct mesh_path *mesh_path_new(struct i
- 	return new_mpath;
- }
- 
-+static void mesh_fast_tx_entry_free(struct mesh_tx_cache *cache,
-+				    struct ieee80211_mesh_fast_tx *entry)
-+{
-+	hlist_del_rcu(&entry->walk_list);
-+	rhashtable_remove_fast(&cache->rht, &entry->rhash, fast_tx_rht_params);
-+	kfree_rcu(entry, fast_tx.rcu_head);
-+}
-+
-+struct ieee80211_mesh_fast_tx *
-+mesh_fast_tx_get(struct ieee80211_sub_if_data *sdata, const u8 *addr)
-+{
-+	struct ieee80211_mesh_fast_tx *entry;
-+	struct mesh_tx_cache *cache;
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	entry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);
-+	if (!entry)
-+		return NULL;
-+
-+	if (!(entry->mpath->flags & MESH_PATH_ACTIVE) ||
-+	    mpath_expired(entry->mpath)) {
-+		spin_lock_bh(&cache->walk_lock);
-+		entry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);
-+		if (entry)
-+		    mesh_fast_tx_entry_free(cache, entry);
-+		spin_unlock_bh(&cache->walk_lock);
-+		return NULL;
-+	}
-+
-+	mesh_path_refresh(sdata, entry->mpath, NULL);
-+	if (entry->mppath)
-+		entry->mppath->exp_time = jiffies;
-+	entry->timestamp = jiffies;
-+
-+	return entry;
-+}
-+
-+void mesh_fast_tx_cache(struct ieee80211_sub_if_data *sdata,
-+			struct sk_buff *skb, struct mesh_path *mpath)
-+{
-+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-+	struct ieee80211_mesh_fast_tx *entry, *prev;
-+	struct ieee80211_mesh_fast_tx build = {};
-+	struct ieee80211s_hdr *meshhdr;
-+	struct mesh_tx_cache *cache;
-+	struct ieee80211_key *key;
-+	struct mesh_path *mppath;
-+	struct sta_info *sta;
-+	u8 *qc;
-+
-+	if (sdata->noack_map ||
-+	    !ieee80211_is_data_qos(hdr->frame_control))
-+		return;
-+
-+	build.fast_tx.hdr_len = ieee80211_hdrlen(hdr->frame_control);
-+	meshhdr = (struct ieee80211s_hdr *)(skb->data + build.fast_tx.hdr_len);
-+	build.hdrlen = ieee80211_get_mesh_hdrlen(meshhdr);
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	if (atomic_read(&cache->rht.nelems) >= MESH_FAST_TX_CACHE_MAX_SIZE)
-+		return;
-+
-+	sta = rcu_dereference(mpath->next_hop);
-+	if (!sta)
-+		return;
-+
-+	if ((meshhdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6) {
-+		/* This is required to keep the mppath alive */
-+		mppath = mpp_path_lookup(sdata, meshhdr->eaddr1);
-+		if (!mppath)
-+			return;
-+		build.mppath = mppath;
-+	} else if (ieee80211_has_a4(hdr->frame_control)) {
-+		mppath = mpath;
-+	} else {
-+		return;
-+	}
-+
-+	/* rate limit, in case fast xmit can't be enabled */
-+	if (mppath->fast_tx_check == jiffies)
-+		return;
-+
-+	mppath->fast_tx_check = jiffies;
-+
-+	/*
-+	 * Same use of the sta lock as in ieee80211_check_fast_xmit, in order
-+	 * to protect against concurrent sta key updates.
-+	 */
-+	spin_lock_bh(&sta->lock);
-+	key = rcu_access_pointer(sta->ptk[sta->ptk_idx]);
-+	if (!key)
-+		key = rcu_access_pointer(sdata->default_unicast_key);
-+	build.fast_tx.key = key;
-+
-+	if (key) {
-+		bool gen_iv, iv_spc;
-+
-+		gen_iv = key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV;
-+		iv_spc = key->conf.flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE;
-+
-+		if (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE) ||
-+		    (key->flags & KEY_FLAG_TAINTED))
-+			goto unlock_sta;
-+
-+		switch (key->conf.cipher) {
-+		case WLAN_CIPHER_SUITE_CCMP:
-+		case WLAN_CIPHER_SUITE_CCMP_256:
-+			if (gen_iv)
-+				build.fast_tx.pn_offs = build.fast_tx.hdr_len;
-+			if (gen_iv || iv_spc)
-+				build.fast_tx.hdr_len += IEEE80211_CCMP_HDR_LEN;
-+			break;
-+		case WLAN_CIPHER_SUITE_GCMP:
-+		case WLAN_CIPHER_SUITE_GCMP_256:
-+			if (gen_iv)
-+				build.fast_tx.pn_offs = build.fast_tx.hdr_len;
-+			if (gen_iv || iv_spc)
-+				build.fast_tx.hdr_len += IEEE80211_GCMP_HDR_LEN;
-+			break;
-+		default:
-+			goto unlock_sta;
-+		}
-+	}
-+
-+	memcpy(build.addr_key, mppath->dst, ETH_ALEN);
-+	build.timestamp = jiffies;
-+	build.fast_tx.band = info->band;
-+	build.fast_tx.da_offs = offsetof(struct ieee80211_hdr, addr3);
-+	build.fast_tx.sa_offs = offsetof(struct ieee80211_hdr, addr4);
-+	build.mpath = mpath;
-+	memcpy(build.hdr, meshhdr, build.hdrlen);
-+	memcpy(build.hdr + build.hdrlen, rfc1042_header, sizeof(rfc1042_header));
-+	build.hdrlen += sizeof(rfc1042_header);
-+	memcpy(build.fast_tx.hdr, hdr, build.fast_tx.hdr_len);
-+
-+	hdr = (struct ieee80211_hdr *)build.fast_tx.hdr;
-+	if (build.fast_tx.key)
-+		hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
-+
-+	qc = ieee80211_get_qos_ctl(hdr);
-+	qc[1] |= IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT >> 8;
-+
-+	entry = kmemdup(&build, sizeof(build), GFP_ATOMIC);
-+	if (!entry)
-+		goto unlock_sta;
-+
-+	spin_lock(&cache->walk_lock);
-+	prev = rhashtable_lookup_get_insert_fast(&cache->rht,
-+						 &entry->rhash,
-+						 fast_tx_rht_params);
-+	if (unlikely(IS_ERR(prev))) {
-+		kfree(entry);
-+		goto unlock_cache;
-+	}
-+
-+	/*
-+	 * replace any previous entry in the hash table, in case we're
-+	 * replacing it with a different type (e.g. mpath -> mpp)
-+	 */
-+	if (unlikely(prev)) {
-+		rhashtable_replace_fast(&cache->rht, &prev->rhash,
-+					&entry->rhash, fast_tx_rht_params);
-+		hlist_del_rcu(&prev->walk_list);
-+		kfree_rcu(prev, fast_tx.rcu_head);
-+	}
-+
-+	hlist_add_head(&entry->walk_list, &cache->walk_head);
-+
-+unlock_cache:
-+	spin_unlock(&cache->walk_lock);
-+unlock_sta:
-+	spin_unlock_bh(&sta->lock);
-+}
-+
-+void mesh_fast_tx_gc(struct ieee80211_sub_if_data *sdata)
-+{
-+	unsigned long timeout = msecs_to_jiffies(MESH_FAST_TX_CACHE_TIMEOUT);
-+	struct mesh_tx_cache *cache;
-+	struct ieee80211_mesh_fast_tx *entry;
-+	struct hlist_node *n;
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	if (atomic_read(&cache->rht.nelems) < MESH_FAST_TX_CACHE_THRESHOLD_SIZE)
-+		return;
-+
-+	spin_lock_bh(&cache->walk_lock);
-+	hlist_for_each_entry_safe(entry, n, &cache->walk_head, walk_list)
-+		if (!time_is_after_jiffies(entry->timestamp + timeout))
-+			mesh_fast_tx_entry_free(cache, entry);
-+	spin_unlock_bh(&cache->walk_lock);
-+}
-+
-+void mesh_fast_tx_flush_mpath(struct mesh_path *mpath)
-+{
-+	struct ieee80211_sub_if_data *sdata = mpath->sdata;
-+	struct mesh_tx_cache *cache = &sdata->u.mesh.tx_cache;
-+	struct ieee80211_mesh_fast_tx *entry;
-+	struct hlist_node *n;
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	spin_lock_bh(&cache->walk_lock);
-+	hlist_for_each_entry_safe(entry, n, &cache->walk_head, walk_list)
-+		if (entry->mpath == mpath)
-+			mesh_fast_tx_entry_free(cache, entry);
-+	spin_unlock_bh(&cache->walk_lock);
-+}
-+
-+void mesh_fast_tx_flush_sta(struct ieee80211_sub_if_data *sdata,
-+			    struct sta_info *sta)
-+{
-+	struct mesh_tx_cache *cache = &sdata->u.mesh.tx_cache;
-+	struct ieee80211_mesh_fast_tx *entry;
-+	struct hlist_node *n;
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	spin_lock_bh(&cache->walk_lock);
-+	hlist_for_each_entry_safe(entry, n, &cache->walk_head, walk_list)
-+		if (rcu_access_pointer(entry->mpath->next_hop) == sta)
-+			mesh_fast_tx_entry_free(cache, entry);
-+	spin_unlock_bh(&cache->walk_lock);
-+}
-+
-+void mesh_fast_tx_flush_addr(struct ieee80211_sub_if_data *sdata,
-+			     const u8 *addr)
-+{
-+	struct mesh_tx_cache *cache = &sdata->u.mesh.tx_cache;
-+	struct ieee80211_mesh_fast_tx *entry;
-+
-+	cache = &sdata->u.mesh.tx_cache;
-+	spin_lock_bh(&cache->walk_lock);
-+	entry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);
-+	if (entry)
-+		mesh_fast_tx_entry_free(cache, entry);
-+	spin_unlock_bh(&cache->walk_lock);
-+}
-+
- /**
-  * mesh_path_add - allocate and add a new path to the mesh path table
-  * @dst: destination address of the path (ETH_ALEN length)
-@@ -464,6 +737,8 @@ int mpp_path_add(struct ieee80211_sub_if
- 
- 	if (ret)
- 		kfree(new_mpath);
-+	else
-+		mesh_fast_tx_flush_addr(sdata, dst);
- 
- 	sdata->u.mesh.mpp_paths_generation++;
- 	return ret;
-@@ -523,6 +798,10 @@ static void __mesh_path_del(struct mesh_
- {
- 	hlist_del_rcu(&mpath->walk_list);
- 	rhashtable_remove_fast(&tbl->rhead, &mpath->rhash, mesh_rht_params);
-+	if (tbl == &mpath->sdata->u.mesh.mpp_paths)
-+		mesh_fast_tx_flush_addr(mpath->sdata, mpath->dst);
-+	else
-+		mesh_fast_tx_flush_mpath(mpath);
- 	mesh_path_free_rcu(tbl, mpath);
- }
- 
-@@ -747,6 +1026,7 @@ void mesh_path_fix_nexthop(struct mesh_p
- 	mpath->exp_time = 0;
- 	mpath->flags = MESH_PATH_FIXED | MESH_PATH_SN_VALID;
- 	mesh_path_activate(mpath);
-+	mesh_fast_tx_flush_mpath(mpath);
- 	spin_unlock_bh(&mpath->state_lock);
- 	ewma_mesh_fail_avg_init(&next_hop->mesh->fail_avg);
- 	/* init it at a low value - 0 start is tricky */
-@@ -758,6 +1038,7 @@ void mesh_pathtbl_init(struct ieee80211_
- {
- 	mesh_table_init(&sdata->u.mesh.mesh_paths);
- 	mesh_table_init(&sdata->u.mesh.mpp_paths);
-+	mesh_fast_tx_init(sdata);
- }
- 
- static
-@@ -785,6 +1066,7 @@ void mesh_path_expire(struct ieee80211_s
- 
- void mesh_pathtbl_unregister(struct ieee80211_sub_if_data *sdata)
- {
-+	mesh_fast_tx_deinit(sdata);
- 	mesh_table_free(&sdata->u.mesh.mesh_paths);
- 	mesh_table_free(&sdata->u.mesh.mpp_paths);
- }
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2791,6 +2791,7 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 	if (mesh_hdr->flags & MESH_FLAGS_AE) {
- 		struct mesh_path *mppath;
- 		char *proxied_addr;
-+		bool update = false;
- 
- 		if (multicast)
- 			proxied_addr = mesh_hdr->eaddr1;
-@@ -2806,11 +2807,18 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 			mpp_path_add(sdata, proxied_addr, eth->h_source);
- 		} else {
- 			spin_lock_bh(&mppath->state_lock);
--			if (!ether_addr_equal(mppath->mpp, eth->h_source))
-+			if (!ether_addr_equal(mppath->mpp, eth->h_source)) {
- 				memcpy(mppath->mpp, eth->h_source, ETH_ALEN);
-+				update = true;
-+			}
- 			mppath->exp_time = jiffies;
- 			spin_unlock_bh(&mppath->state_lock);
- 		}
-+
-+		/* flush fast xmit cache if the address path changed */
-+		if (update)
-+			mesh_fast_tx_flush_addr(sdata, proxied_addr);
-+
- 		rcu_read_unlock();
- 	}
- 
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3026,6 +3026,9 @@ void ieee80211_check_fast_xmit(struct st
- 	if (!ieee80211_hw_check(&local->hw, SUPPORT_FAST_XMIT))
- 		return;
- 
-+	if (ieee80211_vif_is_mesh(&sdata->vif))
-+		mesh_fast_tx_flush_sta(sdata, sta);
-+
- 	/* Locking here protects both the pointer itself, and against concurrent
- 	 * invocations winning data access races to, e.g., the key pointer that
- 	 * is used.
-@@ -3407,6 +3410,9 @@ static bool ieee80211_amsdu_aggregate(st
- 	if (sdata->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
- 		return false;
- 
-+	if (ieee80211_vif_is_mesh(&sdata->vif))
-+		return false;
-+
- 	if (skb_is_gso(skb))
- 		return false;
- 
-@@ -3639,10 +3645,11 @@ free:
- 	return NULL;
- }
- 
--static void __ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
--				  struct sta_info *sta,
--				  struct ieee80211_fast_tx *fast_tx,
--				  struct sk_buff *skb, u8 tid, bool ampdu)
-+void __ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
-+			   struct sta_info *sta,
-+			   struct ieee80211_fast_tx *fast_tx,
-+			   struct sk_buff *skb, bool ampdu,
-+			   const u8 *da, const u8 *sa)
- {
- 	struct ieee80211_local *local = sdata->local;
- 	struct ieee80211_hdr *hdr = (void *)fast_tx->hdr;
-@@ -3651,7 +3658,6 @@ static void __ieee80211_xmit_fast(struct
- 	ieee80211_tx_result r;
- 	int hw_headroom = sdata->local->hw.extra_tx_headroom;
- 	int extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);
--	struct ethhdr eth;
- 
- 	skb = skb_share_check(skb, GFP_ATOMIC);
- 	if (unlikely(!skb))
-@@ -3671,11 +3677,10 @@ static void __ieee80211_xmit_fast(struct
- 					  ENCRYPT_NO)))
- 		goto free;
- 
--	memcpy(&eth, skb->data, ETH_HLEN - 2);
- 	hdr = skb_push(skb, extra_head);
- 	memcpy(skb->data, fast_tx->hdr, fast_tx->hdr_len);
--	memcpy(skb->data + fast_tx->da_offs, eth.h_dest, ETH_ALEN);
--	memcpy(skb->data + fast_tx->sa_offs, eth.h_source, ETH_ALEN);
-+	memcpy(skb->data + fast_tx->da_offs, da, ETH_ALEN);
-+	memcpy(skb->data + fast_tx->sa_offs, sa, ETH_ALEN);
- 
- 	info = IEEE80211_SKB_CB(skb);
- 	memset(info, 0, sizeof(*info));
-@@ -3694,7 +3699,8 @@ static void __ieee80211_xmit_fast(struct
- #endif
- 
- 	if (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {
--		tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
-+		u8 tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
-+
- 		*ieee80211_get_qos_ctl(hdr) = tid;
- 	}
- 
-@@ -3737,6 +3743,7 @@ static bool ieee80211_xmit_fast(struct i
- 	struct ieee80211_hdr *hdr = (void *)fast_tx->hdr;
- 	struct tid_ampdu_tx *tid_tx = NULL;
- 	struct sk_buff *next;
-+	struct ethhdr eth;
- 	u8 tid = IEEE80211_NUM_TIDS;
- 
- 	/* control port protocol needs a lot of special handling */
-@@ -3762,6 +3769,8 @@ static bool ieee80211_xmit_fast(struct i
- 		}
- 	}
- 
-+	memcpy(&eth, skb->data, ETH_HLEN - 2);
-+
- 	/* after this point (skb is modified) we cannot return false */
- 	skb = ieee80211_tx_skb_fixup(skb, ieee80211_sdata_netdev_features(sdata));
- 	if (!skb)
-@@ -3769,7 +3778,8 @@ static bool ieee80211_xmit_fast(struct i
- 
- 	skb_list_walk_safe(skb, skb, next) {
- 		skb_mark_not_on_list(skb);
--		__ieee80211_xmit_fast(sdata, sta, fast_tx, skb, tid, tid_tx);
-+		__ieee80211_xmit_fast(sdata, sta, fast_tx, skb, tid_tx,
-+				      eth.h_dest, eth.h_source);
- 	}
- 
- 	return true;
-@@ -4256,8 +4266,15 @@ void __ieee80211_subif_start_xmit(struct
- 		return;
- 	}
- 
-+	sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
-+
- 	rcu_read_lock();
- 
-+	if (ieee80211_vif_is_mesh(&sdata->vif) &&
-+	    ieee80211_hw_check(&local->hw, SUPPORT_FAST_XMIT) &&
-+	    ieee80211_mesh_xmit_fast(sdata, skb, ctrl_flags))
-+		goto out;
-+
- 	if (ieee80211_lookup_ra_sta(sdata, skb, &sta))
- 		goto out_free;
- 
-@@ -4267,8 +4284,6 @@ void __ieee80211_subif_start_xmit(struct
- 	skb_set_queue_mapping(skb, ieee80211_select_queue(sdata, sta, skb));
- 	ieee80211_aggr_check(sdata, sta, skb);
- 
--	sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
--
- 	if (sta) {
- 		struct ieee80211_fast_tx *fast_tx;
- 
diff --git a/package/kernel/mac80211/patches/subsys/320-wifi-mac80211-use-mesh-header-cache-to-speed-up-mesh.patch b/package/kernel/mac80211/patches/subsys/320-wifi-mac80211-use-mesh-header-cache-to-speed-up-mesh.patch
deleted file mode 100644
index 711c5f36..00000000
--- a/package/kernel/mac80211/patches/subsys/320-wifi-mac80211-use-mesh-header-cache-to-speed-up-mesh.patch
+++ /dev/null
@@ -1,132 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 16 Feb 2023 11:07:30 +0100
-Subject: [PATCH] wifi: mac80211: use mesh header cache to speed up mesh
- forwarding
-
-Significantly reduces mesh forwarding path CPU usage and enables the
-direct use of iTXQ.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2720,6 +2720,65 @@ ieee80211_deliver_skb(struct ieee80211_r
- 	}
- }
- 
-+#ifdef CPTCFG_MAC80211_MESH
-+static bool
-+ieee80211_rx_mesh_fast_forward(struct ieee80211_sub_if_data *sdata,
-+			       struct sk_buff *skb, int hdrlen)
-+{
-+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
-+	struct ieee80211_mesh_fast_tx *entry = NULL;
-+	struct ieee80211s_hdr *mesh_hdr;
-+	struct tid_ampdu_tx *tid_tx;
-+	struct sta_info *sta;
-+	struct ethhdr eth;
-+	u8 tid;
-+
-+	mesh_hdr = (struct ieee80211s_hdr *)(skb->data + sizeof(eth));
-+	if ((mesh_hdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6)
-+		entry = mesh_fast_tx_get(sdata, mesh_hdr->eaddr1);
-+	else if (!(mesh_hdr->flags & MESH_FLAGS_AE))
-+		entry = mesh_fast_tx_get(sdata, skb->data);
-+	if (!entry)
-+		return false;
-+
-+	sta = rcu_dereference(entry->mpath->next_hop);
-+	if (!sta)
-+		return false;
-+
-+	if (skb_linearize(skb))
-+		return false;
-+
-+	tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;
-+	tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
-+	if (tid_tx) {
-+		if (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))
-+			return false;
-+
-+		if (tid_tx->timeout)
-+			tid_tx->last_tx = jiffies;
-+	}
-+
-+	ieee80211_aggr_check(sdata, sta, skb);
-+
-+	if (ieee80211_get_8023_tunnel_proto(skb->data + hdrlen,
-+					    &skb->protocol))
-+		hdrlen += ETH_ALEN;
-+	else
-+		skb->protocol = htons(skb->len - hdrlen);
-+	skb_set_network_header(skb, hdrlen + 2);
-+
-+	skb->dev = sdata->dev;
-+	memcpy(&eth, skb->data, ETH_HLEN - 2);
-+	skb_pull(skb, 2);
-+	__ieee80211_xmit_fast(sdata, sta, &entry->fast_tx, skb, tid_tx,
-+			      eth.h_dest, eth.h_source);
-+	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_unicast);
-+	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);
-+
-+	return true;
-+}
-+#endif
-+
- static ieee80211_rx_result
- ieee80211_rx_mesh_data(struct ieee80211_sub_if_data *sdata, struct sta_info *sta,
- 		       struct sk_buff *skb)
-@@ -2824,6 +2883,10 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 
- 	skb_set_queue_mapping(skb, ieee802_1d_to_ac[skb->priority]);
- 
-+	if (!multicast &&
-+	    ieee80211_rx_mesh_fast_forward(sdata, skb, mesh_hdrlen))
-+		return RX_QUEUED;
-+
- 	ieee80211_fill_mesh_addresses(&hdr, &hdr.frame_control,
- 				      eth->h_dest, eth->h_source);
- 	hdrlen = ieee80211_hdrlen(hdr.frame_control);
-@@ -2862,6 +2925,7 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 	info->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;
- 	info->control.vif = &sdata->vif;
- 	info->control.jiffies = jiffies;
-+	fwd_skb->dev = sdata->dev;
- 	if (multicast) {
- 		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_mcast);
- 		memcpy(fwd_hdr->addr2, sdata->vif.addr, ETH_ALEN);
-@@ -2883,7 +2947,6 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 	}
- 
- 	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);
--	fwd_skb->dev = sdata->dev;
- 	ieee80211_add_pending_skb(local, fwd_skb);
- 
- rx_accept:
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -2022,6 +2022,8 @@ void __ieee80211_xmit_fast(struct ieee80
- 			   struct ieee80211_fast_tx *fast_tx,
- 			   struct sk_buff *skb, bool ampdu,
- 			   const u8 *da, const u8 *sa);
-+void ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,
-+			  struct sta_info *sta, struct sk_buff *skb);
- 
- /* HT */
- void ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1195,10 +1195,8 @@ static bool ieee80211_tx_prep_agg(struct
- 	return queued;
- }
- 
--static void
--ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,
--		     struct sta_info *sta,
--		     struct sk_buff *skb)
-+void ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,
-+			  struct sta_info *sta, struct sk_buff *skb)
- {
- 	struct rate_control_ref *ref = sdata->local->rate_ctrl;
- 	u16 tid;
diff --git a/package/kernel/mac80211/patches/subsys/321-mac80211-fix-mesh-forwarding.patch b/package/kernel/mac80211/patches/subsys/321-mac80211-fix-mesh-forwarding.patch
deleted file mode 100644
index e2b268ae..00000000
--- a/package/kernel/mac80211/patches/subsys/321-mac80211-fix-mesh-forwarding.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 20 Feb 2023 12:50:50 +0100
-Subject: [PATCH] mac80211: fix mesh forwarding
-
-Linearize packets (needed for forwarding A-MSDU subframes).
-Fix network header offset to fix flow dissector (and fair queueing).
-
-Fixes: 986e43b19ae9 ("wifi: mac80211: fix receiving A-MSDU frames on mesh interfaces")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2904,6 +2904,9 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 
- 		if (skb_cow_head(fwd_skb, hdrlen - sizeof(struct ethhdr)))
- 			return RX_DROP_UNUSABLE;
-+
-+		if (skb_linearize(fwd_skb))
-+			return RX_DROP_UNUSABLE;
- 	}
- 
- 	fwd_hdr = skb_push(fwd_skb, hdrlen - sizeof(struct ethhdr));
-@@ -2918,7 +2921,7 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 		hdrlen += ETH_ALEN;
- 	else
- 		fwd_skb->protocol = htons(fwd_skb->len - hdrlen);
--	skb_set_network_header(fwd_skb, hdrlen);
-+	skb_set_network_header(fwd_skb, hdrlen + 2);
- 
- 	info = IEEE80211_SKB_CB(fwd_skb);
- 	memset(info, 0, sizeof(*info));
diff --git a/package/kernel/mac80211/patches/subsys/322-wifi-mac80211-fix-mesh-path-discovery-based-on-unica.patch b/package/kernel/mac80211/patches/subsys/322-wifi-mac80211-fix-mesh-path-discovery-based-on-unica.patch
deleted file mode 100644
index 292a89ef..00000000
--- a/package/kernel/mac80211/patches/subsys/322-wifi-mac80211-fix-mesh-path-discovery-based-on-unica.patch
+++ /dev/null
@@ -1,52 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 26 Feb 2023 20:30:20 +0100
-Subject: [PATCH] wifi: mac80211: fix mesh path discovery based on unicast
- packets
-
-If a packet has reached its intended destination, it was bumped to the code
-that accepts it, without first checking if a mesh_path needs to be created
-based on the discovered source.
-Fix this by moving the destination address check further down
-
-Fixes: 986e43b19ae9 ("wifi: mac80211: fix receiving A-MSDU frames on mesh interfaces")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2824,17 +2824,6 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 	    mesh_rmc_check(sdata, eth->h_source, mesh_hdr))
- 		return RX_DROP_MONITOR;
- 
--	/* Frame has reached destination.  Don't forward */
--	if (ether_addr_equal(sdata->vif.addr, eth->h_dest))
--		goto rx_accept;
--
--	if (!ifmsh->mshcfg.dot11MeshForwarding) {
--		if (is_multicast_ether_addr(eth->h_dest))
--			goto rx_accept;
--
--		return RX_DROP_MONITOR;
--	}
--
- 	/* forward packet */
- 	if (sdata->crypto_tx_tailroom_needed_cnt)
- 		tailroom = IEEE80211_ENCRYPT_TAILROOM;
-@@ -2881,6 +2870,17 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 		rcu_read_unlock();
- 	}
- 
-+	/* Frame has reached destination.  Don't forward */
-+	if (ether_addr_equal(sdata->vif.addr, eth->h_dest))
-+		goto rx_accept;
-+
-+	if (!ifmsh->mshcfg.dot11MeshForwarding) {
-+		if (is_multicast_ether_addr(eth->h_dest))
-+			goto rx_accept;
-+
-+		return RX_DROP_MONITOR;
-+	}
-+
- 	skb_set_queue_mapping(skb, ieee802_1d_to_ac[skb->priority]);
- 
- 	if (!multicast &&
diff --git a/package/kernel/mac80211/patches/subsys/323-v6.3-wifi-mac80211-Add-VHT-MU-MIMO-related-flags-in-ieee8.patch b/package/kernel/mac80211/patches/subsys/323-v6.3-wifi-mac80211-Add-VHT-MU-MIMO-related-flags-in-ieee8.patch
deleted file mode 100644
index e23dc4d2..00000000
--- a/package/kernel/mac80211/patches/subsys/323-v6.3-wifi-mac80211-Add-VHT-MU-MIMO-related-flags-in-ieee8.patch
+++ /dev/null
@@ -1,68 +0,0 @@
-From: Muna Sinada <quic_msinada@quicinc.com>
-Date: Wed, 5 Oct 2022 14:54:45 -0700
-Subject: [PATCH] wifi: mac80211: Add VHT MU-MIMO related flags in
- ieee80211_bss_conf
-
-Adding flags for SU Beamformer, SU Beamformee, MU Beamformer and
-MU Beamformee for VHT. This is utilized to pass MU-MIMO
-configurations from user space to driver in AP mode.
-
-Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
-Link: https://lore.kernel.org/r/1665006886-23874-1-git-send-email-quic_msinada@quicinc.com
-[fixed indentation, removed redundant !!]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -653,6 +653,14 @@ struct ieee80211_fils_discovery {
-  *	write-protected by sdata_lock and local->mtx so holding either is fine
-  *	for read access.
-  * @color_change_color: the bss color that will be used after the change.
-+ * @vht_su_beamformer: in AP mode, does this BSS support operation as an VHT SU
-+ *	beamformer
-+ * @vht_su_beamformee: in AP mode, does this BSS support operation as an VHT SU
-+ *	beamformee
-+ * @vht_mu_beamformer: in AP mode, does this BSS support operation as an VHT MU
-+ *	beamformer
-+ * @vht_mu_beamformee: in AP mode, does this BSS support operation as an VHT MU
-+ *	beamformee
-  */
- struct ieee80211_bss_conf {
- 	const u8 *bssid;
-@@ -726,6 +734,11 @@ struct ieee80211_bss_conf {
- 
- 	bool color_change_active;
- 	u8 color_change_color;
-+
-+	bool vht_su_beamformer;
-+	bool vht_su_beamformee;
-+	bool vht_mu_beamformer;
-+	bool vht_mu_beamformee;
- };
- 
- /**
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1252,6 +1252,21 @@ static int ieee80211_start_ap(struct wip
- 	prev_beacon_int = link_conf->beacon_int;
- 	link_conf->beacon_int = params->beacon_interval;
- 
-+	if (params->vht_cap) {
-+		link_conf->vht_su_beamformer =
-+			params->vht_cap->vht_cap_info &
-+				cpu_to_le32(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);
-+		link_conf->vht_su_beamformee =
-+			params->vht_cap->vht_cap_info &
-+				cpu_to_le32(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);
-+		link_conf->vht_mu_beamformer =
-+			params->vht_cap->vht_cap_info &
-+				cpu_to_le32(IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE);
-+		link_conf->vht_mu_beamformee =
-+			params->vht_cap->vht_cap_info &
-+				cpu_to_le32(IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);
-+	}
-+
- 	if (params->he_cap && params->he_oper) {
- 		link_conf->he_support = true;
- 		link_conf->htc_trig_based_pkt_ext =
diff --git a/package/kernel/mac80211/patches/subsys/324-v6.3-wifi-mac80211-Add-HE-MU-MIMO-related-flags-in-ieee80.patch b/package/kernel/mac80211/patches/subsys/324-v6.3-wifi-mac80211-Add-HE-MU-MIMO-related-flags-in-ieee80.patch
deleted file mode 100644
index f843dba1..00000000
--- a/package/kernel/mac80211/patches/subsys/324-v6.3-wifi-mac80211-Add-HE-MU-MIMO-related-flags-in-ieee80.patch
+++ /dev/null
@@ -1,68 +0,0 @@
-From: Muna Sinada <quic_msinada@quicinc.com>
-Date: Wed, 5 Oct 2022 14:54:46 -0700
-Subject: [PATCH] wifi: mac80211: Add HE MU-MIMO related flags in
- ieee80211_bss_conf
-
-Adding flags for SU Beamformer, SU Beamformee, MU Beamformer and Full
-Bandwidth UL MU-MIMO for HE. This is utilized to pass MU-MIMO
-configurations from user space to driver in AP mode.
-
-Signed-off-by: Muna Sinada <quic_msinada@quicinc.com>
-Link: https://lore.kernel.org/r/1665006886-23874-2-git-send-email-quic_msinada@quicinc.com
-[fixed indentation, removed redundant !!]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -661,6 +661,15 @@ struct ieee80211_fils_discovery {
-  *	beamformer
-  * @vht_mu_beamformee: in AP mode, does this BSS support operation as an VHT MU
-  *	beamformee
-+ * @he_su_beamformer: in AP-mode, does this BSS support operation as an HE SU
-+ *	beamformer
-+ * @he_su_beamformee: in AP-mode, does this BSS support operation as an HE SU
-+ *	beamformee
-+ * @he_mu_beamformer: in AP-mode, does this BSS support operation as an HE MU
-+ *	beamformer
-+ * @he_full_ul_mumimo: does this BSS support the reception (AP) or transmission
-+ *	(non-AP STA) of an HE TB PPDU on an RU that spans the entire PPDU
-+ *	bandwidth
-  */
- struct ieee80211_bss_conf {
- 	const u8 *bssid;
-@@ -739,6 +748,10 @@ struct ieee80211_bss_conf {
- 	bool vht_su_beamformee;
- 	bool vht_mu_beamformer;
- 	bool vht_mu_beamformee;
-+	bool he_su_beamformer;
-+	bool he_su_beamformee;
-+	bool he_mu_beamformer;
-+	bool he_full_ul_mumimo;
- };
- 
- /**
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1281,6 +1281,21 @@ static int ieee80211_start_ap(struct wip
- 			changed |= BSS_CHANGED_HE_BSS_COLOR;
- 	}
- 
-+	if (params->he_cap) {
-+		link_conf->he_su_beamformer =
-+			params->he_cap->phy_cap_info[3] &
-+				IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER;
-+		link_conf->he_su_beamformee =
-+			params->he_cap->phy_cap_info[4] &
-+				IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE;
-+		link_conf->he_mu_beamformer =
-+			params->he_cap->phy_cap_info[4] &
-+				IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER;
-+		link_conf->he_full_ul_mumimo =
-+			params->he_cap->phy_cap_info[2] &
-+				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO;
-+	}
-+
- 	if (sdata->vif.type == NL80211_IFTYPE_AP &&
- 	    params->mbssid_config.tx_wdev) {
- 		err = ieee80211_set_ap_mbssid_options(sdata,
diff --git a/package/kernel/mac80211/patches/subsys/325-wifi-mac80211-introduce-ieee80211_refresh_tx_agg_ses.patch b/package/kernel/mac80211/patches/subsys/325-wifi-mac80211-introduce-ieee80211_refresh_tx_agg_ses.patch
deleted file mode 100644
index 978f82b2..00000000
--- a/package/kernel/mac80211/patches/subsys/325-wifi-mac80211-introduce-ieee80211_refresh_tx_agg_ses.patch
+++ /dev/null
@@ -1,60 +0,0 @@
-From: Ryder Lee <ryder.lee@mediatek.com>
-Date: Sat, 18 Feb 2023 01:50:05 +0800
-Subject: [PATCH] wifi: mac80211: introduce
- ieee80211_refresh_tx_agg_session_timer()
-
-This allows low level drivers to refresh the tx agg session timer, based on
-querying stats from the firmware usually. Especially for some mt76 devices
-support .net_fill_forward_path would bypass mac80211, which leads to tx BA
-session timeout for certain clients.
-
-Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -5975,6 +5975,18 @@ void ieee80211_queue_delayed_work(struct
- 				  unsigned long delay);
- 
- /**
-+ * ieee80211_refresh_tx_agg_session_timer - Refresh a tx agg session timer.
-+ * @sta: the station for which to start a BA session
-+ * @tid: the TID to BA on.
-+ *
-+ * This function allows low level driver to refresh tx agg session timer
-+ * to maintain BA session, the session level will still be managed by the
-+ * mac80211.
-+ */
-+void ieee80211_refresh_tx_agg_session_timer(struct ieee80211_sta *sta,
-+					    u16 tid);
-+
-+/**
-  * ieee80211_start_tx_ba_session - Start a tx Block Ack session.
-  * @sta: the station for which to start a BA session
-  * @tid: the TID to BA on.
---- a/net/mac80211/agg-tx.c
-+++ b/net/mac80211/agg-tx.c
-@@ -554,6 +554,23 @@ void ieee80211_tx_ba_session_handle_star
- 	ieee80211_send_addba_with_timeout(sta, tid_tx);
- }
- 
-+void ieee80211_refresh_tx_agg_session_timer(struct ieee80211_sta *pubsta,
-+					    u16 tid)
-+{
-+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
-+	struct tid_ampdu_tx *tid_tx;
-+
-+	if (WARN_ON_ONCE(tid >= IEEE80211_NUM_TIDS))
-+		return;
-+
-+	tid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);
-+	if (!tid_tx)
-+		return;
-+
-+	tid_tx->last_tx = jiffies;
-+}
-+EXPORT_SYMBOL(ieee80211_refresh_tx_agg_session_timer);
-+
- /*
-  * After accepting the AddBA Response we activated a timer,
-  * resetting it after each frame that we send.
diff --git a/package/kernel/mac80211/patches/subsys/326-wifi-mac80211-add-mesh-fast-rx-support.patch b/package/kernel/mac80211/patches/subsys/326-wifi-mac80211-add-mesh-fast-rx-support.patch
deleted file mode 100644
index 11f39c2d..00000000
--- a/package/kernel/mac80211/patches/subsys/326-wifi-mac80211-add-mesh-fast-rx-support.patch
+++ /dev/null
@@ -1,77 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 2 Mar 2023 13:52:29 +0100
-Subject: [PATCH] wifi: mac80211: add mesh fast-rx support
-
-This helps bring down rx CPU usage by avoiding calls to the rx handlers in
-the slow path. Supports forwarding and local rx, including A-MSDU.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -4564,6 +4564,12 @@ void ieee80211_check_fast_rx(struct sta_
- 		}
- 
- 		break;
-+	case NL80211_IFTYPE_MESH_POINT:
-+		fastrx.expected_ds_bits = cpu_to_le16(IEEE80211_FCTL_FROMDS |
-+						      IEEE80211_FCTL_TODS);
-+		fastrx.da_offs = offsetof(struct ieee80211_hdr, addr3);
-+		fastrx.sa_offs = offsetof(struct ieee80211_hdr, addr4);
-+		break;
- 	default:
- 		goto clear;
- 	}
-@@ -4772,6 +4778,7 @@ static bool ieee80211_invoke_fast_rx(str
- 	struct sk_buff *skb = rx->skb;
- 	struct ieee80211_hdr *hdr = (void *)skb->data;
- 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
-+	static ieee80211_rx_result res;
- 	int orig_len = skb->len;
- 	int hdrlen = ieee80211_hdrlen(hdr->frame_control);
- 	int snap_offs = hdrlen;
-@@ -4833,7 +4840,8 @@ static bool ieee80211_invoke_fast_rx(str
- 		snap_offs += IEEE80211_CCMP_HDR_LEN;
- 	}
- 
--	if (!(status->rx_flags & IEEE80211_RX_AMSDU)) {
-+	if (!ieee80211_vif_is_mesh(&rx->sdata->vif) &&
-+	    !(status->rx_flags & IEEE80211_RX_AMSDU)) {
- 		if (!pskb_may_pull(skb, snap_offs + sizeof(*payload)))
- 			return false;
- 
-@@ -4872,13 +4880,29 @@ static bool ieee80211_invoke_fast_rx(str
- 	/* do the header conversion - first grab the addresses */
- 	ether_addr_copy(addrs.da, skb->data + fast_rx->da_offs);
- 	ether_addr_copy(addrs.sa, skb->data + fast_rx->sa_offs);
--	skb_postpull_rcsum(skb, skb->data + snap_offs,
--			   sizeof(rfc1042_header) + 2);
--	/* remove the SNAP but leave the ethertype */
--	skb_pull(skb, snap_offs + sizeof(rfc1042_header));
-+	if (ieee80211_vif_is_mesh(&rx->sdata->vif)) {
-+	    skb_pull(skb, snap_offs - 2);
-+	    put_unaligned_be16(skb->len - 2, skb->data);
-+	} else {
-+	    skb_postpull_rcsum(skb, skb->data + snap_offs,
-+			       sizeof(rfc1042_header) + 2);
-+
-+	    /* remove the SNAP but leave the ethertype */
-+	    skb_pull(skb, snap_offs + sizeof(rfc1042_header));
-+	}
- 	/* push the addresses in front */
- 	memcpy(skb_push(skb, sizeof(addrs)), &addrs, sizeof(addrs));
- 
-+	res = ieee80211_rx_mesh_data(rx->sdata, rx->sta, rx->skb);
-+	switch (res) {
-+	case RX_QUEUED:
-+		return true;
-+	case RX_CONTINUE:
-+		break;
-+	default:
-+		goto drop;
-+	}
-+
- 	ieee80211_rx_8023(rx, fast_rx, orig_len);
- 
- 	return true;
diff --git a/package/kernel/mac80211/patches/subsys/327-wifi-mac80211-add-support-for-letting-drivers-regist.patch b/package/kernel/mac80211/patches/subsys/327-wifi-mac80211-add-support-for-letting-drivers-regist.patch
deleted file mode 100644
index e47b10bf..00000000
--- a/package/kernel/mac80211/patches/subsys/327-wifi-mac80211-add-support-for-letting-drivers-regist.patch
+++ /dev/null
@@ -1,149 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Mon, 20 Mar 2023 14:28:08 +0100
-Subject: [PATCH] wifi: mac80211: add support for letting drivers register tc
- offload support
-
-On newer MediaTek SoCs (e.g. MT7986), WLAN->WLAN or WLAN->Ethernet flows can
-be offloaded by the SoC. In order to support that, the .ndo_setup_tc op is
-needed.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -4203,6 +4203,10 @@ struct ieee80211_prep_tx_info {
-  *	Note that a sta can also be inserted or removed with valid links,
-  *	i.e. passed to @sta_add/@sta_state with sta->valid_links not zero.
-  *	In fact, cannot change from having valid_links and not having them.
-+ * @net_setup_tc: Called from .ndo_setup_tc in order to prepare hardware
-+ *	flow offloading for flows originating from the vif.
-+ *	Note that the driver must not assume that the vif driver_data is valid
-+ *	at this point, since the callback can be called during netdev teardown.
-  */
- struct ieee80211_ops {
- 	void (*tx)(struct ieee80211_hw *hw,
-@@ -4558,6 +4562,11 @@ struct ieee80211_ops {
- 				struct ieee80211_vif *vif,
- 				struct ieee80211_sta *sta,
- 				u16 old_links, u16 new_links);
-+	int (*net_setup_tc)(struct ieee80211_hw *hw,
-+			    struct ieee80211_vif *vif,
-+			    struct net_device *dev,
-+			    enum tc_setup_type type,
-+			    void *type_data);
- };
- 
- /**
---- a/net/mac80211/driver-ops.h
-+++ b/net/mac80211/driver-ops.h
-@@ -1470,6 +1470,23 @@ static inline int drv_net_fill_forward_p
- 	return ret;
- }
- 
-+static inline int drv_net_setup_tc(struct ieee80211_local *local,
-+				   struct ieee80211_sub_if_data *sdata,
-+				   struct net_device *dev,
-+				   enum tc_setup_type type, void *type_data)
-+{
-+	int ret = -EOPNOTSUPP;
-+
-+	sdata = get_bss_sdata(sdata);
-+	trace_drv_net_setup_tc(local, sdata, type);
-+	if (local->ops->net_setup_tc)
-+		ret = local->ops->net_setup_tc(&local->hw, &sdata->vif, dev,
-+					       type, type_data);
-+	trace_drv_return_int(local, ret);
-+
-+	return ret;
-+}
-+
- int drv_change_vif_links(struct ieee80211_local *local,
- 			 struct ieee80211_sub_if_data *sdata,
- 			 u16 old_links, u16 new_links,
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1939,7 +1939,8 @@ void ieee80211_color_collision_detection
- /* interface handling */
- #define MAC80211_SUPPORTED_FEATURES_TX	(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | \
- 					 NETIF_F_HW_CSUM | NETIF_F_SG | \
--					 NETIF_F_HIGHDMA | NETIF_F_GSO_SOFTWARE)
-+					 NETIF_F_HIGHDMA | NETIF_F_GSO_SOFTWARE | \
-+					 NETIF_F_HW_TC)
- #define MAC80211_SUPPORTED_FEATURES_RX	(NETIF_F_RXCSUM)
- #define MAC80211_SUPPORTED_FEATURES	(MAC80211_SUPPORTED_FEATURES_TX | \
- 					 MAC80211_SUPPORTED_FEATURES_RX)
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -813,6 +813,21 @@ ieee80211_get_stats64(struct net_device
- 	dev_fetch_sw_netstats(stats, dev->tstats);
- }
- 
-+static int ieee80211_netdev_setup_tc(struct net_device *dev,
-+				     enum tc_setup_type type, void *type_data)
-+{
-+	struct ieee80211_sub_if_data *sdata;
-+	struct ieee80211_local *local;
-+
-+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
-+	local = sdata->local;
-+
-+	if (!local->ops->net_setup_tc)
-+		return -EOPNOTSUPP;
-+
-+	return drv_net_setup_tc(local, sdata, dev, type, type_data);
-+}
-+
- static const struct net_device_ops ieee80211_dataif_ops = {
- 	.ndo_open		= ieee80211_open,
- 	.ndo_stop		= ieee80211_stop,
-@@ -821,6 +836,7 @@ static const struct net_device_ops ieee8
- 	.ndo_set_rx_mode	= ieee80211_set_multicast_list,
- 	.ndo_set_mac_address 	= ieee80211_change_mac,
- 	.ndo_get_stats64	= ieee80211_get_stats64,
-+	.ndo_setup_tc		= ieee80211_netdev_setup_tc,
- };
- 
- static u16 ieee80211_monitor_select_queue(struct net_device *dev,
-@@ -929,6 +945,7 @@ static const struct net_device_ops ieee8
- 	.ndo_set_mac_address	= ieee80211_change_mac,
- 	.ndo_get_stats64	= ieee80211_get_stats64,
- 	.ndo_fill_forward_path	= ieee80211_netdev_fill_forward_path,
-+	.ndo_setup_tc		= ieee80211_netdev_setup_tc,
- };
- 
- static bool ieee80211_iftype_supports_hdr_offload(enum nl80211_iftype iftype)
---- a/net/mac80211/trace.h
-+++ b/net/mac80211/trace.h
-@@ -2478,6 +2478,31 @@ DEFINE_EVENT(sta_event, drv_net_fill_for
- 	TP_ARGS(local, sdata, sta)
- );
- 
-+TRACE_EVENT(drv_net_setup_tc,
-+	TP_PROTO(struct ieee80211_local *local,
-+		 struct ieee80211_sub_if_data *sdata,
-+		 u8 type),
-+
-+	TP_ARGS(local, sdata, type),
-+
-+	TP_STRUCT__entry(
-+		LOCAL_ENTRY
-+		VIF_ENTRY
-+		__field(u8, type)
-+	),
-+
-+	TP_fast_assign(
-+		LOCAL_ASSIGN;
-+		VIF_ASSIGN;
-+		__entry->type = type;
-+	),
-+
-+	TP_printk(
-+		LOCAL_PR_FMT VIF_PR_FMT " type:%d\n",
-+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->type
-+	)
-+);
-+
- TRACE_EVENT(drv_change_vif_links,
- 	TP_PROTO(struct ieee80211_local *local,
- 		 struct ieee80211_sub_if_data *sdata,
diff --git a/package/kernel/mac80211/patches/subsys/329-wifi-mac80211-fix-receiving-mesh-packets-in-forwardi.patch b/package/kernel/mac80211/patches/subsys/329-wifi-mac80211-fix-receiving-mesh-packets-in-forwardi.patch
deleted file mode 100644
index 6882694d..00000000
--- a/package/kernel/mac80211/patches/subsys/329-wifi-mac80211-fix-receiving-mesh-packets-in-forwardi.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 26 Mar 2023 17:11:34 +0200
-Subject: [PATCH] wifi: mac80211: fix receiving mesh packets in forwarding=0
- networks
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-When forwarding is set to 0, frames are typically sent with ttl=1.
-Move the ttl decrement check below the check for local receive in order to
-fix packet drops.
-
-Reported-by: Thomas Hühn <thomas.huehn@hs-nordhausen.de>
-Reported-by: Nick Hainke <vincent@systemli.org>
-Fixes: 986e43b19ae9 ("wifi: mac80211: fix receiving A-MSDU frames on mesh interfaces")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2828,14 +2828,6 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 	if (sdata->crypto_tx_tailroom_needed_cnt)
- 		tailroom = IEEE80211_ENCRYPT_TAILROOM;
- 
--	if (!--mesh_hdr->ttl) {
--		if (multicast)
--			goto rx_accept;
--
--		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_ttl);
--		return RX_DROP_MONITOR;
--	}
--
- 	if (mesh_hdr->flags & MESH_FLAGS_AE) {
- 		struct mesh_path *mppath;
- 		char *proxied_addr;
-@@ -2874,6 +2866,14 @@ ieee80211_rx_mesh_data(struct ieee80211_
- 	if (ether_addr_equal(sdata->vif.addr, eth->h_dest))
- 		goto rx_accept;
- 
-+	if (!--mesh_hdr->ttl) {
-+		if (multicast)
-+			goto rx_accept;
-+
-+		IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_ttl);
-+		return RX_DROP_MONITOR;
-+	}
-+
- 	if (!ifmsh->mshcfg.dot11MeshForwarding) {
- 		if (is_multicast_ether_addr(eth->h_dest))
- 			goto rx_accept;
diff --git a/package/kernel/mac80211/patches/subsys/330-wifi-ieee80211-correctly-mark-FTM-frames-non-buffera.patch b/package/kernel/mac80211/patches/subsys/330-wifi-ieee80211-correctly-mark-FTM-frames-non-buffera.patch
deleted file mode 100644
index 1e57a590..00000000
--- a/package/kernel/mac80211/patches/subsys/330-wifi-ieee80211-correctly-mark-FTM-frames-non-buffera.patch
+++ /dev/null
@@ -1,134 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Wed, 29 Mar 2023 16:46:26 +0200
-Subject: [PATCH] wifi: ieee80211: correctly mark FTM frames non-bufferable
-
-The checks of whether or not a frame is bufferable were not
-taking into account that some action frames aren't, such as
-FTM. Check this, which requires some changes to the function
-ieee80211_is_bufferable_mmpdu() since we need the whole skb
-for the checks now.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Reviewed-by: Greenman, Gregory <gregory.greenman@intel.com>
-Reviewed-by: Peer, Ilan <ilan.peer@intel.com>
----
-
---- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
-+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
-@@ -605,8 +605,9 @@ static void iwl_mvm_skb_prepare_status(s
- 
- static int iwl_mvm_get_ctrl_vif_queue(struct iwl_mvm *mvm,
- 				      struct ieee80211_tx_info *info,
--				      struct ieee80211_hdr *hdr)
-+				      struct sk_buff *skb)
- {
-+	struct ieee80211_hdr *hdr = (void *)skb->data;
- 	struct iwl_mvm_vif *mvmvif =
- 		iwl_mvm_vif_from_mac80211(info->control.vif);
- 	__le16 fc = hdr->frame_control;
-@@ -625,7 +626,7 @@ static int iwl_mvm_get_ctrl_vif_queue(st
- 		 * reason 7 ("Class 3 frame received from nonassociated STA").
- 		 */
- 		if (ieee80211_is_mgmt(fc) &&
--		    (!ieee80211_is_bufferable_mmpdu(fc) ||
-+		    (!ieee80211_is_bufferable_mmpdu(skb) ||
- 		     ieee80211_is_deauth(fc) || ieee80211_is_disassoc(fc)))
- 			return mvm->probe_queue;
- 
-@@ -744,7 +745,7 @@ int iwl_mvm_tx_skb_non_sta(struct iwl_mv
- 			else
- 				sta_id = mvmvif->mcast_sta.sta_id;
- 
--			queue = iwl_mvm_get_ctrl_vif_queue(mvm, &info, hdr);
-+			queue = iwl_mvm_get_ctrl_vif_queue(mvm, &info, skb);
- 		} else if (info.control.vif->type == NL80211_IFTYPE_MONITOR) {
- 			queue = mvm->snif_queue;
- 			sta_id = mvm->snif_sta.sta_id;
---- a/include/linux/ieee80211.h
-+++ b/include/linux/ieee80211.h
-@@ -772,20 +772,6 @@ static inline bool ieee80211_is_any_null
- }
- 
- /**
-- * ieee80211_is_bufferable_mmpdu - check if frame is bufferable MMPDU
-- * @fc: frame control field in little-endian byteorder
-- */
--static inline bool ieee80211_is_bufferable_mmpdu(__le16 fc)
--{
--	/* IEEE 802.11-2012, definition of "bufferable management frame";
--	 * note that this ignores the IBSS special case. */
--	return ieee80211_is_mgmt(fc) &&
--	       (ieee80211_is_action(fc) ||
--		ieee80211_is_disassoc(fc) ||
--		ieee80211_is_deauth(fc));
--}
--
--/**
-  * ieee80211_is_first_frag - check if IEEE80211_SCTL_FRAG is not set
-  * @seq_ctrl: frame sequence control bytes in little-endian byteorder
-  */
-@@ -4121,6 +4107,44 @@ static inline u8 *ieee80211_get_DA(struc
- }
- 
- /**
-+ * ieee80211_is_bufferable_mmpdu - check if frame is bufferable MMPDU
-+ * @skb: the skb to check, starting with the 802.11 header
-+ */
-+static inline bool ieee80211_is_bufferable_mmpdu(struct sk_buff *skb)
-+{
-+	struct ieee80211_mgmt *mgmt = (void *)skb->data;
-+	__le16 fc = mgmt->frame_control;
-+
-+	/*
-+	 * IEEE 802.11 REVme D2.0 definition of bufferable MMPDU;
-+	 * note that this ignores the IBSS special case.
-+	 */
-+	if (!ieee80211_is_mgmt(fc))
-+		return false;
-+
-+	if (ieee80211_is_disassoc(fc) || ieee80211_is_deauth(fc))
-+		return true;
-+
-+	if (!ieee80211_is_action(fc))
-+		return false;
-+
-+	if (skb->len < offsetofend(typeof(*mgmt), u.action.u.ftm.action_code))
-+		return true;
-+
-+	/* action frame - additionally check for non-bufferable FTM */
-+
-+	if (mgmt->u.action.category != WLAN_CATEGORY_PUBLIC &&
-+	    mgmt->u.action.category != WLAN_CATEGORY_PROTECTED_DUAL_OF_ACTION)
-+		return true;
-+
-+	if (mgmt->u.action.u.ftm.action_code == WLAN_PUB_ACTION_FTM_REQUEST ||
-+	    mgmt->u.action.u.ftm.action_code == WLAN_PUBLIC_ACTION_FTM_RESPONSE)
-+		return false;
-+
-+	return true;
-+}
-+
-+/**
-  * _ieee80211_is_robust_mgmt_frame - check if frame is a robust management frame
-  * @hdr: the frame (buffer must include at least the first octet of payload)
-  */
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -492,7 +492,7 @@ ieee80211_tx_h_unicast_ps_buf(struct iee
- 		int ac = skb_get_queue_mapping(tx->skb);
- 
- 		if (ieee80211_is_mgmt(hdr->frame_control) &&
--		    !ieee80211_is_bufferable_mmpdu(hdr->frame_control)) {
-+		    !ieee80211_is_bufferable_mmpdu(tx->skb)) {
- 			info->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;
- 			return TX_CONTINUE;
- 		}
-@@ -1330,7 +1330,7 @@ static struct txq_info *ieee80211_get_tx
- 	if (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&
- 	    unlikely(!ieee80211_is_data_present(hdr->frame_control))) {
- 		if ((!ieee80211_is_mgmt(hdr->frame_control) ||
--		     ieee80211_is_bufferable_mmpdu(hdr->frame_control) ||
-+		     ieee80211_is_bufferable_mmpdu(skb) ||
- 		     vif->type == NL80211_IFTYPE_STATION) &&
- 		    sta && sta->uploaded) {
- 			/*
diff --git a/package/kernel/mac80211/patches/subsys/331-wifi-mac80211-flush-queues-on-STA-removal.patch b/package/kernel/mac80211/patches/subsys/331-wifi-mac80211-flush-queues-on-STA-removal.patch
deleted file mode 100644
index 00232ec1..00000000
--- a/package/kernel/mac80211/patches/subsys/331-wifi-mac80211-flush-queues-on-STA-removal.patch
+++ /dev/null
@@ -1,36 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Mon, 13 Mar 2023 11:42:12 +0100
-Subject: [PATCH] wifi: mac80211: flush queues on STA removal
-
-When we remove a station, we first make it unreachable,
-then we (must) remove its keys, and then remove the
-station itself. Depending on the hardware design, if
-we have hardware crypto at all, frames still sitting
-on hardware queues may then be transmitted without a
-valid key, possibly unencrypted or with a fixed key.
-
-Fix this by flushing the queues when removing stations
-so this cannot happen.
-
-Cc: stable@vger.kernel.org
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Reviewed-by: Greenman, Gregory <gregory.greenman@intel.com>
----
-
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -1271,6 +1271,14 @@ static void __sta_info_destroy_part2(str
- 		WARN_ON_ONCE(ret);
- 	}
- 
-+	/* Flush queues before removing keys, as that might remove them
-+	 * from hardware, and then depending on the offload method, any
-+	 * frames sitting on hardware queues might be sent out without
-+	 * any encryption at all.
-+	 */
-+	if (local->ops->set_key)
-+		ieee80211_flush_queues(local, sta->sdata, false);
-+
- 	/* now keys can no longer be reached */
- 	ieee80211_free_sta_keys(local, sta);
- 
diff --git a/package/kernel/mac80211/patches/subsys/332-wifi-iwlwifi-mvm-support-flush-on-AP-interfaces.patch b/package/kernel/mac80211/patches/subsys/332-wifi-iwlwifi-mvm-support-flush-on-AP-interfaces.patch
deleted file mode 100644
index 3c31dfed..00000000
--- a/package/kernel/mac80211/patches/subsys/332-wifi-iwlwifi-mvm-support-flush-on-AP-interfaces.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Mon, 13 Mar 2023 12:02:58 +0100
-Subject: [PATCH] wifi: iwlwifi: mvm: support flush on AP interfaces
-
-Support TX flush on AP interfaces so that we will do a
-proper flush for frames on the queue before keys are
-removed.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Reviewed-by: Greenman, Gregory <gregory.greenman@intel.com>
----
-
---- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
-+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
-@@ -4854,9 +4854,6 @@ static void iwl_mvm_mac_flush(struct iee
- 		return;
- 	}
- 
--	if (vif->type != NL80211_IFTYPE_STATION)
--		return;
--
- 	/* Make sure we're done with the deferred traffic before flushing */
- 	flush_work(&mvm->add_stream_wk);
- 
-@@ -4874,9 +4871,6 @@ static void iwl_mvm_mac_flush(struct iee
- 		if (mvmsta->vif != vif)
- 			continue;
- 
--		/* make sure only TDLS peers or the AP are flushed */
--		WARN_ON(i != mvmvif->ap_sta_id && !sta->tdls);
--
- 		if (drop) {
- 			if (iwl_mvm_flush_sta(mvm, mvmsta, false))
- 				IWL_ERR(mvm, "flush request fail\n");
diff --git a/package/kernel/mac80211/patches/subsys/333-wifi-mac80211-add-flush_sta-method.patch b/package/kernel/mac80211/patches/subsys/333-wifi-mac80211-add-flush_sta-method.patch
deleted file mode 100644
index 1a70e77b..00000000
--- a/package/kernel/mac80211/patches/subsys/333-wifi-mac80211-add-flush_sta-method.patch
+++ /dev/null
@@ -1,91 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Mon, 13 Mar 2023 11:53:51 +0100
-Subject: [PATCH] wifi: mac80211: add flush_sta method
-
-Some drivers like iwlwifi might have per-STA queues, so we
-may want to flush/drop just those queues rather than all
-when removing a station. Add a separate method for that.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Reviewed-by: Greenman, Gregory <gregory.greenman@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -3929,6 +3929,10 @@ struct ieee80211_prep_tx_info {
-  *	Note that vif can be NULL.
-  *	The callback can sleep.
-  *
-+ * @flush_sta: Flush or drop all pending frames from the hardware queue(s) for
-+ *	the given station, as it's about to be removed.
-+ *	The callback can sleep.
-+ *
-  * @channel_switch: Drivers that need (or want) to offload the channel
-  *	switch operation for CSAs received from the AP may implement this
-  *	callback. They must then call ieee80211_chswitch_done() to indicate
-@@ -4383,6 +4387,8 @@ struct ieee80211_ops {
- #endif
- 	void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
- 		      u32 queues, bool drop);
-+	void (*flush_sta)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-+			  struct ieee80211_sta *sta);
- 	void (*channel_switch)(struct ieee80211_hw *hw,
- 			       struct ieee80211_vif *vif,
- 			       struct ieee80211_channel_switch *ch_switch);
---- a/net/mac80211/driver-ops.h
-+++ b/net/mac80211/driver-ops.h
-@@ -617,6 +617,21 @@ static inline void drv_flush(struct ieee
- 	trace_drv_return_void(local);
- }
- 
-+static inline void drv_flush_sta(struct ieee80211_local *local,
-+				 struct ieee80211_sub_if_data *sdata,
-+				 struct sta_info *sta)
-+{
-+	might_sleep();
-+
-+	if (sdata && !check_sdata_in_driver(sdata))
-+		return;
-+
-+	trace_drv_flush_sta(local, sdata, &sta->sta);
-+	if (local->ops->flush_sta)
-+		local->ops->flush_sta(&local->hw, &sdata->vif, &sta->sta);
-+	trace_drv_return_void(local);
-+}
-+
- static inline void drv_channel_switch(struct ieee80211_local *local,
- 				      struct ieee80211_sub_if_data *sdata,
- 				      struct ieee80211_channel_switch *ch_switch)
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -1276,8 +1276,12 @@ static void __sta_info_destroy_part2(str
- 	 * frames sitting on hardware queues might be sent out without
- 	 * any encryption at all.
- 	 */
--	if (local->ops->set_key)
--		ieee80211_flush_queues(local, sta->sdata, false);
-+	if (local->ops->set_key) {
-+		if (local->ops->flush_sta)
-+			drv_flush_sta(local, sta->sdata, sta);
-+		else
-+			ieee80211_flush_queues(local, sta->sdata, false);
-+	}
- 
- 	/* now keys can no longer be reached */
- 	ieee80211_free_sta_keys(local, sta);
---- a/net/mac80211/trace.h
-+++ b/net/mac80211/trace.h
-@@ -1177,6 +1177,13 @@ TRACE_EVENT(drv_flush,
- 	)
- );
- 
-+DEFINE_EVENT(sta_event, drv_flush_sta,
-+	TP_PROTO(struct ieee80211_local *local,
-+		 struct ieee80211_sub_if_data *sdata,
-+		 struct ieee80211_sta *sta),
-+	TP_ARGS(local, sdata, sta)
-+);
-+
- TRACE_EVENT(drv_channel_switch,
- 	TP_PROTO(struct ieee80211_local *local,
- 		 struct ieee80211_sub_if_data *sdata,
diff --git a/package/kernel/mac80211/patches/subsys/334-wifi-iwlwifi-mvm-support-new-flush_sta-method.patch b/package/kernel/mac80211/patches/subsys/334-wifi-iwlwifi-mvm-support-new-flush_sta-method.patch
deleted file mode 100644
index 18f39d50..00000000
--- a/package/kernel/mac80211/patches/subsys/334-wifi-iwlwifi-mvm-support-new-flush_sta-method.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Mon, 13 Mar 2023 12:05:35 +0100
-Subject: [PATCH] wifi: iwlwifi: mvm: support new flush_sta method
-
-For iwlwifi this is simple to implement, and on newer hardware
-it's an improvement since we have per-station queues.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Reviewed-by: Greenman, Gregory <gregory.greenman@intel.com>
----
-
---- a/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
-+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c
-@@ -4890,6 +4890,31 @@ static void iwl_mvm_mac_flush(struct iee
- 		iwl_trans_wait_tx_queues_empty(mvm->trans, msk);
- }
- 
-+static void iwl_mvm_mac_flush_sta(struct ieee80211_hw *hw,
-+				  struct ieee80211_vif *vif,
-+				  struct ieee80211_sta *sta)
-+{
-+	struct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);
-+	int i;
-+
-+	mutex_lock(&mvm->mutex);
-+	for (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {
-+		struct iwl_mvm_sta *mvmsta;
-+		struct ieee80211_sta *tmp;
-+
-+		tmp = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],
-+						lockdep_is_held(&mvm->mutex));
-+		if (tmp != sta)
-+			continue;
-+
-+		mvmsta = iwl_mvm_sta_from_mac80211(sta);
-+
-+		if (iwl_mvm_flush_sta(mvm, mvmsta, false))
-+			IWL_ERR(mvm, "flush request fail\n");
-+	}
-+	mutex_unlock(&mvm->mutex);
-+}
-+
- static int iwl_mvm_mac_get_survey(struct ieee80211_hw *hw, int idx,
- 				  struct survey_info *survey)
- {
-@@ -5417,6 +5442,7 @@ const struct ieee80211_ops iwl_mvm_hw_op
- 	.mgd_complete_tx = iwl_mvm_mac_mgd_complete_tx,
- 	.mgd_protect_tdls_discover = iwl_mvm_mac_mgd_protect_tdls_discover,
- 	.flush = iwl_mvm_mac_flush,
-+	.flush_sta = iwl_mvm_mac_flush_sta,
- 	.sched_scan_start = iwl_mvm_mac_sched_scan_start,
- 	.sched_scan_stop = iwl_mvm_mac_sched_scan_stop,
- 	.set_key = iwl_mvm_mac_set_key,
diff --git a/package/kernel/mac80211/patches/subsys/335-wifi-mac80211-add-LDPC-related-flags-in-ieee80211_bs.patch b/package/kernel/mac80211/patches/subsys/335-wifi-mac80211-add-LDPC-related-flags-in-ieee80211_bs.patch
deleted file mode 100644
index 1b379b76..00000000
--- a/package/kernel/mac80211/patches/subsys/335-wifi-mac80211-add-LDPC-related-flags-in-ieee80211_bs.patch
+++ /dev/null
@@ -1,62 +0,0 @@
-From: Ryder Lee <ryder.lee@mediatek.com>
-Date: Sat, 18 Feb 2023 01:49:25 +0800
-Subject: [PATCH] wifi: mac80211: add LDPC related flags in ieee80211_bss_conf
-
-This is utilized to pass LDPC configurations from user space
-(i.e. hostapd) to driver.
-
-Signed-off-by: Ryder Lee <ryder.lee@mediatek.com>
-Link: https://lore.kernel.org/r/1de696aaa34efd77a926eb657b8c0fda05aaa177.1676628065.git.ryder.lee@mediatek.com
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -653,6 +653,9 @@ struct ieee80211_fils_discovery {
-  *	write-protected by sdata_lock and local->mtx so holding either is fine
-  *	for read access.
-  * @color_change_color: the bss color that will be used after the change.
-+ * @ht_ldpc: in AP mode, indicates interface has HT LDPC capability.
-+ * @vht_ldpc: in AP mode, indicates interface has VHT LDPC capability.
-+ * @he_ldpc: in AP mode, indicates interface has HE LDPC capability.
-  * @vht_su_beamformer: in AP mode, does this BSS support operation as an VHT SU
-  *	beamformer
-  * @vht_su_beamformee: in AP mode, does this BSS support operation as an VHT SU
-@@ -744,6 +747,9 @@ struct ieee80211_bss_conf {
- 	bool color_change_active;
- 	u8 color_change_color;
- 
-+	bool ht_ldpc;
-+	bool vht_ldpc;
-+	bool he_ldpc;
- 	bool vht_su_beamformer;
- 	bool vht_su_beamformee;
- 	bool vht_mu_beamformer;
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1252,7 +1252,15 @@ static int ieee80211_start_ap(struct wip
- 	prev_beacon_int = link_conf->beacon_int;
- 	link_conf->beacon_int = params->beacon_interval;
- 
-+	if (params->ht_cap)
-+		link_conf->ht_ldpc =
-+			params->ht_cap->cap_info &
-+				cpu_to_le16(IEEE80211_HT_CAP_LDPC_CODING);
-+
- 	if (params->vht_cap) {
-+		link_conf->vht_ldpc =
-+			params->vht_cap->vht_cap_info &
-+				cpu_to_le32(IEEE80211_VHT_CAP_RXLDPC);
- 		link_conf->vht_su_beamformer =
- 			params->vht_cap->vht_cap_info &
- 				cpu_to_le32(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);
-@@ -1282,6 +1290,9 @@ static int ieee80211_start_ap(struct wip
- 	}
- 
- 	if (params->he_cap) {
-+		link_conf->he_ldpc =
-+			params->he_cap->phy_cap_info[1] &
-+				IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD;
- 		link_conf->he_su_beamformer =
- 			params->he_cap->phy_cap_info[3] &
- 				IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER;
diff --git a/package/kernel/mac80211/patches/subsys/336-v6.4-wifi-mac80211-generate-EMA-beacons-in-AP-mode.patch b/package/kernel/mac80211/patches/subsys/336-v6.4-wifi-mac80211-generate-EMA-beacons-in-AP-mode.patch
deleted file mode 100644
index 8eb93b0e..00000000
--- a/package/kernel/mac80211/patches/subsys/336-v6.4-wifi-mac80211-generate-EMA-beacons-in-AP-mode.patch
+++ /dev/null
@@ -1,372 +0,0 @@
-From bd54f3c29077f23dad92ef82a78061b40be30c65 Mon Sep 17 00:00:00 2001
-From: Aloka Dixit <quic_alokad@quicinc.com>
-Date: Mon, 5 Dec 2022 16:50:37 -0800
-Subject: [PATCH] wifi: mac80211: generate EMA beacons in AP mode
-
-Add APIs to generate an array of beacons for an EMA AP (enhanced
-multiple BSSID advertisements), each including a single MBSSID element.
-EMA profile periodicity equals the count of elements.
-
-- ieee80211_beacon_get_template_ema_list() - Generate and return all
-EMA beacon templates. Drivers must call ieee80211_beacon_free_ema_list()
-to free the memory. No change in the prototype for the existing API,
-ieee80211_beacon_get_template(), which should be used for non-EMA AP.
-
-- ieee80211_beacon_get_template_ema_index() - Generate a beacon which
-includes the multiple BSSID element at the given index. Drivers can use
-this function in a loop until NULL is returned which indicates end of
-available MBSSID elements.
-
-- ieee80211_beacon_free_ema_list() - free the memory allocated for the
-list of EMA beacon templates.
-
-Modify existing functions ieee80211_beacon_get_ap(),
-ieee80211_get_mbssid_beacon_len() and ieee80211_beacon_add_mbssid()
-to accept a new parameter for EMA index.
-
-Signed-off-by: Aloka Dixit <quic_alokad@quicinc.com>
-Co-developed-by: John Crispin <john@phrozen.org>
-Signed-off-by: John Crispin <john@phrozen.org>
-Link: https://lore.kernel.org/r/20221206005040.3177-2-quic_alokad@quicinc.com
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
- include/net/mac80211.h     |  68 +++++++++++++++++++
- net/mac80211/cfg.c         |  11 +--
- net/mac80211/ieee80211_i.h |  10 ++-
- net/mac80211/tx.c          | 134 ++++++++++++++++++++++++++++++++++---
- 4 files changed, 205 insertions(+), 18 deletions(-)
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -5263,6 +5263,74 @@ ieee80211_beacon_get_template(struct iee
- 			      unsigned int link_id);
- 
- /**
-+ * ieee80211_beacon_get_template_ema_index - EMA beacon template generation
-+ * @hw: pointer obtained from ieee80211_alloc_hw().
-+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
-+ * @offs: &struct ieee80211_mutable_offsets pointer to struct that will
-+ *	receive the offsets that may be updated by the driver.
-+ * @link_id: the link id to which the beacon belongs (or 0 for a non-MLD AP).
-+ * @ema_index: index of the beacon in the EMA set.
-+ *
-+ * This function follows the same rules as ieee80211_beacon_get_template()
-+ * but returns a beacon template which includes multiple BSSID element at the
-+ * requested index.
-+ *
-+ * Return: The beacon template. %NULL indicates the end of EMA templates.
-+ */
-+struct sk_buff *
-+ieee80211_beacon_get_template_ema_index(struct ieee80211_hw *hw,
-+					struct ieee80211_vif *vif,
-+					struct ieee80211_mutable_offsets *offs,
-+					unsigned int link_id, u8 ema_index);
-+
-+/**
-+ * struct ieee80211_ema_beacons - List of EMA beacons
-+ * @cnt: count of EMA beacons.
-+ *
-+ * @bcn: array of EMA beacons.
-+ * @bcn.skb: the skb containing this specific beacon
-+ * @bcn.offs: &struct ieee80211_mutable_offsets pointer to struct that will
-+ *	receive the offsets that may be updated by the driver.
-+ */
-+struct ieee80211_ema_beacons {
-+	u8 cnt;
-+	struct {
-+		struct sk_buff *skb;
-+		struct ieee80211_mutable_offsets offs;
-+	} bcn[];
-+};
-+
-+/**
-+ * ieee80211_beacon_get_template_ema_list - EMA beacon template generation
-+ * @hw: pointer obtained from ieee80211_alloc_hw().
-+ * @vif: &struct ieee80211_vif pointer from the add_interface callback.
-+ * @link_id: the link id to which the beacon belongs (or 0 for a non-MLD AP)
-+ *
-+ * This function follows the same rules as ieee80211_beacon_get_template()
-+ * but allocates and returns a pointer to list of all beacon templates required
-+ * to cover all profiles in the multiple BSSID set. Each template includes only
-+ * one multiple BSSID element.
-+ *
-+ * Driver must call ieee80211_beacon_free_ema_list() to free the memory.
-+ *
-+ * Return: EMA beacon templates of type struct ieee80211_ema_beacons *.
-+ *	%NULL on error.
-+ */
-+struct ieee80211_ema_beacons *
-+ieee80211_beacon_get_template_ema_list(struct ieee80211_hw *hw,
-+				       struct ieee80211_vif *vif,
-+				       unsigned int link_id);
-+
-+/**
-+ * ieee80211_beacon_free_ema_list - free an EMA beacon template list
-+ * @ema_beacons: list of EMA beacons of type &struct ieee80211_ema_beacons pointers.
-+ *
-+ * This function will free a list previously acquired by calling
-+ * ieee80211_beacon_get_template_ema_list()
-+ */
-+void ieee80211_beacon_free_ema_list(struct ieee80211_ema_beacons *ema_beacons);
-+
-+/**
-  * ieee80211_beacon_get_tim - beacon generation function
-  * @hw: pointer obtained from ieee80211_alloc_hw().
-  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1122,11 +1122,11 @@ static int ieee80211_assign_beacon(struc
- 	if (params->mbssid_ies) {
- 		mbssid = params->mbssid_ies;
- 		size += struct_size(new->mbssid_ies, elem, mbssid->cnt);
--		size += ieee80211_get_mbssid_beacon_len(mbssid);
-+		size += ieee80211_get_mbssid_beacon_len(mbssid, mbssid->cnt);
- 	} else if (old && old->mbssid_ies) {
- 		mbssid = old->mbssid_ies;
- 		size += struct_size(new->mbssid_ies, elem, mbssid->cnt);
--		size += ieee80211_get_mbssid_beacon_len(mbssid);
-+		size += ieee80211_get_mbssid_beacon_len(mbssid, mbssid->cnt);
- 	}
- 
- 	new = kzalloc(size, GFP_KERNEL);
-@@ -3384,8 +3384,11 @@ cfg80211_beacon_dup(struct cfg80211_beac
- 
- 	len = beacon->head_len + beacon->tail_len + beacon->beacon_ies_len +
- 	      beacon->proberesp_ies_len + beacon->assocresp_ies_len +
--	      beacon->probe_resp_len + beacon->lci_len + beacon->civicloc_len +
--	      ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies);
-+	      beacon->probe_resp_len + beacon->lci_len + beacon->civicloc_len;
-+
-+	if (beacon->mbssid_ies)
-+		len += ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies,
-+						       beacon->mbssid_ies->cnt);
- 
- 	new_beacon = kzalloc(sizeof(*new_beacon) + len, GFP_KERNEL);
- 	if (!new_beacon)
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1182,13 +1182,17 @@ ieee80211_vif_get_shift(struct ieee80211
- }
- 
- static inline int
--ieee80211_get_mbssid_beacon_len(struct cfg80211_mbssid_elems *elems)
-+ieee80211_get_mbssid_beacon_len(struct cfg80211_mbssid_elems *elems, u8 i)
- {
--	int i, len = 0;
-+	int len = 0;
- 
--	if (!elems)
-+	if (!elems || !elems->cnt || i > elems->cnt)
- 		return 0;
- 
-+	if (i < elems->cnt)
-+		return elems->elem[i].len;
-+
-+	/* i == elems->cnt, calculate total length of all MBSSID elements */
- 	for (i = 0; i < elems->cnt; i++)
- 		len += elems->elem[i].len;
- 
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -5209,13 +5209,20 @@ ieee80211_beacon_get_finish(struct ieee8
- }
- 
- static void
--ieee80211_beacon_add_mbssid(struct sk_buff *skb, struct beacon_data *beacon)
-+ieee80211_beacon_add_mbssid(struct sk_buff *skb, struct beacon_data *beacon,
-+			    u8 i)
- {
--	int i;
-+	if (!beacon->mbssid_ies || !beacon->mbssid_ies->cnt ||
-+	    i > beacon->mbssid_ies->cnt)
-+		return;
- 
--	if (!beacon->mbssid_ies)
-+	if (i < beacon->mbssid_ies->cnt) {
-+		skb_put_data(skb, beacon->mbssid_ies->elem[i].data,
-+			     beacon->mbssid_ies->elem[i].len);
- 		return;
-+	}
- 
-+	/* i == beacon->mbssid_ies->cnt, include all MBSSID elements */
- 	for (i = 0; i < beacon->mbssid_ies->cnt; i++)
- 		skb_put_data(skb, beacon->mbssid_ies->elem[i].data,
- 			     beacon->mbssid_ies->elem[i].len);
-@@ -5228,7 +5235,8 @@ ieee80211_beacon_get_ap(struct ieee80211
- 			struct ieee80211_mutable_offsets *offs,
- 			bool is_template,
- 			struct beacon_data *beacon,
--			struct ieee80211_chanctx_conf *chanctx_conf)
-+			struct ieee80211_chanctx_conf *chanctx_conf,
-+			u8 ema_index)
- {
- 	struct ieee80211_local *local = hw_to_local(hw);
- 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
-@@ -5247,7 +5255,9 @@ ieee80211_beacon_get_ap(struct ieee80211
- 	/* headroom, head length,
- 	 * tail length, maximum TIM length and multiple BSSID length
- 	 */
--	mbssid_len = ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies);
-+	mbssid_len = ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies,
-+						     ema_index);
-+
- 	skb = dev_alloc_skb(local->tx_headroom + beacon->head_len +
- 			    beacon->tail_len + 256 +
- 			    local->hw.extra_beacon_tailroom + mbssid_len);
-@@ -5265,7 +5275,7 @@ ieee80211_beacon_get_ap(struct ieee80211
- 		offs->cntdwn_counter_offs[0] = beacon->cntdwn_counter_offsets[0];
- 
- 		if (mbssid_len) {
--			ieee80211_beacon_add_mbssid(skb, beacon);
-+			ieee80211_beacon_add_mbssid(skb, beacon, ema_index);
- 			offs->mbssid_off = skb->len - mbssid_len;
- 		}
- 
-@@ -5284,12 +5294,51 @@ ieee80211_beacon_get_ap(struct ieee80211
- 	return skb;
- }
- 
-+static struct ieee80211_ema_beacons *
-+ieee80211_beacon_get_ap_ema_list(struct ieee80211_hw *hw,
-+				 struct ieee80211_vif *vif,
-+				 struct ieee80211_link_data *link,
-+				 struct ieee80211_mutable_offsets *offs,
-+				 bool is_template, struct beacon_data *beacon,
-+				 struct ieee80211_chanctx_conf *chanctx_conf)
-+{
-+	struct ieee80211_ema_beacons *ema = NULL;
-+
-+	if (!beacon->mbssid_ies || !beacon->mbssid_ies->cnt)
-+		return NULL;
-+
-+	ema = kzalloc(struct_size(ema, bcn, beacon->mbssid_ies->cnt),
-+		      GFP_ATOMIC);
-+	if (!ema)
-+		return NULL;
-+
-+	for (ema->cnt = 0; ema->cnt < beacon->mbssid_ies->cnt; ema->cnt++) {
-+		ema->bcn[ema->cnt].skb =
-+			ieee80211_beacon_get_ap(hw, vif, link,
-+						&ema->bcn[ema->cnt].offs,
-+						is_template, beacon,
-+						chanctx_conf, ema->cnt);
-+		if (!ema->bcn[ema->cnt].skb)
-+			break;
-+	}
-+
-+	if (ema->cnt == beacon->mbssid_ies->cnt)
-+		return ema;
-+
-+	ieee80211_beacon_free_ema_list(ema);
-+	return NULL;
-+}
-+
-+#define IEEE80211_INCLUDE_ALL_MBSSID_ELEMS -1
-+
- static struct sk_buff *
- __ieee80211_beacon_get(struct ieee80211_hw *hw,
- 		       struct ieee80211_vif *vif,
- 		       struct ieee80211_mutable_offsets *offs,
- 		       bool is_template,
--		       unsigned int link_id)
-+		       unsigned int link_id,
-+		       int ema_index,
-+		       struct ieee80211_ema_beacons **ema_beacons)
- {
- 	struct ieee80211_local *local = hw_to_local(hw);
- 	struct beacon_data *beacon = NULL;
-@@ -5318,8 +5367,29 @@ __ieee80211_beacon_get(struct ieee80211_
- 		if (!beacon)
- 			goto out;
- 
--		skb = ieee80211_beacon_get_ap(hw, vif, link, offs, is_template,
--					      beacon, chanctx_conf);
-+		if (ema_beacons) {
-+			*ema_beacons =
-+				ieee80211_beacon_get_ap_ema_list(hw, vif, link,
-+								 offs,
-+								 is_template,
-+								 beacon,
-+								 chanctx_conf);
-+		} else {
-+			if (beacon->mbssid_ies && beacon->mbssid_ies->cnt) {
-+				if (ema_index >= beacon->mbssid_ies->cnt)
-+					goto out; /* End of MBSSID elements */
-+
-+				if (ema_index <= IEEE80211_INCLUDE_ALL_MBSSID_ELEMS)
-+					ema_index = beacon->mbssid_ies->cnt;
-+			} else {
-+				ema_index = 0;
-+			}
-+
-+			skb = ieee80211_beacon_get_ap(hw, vif, link, offs,
-+						      is_template, beacon,
-+						      chanctx_conf,
-+						      ema_index);
-+		}
- 	} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {
- 		struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
- 		struct ieee80211_hdr *hdr;
-@@ -5407,10 +5477,50 @@ ieee80211_beacon_get_template(struct iee
- 			      struct ieee80211_mutable_offsets *offs,
- 			      unsigned int link_id)
- {
--	return __ieee80211_beacon_get(hw, vif, offs, true, link_id);
-+	return __ieee80211_beacon_get(hw, vif, offs, true, link_id,
-+				      IEEE80211_INCLUDE_ALL_MBSSID_ELEMS, NULL);
- }
- EXPORT_SYMBOL(ieee80211_beacon_get_template);
- 
-+struct sk_buff *
-+ieee80211_beacon_get_template_ema_index(struct ieee80211_hw *hw,
-+					struct ieee80211_vif *vif,
-+					struct ieee80211_mutable_offsets *offs,
-+					unsigned int link_id, u8 ema_index)
-+{
-+	return __ieee80211_beacon_get(hw, vif, offs, true, link_id, ema_index,
-+				      NULL);
-+}
-+EXPORT_SYMBOL(ieee80211_beacon_get_template_ema_index);
-+
-+void ieee80211_beacon_free_ema_list(struct ieee80211_ema_beacons *ema_beacons)
-+{
-+	u8 i;
-+
-+	if (!ema_beacons)
-+		return;
-+
-+	for (i = 0; i < ema_beacons->cnt; i++)
-+		kfree_skb(ema_beacons->bcn[i].skb);
-+
-+	kfree(ema_beacons);
-+}
-+EXPORT_SYMBOL(ieee80211_beacon_free_ema_list);
-+
-+struct ieee80211_ema_beacons *
-+ieee80211_beacon_get_template_ema_list(struct ieee80211_hw *hw,
-+				       struct ieee80211_vif *vif,
-+				       unsigned int link_id)
-+{
-+	struct ieee80211_ema_beacons *ema_beacons = NULL;
-+
-+	WARN_ON(__ieee80211_beacon_get(hw, vif, NULL, false, link_id, 0,
-+				       &ema_beacons));
-+
-+	return ema_beacons;
-+}
-+EXPORT_SYMBOL(ieee80211_beacon_get_template_ema_list);
-+
- struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,
- 					 struct ieee80211_vif *vif,
- 					 u16 *tim_offset, u16 *tim_length,
-@@ -5418,7 +5528,9 @@ struct sk_buff *ieee80211_beacon_get_tim
- {
- 	struct ieee80211_mutable_offsets offs = {};
- 	struct sk_buff *bcn = __ieee80211_beacon_get(hw, vif, &offs, false,
--						     link_id);
-+						     link_id,
-+						     IEEE80211_INCLUDE_ALL_MBSSID_ELEMS,
-+						     NULL);
- 	struct sk_buff *copy;
- 	int shift;
- 
diff --git a/package/kernel/mac80211/patches/subsys/337-mac80211-fix-sband-iftype-data-lookup-for-AP_VLAN.patch b/package/kernel/mac80211/patches/subsys/337-mac80211-fix-sband-iftype-data-lookup-for-AP_VLAN.patch
deleted file mode 100644
index 67b42849..00000000
--- a/package/kernel/mac80211/patches/subsys/337-mac80211-fix-sband-iftype-data-lookup-for-AP_VLAN.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 22 Jun 2023 18:02:25 +0200
-Subject: [PATCH] mac80211: fix sband iftype data lookup for AP_VLAN
-
-AP_VLAN interfaces are virtual, so doesn't really exist as a type for
-capabilities. When passed in as a type, AP is the one that's really intended.
-
-Fixes: c4cbaf7973a7 ("cfg80211: Add support for HE")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -567,6 +567,9 @@ ieee80211_get_sband_iftype_data(const st
- 	if (WARN_ON(iftype >= NL80211_IFTYPE_MAX))
- 		return NULL;
- 
-+	if (iftype == NL80211_IFTYPE_AP_VLAN)
-+		iftype = NL80211_IFTYPE_AP;
-+
- 	for (i = 0; i < sband->n_iftype_data; i++)  {
- 		const struct ieee80211_sband_iftype_data *data =
- 			&sband->iftype_data[i];
diff --git a/package/kernel/mac80211/patches/subsys/338-mac80211-split-mesh-fast-tx-cache-into-local-proxied.patch b/package/kernel/mac80211/patches/subsys/338-mac80211-split-mesh-fast-tx-cache-into-local-proxied.patch
deleted file mode 100644
index f7391a58..00000000
--- a/package/kernel/mac80211/patches/subsys/338-mac80211-split-mesh-fast-tx-cache-into-local-proxied.patch
+++ /dev/null
@@ -1,219 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 30 Jun 2023 13:11:51 +0200
-Subject: [PATCH] mac80211: split mesh fast tx cache into
- local/proxied/forwarded
-
-Depending on the origin of the packets (and their SA), 802.11 + mesh headers
-could be filled in differently. In order to properly deal with that, add a
-new field to the lookup key, indicating the type (local, proxied or
-forwarded). This can fix spurious packet drop issues that depend on the order
-in which nodes/hosts communicate with each other.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/mesh.c
-+++ b/net/mac80211/mesh.c
-@@ -703,6 +703,9 @@ bool ieee80211_mesh_xmit_fast(struct iee
- 			      struct sk_buff *skb, u32 ctrl_flags)
- {
- 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
-+	struct ieee80211_mesh_fast_tx_key key = {
-+		.type = MESH_FAST_TX_TYPE_LOCAL
-+	};
- 	struct ieee80211_mesh_fast_tx *entry;
- 	struct ieee80211s_hdr *meshhdr;
- 	u8 sa[ETH_ALEN] __aligned(2);
-@@ -738,7 +741,10 @@ bool ieee80211_mesh_xmit_fast(struct iee
- 			return false;
- 	}
- 
--	entry = mesh_fast_tx_get(sdata, skb->data);
-+	ether_addr_copy(key.addr, skb->data);
-+	if (!ether_addr_equal(skb->data + ETH_ALEN, sdata->vif.addr))
-+		key.type = MESH_FAST_TX_TYPE_PROXIED;
-+	entry = mesh_fast_tx_get(sdata, &key);
- 	if (!entry)
- 		return false;
- 
---- a/net/mac80211/mesh.h
-+++ b/net/mac80211/mesh.h
-@@ -133,9 +133,33 @@ struct mesh_path {
- #define MESH_FAST_TX_CACHE_TIMEOUT		8000 /* msecs */
- 
- /**
-+ * enum ieee80211_mesh_fast_tx_type - cached mesh fast tx entry type
-+ *
-+ * @MESH_FAST_TX_TYPE_LOCAL: tx from the local vif address as SA
-+ * @MESH_FAST_TX_TYPE_PROXIED: local tx with a different SA (e.g. bridged)
-+ * @MESH_FAST_TX_TYPE_FORWARDED: forwarded from a different mesh point
-+ */
-+enum ieee80211_mesh_fast_tx_type {
-+	MESH_FAST_TX_TYPE_LOCAL,
-+	MESH_FAST_TX_TYPE_PROXIED,
-+	MESH_FAST_TX_TYPE_FORWARDED,
-+};
-+
-+/**
-+ * struct ieee80211_mesh_fast_tx_key - cached mesh fast tx entry key
-+ *
-+ * @addr: The Ethernet DA for this entry
-+ * @type: cache entry type
-+ */
-+struct ieee80211_mesh_fast_tx_key {
-+	u8 addr[ETH_ALEN] __aligned(2);
-+	enum ieee80211_mesh_fast_tx_type type;
-+};
-+
-+/**
-  * struct ieee80211_mesh_fast_tx - cached mesh fast tx entry
-  * @rhash: rhashtable pointer
-- * @addr_key: The Ethernet DA which is the key for this entry
-+ * @key: the lookup key for this cache entry
-  * @fast_tx: base fast_tx data
-  * @hdr: cached mesh and rfc1042 headers
-  * @hdrlen: length of mesh + rfc1042
-@@ -146,7 +170,7 @@ struct mesh_path {
-  */
- struct ieee80211_mesh_fast_tx {
- 	struct rhash_head rhash;
--	u8 addr_key[ETH_ALEN] __aligned(2);
-+	struct ieee80211_mesh_fast_tx_key key;
- 
- 	struct ieee80211_fast_tx fast_tx;
- 	u8 hdr[sizeof(struct ieee80211s_hdr) + sizeof(rfc1042_header)];
-@@ -329,7 +353,8 @@ void mesh_path_tx_root_frame(struct ieee
- 
- bool mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt);
- struct ieee80211_mesh_fast_tx *
--mesh_fast_tx_get(struct ieee80211_sub_if_data *sdata, const u8 *addr);
-+mesh_fast_tx_get(struct ieee80211_sub_if_data *sdata,
-+		 struct ieee80211_mesh_fast_tx_key *key);
- bool ieee80211_mesh_xmit_fast(struct ieee80211_sub_if_data *sdata,
- 			      struct sk_buff *skb, u32 ctrl_flags);
- void mesh_fast_tx_cache(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/mesh_pathtbl.c
-+++ b/net/mac80211/mesh_pathtbl.c
-@@ -36,8 +36,8 @@ static const struct rhashtable_params me
- static const struct rhashtable_params fast_tx_rht_params = {
- 	.nelem_hint = 10,
- 	.automatic_shrinking = true,
--	.key_len = ETH_ALEN,
--	.key_offset = offsetof(struct ieee80211_mesh_fast_tx, addr_key),
-+	.key_len = sizeof(struct ieee80211_mesh_fast_tx_key),
-+	.key_offset = offsetof(struct ieee80211_mesh_fast_tx, key),
- 	.head_offset = offsetof(struct ieee80211_mesh_fast_tx, rhash),
- 	.hashfn = mesh_table_hash,
- };
-@@ -426,20 +426,21 @@ static void mesh_fast_tx_entry_free(stru
- }
- 
- struct ieee80211_mesh_fast_tx *
--mesh_fast_tx_get(struct ieee80211_sub_if_data *sdata, const u8 *addr)
-+mesh_fast_tx_get(struct ieee80211_sub_if_data *sdata,
-+		 struct ieee80211_mesh_fast_tx_key *key)
- {
- 	struct ieee80211_mesh_fast_tx *entry;
- 	struct mesh_tx_cache *cache;
- 
- 	cache = &sdata->u.mesh.tx_cache;
--	entry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);
-+	entry = rhashtable_lookup(&cache->rht, key, fast_tx_rht_params);
- 	if (!entry)
- 		return NULL;
- 
- 	if (!(entry->mpath->flags & MESH_PATH_ACTIVE) ||
- 	    mpath_expired(entry->mpath)) {
- 		spin_lock_bh(&cache->walk_lock);
--		entry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);
-+		entry = rhashtable_lookup(&cache->rht, key, fast_tx_rht_params);
- 		if (entry)
- 		    mesh_fast_tx_entry_free(cache, entry);
- 		spin_unlock_bh(&cache->walk_lock);
-@@ -484,18 +485,24 @@ void mesh_fast_tx_cache(struct ieee80211
- 	if (!sta)
- 		return;
- 
-+	build.key.type = MESH_FAST_TX_TYPE_LOCAL;
- 	if ((meshhdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6) {
- 		/* This is required to keep the mppath alive */
- 		mppath = mpp_path_lookup(sdata, meshhdr->eaddr1);
- 		if (!mppath)
- 			return;
- 		build.mppath = mppath;
-+		if (!ether_addr_equal(meshhdr->eaddr2, sdata->vif.addr))
-+			build.key.type = MESH_FAST_TX_TYPE_PROXIED;
- 	} else if (ieee80211_has_a4(hdr->frame_control)) {
- 		mppath = mpath;
- 	} else {
- 		return;
- 	}
- 
-+	if (!ether_addr_equal(hdr->addr4, sdata->vif.addr))
-+		build.key.type = MESH_FAST_TX_TYPE_FORWARDED;
-+
- 	/* rate limit, in case fast xmit can't be enabled */
- 	if (mppath->fast_tx_check == jiffies)
- 		return;
-@@ -542,7 +549,7 @@ void mesh_fast_tx_cache(struct ieee80211
- 		}
- 	}
- 
--	memcpy(build.addr_key, mppath->dst, ETH_ALEN);
-+	memcpy(build.key.addr, mppath->dst, ETH_ALEN);
- 	build.timestamp = jiffies;
- 	build.fast_tx.band = info->band;
- 	build.fast_tx.da_offs = offsetof(struct ieee80211_hdr, addr3);
-@@ -644,13 +651,19 @@ void mesh_fast_tx_flush_addr(struct ieee
- 			     const u8 *addr)
- {
- 	struct mesh_tx_cache *cache = &sdata->u.mesh.tx_cache;
-+	struct ieee80211_mesh_fast_tx_key key = {};
- 	struct ieee80211_mesh_fast_tx *entry;
-+	int i;
- 
-+	ether_addr_copy(key.addr, addr);
- 	cache = &sdata->u.mesh.tx_cache;
- 	spin_lock_bh(&cache->walk_lock);
--	entry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);
--	if (entry)
--		mesh_fast_tx_entry_free(cache, entry);
-+	for (i = MESH_FAST_TX_TYPE_LOCAL; i < MESH_FAST_TX_TYPE_FORWARDED; i++) {
-+		key.type = i;
-+		entry = rhashtable_lookup(&cache->rht, &key, fast_tx_rht_params);
-+		if (entry)
-+			mesh_fast_tx_entry_free(cache, entry);
-+	}
- 	spin_unlock_bh(&cache->walk_lock);
- }
- 
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -2726,7 +2726,10 @@ ieee80211_rx_mesh_fast_forward(struct ie
- 			       struct sk_buff *skb, int hdrlen)
- {
- 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
--	struct ieee80211_mesh_fast_tx *entry = NULL;
-+	struct ieee80211_mesh_fast_tx_key key = {
-+		.type = MESH_FAST_TX_TYPE_FORWARDED
-+	};
-+	struct ieee80211_mesh_fast_tx *entry;
- 	struct ieee80211s_hdr *mesh_hdr;
- 	struct tid_ampdu_tx *tid_tx;
- 	struct sta_info *sta;
-@@ -2735,9 +2738,13 @@ ieee80211_rx_mesh_fast_forward(struct ie
- 
- 	mesh_hdr = (struct ieee80211s_hdr *)(skb->data + sizeof(eth));
- 	if ((mesh_hdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6)
--		entry = mesh_fast_tx_get(sdata, mesh_hdr->eaddr1);
-+		ether_addr_copy(key.addr, mesh_hdr->eaddr1);
- 	else if (!(mesh_hdr->flags & MESH_FLAGS_AE))
--		entry = mesh_fast_tx_get(sdata, skb->data);
-+		ether_addr_copy(key.addr, skb->data);
-+	else
-+		return false;
-+
-+	entry = mesh_fast_tx_get(sdata, &key);
- 	if (!entry)
- 		return false;
- 
diff --git a/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch b/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch
deleted file mode 100644
index 87015648..00000000
--- a/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Mon, 24 Feb 2020 00:00:00 +0100
-Subject: [PATCH] mac80211: Allow IBSS mode and different beacon intervals
-
-ath10k-ct supports the combination to select IBSS (ADHOC) mode and
-different beacon intervals together. mac80211 does not like this
-combination, but Ben says this is ok, so remove this check.
-
-ath10k-ct starting with version 5.2 allows the combination of
-NL80211_IFTYPE_ADHOC and beacon_int_min_gcd in ath10k_10x_ct_if_comb
-which triggers this warning. Ben told me that this is not a big problem
-and we should ignore this.
----
- net/wireless/core.c | 15 ---------------
- 1 file changed, 15 deletions(-)
-
---- a/net/wireless/core.c
-+++ b/net/wireless/core.c
-@@ -630,21 +630,6 @@ static int wiphy_verify_combinations(str
- 				    c->limits[j].max > 1))
- 				return -EINVAL;
- 
--			/*
--			 * This isn't well-defined right now. If you have an
--			 * IBSS interface, then its beacon interval may change
--			 * by joining other networks, and nothing prevents it
--			 * from doing that.
--			 * So technically we probably shouldn't even allow AP
--			 * and IBSS in the same interface, but it seems that
--			 * some drivers support that, possibly only with fixed
--			 * beacon intervals for IBSS.
--			 */
--			if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
--				    c->beacon_int_min_gcd)) {
--				return -EINVAL;
--			}
--
- 			cnt += c->limits[j].max;
- 			/*
- 			 * Don't advertise an unsupported type
diff --git a/package/kernel/mac80211/patches/subsys/401-mac80211-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/subsys/401-mac80211-allow-vht-on-2g.patch
deleted file mode 100644
index 5d8742ba..00000000
--- a/package/kernel/mac80211/patches/subsys/401-mac80211-allow-vht-on-2g.patch
+++ /dev/null
@@ -1,36 +0,0 @@
---- a/net/mac80211/vht.c
-+++ b/net/mac80211/vht.c
-@@ -135,7 +135,8 @@ ieee80211_vht_cap_ie_to_sta_vht_cap(stru
- 	have_80mhz = false;
- 	for (i = 0; i < sband->n_channels; i++) {
- 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
--						IEEE80211_CHAN_NO_80MHZ))
-+						IEEE80211_CHAN_NO_80MHZ) &
-+						(sband->band != NL80211_BAND_2GHZ))
- 			continue;
- 
- 		have_80mhz = true;
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -1955,7 +1955,8 @@ static int ieee80211_build_preq_ies_band
- 	/* Check if any channel in this sband supports at least 80 MHz */
- 	for (i = 0; i < sband->n_channels; i++) {
- 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
--						IEEE80211_CHAN_NO_80MHZ))
-+						IEEE80211_CHAN_NO_80MHZ) &
-+						(sband->band != NL80211_BAND_2GHZ))
- 			continue;
- 
- 		have_80mhz = true;
---- a/net/mac80211/mlme.c
-+++ b/net/mac80211/mlme.c
-@@ -4744,7 +4744,8 @@ static int ieee80211_prep_channel(struct
- 	have_80mhz = false;
- 	for (i = 0; i < sband->n_channels; i++) {
- 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
--						IEEE80211_CHAN_NO_80MHZ))
-+						IEEE80211_CHAN_NO_80MHZ) &
-+						(sband->band != NL80211_BAND_2GHZ))
- 			continue;
- 
- 		have_80mhz = true;
diff --git a/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch b/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch
deleted file mode 100644
index aeedcdab..00000000
--- a/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch
+++ /dev/null
@@ -1,162 +0,0 @@
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -4084,6 +4084,7 @@ struct mgmt_frame_regs {
-  *	(as advertised by the nl80211 feature flag.)
-  * @get_tx_power: store the current TX power into the dbm variable;
-  *	return 0 if successful
-+ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
-  *
-  * @rfkill_poll: polls the hw rfkill line, use cfg80211 reporting
-  *	functions to adjust rfkill hw state
-@@ -4434,6 +4435,7 @@ struct cfg80211_ops {
- 				enum nl80211_tx_power_setting type, int mbm);
- 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
- 				int *dbm);
-+	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
- 
- 	void	(*rfkill_poll)(struct wiphy *wiphy);
- 
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1688,6 +1688,7 @@ enum ieee80211_smps_mode {
-  *
-  * @power_level: requested transmit power (in dBm), backward compatibility
-  *	value only that is set to the minimum of all interfaces
-+ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
-  *
-  * @chandef: the channel definition to tune to
-  * @radar_enabled: whether radar detection is enabled
-@@ -1708,6 +1709,7 @@ enum ieee80211_smps_mode {
- struct ieee80211_conf {
- 	u32 flags;
- 	int power_level, dynamic_ps_timeout;
-+	int max_antenna_gain;
- 
- 	u16 listen_interval;
- 	u8 ps_dtim_period;
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -2749,6 +2749,9 @@ enum nl80211_commands {
-  *	When used with %NL80211_CMD_FRAME_TX_STATUS, indicates the ack RX
-  *	timestamp. When used with %NL80211_CMD_FRAME RX notification, indicates
-  *	the incoming frame RX timestamp.
-+ * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
-+ *	transmit power to stay within regulatory limits. u32, dBi.
-+ *
-  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
-  * @NL80211_ATTR_MAX: highest attribute number currently defined
-  * @__NL80211_ATTR_AFTER_LAST: internal use
-@@ -3277,6 +3280,8 @@ enum nl80211_attrs {
- 	NL80211_ATTR_TX_HW_TIMESTAMP,
- 	NL80211_ATTR_RX_HW_TIMESTAMP,
- 
-+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
-+
- 	/* add attributes here, update the policy in nl80211.c */
- 
- 	__NL80211_ATTR_AFTER_LAST,
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -3046,6 +3046,19 @@ static int ieee80211_get_tx_power(struct
- 	return 0;
- }
- 
-+static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
-+{
-+	struct ieee80211_local *local = wiphy_priv(wiphy);
-+
-+	if (dbi < 0)
-+		return -EINVAL;
-+
-+	local->user_antenna_gain = dbi;
-+	ieee80211_hw_config(local, 0);
-+
-+	return 0;
-+}
-+
- static void ieee80211_rfkill_poll(struct wiphy *wiphy)
- {
- 	struct ieee80211_local *local = wiphy_priv(wiphy);
-@@ -4956,6 +4969,7 @@ const struct cfg80211_ops mac80211_confi
- 	.set_wiphy_params = ieee80211_set_wiphy_params,
- 	.set_tx_power = ieee80211_set_tx_power,
- 	.get_tx_power = ieee80211_get_tx_power,
-+	.set_antenna_gain = ieee80211_set_antenna_gain,
- 	.rfkill_poll = ieee80211_rfkill_poll,
- 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
- 	CFG80211_TESTMODE_DUMP(ieee80211_testmode_dump)
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1542,6 +1542,7 @@ struct ieee80211_local {
- 	int dynamic_ps_forced_timeout;
- 
- 	int user_power_level; /* in dBm, for all interfaces */
-+	int user_antenna_gain; /* in dBi */
- 
- 	enum ieee80211_smps_mode smps_mode;
- 
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -96,7 +96,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 	struct ieee80211_sub_if_data *sdata;
- 	struct cfg80211_chan_def chandef = {};
- 	u32 changed = 0;
--	int power;
-+	int power, max_power;
- 	u32 offchannel_flag;
- 
- 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
-@@ -157,6 +157,12 @@ static u32 ieee80211_hw_conf_chan(struct
- 	}
- 	rcu_read_unlock();
- 
-+	max_power = chandef.chan->max_reg_power;
-+	if (local->user_antenna_gain > 0) {
-+		max_power -= local->user_antenna_gain;
-+		power = min(power, max_power);
-+	}
-+
- 	if (local->hw.conf.power_level != power) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
- 		local->hw.conf.power_level = power;
-@@ -762,6 +768,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
- 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
- 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
-+	local->user_antenna_gain = 0;
- 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
- 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
- 	local->hw.max_mtu = IEEE80211_MAX_DATA_LEN;
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -823,6 +823,7 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_MLD_ADDR] = NLA_POLICY_EXACT_LEN(ETH_ALEN),
- 	[NL80211_ATTR_MLO_SUPPORT] = { .type = NLA_FLAG },
- 	[NL80211_ATTR_MAX_NUM_AKM_SUITES] = { .type = NLA_REJECT },
-+	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
- };
- 
- /* policy for the key attributes */
-@@ -3535,6 +3536,22 @@ static int nl80211_set_wiphy(struct sk_b
- 		if (result)
- 			goto out;
- 	}
-+
-+	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
-+		int idx, dbi = 0;
-+
-+		if (!rdev->ops->set_antenna_gain) {
-+			result = -EOPNOTSUPP;
-+			goto out;
-+		}
-+
-+		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
-+		dbi = nla_get_u32(info->attrs[idx]);
-+
-+		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
-+		if (result)
-+			goto out;
-+	}
- 
- 	if (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {
- 		struct wireless_dev *txp_wdev = wdev;
diff --git a/package/kernel/mac80211/patches/subsys/780-avoid-crashing-missing-band.patch b/package/kernel/mac80211/patches/subsys/780-avoid-crashing-missing-band.patch
deleted file mode 100644
index f8d37742..00000000
--- a/package/kernel/mac80211/patches/subsys/780-avoid-crashing-missing-band.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From: David Bauer <mail@david-bauer.net>
-Date: Thu, 30 Nov 2023 07:32:52 +0100
-Subject: [PATCH] mac80211: avoid crashing on invalid band info
-
-Frequent crashes have been observed on MT7916 based platforms. While the
-root of these crashes are currently unknown, they happen when decoding
-rate information of connected STAs in AP mode. The rate-information is
-associated with a band which is not available on the PHY.
-
-Check for this condition in order to avoid crashing the whole system.
-This patch should be removed once the roout cause has been found and
-fixed.
-
-Link: https://github.com/freifunk-gluon/gluon/issues/2980
-
-Signed-off-by: David Bauer <mail@david-bauer.net>
----
-
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -2363,6 +2363,13 @@ static void sta_stats_decode_rate(struct
- 
- 		sband = local->hw.wiphy->bands[band];
- 
-+		if (!sband) {
-+			wiphy_warn(local->hw.wiphy,
-+				    "Invalid band %d\n",
-+				    band);
-+			break;
-+		}
-+
- 		if (WARN_ON_ONCE(!sband->bitrates))
- 			break;
- 
diff --git a/package/kernel/mac80211/patches/subsys/782-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch b/package/kernel/mac80211/patches/subsys/782-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch
deleted file mode 100644
index 26af6a2f..00000000
--- a/package/kernel/mac80211/patches/subsys/782-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch
+++ /dev/null
@@ -1,29 +0,0 @@
---- a/backport-include/linux/of_net.h
-+++ /dev/null
-@@ -1,26 +0,0 @@
--#ifndef _BP_OF_NET_H
--#define _BP_OF_NET_H
--#include_next <linux/of_net.h>
--#include <linux/version.h>
--#include <linux/etherdevice.h>
--
--/* The behavior of of_get_mac_address() changed in kernel 5.2, it now
-- * returns an error code and not NULL in case of an error.
-- */
--#if LINUX_VERSION_IS_LESS(5,13,0)
--static inline int backport_of_get_mac_address(struct device_node *np, u8 *mac_out)
--{
--	const void *mac = of_get_mac_address(np);
--
--	if (!mac)
--		return -ENODEV;
--	if (IS_ERR(mac))
--		return PTR_ERR(mac);
--	ether_addr_copy(mac_out, mac);
--	
--	return 0;
--}
--#define of_get_mac_address LINUX_BACKPORT(of_get_mac_address)
--#endif /* < 5.2 */
--
--#endif /* _BP_OF_NET_H */
diff --git a/package/kernel/mac80211/patches/subsys/800-rework-eth_hw_addr_set.patch b/package/kernel/mac80211/patches/subsys/800-rework-eth_hw_addr_set.patch
deleted file mode 100644
index 20f857f2..00000000
--- a/package/kernel/mac80211/patches/subsys/800-rework-eth_hw_addr_set.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/backport-include/linux/etherdevice.h
-+++ b/backport-include/linux/etherdevice.h
-@@ -39,7 +39,7 @@ static inline void u64_to_ether_addr(u64
- }
- #endif /* LINUX_VERSION_IS_LESS(4,11,0) */
- 
--#if LINUX_VERSION_IS_LESS(5,15,0)
-+#if LINUX_VERSION_IS_LESS(5,4,0)
- /**
-  * eth_hw_addr_set - Assign Ethernet address to a net_device
-  * @dev: pointer to net_device structure
diff --git a/package/kernel/mac80211/patches/subsys/900-add-eth-ieee80211_bss_conf.patch b/package/kernel/mac80211/patches/subsys/900-add-eth-ieee80211_bss_conf.patch
deleted file mode 100644
index 80668db3..00000000
--- a/package/kernel/mac80211/patches/subsys/900-add-eth-ieee80211_bss_conf.patch
+++ /dev/null
@@ -1,55 +0,0 @@
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -673,6 +673,12 @@ struct ieee80211_fils_discovery {
-  * @he_full_ul_mumimo: does this BSS support the reception (AP) or transmission
-  *	(non-AP STA) of an HE TB PPDU on an RU that spans the entire PPDU
-  *	bandwidth
-+ * @eht_su_beamformer: in AP-mode, does this BSS enable operation as an EHT SU
-+ *	beamformer
-+ * @eht_su_beamformee: in AP-mode, does this BSS enable operation as an EHT SU
-+ *	beamformee
-+ * @eht_mu_beamformer: in AP-mode, does this BSS enable operation as an EHT MU
-+ *	beamformer
-  */
- struct ieee80211_bss_conf {
- 	const u8 *bssid;
-@@ -758,6 +764,9 @@ struct ieee80211_bss_conf {
- 	bool he_su_beamformee;
- 	bool he_mu_beamformer;
- 	bool he_full_ul_mumimo;
-+	bool eht_su_beamformer;
-+	bool eht_su_beamformee;
-+	bool eht_mu_beamformer;
- };
- 
- /**
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1307,6 +1307,27 @@ static int ieee80211_start_ap(struct wip
- 				IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO;
- 	}
- 
-+	if (params->eht_cap) {
-+		if (!link_conf->he_support)
-+			return -EOPNOTSUPP;
-+		link_conf->eht_support = true;
-+		link_conf->eht_su_beamformer =
-+			params->eht_cap->fixed.phy_cap_info[0] &
-+				IEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER;
-+		link_conf->eht_su_beamformee =
-+			params->eht_cap->fixed.phy_cap_info[0] &
-+				IEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE;
-+		link_conf->eht_mu_beamformer =
-+			params->eht_cap->fixed.phy_cap_info[7] &
-+				(IEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_80MHZ |
-+				 IEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_160MHZ |
-+				 IEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_320MHZ);
-+	} else {
-+		link_conf->eht_su_beamformer = false;
-+		link_conf->eht_su_beamformee = false;
-+		link_conf->eht_mu_beamformer = false;
-+	}
-+
- 	if (sdata->vif.type == NL80211_IFTYPE_AP &&
- 	    params->mbssid_config.tx_wdev) {
- 		err = ieee80211_set_ap_mbssid_options(sdata,
diff --git a/package/kernel/mac80211/ralink.mk b/package/kernel/mac80211/ralink.mk
index 83d208ee..6925d9c5 100644
--- a/package/kernel/mac80211/ralink.mk
+++ b/package/kernel/mac80211/ralink.mk
@@ -1,6 +1,7 @@
 PKG_DRIVERS += \
 	rt2x00-lib rt2x00-pci rt2x00-usb rt2x00-mmio \
-	rt2800-lib rt2800-mmio rt2800-pci rt2800-soc rt2800-usb
+	rt2800-lib rt2800-mmio rt2800-pci rt2800-soc rt2800-usb \
+  rt61-pci rt73-usb
 
 PKG_CONFIG_DEPENDS += \
 	CONFIG_PACKAGE_RT2X00_LIB_DEBUGFS \
@@ -128,4 +129,18 @@ $(call KernelPackage/rt2x00/Default)
   AUTOLOAD:=$(call AutoProbe,rt2800usb)
 endef
 
+define KernelPackage/rt61-pci
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci +kmod-eeprom-93cx6 +kmod-lib-crc-itu-t +rt61-pci-firmware
+  TITLE+= (RT2x61 PCI)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt61pci.ko
+  AUTOLOAD:=$(call AutoProbe,rt61pci)
+endef
 
+define KernelPackage/rt73-usb
+  $(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb +kmod-lib-crc-itu-t +rt73-usb-firmware
+  TITLE+= (RT73 USB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt73usb.ko
+  AUTOLOAD:=$(call AutoProbe,rt73usb)
+endef
diff --git a/package/kernel/mac80211/realtek.mk b/package/kernel/mac80211/realtek.mk
index 2f1fa837..6ac4b1ae 100644
--- a/package/kernel/mac80211/realtek.mk
+++ b/package/kernel/mac80211/realtek.mk
@@ -1,7 +1,12 @@
 PKG_DRIVERS += \
-	rtlwifi rtlwifi-pci rtlwifi-btcoexist rtlwifi-usb rtl8192c-common \
-	rtl8192ce rtl8192se rtl8192de rtl8192cu rtl8723bs rtl8821ae \
-	rtl8xxxu rtw88
+	rtlwifi rtlwifi-pci rtlwifi-btcoexist rtlwifi-usb rtl8192c-common rtl8192d-common \
+	rtl8192ce rtl8192se rtl8192de rtl8192cu rtl8192du rtl8723-common rtl8723be \
+	rtl8723bs rtl8821ae rtl8xxxu rtw88 rtw88-pci rtw88-usb rtw88-sdio rtw88-8821c \
+	rtw88-8822b rtw88-8822c rtw88-8723x rtw88-8723d rtw88-8821ce rtw88-8821cu \
+	rtw88-8822be rtw88-8822bu rtw88-8822ce rtw88-8822cu rtw88-8723de rtw88-8723ds \
+	rtw88-88xxa rtw88-8821a rtw88-8812a rtw88-8821au rtw88-8812au \
+	rtw88-8723du rtw89 rtw89-pci rtw89-8851be rtw89-8852ae rtw89-8852b-common \
+	rtw89-8852be rtw89-8852ce rtw89-8922ae
 
 config-$(call config_package,rtlwifi) += RTL_CARDS RTLWIFI
 config-$(call config_package,rtlwifi-pci) += RTLWIFI_PCI
@@ -10,7 +15,9 @@ config-$(call config_package,rtlwifi-usb) += RTLWIFI_USB
 config-$(call config_package,rtl8192c-common) += RTL8192C_COMMON
 config-$(call config_package,rtl8192ce) += RTL8192CE
 config-$(call config_package,rtl8192se) += RTL8192SE
+config-$(call config_package,rtl8192d-common) += RTL8192D_COMMON
 config-$(call config_package,rtl8192de) += RTL8192DE
+config-$(call config_package,rtl8192du) += RTL8192DU
 config-$(call config_package,rtl8192cu) += RTL8192CU
 config-$(call config_package,rtl8821ae) += RTL8821AE
 config-$(CONFIG_PACKAGE_RTLWIFI_DEBUG) += RTLWIFI_DEBUG
@@ -18,14 +25,50 @@ config-$(CONFIG_PACKAGE_RTLWIFI_DEBUG) += RTLWIFI_DEBUG
 config-$(call config_package,rtl8xxxu) += RTL8XXXU
 config-y += RTL8XXXU_UNTESTED
 
+config-$(call config_package,rtl8723-common) += RTL8723_COMMON
+config-$(call config_package,rtl8723be) += RTL8723BE
+
 config-$(call config_package,rtl8723bs) += RTL8723BS
 config-y += STAGING
 
-config-$(call config_package,rtw88) += RTW88 RTW88_CORE RTW88_PCI
-config-y += RTW88_8821CE RTW88_8822BE RTW88_8822CE RTW88_8723DE
+config-$(call config_package,rtw88) += RTW88 RTW88_CORE
+config-$(call config_package,rtw88-pci) += RTW88_PCI
+config-$(call config_package,rtw88-usb) += RTW88_USB
+config-$(call config_package,rtw88-sdio) += RTW88_SDIO
+config-$(call config_package,rtw88-8821c) += RTW88_8821C
+config-$(call config_package,rtw88-8821ce) += RTW88_8821CE
+config-$(call config_package,rtw88-8821cu) += RTW88_8821CU
+config-$(call config_package,rtw88-8822b) += RTW88_8822B
+config-$(call config_package,rtw88-8822be) += RTW88_8822BE
+config-$(call config_package,rtw88-8822bu) += RTW88_8822BU
+config-$(call config_package,rtw88-8822c) += RTW88_8822C
+config-$(call config_package,rtw88-8822ce) += RTW88_8822CE
+config-$(call config_package,rtw88-8822cu) += RTW88_8822CU
+config-$(call config_package,rtw88-8723x) += RTW88_8723X
+config-$(call config_package,rtw88-8723d) += RTW88_8723D
+config-$(call config_package,rtw88-8723de) += RTW88_8723DE
+config-$(call config_package,rtw88-8723ds) += RTW88_8723DS
+config-$(call config_package,rtw88-8723du) += RTW88_8723DU
+config-$(call config_package,rtw88-88xxa) += RTW88_88XXA
+config-$(call config_package,rtw88-8821a) += RTW88_8821A
+config-$(call config_package,rtw88-8812a) += RTW88_8812A
+config-$(call config_package,rtw88-8821au) += RTW88_8821AU
+config-$(call config_package,rtw88-8812au) += RTW88_8812AU
 config-$(CONFIG_PACKAGE_RTW88_DEBUG) += RTW88_DEBUG
 config-$(CONFIG_PACKAGE_RTW88_DEBUGFS) += RTW88_DEBUGFS
 
+config-$(call config_package,rtw89) += RTW89 RTW89_CORE
+config-$(call config_package,rtw89-pci) += RTW89_PCI
+config-$(call config_package,rtw89-8851be) += RTW89_8851B RTW89_8851BE
+config-$(call config_package,rtw89-8852ae) += RTW89_8852A RTW89_8852AE
+config-$(call config_package,rtw89-8852b-common) += RTW89_8852B_COMMON
+config-$(call config_package,rtw89-8852be) += RTW89_8852B RTW89_8852BE
+config-$(call config_package,rtw89-8852ce) += RTW89_8852C RTW89_8852CE
+config-$(call config_package,rtw89-8922ae) += RTW89_8922A RTW89_8922AE
+config-$(CONFIG_PACKAGE_RTW89_DEBUG) += RTW89_DEBUG
+config-$(CONFIG_PACKAGE_RTW89_DEBUGFS) += RTW89_DEBUGFS
+config-$(CONFIG_PACKAGE_RTW89_DEBUGMSG) += RTW89_DEBUGMSG
+
 define KernelPackage/rtlwifi/config
 	config PACKAGE_RTLWIFI_DEBUG
 		bool "Realtek wireless debugging"
@@ -38,7 +81,7 @@ endef
 define KernelPackage/rtlwifi
   $(call KernelPackage/mac80211/Default)
   TITLE:=Realtek common driver part
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT) +kmod-mac80211 +@DRIVER_11N_SUPPORT
+  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT) +kmod-mac80211
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtlwifi.ko
   HIDDEN:=1
 endef
@@ -94,14 +137,30 @@ define KernelPackage/rtl8192se
   AUTOLOAD:=$(call AutoProbe,rtl8192se)
 endef
 
+define KernelPackage/rtl8192d-common
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8192DE/RTL8192DU common support module
+  DEPENDS+= +kmod-rtlwifi
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192d/rtl8192d-common.ko
+  HIDDEN:=1
+endef
+
 define KernelPackage/rtl8192de
   $(call KernelPackage/mac80211/Default)
   TITLE:=Realtek RTL8192DE/RTL8188DE support
-  DEPENDS+= +kmod-rtlwifi-pci +rtl8192de-firmware
+  DEPENDS+= +kmod-rtlwifi-pci +kmod-rtl8192d-common +rtl8192de-firmware
   FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192de/rtl8192de.ko
   AUTOLOAD:=$(call AutoProbe,rtl8192de)
 endef
 
+define KernelPackage/rtl8192du
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8192DU support
+  DEPENDS+= +kmod-rtlwifi-usb +kmod-rtl8192d-common +rtl8192du-firmware
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192du/rtl8192du.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8192du)
+endef
+
 define KernelPackage/rtl8192cu
   $(call KernelPackage/mac80211/Default)
   TITLE:=Realtek RTL8192CU/RTL8188CU support
@@ -168,20 +227,214 @@ endef
 
 define KernelPackage/rtw88
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8821CE/RTL8822BE/RTL8822CE/RTL8723DE
-  DEPENDS+= @(PCI_SUPPORT) +kmod-mac80211 +@DRIVER_11AC_SUPPORT +@DRIVER_11N_SUPPORT
-  FILES:=\
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8821ce.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8821c.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822be.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822b.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822ce.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822c.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8723de.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8723d.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_core.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_pci.ko
-  AUTOLOAD:=$(call AutoProbe,rtw88_8821ce rtw88_8822be rtw88_8822ce rtw88_8723de)
+  TITLE:=Realtek RTW88 common part
+  DEPENDS+= +kmod-mac80211
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_core.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_core)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-pci
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTW88 PCI chips support
+  DEPENDS+= @PCI_SUPPORT +kmod-rtw88
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_pci.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_pci)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-sdio
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTW88 SDIO chips support
+  DEPENDS+= +kmod-mmc +kmod-rtw88
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_sdio.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_sdio)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-usb
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTW88 USB chips support
+  DEPENDS+= @USB_SUPPORT +kmod-rtw88 +kmod-usb-core
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_usb.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_usb)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-88xxa
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8812A/RTL8821A family support
+  DEPENDS+= +@DRIVER_11AC_SUPPORT +kmod-rtw88-usb
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_88xxa.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_88xxa)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8821a
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8821A family support
+  DEPENDS+= +kmod-rtw88-88xxa
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8821a.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8821a)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8812a
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8812A family support
+  DEPENDS+= +kmod-rtw88-88xxa
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8812a.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8812a)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8821c
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8821C family support
+  DEPENDS+= +kmod-rtw88 +rtl8821ce-firmware +@DRIVER_11AC_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8821c.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8821c)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8822b
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8822B family support
+  DEPENDS+= +kmod-rtw88 +rtl8822be-firmware +@DRIVER_11AC_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822b.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8822b)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8822c
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8822C family support
+  DEPENDS+= +kmod-rtw88 +rtl8822ce-firmware +@DRIVER_11AC_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822c.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8822c)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8723x
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8723x family support
+  DEPENDS+= +kmod-rtw88
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8723x.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8723x)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8723d
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8723D family support
+  DEPENDS+= +kmod-rtw88-8723x +rtl8723de-firmware
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8723d.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8723d)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw88-8821au
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8821AU support
+  DEPENDS+= +kmod-rtw88-8821a +rtl8821a-firmware
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8821au.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8821au)
+endef
+
+define KernelPackage/rtw88-8812au
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8812AU support
+  DEPENDS+= +kmod-rtw88-8812a +rtl8812a-firmware
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8812au.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8812au)
+endef
+
+define KernelPackage/rtw88-8821ce
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8821CE support
+  DEPENDS+= +kmod-rtw88-pci +kmod-rtw88-8821c
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8821ce.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8821ce)
+endef
+
+define KernelPackage/rtw88-8821cu
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8821CU support
+  DEPENDS+= +kmod-rtw88-usb +kmod-rtw88-8821c
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8821cu.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8821cu)
+endef
+
+define KernelPackage/rtw88-8822be
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8822BE support
+  DEPENDS+= +kmod-rtw88-pci +kmod-rtw88-8822b
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822be.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8822be)
+endef
+
+define KernelPackage/rtw88-8822bu
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8822BU support
+  DEPENDS+= +kmod-rtw88-usb +kmod-rtw88-8822b
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822bu.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8822bu)
+endef
+
+define KernelPackage/rtw88-8822ce
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8822CE support
+  DEPENDS+= +kmod-rtw88-pci +kmod-rtw88-8822c
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822ce.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8822ce)
+endef
+
+define KernelPackage/rtw88-8822cu
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8822CU support
+  DEPENDS+= +kmod-rtw88-usb +kmod-rtw88-8822c
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8822cu.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8822cu)
+endef
+
+define KernelPackage/rtw88-8723de
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8723DE support
+  DEPENDS+= +kmod-rtw88-pci +kmod-rtw88-8723d
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8723de.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8723de)
+endef
+
+define KernelPackage/rtw88-8723ds
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8723DS support
+  DEPENDS+= +kmod-rtw88-sdio +kmod-rtw88-8723d
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8723ds.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8723ds)
+endef
+
+define KernelPackage/rtw88-8723du
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8723DU support
+  DEPENDS+= +kmod-rtw88-usb +kmod-rtw88-8723d
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88_8723du.ko
+  AUTOLOAD:=$(call AutoProbe,rtw88_8723du)
+endef
+
+define KernelPackage/rtl8723-common
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8723AE/RTL8723BE common support module
+  DEPENDS+= +kmod-rtlwifi
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8723com/rtl8723-common.ko
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtl8723be
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8723AE/RTL8723BE support
+  DEPENDS+= +kmod-rtlwifi-btcoexist +kmod-rtlwifi-pci +kmod-rtl8723-common +rtl8723be-firmware
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8723be/rtl8723be.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8723be)
 endef
 
 define KernelPackage/rtl8723bs
@@ -197,3 +450,103 @@ define KernelPackage/rtl8723bs/description
  on the 1st gen Intel Compute Stick, the CHIP and many other Intel Atom and ARM
  based devices.
 endef
+
+define KernelPackage/rtw89/config
+	config PACKAGE_RTW89_DEBUG
+		bool "Realtek wireless debugging (rtw89)"
+		depends on PACKAGE_kmod-rtw89
+		help
+		  Enable debugging output for rtw89 devices.
+
+	config PACKAGE_RTW89_DEBUGFS
+		bool "Enable rtw89 debugfs support"
+		select KERNEL_DEBUG_FS
+		depends on PACKAGE_kmod-rtw89
+		help
+		  Select this to see extensive information about
+		  the internal state of rtw89 in debugfs.
+
+	config PACKAGE_RTW89_DEBUGMSG
+		bool "Realtek rtw89 debug message support"
+		depends on PACKAGE_kmod-rtw89
+		help
+		  Enable debug message support.
+endef
+
+define KernelPackage/rtw89
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTW89 core
+  DEPENDS+= +@DRIVER_11AC_SUPPORT +@DRIVER_11AX_SUPPORT +kmod-mac80211
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_core.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_core)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw89-pci
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTW89 PCI chips support
+  DEPENDS+= @PCI_SUPPORT +kmod-rtw89
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_pci.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_pci)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw89-8851be
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8851BE support
+  DEPENDS+= +kmod-rtw89-pci +rtl8851be-firmware
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8851b.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8851be.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_8851be)
+endef
+
+define KernelPackage/rtw89-8852ae
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8852AE support
+  DEPENDS+= +kmod-rtw89-pci +rtl8852ae-firmware
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8852a.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8852ae.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_8852ae)
+endef
+
+define KernelPackage/rtw89-8852b-common
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8852B family support
+  DEPENDS+= +kmod-rtw89-pci
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8852b_common.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_8852b_common)
+  HIDDEN:=1
+endef
+
+define KernelPackage/rtw89-8852be
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8852BE support
+  DEPENDS+= +kmod-rtw89-8852b-common +rtl8852be-firmware
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8852b.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8852be.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_8852be)
+endef
+
+define KernelPackage/rtw89-8852ce
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8852CE support
+  DEPENDS+= +kmod-rtw89-pci +rtl8852ce-firmware
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8852c.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8852ce.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_8852ce)
+endef
+
+define KernelPackage/rtw89-8922ae
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8922AE support
+  DEPENDS+= +kmod-rtw89-pci +rtl8922ae-firmware +@DRIVER_11BE_SUPPORT
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8922a.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw89/rtw89_8922ae.ko
+  AUTOLOAD:=$(call AutoProbe,rtw89_8922ae)
+endef
diff --git a/package/libs/elfutils/Makefile b/package/libs/elfutils/Makefile
index a32dd704..472237fb 100644
--- a/package/libs/elfutils/Makefile
+++ b/package/libs/elfutils/Makefile
@@ -22,7 +22,6 @@ PKG_CPE_ID:=cpe:/a:elfutils_project:elfutils
 
 PKG_FIXUP:=autoreconf
 PKG_INSTALL:=1
-PKG_USE_MIPS16:=1
 PKG_BUILD_DEPENDS:=!USE_GLIBC:argp-standalone
 
 include $(INCLUDE_DIR)/package.mk
@@ -87,9 +86,10 @@ CONFIGURE_VARS += \
 TARGET_CFLAGS += \
 	-D_GNU_SOURCE \
 	-Wno-unused-result \
-	-Wno-format-nonliteral
+	-Wno-format-nonliteral \
+	-Wno-error
 
-ifneq ($(filter $(GCC_MAJOR_VERSION),12 13),)
+ifneq ($(CONFIG_GCC_USE_VERSION_11),y)
 TARGET_CFLAGS += \
 	-Wno-error=use-after-free
 endif
diff --git a/package/libs/pcre/Config.in b/package/libs/pcre/Config.in
deleted file mode 100644
index 15e75fc7..00000000
--- a/package/libs/pcre/Config.in
+++ /dev/null
@@ -1,11 +0,0 @@
-config PCRE_JIT_ENABLED
-	bool
-	depends on PACKAGE_libpcre && (arm || i386 || i686 || x86_64 || mips || mipsel || powerpc || sparc)
-	default y if (arm || i686 || x86_64)
-	prompt "Enable JIT compiler support"
-	help
-		Enable JIT (Just-In-Time) compiler support.
-
-		Enabling this option can give an about 10x performance increase on JIT operations. It can be desireable for e.g. high performance Apache mod_rewrite or HA-Proxy reqrep operations.
-
-		However, JIT should _only_ be enabled on architectures that are supported. Enabling JIT on unsupported platforms will result in a compilation failure. A list of supported architectures can be found here: https://pcre.org/original/doc/html/pcrejit.html#SEC3 .
diff --git a/package/libs/pcre/Makefile b/package/libs/pcre/Makefile
deleted file mode 100644
index 894f39b7..00000000
--- a/package/libs/pcre/Makefile
+++ /dev/null
@@ -1,129 +0,0 @@
-#
-# Copyright (C) 2006-2015 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-include $(TOPDIR)/rules.mk
-
-PKG_NAME:=pcre
-PKG_VERSION:=8.45
-PKG_RELEASE:=$(AUTORELEASE)
-
-PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
-PKG_SOURCE_URL:=@SF/$(PKG_NAME)
-PKG_HASH:=4dae6fdcd2bb0bb6c37b5f97c33c2be954da743985369cddac3546e3218bffb8
-
-PKG_MAINTAINER:=Thomas Heil <heil@terminal-consulting.de>
-PKG_LICENSE:=BSD-3-Clause
-PKG_LICENSE_FILES:=LICENCE
-PKG_CPE_ID:=cpe:/a:pcre:pcre
-
-PKG_INSTALL:=1
-PKG_BUILD_PARALLEL:=1
-
-PKG_CONFIG_DEPENDS:=\
-	CONFIG_PACKAGE_libpcrecpp \
-	CONFIG_PCRE_JIT_ENABLED
-
-include $(INCLUDE_DIR)/package.mk
-include $(INCLUDE_DIR)/host-build.mk
-
-define Package/libpcre/default
-  SECTION:=libs
-  CATEGORY:=Libraries
-  URL:=https://www.pcre.org/
-endef
-
-define Package/libpcre/config
-  source "$(SOURCE)/Config.in"
-endef
-
-define Package/libpcre
-  $(call Package/libpcre/default)
-  TITLE:=A Perl Compatible Regular Expression library
-endef
-
-define Package/libpcre16
-  $(call Package/libpcre/default)
-  TITLE:=A Perl Compatible Regular Expression library (16bit support)
-endef
-
-define Package/libpcre32
-  $(call Package/libpcre/default)
-  TITLE:=A Perl Compatible Regular Expression library (32bit support)
-endef
-
-define Package/libpcrecpp
-  $(call Package/libpcre/default)
-  TITLE:=C++ wrapper for Perl Compatible Regular Expression library
-  DEPENDS:=+libpcre +libstdcpp
-endef
-
-HOST_CONFIGURE_ARGS += \
-	--disable-shared \
-	--enable-utf8 \
-	--enable-unicode-properties \
-	--enable-pcre16 \
-	--with-match-limit-recursion=16000 \
-	--enable-cpp \
-	--with-pic
-
-CONFIGURE_ARGS += \
-	--enable-utf8 \
-	--enable-unicode-properties \
-	--enable-pcre16 \
-	--enable-pcre32 \
-	$(if $(CONFIG_PCRE_JIT_ENABLED),--enable-jit,--disable-jit) \
-	--with-match-limit-recursion=16000 \
-	--$(if $(CONFIG_PACKAGE_libpcrecpp),en,dis)able-cpp \
-	--with-pic
-
-MAKE_FLAGS += \
-	CFLAGS="$(TARGET_CFLAGS)"
-
-define Build/InstallDev
-	$(INSTALL_DIR) $(1)/usr/bin
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/pcre-config $(1)/usr/bin/
-	$(SED) 's,^\(prefix\|exec_prefix\)=.*,\1=$(STAGING_DIR)/usr,g' $(1)/usr/bin/pcre-config
-
-	$(INSTALL_DIR) $(2)/bin
-	$(LN) $(STAGING_DIR)/usr/bin/pcre-config $(2)/bin
-
-	$(INSTALL_DIR) $(1)/usr/include
-	$(CP) $(PKG_INSTALL_DIR)/usr/include/pcre*.h $(1)/usr/include/
-
-	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libpcre*.{a,so*} $(1)/usr/lib/
-
-	$(INSTALL_DIR) $(1)/usr/lib/pkgconfig
-	$(CP) $(PKG_INSTALL_DIR)/usr/lib/pkgconfig/libpcre*.pc $(1)/usr/lib/pkgconfig/
-endef
-
-define Package/libpcre/install
-	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libpcre{,posix}.so.* $(1)/usr/lib/
-	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libpcre.so $(1)/usr/lib/
-endef
-
-define Package/libpcre16/install
-	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libpcre16.so* $(1)/usr/lib/
-endef
-
-define Package/libpcre32/install
-	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libpcre32.so* $(1)/usr/lib/
-endef
-
-define Package/libpcrecpp/install
-	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libpcrecpp.so.* $(1)/usr/lib/
-endef
-
-$(eval $(call BuildPackage,libpcre))
-$(eval $(call BuildPackage,libpcre16))
-$(eval $(call BuildPackage,libpcre32))
-$(eval $(call BuildPackage,libpcrecpp))
-$(eval $(call HostBuild))
diff --git a/package/network/services/ppp/Makefile b/package/network/services/ppp/Makefile
index 419136ca..760a31dc 100644
--- a/package/network/services/ppp/Makefile
+++ b/package/network/services/ppp/Makefile
@@ -9,27 +9,38 @@ include $(TOPDIR)/rules.mk
 include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=ppp
-PKG_RELEASE:=6
+PKG_VERSION:=2.5.1
+PKG_RELEASE:=1
 
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_URL:=https://github.com/paulusmack/ppp
-PKG_SOURCE_DATE:=2021-01-04
-PKG_SOURCE_VERSION:=4fb319056f168bb8379865b91b4fd3e1ada73f1e
-PKG_MIRROR_HASH:=429cb5fcff36e1d8698766130711d4764347f08b83233dfb4831bea21616efef
+PKG_SOURCE_URL:=https://github.com/ppp-project/ppp
+PKG_SOURCE_DATE:=2024-09-18
+PKG_SOURCE_VERSION:=d5aeec65752d4a9b3bb46771d0b221c4a4a6539e
+PKG_MIRROR_HASH:=b98125933d8160ff3476b053414e787e65a94948c0ecee53f6261cd403ff4b03
+
 PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
 PKG_LICENSE:=BSD-4-Clause
 PKG_CPE_ID:=cpe:/a:samba:ppp
 
-PKG_RELEASE_VERSION:=2.4.9
-PKG_VERSION:=$(PKG_RELEASE_VERSION).git-$(PKG_SOURCE_DATE)
-
-PKG_BUILD_DEPENDS:=libpcap
-
 PKG_ASLR_PIE_REGULAR:=1
+PKG_BUILD_DEPENDS:=libpcap
+PKG_BUILD_FLAGS:=gc-sections lto
 PKG_BUILD_PARALLEL:=1
+PKG_FIXUP:=autoreconf
 PKG_INSTALL:=1
 
 include $(INCLUDE_DIR)/package.mk
+CONFIGURE_VARS += \
+	enable_eaptls=no \
+	enable_microsoft_extensions=yes \
+	enable_peap=no
+
+CONFIGURE_ARGS += \
+	with_openssl=no \
+	with_pam=no \
+	with_pcap=no \
+	with_srp=no \
+	with_static_pcap=yes
 
 define Package/ppp/Default
   SECTION:=net
@@ -39,7 +50,7 @@ endef
 
 define Package/ppp
 $(call Package/ppp/Default)
-  DEPENDS:=+kmod-ppp +libpthread +shellsync +kmod-mppe
+  DEPENDS:=+kmod-ppp
   TITLE:=PPP daemon
   VARIANT:=default
 endef
@@ -173,54 +184,25 @@ This tool performs the same discovery process as pppoe, but does
 not initiate a session. Can be useful to debug pppoe.
 endef
 
-
-define Build/Configure
-$(call Build/Configure/Default,, \
-	UNAME_S="Linux" \
-	UNAME_R="$(LINUX_VERSION)" \
-	UNAME_M="$(ARCH)" \
-)
-	mkdir -p $(PKG_BUILD_DIR)/pppd/plugins/pppoatm/linux
-	$(CP) \
-		$(LINUX_DIR)/include/linux/compiler.h \
-		$(LINUX_DIR)/include/$(LINUX_UAPI_DIR)linux/atm*.h \
-		$(PKG_BUILD_DIR)/pppd/plugins/pppoatm/linux/
-
-	# Kernel 4.14.9+ only, ignore the exit status of cp in case the file
-	# doesn't exits
-	-$(CP) $(LINUX_DIR)/include/linux/compiler_types.h \
-		$(PKG_BUILD_DIR)/pppd/plugins/pppoatm/linux/
-endef
-
-TARGET_CFLAGS += -ffunction-sections -fdata-sections -flto
-TARGET_LDFLAGS += -Wl,--gc-sections -flto -fuse-linker-plugin
-
-MAKE_FLAGS += COPTS="$(TARGET_CFLAGS)" \
-		PRECOMPILED_FILTER=1 \
-		STAGING_DIR="$(STAGING_DIR)"
-
 ifeq ($(BUILD_VARIANT),multilink)
-  MAKE_FLAGS += HAVE_MULTILINK=y
-else
-  MAKE_FLAGS += HAVE_MULTILINK=
-endif
-
-ifdef CONFIG_USE_MUSL
-  MAKE_FLAGS += USE_LIBUTIL=
+  CONFIGURE_VARS += \
+	enable_multilink=yes
 endif
 
 define Build/InstallDev
 	$(INSTALL_DIR) $(1)/usr/include
-	$(CP) $(PKG_INSTALL_DIR)/include/pppd $(1)/usr/include/
+	$(CP) $(PKG_INSTALL_DIR)/usr/include/pppd $(1)/usr/include/
+	$(INSTALL_DIR) $(1)/usr/lib/pkgconfig
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/pkgconfig/*.pc $(1)/usr/lib/pkgconfig
 endef
 
 define Package/ppp/script_install
 endef
 
 define Package/ppp/install
-	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)
+	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_VERSION)
 	$(INSTALL_DIR) $(1)/usr/sbin
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/sbin/pppd $(1)/usr/sbin/
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/pppd $(1)/usr/sbin/
 	$(INSTALL_DIR) $(1)/etc/ppp
 	$(INSTALL_CONF) ./files/etc/ppp/chap-secrets $(1)/etc/ppp/
 	$(INSTALL_DATA) ./files/etc/ppp/filter $(1)/etc/ppp/
@@ -235,21 +217,21 @@ endef
 Package/ppp-multilink/install=$(Package/ppp/install)
 
 define Package/ppp-mod-pppoa/install
-	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/lib/pppd/$(PKG_RELEASE_VERSION)/pppoatm.so \
-		$(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)/
+	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_VERSION)
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/pppd/$(PKG_VERSION)/pppoatm.so \
+		$(1)/usr/lib/pppd/$(PKG_VERSION)/
 endef
 
 define Package/ppp-mod-pppoe/install
-	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/lib/pppd/$(PKG_RELEASE_VERSION)/pppoe.so \
-		$(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)/
+	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_VERSION)
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/pppd/$(PKG_VERSION)/pppoe.so \
+		$(1)/usr/lib/pppd/$(PKG_VERSION)/
 endef
 
 define Package/ppp-mod-radius/install
-	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/lib/pppd/$(PKG_RELEASE_VERSION)/radius.so \
-		$(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)/
+	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_VERSION)
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/pppd/$(PKG_VERSION)/radius.so \
+		$(1)/usr/lib/pppd/$(PKG_VERSION)/
 	$(INSTALL_DIR) $(1)/etc/ppp
 	$(INSTALL_DATA) ./files/etc/ppp/radius.conf $(1)/etc/ppp/
 	$(INSTALL_DIR) $(1)/etc/ppp/radius
@@ -260,43 +242,43 @@ define Package/ppp-mod-radius/install
 endef
 
 define Package/ppp-mod-pppol2tp/install
-	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/lib/pppd/$(PKG_RELEASE_VERSION)/pppol2tp.so \
-		$(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)/
+	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_VERSION)
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/pppd/$(PKG_VERSION)/pppol2tp.so \
+		$(1)/usr/lib/pppd/$(PKG_VERSION)/
 endef
 
 define Package/ppp-mod-pptp/install
-	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/lib/pppd/$(PKG_RELEASE_VERSION)/pptp.so \
-		$(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)/
+	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_VERSION)
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/pppd/$(PKG_VERSION)/pptp.so \
+		$(1)/usr/lib/pppd/$(PKG_VERSION)/
 	$(INSTALL_DIR) $(1)/etc/ppp
 	$(INSTALL_DATA) ./files/etc/ppp/options.pptp $(1)/etc/ppp/
 endef
 
 define Package/ppp-mod-passwordfd/install
-	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/lib/pppd/$(PKG_RELEASE_VERSION)/passwordfd.so \
-		$(1)/usr/lib/pppd/$(PKG_RELEASE_VERSION)/
+	$(INSTALL_DIR) $(1)/usr/lib/pppd/$(PKG_VERSION)
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/pppd/$(PKG_VERSION)/passwordfd.so \
+		$(1)/usr/lib/pppd/$(PKG_VERSION)/
 endef
 
 define Package/chat/install
 	$(INSTALL_DIR) $(1)/usr/sbin
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/sbin/chat $(1)/usr/sbin/
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/chat $(1)/usr/sbin/
 endef
 
 define Package/pppdump/install
 	$(INSTALL_DIR) $(1)/usr/sbin
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/sbin/pppdump $(1)/usr/sbin/
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/pppdump $(1)/usr/sbin/
 endef
 
 define Package/pppstats/install
 	$(INSTALL_DIR) $(1)/usr/sbin
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/sbin/pppstats $(1)/usr/sbin/
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/pppstats $(1)/usr/sbin/
 endef
 
 define Package/pppoe-discovery/install
 	$(INSTALL_DIR) $(1)/usr/sbin
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/sbin/pppoe-discovery $(1)/usr/sbin/
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/pppoe-discovery $(1)/usr/sbin/
 endef
 
 $(eval $(call BuildPackage,ppp))
diff --git a/package/network/services/ppp/files/lib/netifd/ppp6-up b/package/network/services/ppp/files/lib/netifd/ppp6-up
index 3852bf63..51339ad3 100755
--- a/package/network/services/ppp/files/lib/netifd/ppp6-up
+++ b/package/network/services/ppp/files/lib/netifd/ppp6-up
@@ -27,6 +27,8 @@ if [ -n "$AUTOIPV6" ]; then
 	[ -n "$EXTENDPREFIX" ] && json_add_string extendprefix 1
 	[ -n "$IP6TABLE" ] && json_add_string ip6table $IP6TABLE
 	[ -n "$PEERDNS" ] && json_add_boolean peerdns $PEERDNS
+	[ "$NOSOURCEFILTER" = "1" ] && json_add_boolean sourcefilter "0"
+	[ "$DELEGATE" = "0" ] && json_add_boolean delegate "0"
 	json_close_object
 	ubus call network add_dynamic "$(json_dump)"
 fi
diff --git a/package/network/services/ppp/files/ppp.sh b/package/network/services/ppp/files/ppp.sh
index f6c43b57..d7c0cdb1 100755
--- a/package/network/services/ppp/files/ppp.sh
+++ b/package/network/services/ppp/files/ppp.sh
@@ -82,13 +82,15 @@ ppp_generic_init_config() {
 	proto_config_add_boolean persist
 	proto_config_add_int maxfail
 	proto_config_add_int holdoff
+	proto_config_add_boolean sourcefilter
+	proto_config_add_boolean delegate
 }
 
 ppp_generic_setup() {
 	local config="$1"; shift
 	local localip
 
-	json_get_vars ip6table demand keepalive keepalive_adaptive username password pppd_options pppname unnumbered persist maxfail holdoff peerdns
+	json_get_vars ip6table demand keepalive keepalive_adaptive username password pppd_options pppname unnumbered persist maxfail holdoff peerdns sourcefilter delegate
 
 	[ ! -e /proc/sys/net/ipv6 ] && ipv6=0 || json_get_var ipv6 ipv6
 
@@ -133,6 +135,8 @@ ppp_generic_setup() {
 	[ "${keepalive_adaptive:-1}" -lt 1 ] && lcp_adaptive=""
 	[ -n "$connect" ] || json_get_var connect connect
 	[ -n "$disconnect" ] || json_get_var disconnect disconnect
+	[ "$sourcefilter" = "0" ] || sourcefilter=""
+	[ "$delegate" != "0" ] && delegate=""
 
 	proto_run_command "$config" /usr/sbin/pppd \
 		nodetach ipparam "$config" \
@@ -143,6 +147,8 @@ ppp_generic_setup() {
 		${autoipv6:+set AUTOIPV6=1} \
 		${ip6table:+set IP6TABLE=$ip6table} \
 		${peerdns:+set PEERDNS=$peerdns} \
+		${sourcefilter:+set NOSOURCEFILTER=1} \
+		${delegate:+set DELEGATE=0} \
 		nodefaultroute \
 		usepeerdns \
 		$demand $persist maxfail $maxfail \
@@ -231,16 +237,7 @@ proto_pppoe_setup() {
 	json_get_var padi_attempts padi_attempts
 	json_get_var padi_timeout padi_timeout
 
-#By 蝈蝈：并发拨号同步的前期准备
-	syncppp_option=""
-	[ "$(uci get syncdial.config.enabled)" -eq "1" ] && {
-		ppp_if_cnt=$(uci show network | grep -c "\.proto=\'pppoe\'$")
-		syncppp_option="syncppp $ppp_if_cnt"
-		shellsync $ppp_if_cnt 10
-	}
-
 	ppp_generic_setup "$config" \
-		$syncppp_option \
 		plugin pppoe.so \
 		${ac:+rp_pppoe_ac "$ac"} \
 		${service:+rp_pppoe_service "$service"} \
diff --git a/package/network/services/ppp/patches/010-use_target_for_configure.patch b/package/network/services/ppp/patches/010-use_target_for_configure.patch
deleted file mode 100644
index 9e8618f8..00000000
--- a/package/network/services/ppp/patches/010-use_target_for_configure.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-configure: Allow overriding uname results
-
-In a cross compile setting it makes no sense to rely on the "uname" values
-reported by the build host system. This patch allows overriding the
-"uname -r", "uname -s" and "uname -m" results with the "UNAME_R", "UNAME_S"
-and "UNAME_M" environment variables.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/configure
-+++ b/configure
-@@ -10,9 +10,9 @@ CROSS_COMPILE=
- CC=cc
- CFLAGS=
- 
--system=`uname -s`
--release=`uname -r`
--arch=`uname -m`
-+system=${UNAME_S:-`uname -s`}
-+release=${UNAME_R:-`uname -r`}
-+arch=${UNAME_M:-`uname -m`}
- state="unknown"
- 
- case $system in
diff --git a/package/network/services/ppp/patches/105-debian_demand.patch b/package/network/services/ppp/patches/105-debian_demand.patch
index ff66aa8e..10ce13b2 100644
--- a/package/network/services/ppp/patches/105-debian_demand.patch
+++ b/package/network/services/ppp/patches/105-debian_demand.patch
@@ -1,6 +1,6 @@
 --- a/pppd/demand.c
 +++ b/pppd/demand.c
-@@ -36,6 +36,8 @@
+@@ -40,6 +40,8 @@
  #include <errno.h>
  #include <fcntl.h>
  #include <netdb.h>
@@ -9,16 +9,16 @@
  #include <sys/param.h>
  #include <sys/types.h>
  #include <sys/wait.h>
-@@ -43,6 +45,8 @@
+@@ -47,6 +49,8 @@
  #include <sys/resource.h>
  #include <sys/stat.h>
  #include <sys/socket.h>
 +#include <netinet/in.h>
 +#include <arpa/inet.h>
- #ifdef PPP_FILTER
+ #ifdef PPP_WITH_FILTER
  #include <pcap-bpf.h>
  #endif
-@@ -218,6 +222,14 @@ loop_chars(unsigned char *p, int n)
+@@ -223,6 +227,14 @@ loop_chars(unsigned char *p, int n)
      int c, rv;
  
      rv = 0;
@@ -33,7 +33,7 @@
      for (; n > 0; --n) {
  	c = *p++;
  	if (c == PPP_FLAG) {
-@@ -294,16 +306,100 @@ loop_frame(unsigned char *frame, int len
+@@ -299,16 +311,100 @@ loop_frame(unsigned char *frame, int len
   * loopback, now that the real serial link is up.
   */
  void
@@ -137,7 +137,7 @@
  	} else {
 --- a/pppd/ipcp.c
 +++ b/pppd/ipcp.c
-@@ -1850,7 +1850,7 @@ ipcp_up(fsm *f)
+@@ -1915,7 +1915,7 @@ ipcp_up(fsm *f)
  		    proxy_arp_set[f->unit] = 1;
  
  	}
@@ -148,7 +148,7 @@
      } else {
 --- a/pppd/ipv6cp.c
 +++ b/pppd/ipv6cp.c
-@@ -1253,7 +1253,7 @@ ipv6cp_up(fsm *f)
+@@ -1338,7 +1338,7 @@ ipv6cp_up(fsm *f)
  		if (sif6defaultroute(f->unit, go->ourid, ho->hisid))
  		    default_route_set[f->unit] = 1;
  	}
@@ -157,14 +157,14 @@
  	sifnpmode(f->unit, PPP_IPV6, NPMODE_PASS);
  
      } else {
---- a/pppd/pppd.h
-+++ b/pppd/pppd.h
-@@ -598,7 +598,7 @@ void demand_conf(void);	/* config interf
+--- a/pppd/pppd-private.h
++++ b/pppd/pppd-private.h
+@@ -368,7 +368,7 @@ void demand_conf(void);	/* config interf
  void demand_block(void);	/* set all NPs to queue up packets */
  void demand_unblock(void); /* set all NPs to pass packets */
  void demand_discard(void); /* set all NPs to discard packets */
 -void demand_rexmit(int);	/* retransmit saved frames for an NP */
-+void demand_rexmit(int, u_int32_t); /* retransmit saved frames for an NP*/
++void demand_rexmit(int, u_int32_t); /* retransmit saved frames for an NP */
  int  loop_chars(unsigned char *, int); /* process chars from loopback */
  int  loop_frame(unsigned char *, int); /* should we bring link up? */
  
diff --git a/package/network/services/ppp/patches/120-debian_ipv6_updown_option.patch b/package/network/services/ppp/patches/120-debian_ipv6_updown_option.patch
deleted file mode 100644
index 11e8d81f..00000000
--- a/package/network/services/ppp/patches/120-debian_ipv6_updown_option.patch
+++ /dev/null
@@ -1,95 +0,0 @@
-pppd: Allow specifying ipv6-up and ipv6-down scripts
-
-This patch implements the "ipv6-up-script" and "ipv6-down-script" options
-which allow to specify the path of the ipv6-up and ipv6-down scripts to call.
-
-These options default to _PATH_IPV6UP and _PATH_IPV6DOWN to retain the
-existing behaviour.
-
-The patch originated from the Debian project.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/pppd/main.c
-+++ b/pppd/main.c
-@@ -295,6 +295,8 @@ main(int argc, char *argv[])
- 
-     strlcpy(path_ipup, _PATH_IPUP, sizeof(path_ipup));
-     strlcpy(path_ipdown, _PATH_IPDOWN, sizeof(path_ipdown));
-+    strlcpy(path_ipv6up, _PATH_IPV6UP, sizeof(path_ipv6up));
-+    strlcpy(path_ipv6down, _PATH_IPV6DOWN, sizeof(path_ipv6down));
- 
-     link_stats_valid = 0;
-     new_phase(PHASE_INITIALIZE);
---- a/pppd/options.c
-+++ b/pppd/options.c
-@@ -118,6 +118,8 @@ int	req_unit = -1;		/* requested interfa
- char	path_ipup[MAXPATHLEN];	/* pathname of ip-up script */
- char	path_ipdown[MAXPATHLEN];/* pathname of ip-down script */
- char	req_ifname[MAXIFNAMELEN];	/* requested interface name */
-+char	path_ipv6up[MAXPATHLEN];	/* pathname of ipv6-up script */
-+char	path_ipv6down[MAXPATHLEN];/* pathname of ipv6-down script */
- bool	multilink = 0;		/* Enable multilink operation */
- char	*bundle_name = NULL;	/* bundle name for multilink */
- bool	dump_options;		/* print out option values */
-@@ -324,6 +326,13 @@ option_t general_options[] = {
-       "Set pathname of ip-down script",
-       OPT_PRIV|OPT_STATIC, NULL, MAXPATHLEN },
- 
-+    { "ipv6-up-script", o_string, path_ipv6up,
-+      "Set pathname of ipv6-up script",
-+      OPT_PRIV|OPT_STATIC, NULL, MAXPATHLEN },
-+    { "ipv6-down-script", o_string, path_ipv6down,
-+      "Set pathname of ipv6-down script",
-+      OPT_PRIV|OPT_STATIC, NULL, MAXPATHLEN },
-+
- #ifdef HAVE_MULTILINK
-     { "multilink", o_bool, &multilink,
-       "Enable multilink operation", OPT_PRIO | 1 },
---- a/pppd/ipv6cp.c
-+++ b/pppd/ipv6cp.c
-@@ -1295,7 +1295,7 @@ ipv6cp_up(fsm *f)
-      */
-     if (ipv6cp_script_state == s_down && ipv6cp_script_pid == 0) {
- 	ipv6cp_script_state = s_up;
--	ipv6cp_script(_PATH_IPV6UP);
-+	ipv6cp_script(path_ipv6up);
-     }
- }
- 
-@@ -1346,7 +1346,7 @@ ipv6cp_down(fsm *f)
-     /* Execute the ipv6-down script */
-     if (ipv6cp_script_state == s_up && ipv6cp_script_pid == 0) {
- 	ipv6cp_script_state = s_down;
--	ipv6cp_script(_PATH_IPV6DOWN);
-+	ipv6cp_script(path_ipv6down);
-     }
- }
- 
-@@ -1384,13 +1384,13 @@ ipv6cp_script_done(void *arg)
-     case s_up:
- 	if (ipv6cp_fsm[0].state != OPENED) {
- 	    ipv6cp_script_state = s_down;
--	    ipv6cp_script(_PATH_IPV6DOWN);
-+	    ipv6cp_script(path_ipv6down);
- 	}
- 	break;
-     case s_down:
- 	if (ipv6cp_fsm[0].state == OPENED) {
- 	    ipv6cp_script_state = s_up;
--	    ipv6cp_script(_PATH_IPV6UP);
-+	    ipv6cp_script(path_ipv6up);
- 	}
- 	break;
-     }
---- a/pppd/pppd.h
-+++ b/pppd/pppd.h
-@@ -328,6 +328,8 @@ extern int	req_unit;	/* interface unit n
- extern char	path_ipup[MAXPATHLEN]; /* pathname of ip-up script */
- extern char	path_ipdown[MAXPATHLEN]; /* pathname of ip-down script */
- extern char	req_ifname[MAXIFNAMELEN]; /* interface name to use */
-+extern char	path_ipv6up[MAXPATHLEN]; /* pathname of ipv6-up script */
-+extern char	path_ipv6down[MAXPATHLEN]; /* pathname of ipv6-down script */
- extern bool	multilink;	/* enable multilink operation */
- extern bool	noendpoint;	/* don't send or accept endpt. discrim. */
- extern char	*bundle_name;	/* bundle name for multilink */
diff --git a/package/network/services/ppp/patches/133-fix_sha1_include.patch b/package/network/services/ppp/patches/133-fix_sha1_include.patch
deleted file mode 100644
index 357d9514..00000000
--- a/package/network/services/ppp/patches/133-fix_sha1_include.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/pppd/sha1.c
-+++ b/pppd/sha1.c
-@@ -19,7 +19,7 @@
- #include <string.h>
- #include <time.h>
- #include <netinet/in.h>	/* htonl() */
--#include <net/ppp_defs.h>
-+#include "pppd.h"
- #include "sha1.h"
- 
- static void
diff --git a/package/network/services/ppp/patches/200-makefile.patch b/package/network/services/ppp/patches/200-makefile.patch
deleted file mode 100644
index d0b9a9a9..00000000
--- a/package/network/services/ppp/patches/200-makefile.patch
+++ /dev/null
@@ -1,56 +0,0 @@
-pppd: tune Linux config defaults for OpenWrt
-
-This patch adjusts a number defaults to properly match the OpenWrt environment.
-It is not intended for upstream.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/pppd/Makefile.linux
-+++ b/pppd/Makefile.linux
-@@ -49,7 +49,7 @@ MPPE=y
- # Uncomment the next line to include support for PPP packet filtering.
- # This requires that the libpcap library and headers be installed
- # and that the kernel driver support PPP packet filtering.
--FILTER=y
-+#FILTER=y
- 
- # Uncomment the next line to enable multilink PPP (enabled by default)
- # Linux distributions: Please leave multilink ENABLED in your builds
-@@ -59,7 +59,7 @@ HAVE_MULTILINK=y
- # Uncomment the next line to enable the TDB database (enabled by default.)
- # If you enable multilink, then TDB is automatically enabled also.
- # Linux distributions: Please leave TDB ENABLED in your builds.
--USE_TDB=y
-+#USE_TDB=y
- 
- # Uncomment the next line to enable Type=notify services in systemd
- # If enabled, and the user sets the up_sdnotify option, then
-@@ -85,13 +85,13 @@ USE_LIBUTIL=y
- endif
- 
- # Enable EAP-TLS authentication (requires MPPE support, libssl and libcrypto)
--USE_EAPTLS=y
-+#USE_EAPTLS=y
- 
- MAXOCTETS=y
- 
- INCLUDE_DIRS= -I../include
- 
--COMPILE_FLAGS= -DHAVE_PATHS_H -DIPX_CHANGE -DHAVE_MMAP -pipe
-+COMPILE_FLAGS= -DHAVE_PATHS_H -DHAVE_MMAP -pipe
- 
- CFLAGS= $(COPTS) $(COMPILE_FLAGS) $(INCLUDE_DIRS) '-DDESTDIR="@DESTDIR@"'
- 
-@@ -143,10 +143,10 @@ CFLAGS   += -DHAS_SHADOW
- #LIBS     += -lshadow $(LIBS)
- endif
- 
--ifeq ($(shell echo '\#include <crypt.h>' | $(CC) -E - >/dev/null 2>&1 && echo yes),yes)
-+#ifeq ($(shell echo '\#include <crypt.h>' | $(CC) -E - >/dev/null 2>&1 && echo yes),yes)
- CFLAGS  += -DHAVE_CRYPT_H=1
- LIBS	+= -lcrypt
--endif
-+#endif
- 
- ifdef USE_LIBUTIL
- CFLAGS	+= -DHAVE_LOGWTMP=1
diff --git a/package/network/services/ppp/patches/201-mppe_mppc_1.1.patch b/package/network/services/ppp/patches/201-mppe_mppc_1.1.patch
deleted file mode 100644
index 3c30517e..00000000
--- a/package/network/services/ppp/patches/201-mppe_mppc_1.1.patch
+++ /dev/null
@@ -1,1518 +0,0 @@
-pppd: add support for MPPE and MPPC encryption and compression protocols
-
-This is a forward ported version of ppp-2.4.3-mppe-mppc-1.1.patch.gz found on
-http://mppe-mppc.alphacron.de/ .
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/include/linux/ppp-comp.h
-+++ b/include/linux/ppp-comp.h
-@@ -36,7 +36,7 @@
-  */
- 
- /*
-- *  ==FILEVERSION 20020319==
-+ *  ==FILEVERSION 20020715==
-  *
-  *  NOTE TO MAINTAINERS:
-  *     If you modify this file at all, please set the above date.
-@@ -201,6 +201,33 @@ struct compressor {
- #define CI_MPPE			18	/* config option for MPPE */
- #define CILEN_MPPE		6	/* length of config option */
- 
-+/* MPPE/MPPC definitions by J.D.*/
-+#define MPPE_STATELESS          MPPE_H_BIT	/* configuration bit H */
-+#define MPPE_40BIT              MPPE_L_BIT	/* configuration bit L */
-+#define MPPE_56BIT              MPPE_M_BIT	/* configuration bit M */
-+#define MPPE_128BIT             MPPE_S_BIT	/* configuration bit S */
-+#define MPPE_MPPC               MPPE_C_BIT	/* configuration bit C */
-+
-+/*
-+ * Definitions for Stac LZS.
-+ */
-+
-+#define CI_LZS			17	/* config option for Stac LZS */
-+#define CILEN_LZS		5	/* length of config option */
-+
-+#define LZS_OVHD		4	/* max. LZS overhead */
-+#define LZS_HIST_LEN		2048	/* LZS history size */
-+#define LZS_MAX_CCOUNT		0x0FFF	/* max. coherency counter value */
-+
-+#define LZS_MODE_NONE		0
-+#define LZS_MODE_LCB		1
-+#define LZS_MODE_CRC		2
-+#define LZS_MODE_SEQ		3
-+#define LZS_MODE_EXT		4
-+
-+#define LZS_EXT_BIT_FLUSHED	0x80	/* bit A */
-+#define LZS_EXT_BIT_COMP	0x20	/* bit C */
-+
- /*
-  * Definitions for other, as yet unsupported, compression methods.
-  */
---- a/include/net/ppp-comp.h
-+++ b/include/net/ppp-comp.h
-@@ -168,6 +168,33 @@ struct compressor {
- #define CI_MPPE			18	/* config option for MPPE */
- #define CILEN_MPPE		6	/* length of config option */
- 
-+/* MPPE/MPPC definitions by J.D.*/
-+#define MPPE_STATELESS          MPPE_H_BIT	/* configuration bit H */
-+#define MPPE_40BIT              MPPE_L_BIT	/* configuration bit L */
-+#define MPPE_56BIT              MPPE_M_BIT	/* configuration bit M */
-+#define MPPE_128BIT             MPPE_S_BIT	/* configuration bit S */
-+#define MPPE_MPPC               MPPE_C_BIT	/* configuration bit C */
-+
-+/*
-+ * Definitions for Stac LZS.
-+ */
-+
-+#define CI_LZS			17	/* config option for Stac LZS */
-+#define CILEN_LZS		5	/* length of config option */
-+
-+#define LZS_OVHD		4	/* max. LZS overhead */
-+#define LZS_HIST_LEN		2048	/* LZS history size */
-+#define LZS_MAX_CCOUNT		0x0FFF	/* max. coherency counter value */
-+
-+#define LZS_MODE_NONE		0
-+#define LZS_MODE_LCB		1
-+#define LZS_MODE_CRC		2
-+#define LZS_MODE_SEQ		3
-+#define LZS_MODE_EXT		4
-+
-+#define LZS_EXT_BIT_FLUSHED	0x80	/* bit A */
-+#define LZS_EXT_BIT_COMP	0x20	/* bit C */
-+
- /*
-  * Definitions for other, as yet unsupported, compression methods.
-  */
---- a/pppd/ccp.c
-+++ b/pppd/ccp.c
-@@ -61,12 +61,10 @@ static int setdeflate (char **);
- static char bsd_value[8];
- static char deflate_value[8];
- 
--/*
-- * Option variables.
-- */
- #ifdef MPPE
--bool refuse_mppe_stateful = 1;		/* Allow stateful mode? */
--#endif
-+static int setmppe(char **);
-+static int setnomppe(void);
-+#endif /* MPPE */
- 
- static option_t ccp_option_list[] = {
-     { "noccp", o_bool, &ccp_protent.enabled_flag,
-@@ -107,54 +105,36 @@ static option_t ccp_option_list[] = {
-       "don't allow Predictor-1", OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLR,
-       &ccp_allowoptions[0].predictor_1 },
- 
-+    { "lzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "request Stac LZS", 1, &ccp_allowoptions[0].lzs, OPT_PRIO },
-+    { "+lzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "request Stac LZS", 1, &ccp_allowoptions[0].lzs, OPT_ALIAS | OPT_PRIO },
-+    { "nolzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "don't allow Stac LZS", OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].lzs },
-+    { "-lzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "don't allow Stac LZS", OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].lzs },
-+
- #ifdef MPPE
--    /* MPPE options are symmetrical ... we only set wantoptions here */
--    { "require-mppe", o_bool, &ccp_wantoptions[0].mppe,
--      "require MPPE encryption",
--      OPT_PRIO | MPPE_OPT_40 | MPPE_OPT_128 },
--    { "+mppe", o_bool, &ccp_wantoptions[0].mppe,
--      "require MPPE encryption",
--      OPT_ALIAS | OPT_PRIO | MPPE_OPT_40 | MPPE_OPT_128 },
--    { "nomppe", o_bool, &ccp_wantoptions[0].mppe,
--      "don't allow MPPE encryption", OPT_PRIO },
--    { "-mppe", o_bool, &ccp_wantoptions[0].mppe,
--      "don't allow MPPE encryption", OPT_ALIAS | OPT_PRIO },
--
--    /* We use ccp_allowoptions[0].mppe as a junk var ... it is reset later */
--    { "require-mppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 40-bit encryption", OPT_PRIO | OPT_A2OR | MPPE_OPT_40,
--      &ccp_wantoptions[0].mppe },
--    { "+mppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 40-bit encryption", OPT_PRIO | OPT_A2OR | MPPE_OPT_40,
--      &ccp_wantoptions[0].mppe },
--    { "nomppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 40-bit encryption",
--      OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_40, &ccp_wantoptions[0].mppe },
--    { "-mppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 40-bit encryption",
--      OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_40,
--      &ccp_wantoptions[0].mppe },
--
--    { "require-mppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 128-bit encryption", OPT_PRIO | OPT_A2OR | MPPE_OPT_128,
--      &ccp_wantoptions[0].mppe },
--    { "+mppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 128-bit encryption",
--      OPT_ALIAS | OPT_PRIO | OPT_A2OR | MPPE_OPT_128,
--      &ccp_wantoptions[0].mppe },
--    { "nomppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 128-bit encryption",
--      OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_128, &ccp_wantoptions[0].mppe },
--    { "-mppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 128-bit encryption",
--      OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_128,
--      &ccp_wantoptions[0].mppe },
--
--    /* strange one; we always request stateless, but will we allow stateful? */
--    { "mppe-stateful", o_bool, &refuse_mppe_stateful,
--      "allow MPPE stateful mode", OPT_PRIO },
--    { "nomppe-stateful", o_bool, &refuse_mppe_stateful,
--      "disallow MPPE stateful mode", OPT_PRIO | 1 },
-+    { "mppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "request MPPC compression", 1, &ccp_allowoptions[0].mppc },
-+    { "+mppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "request MPPC compression", 1, &ccp_allowoptions[0].mppc, OPT_ALIAS },
-+    { "nomppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "don't allow MPPC compression", OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].mppc },
-+    { "-mppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "don't allow MPPC compression", OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].mppc },
-+    { "mppe", o_special, (void *)setmppe,
-+      "request MPPE encryption" },
-+    { "+mppe", o_special, (void *)setmppe,
-+      "request MPPE encryption" },
-+    { "nomppe", o_special_noarg, (void *)setnomppe,
-+      "don't allow MPPE encryption" },
-+    { "-mppe", o_special_noarg, (void *)setnomppe,
-+      "don't allow MPPE encryption" },
- #endif /* MPPE */
- 
-     { NULL }
-@@ -240,7 +220,7 @@ static fsm_callbacks ccp_callbacks = {
-  */
- #define ANY_COMPRESS(opt)	((opt).deflate || (opt).bsd_compress \
- 				 || (opt).predictor_1 || (opt).predictor_2 \
--				 || (opt).mppe)
-+				 || (opt).lzs || (opt).mppc || (opt).mppe)
- 
- /*
-  * Local state (mainly for handling reset-reqs and reset-acks).
-@@ -341,6 +321,100 @@ setdeflate(char **argv)
-     return 1;
- }
- 
-+#ifdef MPPE
-+/*
-+ * Functions called from config options
-+ */
-+/* 
-+   MPPE suboptions:
-+	required - require MPPE; disconnect if peer doesn't support it
-+	stateless - use stateless mode
-+	no40 - disable 40 bit keys
-+	no56 - disable 56 bit keys
-+	no128 - disable 128 bit keys
-+*/
-+int setmppe(char **argv)
-+{
-+    int i;
-+    char *str, cmdbuf[16];
-+
-+    ccp_allowoptions[0].mppe = 1;
-+    ccp_allowoptions[0].mppe_40 = 1;
-+    ccp_allowoptions[0].mppe_56 = 1;
-+    ccp_allowoptions[0].mppe_128 = 1;
-+    ccp_allowoptions[0].mppe_stateless = 0;
-+    ccp_wantoptions[0].mppe = 0;
-+
-+    str = *argv;
-+
-+    while (1) {
-+	i = 0;
-+	memset(cmdbuf, '\0', 16);
-+	while ((i < 16) && (*str != ',') && (*str != '\0'))
-+	    cmdbuf[i++] = *str++;
-+	cmdbuf[i] = '\0';
-+	if (!strncasecmp(cmdbuf, "no40", strlen("no40"))) {
-+	    ccp_allowoptions[0].mppe_40 = 0;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "no56", strlen("no56"))) {
-+	    ccp_allowoptions[0].mppe_56 = 0;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "no128", strlen("no128"))) {
-+	    ccp_allowoptions[0].mppe_128 = 0;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "stateless", strlen("stateless"))) {
-+	    ccp_allowoptions[0].mppe_stateless = 1;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "required", strlen("required"))) {
-+	    ccp_wantoptions[0].mppe = 1;
-+	    goto next_param;
-+	} else {
-+	    option_error("invalid parameter '%s' for mppe option", cmdbuf);
-+	    return 0;
-+	}
-+
-+    next_param:
-+	if (*str == ',') {
-+	    str++;
-+	    continue;
-+	}
-+	if (*str == '\0') {
-+	    if (!(ccp_allowoptions[0].mppe_40 || ccp_allowoptions[0].mppe_56 ||
-+		  ccp_allowoptions[0].mppe_128)) {
-+		if (ccp_wantoptions[0].mppe == 1) {
-+		    option_error("You require MPPE but you have switched off "
-+				 "all encryption key lengths.");
-+		    return 0;
-+		}
-+		ccp_wantoptions[0].mppe = ccp_allowoptions[0].mppe = 0;
-+		ccp_wantoptions[0].mppe_stateless =
-+		    ccp_allowoptions[0].mppe_stateless = 0;
-+	    } else {
-+		ccp_allowoptions[0].mppe = 1;
-+		ccp_wantoptions[0].mppe_stateless =
-+		    ccp_allowoptions[0].mppe_stateless;
-+		if (ccp_wantoptions[0].mppe == 1) {
-+		    ccp_wantoptions[0].mppe_40 = ccp_allowoptions[0].mppe_40;
-+		    ccp_wantoptions[0].mppe_56 = ccp_allowoptions[0].mppe_56;
-+		    ccp_wantoptions[0].mppe_128 = ccp_allowoptions[0].mppe_128;
-+		}
-+	    }
-+	    return 1;
-+	}
-+    }
-+}
-+
-+int setnomppe(void)
-+{
-+    ccp_wantoptions[0].mppe = ccp_allowoptions[0].mppe = 0;
-+    ccp_wantoptions[0].mppe_40 = ccp_allowoptions[0].mppe_40 = 0;
-+    ccp_wantoptions[0].mppe_56 = ccp_allowoptions[0].mppe_56 = 0;
-+    ccp_wantoptions[0].mppe_128 = ccp_allowoptions[0].mppe_128 = 0;
-+    ccp_wantoptions[0].mppe_stateless = ccp_allowoptions[0].mppe_stateless = 0;
-+    return 1;
-+}
-+#endif /* MPPE */
-+
- /*
-  * ccp_init - initialize CCP.
-  */
-@@ -374,6 +448,30 @@ ccp_init(int unit)
-     ccp_allowoptions[0].bsd_bits = BSD_MAX_BITS;
- 
-     ccp_allowoptions[0].predictor_1 = 1;
-+
-+    ccp_wantoptions[0].lzs = 0; /* Stac LZS  - will be enabled in the future */
-+    ccp_wantoptions[0].lzs_mode = LZS_MODE_SEQ;
-+    ccp_wantoptions[0].lzs_hists = 1;
-+    ccp_allowoptions[0].lzs = 0; /* Stac LZS  - will be enabled in the future */
-+    ccp_allowoptions[0].lzs_mode = LZS_MODE_SEQ;
-+    ccp_allowoptions[0].lzs_hists = 1;
-+
-+#ifdef MPPE
-+    /* by default allow and request MPPC... */
-+    ccp_wantoptions[0].mppc = ccp_allowoptions[0].mppc = 1;
-+
-+    /* ... and allow but don't request MPPE */
-+    ccp_allowoptions[0].mppe = 1;
-+    ccp_allowoptions[0].mppe_40 = 1;
-+    ccp_allowoptions[0].mppe_56 = 1;
-+    ccp_allowoptions[0].mppe_128 = 1;
-+    ccp_allowoptions[0].mppe_stateless = 1;
-+    ccp_wantoptions[0].mppe = 0;
-+    ccp_wantoptions[0].mppe_40 = 0;
-+    ccp_wantoptions[0].mppe_56 = 0;
-+    ccp_wantoptions[0].mppe_128 = 0;
-+    ccp_wantoptions[0].mppe_stateless = 0;
-+#endif /* MPPE */
- }
- 
- /*
-@@ -443,11 +541,11 @@ ccp_input(int unit, u_char *p, int len)
-     if (oldstate == OPENED && p[0] == TERMREQ && f->state != OPENED) {
- 	notice("Compression disabled by peer.");
- #ifdef MPPE
--	if (ccp_gotoptions[unit].mppe) {
-+	if (ccp_wantoptions[unit].mppe) {
- 	    error("MPPE disabled, closing LCP");
- 	    lcp_close(unit, "MPPE disabled by peer");
- 	}
--#endif
-+#endif /* MPPE */
-     }
- 
-     /*
-@@ -471,6 +569,15 @@ ccp_extcode(fsm *f, int code, int id, u_
- 	    break;
- 	/* send a reset-ack, which the transmitter will see and
- 	   reset its compression state. */
-+
-+	/* In case of MPPE/MPPC or LZS we shouldn't send CCP_RESETACK,
-+	   but we do it in order to reset compressor; CCP_RESETACK is
-+	   then silently discarded. See functions ppp_send_frame and
-+	   ppp_ccp_peek in ppp_generic.c (Linux only !!!). All the
-+	   confusion is caused by the fact that CCP code is splited
-+	   into two parts - one part is handled by pppd, the other one
-+	   is handled by kernel. */
-+
- 	fsm_sdata(f, CCP_RESETACK, id, NULL, 0);
- 	break;
- 
-@@ -498,12 +605,11 @@ ccp_protrej(int unit)
-     fsm_lowerdown(&ccp_fsm[unit]);
- 
- #ifdef MPPE
--    if (ccp_gotoptions[unit].mppe) {
-+    if (ccp_wantoptions[unit].mppe) {
- 	error("MPPE required but peer negotiation failed");
- 	lcp_close(unit, "MPPE required but peer negotiation failed");
-     }
--#endif
--
-+#endif /* MPPE */
- }
- 
- /*
-@@ -519,7 +625,7 @@ ccp_resetci(fsm *f)
-     all_rejected[f->unit] = 0;
- 
- #ifdef MPPE
--    if (go->mppe) {
-+    if (go->mppe || go->mppc) {
- 	ccp_options *ao = &ccp_allowoptions[f->unit];
- 	int auth_mschap_bits = auth_done[f->unit];
- #ifdef USE_EAPTLS
-@@ -536,95 +642,124 @@ ccp_resetci(fsm *f)
- 	 * NB: If MPPE is required, all other compression opts are invalid.
- 	 *     So, we return right away if we can't do it.
- 	 */
--
--	/* Leave only the mschap auth bits set */
--	auth_mschap_bits &= (CHAP_MS_WITHPEER  | CHAP_MS_PEER |
--			     CHAP_MS2_WITHPEER | CHAP_MS2_PEER);
--	/* Count the mschap auths */
--	auth_mschap_bits >>= CHAP_MS_SHIFT;
--	numbits = 0;
--	do {
--	    numbits += auth_mschap_bits & 1;
--	    auth_mschap_bits >>= 1;
--	} while (auth_mschap_bits);
--	if (numbits > 1) {
--	    error("MPPE required, but auth done in both directions.");
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
--	}
-+	if (ccp_wantoptions[f->unit].mppe) {
-+	    /* Leave only the mschap auth bits set */
-+	    auth_mschap_bits &= (CHAP_MS_WITHPEER  | CHAP_MS_PEER |
-+				 CHAP_MS2_WITHPEER | CHAP_MS2_PEER);
-+	    /* Count the mschap auths */
-+	    auth_mschap_bits >>= CHAP_MS_SHIFT;
-+	    numbits = 0;
-+	    do {
-+		numbits += auth_mschap_bits & 1;
-+		auth_mschap_bits >>= 1;
-+	    } while (auth_mschap_bits);
-+	    if (numbits > 1) {
-+		error("MPPE required, but auth done in both directions.");
-+		lcp_close(f->unit, "MPPE required but not available");
-+		return;
-+	    }
- 
- #ifdef USE_EAPTLS
--    /*
--     * MPPE is also possible in combination with EAP-TLS.
--     * It is not possible to detect if we're doing EAP or EAP-TLS
--     * at this stage, hence we accept all forms of EAP. If TLS is
--     * not used then the MPPE keys will not be derived anyway.
--     */
--	/* Leave only the eap auth bits set */
--	auth_eap_bits &= (EAP_WITHPEER | EAP_PEER );
-+	    /*
-+	     * MPPE is also possible in combination with EAP-TLS.
-+	     * It is not possible to detect if we're doing EAP or EAP-TLS
-+	     * at this stage, hence we accept all forms of EAP. If TLS is
-+	     * not used then the MPPE keys will not be derived anyway.
-+	     */
-+		/* Leave only the eap auth bits set */
-+		auth_eap_bits &= (EAP_WITHPEER | EAP_PEER );
- 
--	if ((numbits == 0) && (auth_eap_bits == 0)) {
--	    error("MPPE required, but MS-CHAP[v2] nor EAP-TLS auth are performed.");
-+		if ((numbits == 0) && (auth_eap_bits == 0)) {
-+		    error("MPPE required, but MS-CHAP[v2] nor EAP-TLS auth are performed.");
- #else
--	if (!numbits) {
--	    error("MPPE required, but MS-CHAP[v2] auth not performed.");
-+	    if (!numbits) {
-+		error("MPPE required, but MS-CHAP[v2] auth not performed.");
- #endif
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
--	}
-+		lcp_close(f->unit, "MPPE required but not available");
-+		return;
-+	    }
- 
--	/* A plugin (eg radius) may not have obtained key material. */
--	if (!mppe_keys_set) {
--	    error("MPPE required, but keys are not available.  "
--		  "Possible plugin problem?");
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
--	}
--
--	/* LM auth not supported for MPPE */
--	if (auth_done[f->unit] & (CHAP_MS_WITHPEER | CHAP_MS_PEER)) {
--	    /* This might be noise */
--	    if (go->mppe & MPPE_OPT_40) {
--		notice("Disabling 40-bit MPPE; MS-CHAP LM not supported");
--		go->mppe &= ~MPPE_OPT_40;
--		ccp_wantoptions[f->unit].mppe &= ~MPPE_OPT_40;
-+	    /* A plugin (eg radius) may not have obtained key material. */
-+	    if (!mppe_keys_set) {
-+		error("MPPE required, but keys are not available.  "
-+		      "Possible plugin problem?");
-+		lcp_close(f->unit, "MPPE required but not available");
-+		return;
- 	    }
- 	}
- 
--	/* Last check: can we actually negotiate something? */
--	if (!(go->mppe & (MPPE_OPT_40 | MPPE_OPT_128))) {
--	    /* Could be misconfig, could be 40-bit disabled above. */
--	    error("MPPE required, but both 40-bit and 128-bit disabled.");
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
-+	/*
-+	 * Check whether the kernel knows about the various
-+	 * compression methods we might request. Key material
-+	 * unimportant here.
-+	 */
-+	if (go->mppc) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = 0;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_MPPC;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE, 0) <= 0)
-+		go->mppc = 0;
-+	}
-+	if (go->mppe_40) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = MPPE_STATELESS;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_40BIT;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0)
-+		go->mppe_40 = 0;
-+	}
-+	if (go->mppe_56) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = MPPE_STATELESS;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_56BIT;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0)
-+		go->mppe_56 = 0;
-+	}
-+	if (go->mppe_128) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = MPPE_STATELESS;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_128BIT;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0)
-+		go->mppe_128 = 0;
-+	}
-+	if (!go->mppe_40 && !go->mppe_56 && !go->mppe_128) {
-+	    if (ccp_wantoptions[f->unit].mppe) {
-+		error("MPPE required, but kernel has no support.");
-+		lcp_close(f->unit, "MPPE required but not available");
-+	    }
-+	    go->mppe = go->mppe_stateless = 0;
-+	} else {
-+	    /* MPPE is not compatible with other compression types */
-+	    if (ccp_wantoptions[f->unit].mppe) {
-+		ao->bsd_compress = go->bsd_compress = 0;
-+		ao->predictor_1  = go->predictor_1  = 0;
-+		ao->predictor_2  = go->predictor_2  = 0;
-+		ao->deflate	 = go->deflate	    = 0;
-+		ao->lzs		 = go->lzs	    = 0;
-+	    }
- 	}
--
--	/* sync options */
--	ao->mppe = go->mppe;
--	/* MPPE is not compatible with other compression types */
--	ao->bsd_compress = go->bsd_compress = 0;
--	ao->predictor_1  = go->predictor_1  = 0;
--	ao->predictor_2  = go->predictor_2  = 0;
--	ao->deflate      = go->deflate      = 0;
-     }
- #endif /* MPPE */
--
--    /*
--     * Check whether the kernel knows about the various
--     * compression methods we might request.
--     */
--#ifdef MPPE
--    if (go->mppe) {
--	opt_buf[0] = CI_MPPE;
--	opt_buf[1] = CILEN_MPPE;
--	MPPE_OPTS_TO_CI(go->mppe, &opt_buf[2]);
--	/* Key material unimportant here. */
--	if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0) {
--	    error("MPPE required, but kernel has no support.");
--	    lcp_close(f->unit, "MPPE required but not available");
--	}
-+    if (go->lzs) {
-+	opt_buf[0] = CI_LZS;
-+	opt_buf[1] = CILEN_LZS;
-+	opt_buf[2] = go->lzs_hists >> 8;
-+	opt_buf[3] = go->lzs_hists & 0xff;
-+	opt_buf[4] = LZS_MODE_SEQ;
-+	if (ccp_test(f->unit, opt_buf, CILEN_LZS, 0) <= 0)
-+	    go->lzs = 0;
-     }
--#endif
-     if (go->bsd_compress) {
- 	opt_buf[0] = CI_BSD_COMPRESS;
- 	opt_buf[1] = CILEN_BSD_COMPRESS;
-@@ -679,7 +814,8 @@ static int
- 	+ (go->deflate && go->deflate_draft? CILEN_DEFLATE: 0)
- 	+ (go->predictor_1? CILEN_PREDICTOR_1: 0)
- 	+ (go->predictor_2? CILEN_PREDICTOR_2: 0)
--	+ (go->mppe? CILEN_MPPE: 0);
-+	+ (go->lzs? CILEN_LZS: 0)
-+	+ ((go->mppe || go->mppc)? CILEN_MPPE: 0);
- }
- 
- /*
-@@ -690,6 +826,8 @@ static void
- {
-     int res;
-     ccp_options *go = &ccp_gotoptions[f->unit];
-+    ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
-     u_char *p0 = p;
- 
-     /*
-@@ -698,22 +836,43 @@ static void
-      * in case it gets Acked.
-      */
- #ifdef MPPE
--    if (go->mppe) {
-+    if (go->mppe || go->mppc || (!wo->mppe && ao->mppe)) {
- 	u_char opt_buf[CILEN_MPPE + MPPE_MAX_KEY_LEN];
- 
--	p[0] = opt_buf[0] = CI_MPPE;
--	p[1] = opt_buf[1] = CILEN_MPPE;
--	MPPE_OPTS_TO_CI(go->mppe, &p[2]);
--	MPPE_OPTS_TO_CI(go->mppe, &opt_buf[2]);
-+	p[0] = CI_MPPE;
-+	p[1] = CILEN_MPPE;
-+	p[2] = (go->mppe_stateless ? MPPE_STATELESS : 0);
-+	p[3] = 0;
-+	p[4] = 0;
-+	p[5] = (go->mppe_40 ? MPPE_40BIT : 0) | (go->mppe_56 ? MPPE_56BIT : 0) |
-+	    (go->mppe_128 ? MPPE_128BIT : 0) | (go->mppc ? MPPE_MPPC : 0);
-+
-+	BCOPY(p, opt_buf, CILEN_MPPE);
- 	BCOPY(mppe_recv_key, &opt_buf[CILEN_MPPE], MPPE_MAX_KEY_LEN);
- 	res = ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0);
--	if (res > 0)
-+	if (res > 0) {
- 	    p += CILEN_MPPE;
--	else
-+	} else {
- 	    /* This shouldn't happen, we've already tested it! */
--	    lcp_close(f->unit, "MPPE required but not available in kernel");
-+	    go->mppe = go->mppe_40 = go->mppe_56 = go->mppe_128 =
-+		go->mppe_stateless = go->mppc = 0;
-+	    if (ccp_wantoptions[f->unit].mppe)
-+		lcp_close(f->unit, "MPPE required but not available in kernel");
-+	}
-+    }
-+#endif /* MPPE */
-+    if (go->lzs) {
-+	p[0] = CI_LZS;
-+	p[1] = CILEN_LZS;
-+	p[2] = go->lzs_hists >> 8;
-+	p[3] = go->lzs_hists & 0xff;
-+	p[4] = LZS_MODE_SEQ;
-+	res = ccp_test(f->unit, p, CILEN_LZS, 0);
-+	if (res > 0) {
-+	    p += CILEN_LZS;
-+	} else
-+	    go->lzs = 0;
-     }
--#endif
-     if (go->deflate) {
- 	p[0] = go->deflate_correct? CI_DEFLATE: CI_DEFLATE_DRAFT;
- 	p[1] = CILEN_DEFLATE;
-@@ -799,30 +958,50 @@ static void
- 
- /*
-  * ccp_ackci - process a received configure-ack, and return
-- * 1 iff the packet was OK.
-+ * 1 if the packet was OK.
-  */
- static int
-   ccp_ackci(fsm *f, u_char *p, int len)
- {
-     ccp_options *go = &ccp_gotoptions[f->unit];
-+    ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
-     u_char *p0 = p;
- 
- #ifdef MPPE
--    if (go->mppe) {
--	u_char opt_buf[CILEN_MPPE];
--
--	opt_buf[0] = CI_MPPE;
--	opt_buf[1] = CILEN_MPPE;
--	MPPE_OPTS_TO_CI(go->mppe, &opt_buf[2]);
--	if (len < CILEN_MPPE || memcmp(opt_buf, p, CILEN_MPPE))
-+    if (go->mppe || go->mppc || (!wo->mppe && ao->mppe)) {
-+	if (len < CILEN_MPPE
-+	    || p[1] != CILEN_MPPE || p[0] != CI_MPPE
-+	    || p[2] != (go->mppe_stateless ? MPPE_STATELESS : 0)
-+	    || p[3] != 0
-+	    || p[4] != 0
-+	    || (p[5] != ((go->mppe_40 ? MPPE_40BIT : 0) |
-+			 (go->mppc ? MPPE_MPPC : 0))
-+		&& p[5] != ((go->mppe_56 ? MPPE_56BIT : 0) |
-+			    (go->mppc ? MPPE_MPPC : 0))
-+		&& p[5] != ((go->mppe_128 ? MPPE_128BIT : 0) |
-+			    (go->mppc ? MPPE_MPPC : 0))))
- 	    return 0;
-+	if (go->mppe_40 || go->mppe_56 || go->mppe_128)
-+	    go->mppe = 1;
- 	p += CILEN_MPPE;
- 	len -= CILEN_MPPE;
-+	/* Cope with first/fast ack */
-+	if (p == p0 && len == 0)
-+	    return 1;
-+    }
-+#endif /* MPPE */
-+    if (go->lzs) {
-+	if (len < CILEN_LZS || p[0] != CI_LZS || p[1] != CILEN_LZS
-+	    || p[2] != go->lzs_hists>>8 || p[3] != (go->lzs_hists&0xff)
-+	    || p[4] != LZS_MODE_SEQ)
-+	    return 0;
-+	p += CILEN_LZS;
-+	len -= CILEN_LZS;
- 	/* XXX Cope with first/fast ack */
--	if (len == 0)
-+	if (p == p0 && len == 0)
- 	    return 1;
-     }
--#endif
-     if (go->deflate) {
- 	if (len < CILEN_DEFLATE
- 	    || p[0] != (go->deflate_correct? CI_DEFLATE: CI_DEFLATE_DRAFT)
-@@ -891,6 +1070,8 @@ static int
-   ccp_nakci(fsm *f, u_char *p, int len, int treat_as_reject)
- {
-     ccp_options *go = &ccp_gotoptions[f->unit];
-+    ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
-     ccp_options no;		/* options we've seen already */
-     ccp_options try;		/* options to ask for next time */
- 
-@@ -898,28 +1079,100 @@ static int
-     try = *go;
- 
- #ifdef MPPE
--    if (go->mppe && len >= CILEN_MPPE
--	&& p[0] == CI_MPPE && p[1] == CILEN_MPPE) {
--	no.mppe = 1;
--	/*
--	 * Peer wants us to use a different strength or other setting.
--	 * Fail if we aren't willing to use his suggestion.
--	 */
--	MPPE_CI_TO_OPTS(&p[2], try.mppe);
--	if ((try.mppe & MPPE_OPT_STATEFUL) && refuse_mppe_stateful) {
--	    error("Refusing MPPE stateful mode offered by peer");
--	    try.mppe = 0;
--	} else if (((go->mppe | MPPE_OPT_STATEFUL) & try.mppe) != try.mppe) {
--	    /* Peer must have set options we didn't request (suggest) */
--	    try.mppe = 0;
--	}
-+    if ((go->mppe || go->mppc || (!wo->mppe && ao->mppe)) &&
-+	len >= CILEN_MPPE && p[0] == CI_MPPE && p[1] == CILEN_MPPE) {
- 
--	if (!try.mppe) {
--	    error("MPPE required but peer negotiation failed");
--	    lcp_close(f->unit, "MPPE required but peer negotiation failed");
-+	if (go->mppc) {
-+	    no.mppc = 1;
-+	    if (!(p[5] & MPPE_MPPC))
-+		try.mppc = 0;
-+	}
-+
-+	if (go->mppe)
-+	    no.mppe = 1;
-+	if (go->mppe_40)
-+	    no.mppe_40 = 1;
-+	if (go->mppe_56)
-+	    no.mppe_56 = 1;
-+	if (go->mppe_128)
-+	    no.mppe_128 = 1;
-+	if (go->mppe_stateless)
-+	    no.mppe_stateless = 1;
-+
-+	if (ao->mppe_40) {
-+	    if ((p[5] & MPPE_40BIT))
-+		try.mppe_40 = 1;
-+	    else
-+		try.mppe_40 = (p[5] == 0) ? 1 : 0;
-+	}
-+	if (ao->mppe_56) {
-+	    if ((p[5] & MPPE_56BIT))
-+		try.mppe_56 = 1;
-+	    else
-+		try.mppe_56 = (p[5] == 0) ? 1 : 0;
-+	}
-+	if (ao->mppe_128) {
-+	    if ((p[5] & MPPE_128BIT))
-+		try.mppe_128 = 1;
-+	    else
-+		try.mppe_128 = (p[5] == 0) ? 1 : 0;
-+	}
-+
-+	if (ao->mppe_stateless) {
-+	    if ((p[2] & MPPE_STATELESS) || wo->mppe_stateless)
-+		try.mppe_stateless = 1;
-+	    else
-+		try.mppe_stateless = 0;
-+	}
-+
-+	if (!try.mppe_56 && !try.mppe_40 && !try.mppe_128) {
-+	    try.mppe = try.mppe_stateless = 0;
-+	    if (wo->mppe) {
-+		/* we require encryption, but peer doesn't support it
-+		   so we close connection */
-+		wo->mppc = wo->mppe = wo->mppe_stateless = wo->mppe_40 =
-+		    wo->mppe_56 = wo->mppe_128 = 0;
-+		lcp_close(f->unit, "MPPE required but cannot negotiate MPPE "
-+			  "key length");
-+	    }
-+        }
-+	if (wo->mppe && (wo->mppe_40 != try.mppe_40) &&
-+	    (wo->mppe_56 != try.mppe_56) && (wo->mppe_128 != try.mppe_128)) {
-+	    /* cannot negotiate key length */
-+	    wo->mppc = wo->mppe = wo->mppe_stateless = wo->mppe_40 =
-+		wo->mppe_56 = wo->mppe_128 = 0;
-+	    lcp_close(f->unit, "Cannot negotiate MPPE key length");
- 	}
-+	if (try.mppe_40 && try.mppe_56 && try.mppe_128)
-+	    try.mppe_40 = try.mppe_56 = 0;
-+	else
-+	    if (try.mppe_56 && try.mppe_128)
-+		try.mppe_56 = 0;
-+	    else
-+		if (try.mppe_40 && try.mppe_128)
-+		    try.mppe_40 = 0;
-+		else
-+		    if (try.mppe_40 && try.mppe_56)
-+			try.mppe_40 = 0;
-+
-+	p += CILEN_MPPE;
-+	len -= CILEN_MPPE;
-     }
- #endif /* MPPE */
-+
-+    if (go->lzs && len >= CILEN_LZS && p[0] == CI_LZS && p[1] == CILEN_LZS) {
-+	no.lzs = 1;
-+	if (((p[2]<<8)|p[3]) > 1 || (p[4] != LZS_MODE_SEQ &&
-+				     p[4] != LZS_MODE_EXT))
-+	    try.lzs = 0;
-+	else {
-+	    try.lzs_mode = p[4];
-+	    try.lzs_hists = (p[2] << 8) | p[3];
-+	}
-+	p += CILEN_LZS;
-+	len -= CILEN_LZS;
-+    }
-+
-     if (go->deflate && len >= CILEN_DEFLATE
- 	&& p[0] == (go->deflate_correct? CI_DEFLATE: CI_DEFLATE_DRAFT)
- 	&& p[1] == CILEN_DEFLATE) {
-@@ -989,14 +1242,50 @@ ccp_rejci(fsm *f, u_char *p, int len)
- 	return -1;
- 
- #ifdef MPPE
--    if (go->mppe && len >= CILEN_MPPE
-+    if ((go->mppe || go->mppc) && len >= CILEN_MPPE
- 	&& p[0] == CI_MPPE && p[1] == CILEN_MPPE) {
--	error("MPPE required but peer refused");
--	lcp_close(f->unit, "MPPE required but peer refused");
-+	ccp_options *wo = &ccp_wantoptions[f->unit];
-+	if (p[2] != (go->mppe_stateless ? MPPE_STATELESS : 0) ||
-+	    p[3] != 0 ||
-+	    p[4] != 0 ||
-+	    p[5] != ((go->mppe_40 ? MPPE_40BIT : 0) |
-+		     (go->mppe_56 ? MPPE_56BIT : 0) |
-+		     (go->mppe_128 ? MPPE_128BIT : 0) |
-+		     (go->mppc ? MPPE_MPPC : 0)))
-+	    return 0;
-+	if (go->mppc)
-+	    try.mppc = 0;
-+	if (go->mppe) {
-+	    try.mppe = 0;
-+	    if (go->mppe_40)
-+		try.mppe_40 = 0;
-+	    if (go->mppe_56)
-+		try.mppe_56 = 0;
-+	    if (go->mppe_128)
-+		try.mppe_128 = 0;
-+	    if (go->mppe_stateless)
-+		try.mppe_stateless = 0;
-+	    if (!try.mppe_56 && !try.mppe_40 && !try.mppe_128)
-+		try.mppe = try.mppe_stateless = 0;
-+	    if (wo->mppe) { /* we want MPPE but cannot negotiate key length */
-+		wo->mppc = wo->mppe = wo->mppe_stateless = wo->mppe_40 =
-+		    wo->mppe_56 = wo->mppe_128 = 0;
-+		lcp_close(f->unit, "MPPE required but cannot negotiate MPPE "
-+			  "key length");
-+	    }
-+	}
- 	p += CILEN_MPPE;
- 	len -= CILEN_MPPE;
-     }
--#endif
-+#endif /* MPPE */
-+    if (go->lzs && len >= CILEN_LZS && p[0] == CI_LZS && p[1] == CILEN_LZS) {
-+	if (p[2] != go->lzs_hists>>8 || p[3] != (go->lzs_hists&0xff) 
-+	    || p[4] != go->lzs_mode)
-+	    return 0;
-+	try.lzs = 0;
-+	p += CILEN_LZS;
-+	len -= CILEN_LZS;
-+    }
-     if (go->deflate_correct && len >= CILEN_DEFLATE
- 	&& p[0] == CI_DEFLATE && p[1] == CILEN_DEFLATE) {
- 	if (p[2] != DEFLATE_MAKE_OPT(go->deflate_size)
-@@ -1056,14 +1345,15 @@ static int
- ccp_reqci(fsm *f, u_char *p, int *lenp, int dont_nak)
- {
-     int ret, newret, res;
--    u_char *p0, *retp;
-+    u_char *p0, *retp, p2, p5;
-     int len, clen, type, nb;
-     ccp_options *ho = &ccp_hisoptions[f->unit];
-     ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
- #ifdef MPPE
--    bool rej_for_ci_mppe = 1;	/* Are we rejecting based on a bad/missing */
--				/* CI_MPPE, or due to other options?       */
--#endif
-+    u_char opt_buf[CILEN_MPPE + MPPE_MAX_KEY_LEN];
-+/*     int mtu; */
-+#endif /* MPPE */
- 
-     ret = CONFACK;
-     retp = p0 = p;
-@@ -1086,106 +1376,302 @@ ccp_reqci(fsm *f, u_char *p, int *lenp,
- 	    switch (type) {
- #ifdef MPPE
- 	    case CI_MPPE:
--		if (!ao->mppe || clen != CILEN_MPPE) {
-+ 		if ((!ao->mppc && !ao->mppe) || clen != CILEN_MPPE) {
- 		    newret = CONFREJ;
- 		    break;
- 		}
--		MPPE_CI_TO_OPTS(&p[2], ho->mppe);
--
--		/* Nak if anything unsupported or unknown are set. */
--		if (ho->mppe & MPPE_OPT_UNSUPPORTED) {
-+ 		p2 = p[2];
-+ 		p5 = p[5];
-+ 		/* not sure what they want, tell 'em what we got */
-+ 		if (((p[2] & ~MPPE_STATELESS) != 0 || p[3] != 0 || p[4] != 0 ||
-+ 		     (p[5] & ~(MPPE_40BIT | MPPE_56BIT | MPPE_128BIT |
-+ 			       MPPE_MPPC)) != 0 || p[5] == 0) ||
-+ 		    (p[2] == 0 && p[3] == 0 && p[4] == 0 &&  p[5] == 0)) {
- 		    newret = CONFNAK;
--		    ho->mppe &= ~MPPE_OPT_UNSUPPORTED;
--		}
--		if (ho->mppe & MPPE_OPT_UNKNOWN) {
--		    newret = CONFNAK;
--		    ho->mppe &= ~MPPE_OPT_UNKNOWN;
--		}
--
--		/* Check state opt */
--		if (ho->mppe & MPPE_OPT_STATEFUL) {
--		    /*
--		     * We can Nak and request stateless, but it's a
--		     * lot easier to just assume the peer will request
--		     * it if he can do it; stateful mode is bad over
--		     * the Internet -- which is where we expect MPPE.
--		     */
--		   if (refuse_mppe_stateful) {
--			error("Refusing MPPE stateful mode offered by peer");
--			newret = CONFREJ;
--			break;
-+ 		    p[2] = (wo->mppe_stateless ? MPPE_STATELESS : 0);
-+		    p[3] = 0;
-+ 		    p[4] = 0;
-+ 		    p[5] = (wo->mppe_40 ? MPPE_40BIT : 0) |
-+ 			(wo->mppe_56 ? MPPE_56BIT : 0) |
-+ 			(wo->mppe_128 ? MPPE_128BIT : 0) |
-+ 			(wo->mppc ? MPPE_MPPC : 0);
-+ 		    break;
-+  		}
-+
-+ 		if ((p[5] & MPPE_MPPC)) {
-+ 		    if (ao->mppc) {
-+ 			ho->mppc = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			opt_buf[2] = opt_buf[3] = opt_buf[4] = 0;
-+ 			opt_buf[5] = MPPE_MPPC;
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE, 1) <= 0) {
-+ 			    ho->mppc = 0;
-+ 			    p[5] &= ~MPPE_MPPC;
-+ 			    newret = CONFNAK;
-+ 			}
-+ 		    } else {
-+		      newret = CONFREJ;
-+ 			if (wo->mppe || ao->mppe) {
-+ 			    p[5] &= ~MPPE_MPPC;
-+ 			    newret = CONFNAK;
-+ 			}
- 		    }
- 		}
--
--		/* Find out which of {S,L} are set. */
--		if ((ho->mppe & MPPE_OPT_128)
--		     && (ho->mppe & MPPE_OPT_40)) {
--		    /* Both are set, negotiate the strongest. */
--		    newret = CONFNAK;
--		    if (ao->mppe & MPPE_OPT_128)
--			ho->mppe &= ~MPPE_OPT_40;
--		    else if (ao->mppe & MPPE_OPT_40)
--			ho->mppe &= ~MPPE_OPT_128;
--		    else {
--			newret = CONFREJ;
--			break;
--		    }
--		} else if (ho->mppe & MPPE_OPT_128) {
--		    if (!(ao->mppe & MPPE_OPT_128)) {
--			newret = CONFREJ;
--			break;
--		    }
--		} else if (ho->mppe & MPPE_OPT_40) {
--		    if (!(ao->mppe & MPPE_OPT_40)) {
--			newret = CONFREJ;
--			break;
--		    }
-+ 		if (ao->mppe)
-+ 		    ho->mppe = 1;
-+ 
-+ 		if ((p[2] & MPPE_STATELESS)) {
-+ 		    if (ao->mppe_stateless) {
-+ 			if (wo->mppe_stateless)
-+ 			    ho->mppe_stateless = 1;
-+ 			else {
-+ 			    newret = CONFNAK;
-+ 			    if (!dont_nak)
-+ 				p[2] &= ~MPPE_STATELESS;
-+ 			}
-+ 		    } else {
-+ 			newret = CONFNAK;
-+ 			if (!dont_nak)
-+ 			    p[2] &= ~MPPE_STATELESS;
-+ 		    }
-+ 		} else {
-+ 		    if (wo->mppe_stateless && !dont_nak) {
-+ 			wo->mppe_stateless = 0;
-+ 			newret = CONFNAK;
-+ 			p[2] |= MPPE_STATELESS;
-+  		    }
-+  		}
-+  
-+ 		if ((p[5] & ~MPPE_MPPC) == (MPPE_40BIT|MPPE_56BIT|MPPE_128BIT)) {
-+  		    newret = CONFNAK;
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			p[5] &= ~(MPPE_40BIT|MPPE_56BIT);
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] |= (MPPE_40BIT|MPPE_56BIT);
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    goto check_mppe_56_40;
-+ 			}
-+ 			goto check_mppe;
-+  		    }
-+ 		    p[5] &= ~MPPE_128BIT;
-+ 		    goto check_mppe_56_40;
-+ 		}
-+ 		if ((p[5] & ~MPPE_MPPC) == (MPPE_56BIT|MPPE_128BIT)) {
-+ 		    newret = CONFNAK;
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			p[5] &= ~MPPE_56BIT;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] |= MPPE_56BIT;
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    goto check_mppe_56;
-+ 			}
-+ 			goto check_mppe;
-+  		    }
-+ 		    p[5] &= ~MPPE_128BIT;
-+ 		    goto check_mppe_56;
-+ 		}
-+ 		if ((p[5] & ~MPPE_MPPC) == (MPPE_40BIT|MPPE_128BIT)) {
-+ 		    newret = CONFNAK;
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			p[5] &= ~MPPE_40BIT;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] |= MPPE_40BIT;
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    goto check_mppe_40;
-+ 			}
-+ 			goto check_mppe;
-+ 		    }
-+ 		    p[5] &= ~MPPE_128BIT;
-+ 		    goto check_mppe_40;
-+ 		}
-+ 		if ((p[5] & ~MPPE_MPPC) == MPPE_128BIT) {
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    newret = CONFNAK;
-+ 			}
-+ 			goto check_mppe;
-+ 		    }
-+		    p[5] &= ~MPPE_128BIT;
-+ 		    newret = CONFNAK;
-+ 		    goto check_mppe;
-+ 		}
-+ 	    check_mppe_56_40:
-+		if ((p[5] & ~MPPE_MPPC) == (MPPE_40BIT|MPPE_56BIT)) {
-+ 		    newret = CONFNAK;
-+ 		    if (ao->mppe_56) {
-+ 			ho->mppe_56 = 1;
-+ 			p[5] &= ~MPPE_40BIT;
-+			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_56 = 0;
-+ 			    p[5] |= MPPE_40BIT;
-+ 			    p[5] &= ~MPPE_56BIT;
-+			    newret = CONFNAK;
-+ 			    goto check_mppe_40;
-+ 			}
-+			goto check_mppe;
-+ 		    }
-+		    p[5] &= ~MPPE_56BIT;
-+ 		    goto check_mppe_40;
-+ 		}
-+ 	    check_mppe_56:
-+		if ((p[5] & ~MPPE_MPPC) == MPPE_56BIT) {
-+ 		    if (ao->mppe_56) {
-+ 			ho->mppe_56 = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_56 = 0;
-+ 			    p[5] &= ~MPPE_56BIT;
-+			    newret = CONFNAK;
-+ 			}
-+			goto check_mppe;
-+ 		    }
-+ 		    p[5] &= ~MPPE_56BIT;
-+ 		    newret = CONFNAK;
-+		    goto check_mppe;
-+ 		}
-+ 	    check_mppe_40:
-+		if ((p[5] & ~MPPE_MPPC) == MPPE_40BIT) {
-+ 		    if (ao->mppe_40) {
-+ 			ho->mppe_40 = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_40 = 0;
-+			    p[5] &= ~MPPE_40BIT;
-+ 			    newret = CONFNAK;
-+ 			}
-+ 			goto check_mppe;
-+ 		    }
-+ 		    p[5] &= ~MPPE_40BIT;
-+ 		}
-+ 
-+ 	    check_mppe:
-+ 		if (!ho->mppe_40 && !ho->mppe_56 && !ho->mppe_128) {
-+ 		    if (wo->mppe_40 || wo->mppe_56 || wo->mppe_128) {
-+ 			newret = CONFNAK;
-+ 			p[2] |= (wo->mppe_stateless ? MPPE_STATELESS : 0);
-+			p[5] |= (wo->mppe_40 ? MPPE_40BIT : 0) |
-+ 			    (wo->mppe_56 ? MPPE_56BIT : 0) |
-+ 			    (wo->mppe_128 ? MPPE_128BIT : 0) |
-+ 			    (wo->mppc ? MPPE_MPPC : 0);
-+ 		    } else {
-+ 			ho->mppe = ho->mppe_stateless = 0;
-+ 		    }
- 		} else {
--		    /* Neither are set. */
--		    /* We cannot accept this.  */
--		    newret = CONFNAK;
--		    /* Give the peer our idea of what can be used,
--		       so it can choose and confirm */
--		    ho->mppe = ao->mppe;
--		}
--
--		/* rebuild the opts */
--		MPPE_OPTS_TO_CI(ho->mppe, &p[2]);
--		if (newret == CONFACK) {
--		    u_char opt_buf[CILEN_MPPE + MPPE_MAX_KEY_LEN];
--		    int mtu;
--
--		    BCOPY(p, opt_buf, CILEN_MPPE);
--		    BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
--			  MPPE_MAX_KEY_LEN);
--		    if (ccp_test(f->unit, opt_buf,
--				 CILEN_MPPE + MPPE_MAX_KEY_LEN, 1) <= 0) {
--			/* This shouldn't happen, we've already tested it! */
--			error("MPPE required, but kernel has no support.");
--			lcp_close(f->unit, "MPPE required but not available");
--			newret = CONFREJ;
--			break;
--		    }
--		    /*
--		     * We need to decrease the interface MTU by MPPE_PAD
--		     * because MPPE frames **grow**.  The kernel [must]
--		     * allocate MPPE_PAD extra bytes in xmit buffers.
--		     */
--		    mtu = netif_get_mtu(f->unit);
--		    if (mtu)
--			netif_set_mtu(f->unit, mtu - MPPE_PAD);
--		    else
--			newret = CONFREJ;
--		}
--
--		/*
--		 * We have accepted MPPE or are willing to negotiate
--		 * MPPE parameters.  A CONFREJ is due to subsequent
--		 * (non-MPPE) processing.
--		 */
--		rej_for_ci_mppe = 0;
--		break;
--#endif /* MPPE */
-+ 		    /* MPPE is not compatible with other compression types */
-+ 		    if (wo->mppe) {
-+ 			ao->bsd_compress = 0;
-+ 			ao->predictor_1 = 0;
-+ 			ao->predictor_2 = 0;
-+			ao->deflate = 0;
-+ 			ao->lzs = 0;
-+ 		    }
-+ 		}
-+ 		if ((!ho->mppc || !ao->mppc) && !ho->mppe) {
-+ 		    p[2] = p2;
-+ 		    p[5] = p5;
-+  		    newret = CONFREJ;
-+  		    break;
-+  		}
-+  
-+ 		/*
-+ 		 * I have commented the code below because according to RFC1547
-+ 		 * MTU is only information for higher level protocols about
-+ 		 * "the maximum allowable length for a packet (q.v.) transmitted
-+ 		 * over a point-to-point link without incurring network layer
-+ 		 * fragmentation." Of course a PPP implementation should be able
-+ 		 * to handle overhead added by MPPE - in our case apropriate code
-+ 		 * is located in drivers/net/ppp_generic.c in the kernel sources.
-+		 *
-+ 		 * According to RFC1661:
-+ 		 * - when negotiated MRU is less than 1500 octets, a PPP
-+ 		 *   implementation must still be able to receive at least 1500
-+ 		 *   octets,
-+ 		 * - when PFC is negotiated, a PPP implementation is still
-+ 		 *   required to receive frames with uncompressed protocol field.
-+		 *
-+ 		 * So why not to handle MPPE overhead without changing MTU value?
-+ 		 * I am sure that RFC3078, unfortunately silently, assumes that.
-+ 		 */
-+ 
-+ 		/*
-+ 		 * We need to decrease the interface MTU by MPPE_PAD
-+ 		 * because MPPE frames **grow**.  The kernel [must]
-+ 		 * allocate MPPE_PAD extra bytes in xmit buffers.
-+ 		 */
-+ /*
-+ 		mtu = netif_get_mtu(f->unit);
-+ 		if (mtu) {
-+ 		    netif_set_mtu(f->unit, mtu - MPPE_PAD);
-+ 		} else {
-+		    newret = CONFREJ;
-+ 		    if (ccp_wantoptions[f->unit].mppe) {
-+ 			error("Cannot adjust MTU needed by MPPE.");
-+ 			lcp_close(f->unit, "Cannot adjust MTU needed by MPPE.");
-+ 		    }
-+ 		}
-+ */
-+ 		break;
-+  #endif /* MPPE */
-+ 
-+	    case CI_LZS:
-+ 		if (!ao->lzs || clen != CILEN_LZS) {
-+ 		    newret = CONFREJ;
-+ 		    break;
-+ 		}
-+ 
-+ 		ho->lzs = 1;
-+		ho->lzs_hists = (p[2] << 8) | p[3];
-+ 		ho->lzs_mode = p[4];
-+	if ((ho->lzs_hists != ao->lzs_hists) ||
-+		    (ho->lzs_mode != ao->lzs_mode)) {
-+ 		    newret = CONFNAK;
-+ 		    if (!dont_nak) {
-+ 			p[2] = ao->lzs_hists >> 8;
-+ 			p[3] = ao->lzs_hists & 0xff;
-+ 			p[4] = ao->lzs_mode;
-+	    } else
-+ 			break;
-+ 		}
-+ 
-+ 		if (p == p0 && ccp_test(f->unit, p, CILEN_LZS, 1) <= 0) {
-+ 		    newret = CONFREJ;
-+ 		}
-+ 		break;
- 	    case CI_DEFLATE:
- 	    case CI_DEFLATE_DRAFT:
- 		if (!ao->deflate || clen != CILEN_DEFLATE
-@@ -1327,12 +1813,6 @@ ccp_reqci(fsm *f, u_char *p, int *lenp,
- 	else
- 	    *lenp = retp - p0;
-     }
--#ifdef MPPE
--    if (ret == CONFREJ && ao->mppe && rej_for_ci_mppe) {
--	error("MPPE required but peer negotiation failed");
--	lcp_close(f->unit, "MPPE required but peer negotiation failed");
--    }
--#endif
-     return ret;
- }
- 
-@@ -1353,24 +1833,35 @@ method_name(ccp_options *opt, ccp_option
- 	char *p = result;
- 	char *q = result + sizeof(result); /* 1 past result */
- 
--	slprintf(p, q - p, "MPPE ");
--	p += 5;
--	if (opt->mppe & MPPE_OPT_128) {
--	    slprintf(p, q - p, "128-bit ");
--	    p += 8;
--	}
--	if (opt->mppe & MPPE_OPT_40) {
--	    slprintf(p, q - p, "40-bit ");
--	    p += 7;
--	}
--	if (opt->mppe & MPPE_OPT_STATEFUL)
--	    slprintf(p, q - p, "stateful");
--	else
--	    slprintf(p, q - p, "stateless");
--
-+	if (opt->mppe) {
-+	    if (opt->mppc) {
-+		slprintf(p, q - p, "MPPC/MPPE ");
-+		p += 10;
-+	    } else {
-+		slprintf(p, q - p, "MPPE ");
-+		p += 5;
-+	    }
-+	    if (opt->mppe_128) {
-+		slprintf(p, q - p, "128-bit ");
-+		p += 8;
-+	    } else if (opt->mppe_56) {
-+		slprintf(p, q - p, "56-bit ");
-+		p += 7;
-+	    } else if (opt->mppe_40) {
-+		slprintf(p, q - p, "40-bit ");
-+		p += 7;
-+	    }
-+	    if (opt->mppe_stateless)
-+		slprintf(p, q - p, "stateless");
-+	    else
-+		slprintf(p, q - p, "stateful");
-+	} else if (opt->mppc)
-+	    slprintf(p, q - p, "MPPC");
- 	break;
-     }
--#endif
-+#endif /* MPPE */
-+    case CI_LZS:
-+	return "Stac LZS";
-     case CI_DEFLATE:
-     case CI_DEFLATE_DRAFT:
- 	if (opt2 != NULL && opt2->deflate_size != opt->deflate_size)
-@@ -1425,12 +1916,12 @@ ccp_up(fsm *f)
-     } else if (ANY_COMPRESS(*ho))
- 	notice("%s transmit compression enabled", method_name(ho, NULL));
- #ifdef MPPE
--    if (go->mppe) {
-+    if (go->mppe || go->mppc) {
- 	BZERO(mppe_recv_key, MPPE_MAX_KEY_LEN);
- 	BZERO(mppe_send_key, MPPE_MAX_KEY_LEN);
- 	continue_networks(f->unit);		/* Bring up IP et al */
-     }
--#endif
-+#endif /* MPPE */
- }
- 
- /*
-@@ -1452,7 +1943,7 @@ ccp_down(fsm *f)
- 	    lcp_close(f->unit, "MPPE disabled");
- 	}
-     }
--#endif
-+#endif /* MPPE */
- }
- 
- /*
-@@ -1509,24 +2000,28 @@ ccp_printpkt(u_char *p, int plen,
- #ifdef MPPE
- 	    case CI_MPPE:
- 		if (optlen >= CILEN_MPPE) {
--		    u_char mppe_opts;
--
--		    MPPE_CI_TO_OPTS(&p[2], mppe_opts);
--		    printer(arg, "mppe %s %s %s %s %s %s%s",
--			    (p[2] & MPPE_H_BIT)? "+H": "-H",
--			    (p[5] & MPPE_M_BIT)? "+M": "-M",
--			    (p[5] & MPPE_S_BIT)? "+S": "-S",
--			    (p[5] & MPPE_L_BIT)? "+L": "-L",
-+		    printer(arg, "mppe %s %s %s %s %s %s",
-+			    (p[2] & MPPE_STATELESS)? "+H": "-H",
-+			    (p[5] & MPPE_56BIT)? "+M": "-M",
-+			    (p[5] & MPPE_128BIT)? "+S": "-S",
-+			    (p[5] & MPPE_40BIT)? "+L": "-L",
- 			    (p[5] & MPPE_D_BIT)? "+D": "-D",
--			    (p[5] & MPPE_C_BIT)? "+C": "-C",
--			    (mppe_opts & MPPE_OPT_UNKNOWN)? " +U": "");
--		    if (mppe_opts & MPPE_OPT_UNKNOWN)
-+			    (p[5] & MPPE_MPPC)? "+C": "-C");
-+		    if ((p[5] & ~(MPPE_56BIT | MPPE_128BIT | MPPE_40BIT |
-+				  MPPE_D_BIT | MPPE_MPPC)) ||
-+			(p[2] & ~MPPE_STATELESS))
- 			printer(arg, " (%.2x %.2x %.2x %.2x)",
- 				p[2], p[3], p[4], p[5]);
- 		    p += CILEN_MPPE;
- 		}
- 		break;
--#endif
-+#endif /* MPPE */
-+	    case CI_LZS:
-+		if (optlen >= CILEN_LZS) {
-+		    printer(arg, "lzs %.2x %.2x %.2x", p[2], p[3], p[4]);
-+		    p += CILEN_LZS;
-+		}
-+		break;
- 	    case CI_DEFLATE:
- 	    case CI_DEFLATE_DRAFT:
- 		if (optlen >= CILEN_DEFLATE) {
-@@ -1609,6 +2104,7 @@ ccp_datainput(int unit, u_char *pkt, int
- 	    error("Lost compression sync: disabling compression");
- 	    ccp_close(unit, "Lost compression sync");
- #ifdef MPPE
-+	    /* My module dosn't need this. J.D., 2003-07-06 */
- 	    /*
- 	     * If we were doing MPPE, we must also take the link down.
- 	     */
-@@ -1616,9 +2112,18 @@ ccp_datainput(int unit, u_char *pkt, int
- 		error("Too many MPPE errors, closing LCP");
- 		lcp_close(unit, "Too many MPPE errors");
- 	    }
--#endif
-+#endif /* MPPE */
- 	} else {
- 	    /*
-+	     * When LZS or MPPE/MPPC is negotiated we just send CCP_RESETREQ
-+	     * and don't wait for CCP_RESETACK
-+	     */
-+	    if ((ccp_gotoptions[f->unit].method == CI_LZS) ||
-+		(ccp_gotoptions[f->unit].method == CI_MPPE)) {
-+		fsm_sdata(f, CCP_RESETREQ, f->reqid = ++f->id, NULL, 0);
-+		return;
-+	    }
-+	    /*
- 	     * Send a reset-request to reset the peer's compressor.
- 	     * We don't do that if we are still waiting for an
- 	     * acknowledgement to a previous reset-request.
---- a/pppd/ccp.h
-+++ b/pppd/ccp.h
-@@ -37,9 +37,17 @@ typedef struct ccp_options {
-     bool predictor_2;		/* do Predictor-2? */
-     bool deflate_correct;	/* use correct code for deflate? */
-     bool deflate_draft;		/* use draft RFC code for deflate? */
-+    bool lzs;			/* do Stac LZS? */
-+    bool mppc;			/* do MPPC? */
-     u_char mppe;		/* MPPE bitfield */
-+    bool mppe_40;		/* allow 40 bit encryption? */
-+    bool mppe_56;		/* allow 56 bit encryption? */
-+    bool mppe_128;		/* allow 128 bit encryption? */
-+    bool mppe_stateless;	/* allow stateless encryption */
-     u_short bsd_bits;		/* # bits/code for BSD Compress */
-     u_short deflate_size;	/* lg(window size) for Deflate */
-+    u_short lzs_mode;		/* LZS check mode */
-+    u_short lzs_hists;		/* number of LZS histories */
-     short method;		/* code for chosen compression method */
- } ccp_options;
- 
---- a/pppd/chap_ms.c
-+++ b/pppd/chap_ms.c
-@@ -964,13 +964,17 @@ set_mppe_enc_types(int policy, int types
-     /*
-      * Disable undesirable encryption types.  Note that we don't ENABLE
-      * any encryption types, to avoid overriding manual configuration.
-+     *
-+     * It seems that 56 bit keys are unsupported in MS-RADIUS (see RFC 2548)
-      */
-     switch(types) {
- 	case MPPE_ENC_TYPES_RC4_40:
--	    ccp_wantoptions[0].mppe &= ~MPPE_OPT_128;	/* disable 128-bit */
-+	    ccp_wantoptions[0].mppe_128 = 0;	/* disable 128-bit */
-+	    ccp_wantoptions[0].mppe_56 = 0;	/* disable 56-bit */
- 	    break;
- 	case MPPE_ENC_TYPES_RC4_128:
--	    ccp_wantoptions[0].mppe &= ~MPPE_OPT_40;	/* disable 40-bit */
-+	    ccp_wantoptions[0].mppe_56 = 0;	/* disable 56-bit */
-+	    ccp_wantoptions[0].mppe_40 = 0;	/* disable 40-bit */
- 	    break;
- 	default:
- 	    break;
diff --git a/package/network/services/ppp/patches/203-opt_flags.patch b/package/network/services/ppp/patches/203-opt_flags.patch
deleted file mode 100644
index 705959e7..00000000
--- a/package/network/services/ppp/patches/203-opt_flags.patch
+++ /dev/null
@@ -1,38 +0,0 @@
-build: Move optimization flags into a separate variable
-
-Isolate optimization related compiler flags from CFLAGS and move them into a
-separate COPTS variable so that it is easier to override optimizations from
-the environment.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/pppd/plugins/radius/Makefile.linux
-+++ b/pppd/plugins/radius/Makefile.linux
-@@ -47,13 +47,13 @@ install: all
- 	$(INSTALL) -c -m 444 pppd-radattr.8 $(MANDIR)
- 
- radius.so: radius.o libradiusclient.a
--	$(CC) $(LDFLAGS) -o radius.so -shared radius.o libradiusclient.a
-+	$(CC) $(LDFLAGS) -fPIC -o radius.so -shared radius.o libradiusclient.a
- 
- radattr.so: radattr.o
--	$(CC) $(LDFLAGS) -o radattr.so -shared radattr.o
-+	$(CC) $(LDFLAGS) -fPIC -o radattr.so -shared radattr.o
- 
- radrealms.so: radrealms.o
--	$(CC) $(LDFLAGS) -o radrealms.so -shared radrealms.o
-+	$(CC) $(LDFLAGS) -fPIC -o radrealms.so -shared radrealms.o
- 
- CLIENTOBJS = avpair.o buildreq.o config.o dict.o ip_util.o \
- 	clientid.o sendserver.o lock.o util.o md5.o
---- a/pppd/plugins/pppoe/Makefile.linux
-+++ b/pppd/plugins/pppoe/Makefile.linux
-@@ -38,7 +38,7 @@ debug.o: debug.c
- 	$(CC) $(CFLAGS) -I../../.. -c -o debug.o debug.c
- 
- pppoe.so: plugin.o discovery.o if.o common.o
--	$(CC) $(LDFLAGS) -o pppoe.so -shared plugin.o discovery.o if.o common.o
-+	$(CC) $(LDFLAGS) -fPIC -o pppoe.so -shared plugin.o discovery.o if.o common.o
- 
- install: all
- 	$(INSTALL) -d -m 755 $(LIBDIR)
diff --git a/package/network/services/ppp/patches/204-radius_config.patch b/package/network/services/ppp/patches/204-radius_config.patch
index 2f30b9d3..3f6db59b 100644
--- a/package/network/services/ppp/patches/204-radius_config.patch
+++ b/package/network/services/ppp/patches/204-radius_config.patch
@@ -1,6 +1,6 @@
 --- a/pppd/plugins/radius/config.c
 +++ b/pppd/plugins/radius/config.c
-@@ -371,31 +371,37 @@ static int test_config(char *filename)
+@@ -381,31 +381,37 @@ static int test_config(char *filename)
  	}
  #endif
  
diff --git a/package/network/services/ppp/patches/205-no_exponential_timeout.patch b/package/network/services/ppp/patches/205-no_exponential_timeout.patch
deleted file mode 100644
index b08c2eff..00000000
--- a/package/network/services/ppp/patches/205-no_exponential_timeout.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-pppd: Don't use exponential timeout in discovery phase
-
-This patch removes the exponential timeout increase between PADO or PADS
-discovery attempts.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/pppd/plugins/pppoe/discovery.c
-+++ b/pppd/plugins/pppoe/discovery.c
-@@ -632,7 +632,9 @@ discovery(PPPoEConnection *conn)
- 	conn->discoveryState = STATE_SENT_PADI;
- 	waitForPADO(conn, timeout);
- 
-+#if 0
- 	timeout *= 2;
-+#endif
-     } while (conn->discoveryState == STATE_SENT_PADI);
- 
-     timeout = conn->discoveryTimeout;
-@@ -647,7 +649,9 @@ discovery(PPPoEConnection *conn)
- 	sendPADR(conn);
- 	conn->discoveryState = STATE_SENT_PADR;
- 	waitForPADS(conn, timeout);
-+#if 0
- 	timeout *= 2;
-+#endif
-     } while (conn->discoveryState == STATE_SENT_PADR);
- 
-     if (!conn->seenMaxPayload) {
diff --git a/package/network/services/ppp/patches/207-lcp_mtu_max.patch b/package/network/services/ppp/patches/207-lcp_mtu_max.patch
index 522576c6..3ca0534f 100644
--- a/package/network/services/ppp/patches/207-lcp_mtu_max.patch
+++ b/package/network/services/ppp/patches/207-lcp_mtu_max.patch
@@ -8,18 +8,18 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
 --- a/pppd/lcp.c
 +++ b/pppd/lcp.c
-@@ -1862,12 +1862,12 @@ lcp_up(fsm *f)
+@@ -1888,12 +1888,12 @@ lcp_up(fsm *f)
       * the interface MTU is set to the lowest of that, the
       * MTU we want to use, and our link MRU.
       */
 -    mtu = ho->neg_mru? ho->mru: PPP_MRU;
 +    mtu = MIN(ho->neg_mru? ho->mru: PPP_MRU, ao->mru);
      mru = go->neg_mru? MAX(wo->mru, go->mru): PPP_MRU;
- #ifdef HAVE_MULTILINK
+ #ifdef PPP_WITH_MULTILINK
      if (!(multilink && go->neg_mrru && ho->neg_mrru))
- #endif /* HAVE_MULTILINK */
--	netif_set_mtu(f->unit, MIN(MIN(mtu, mru), ao->mru));
-+	netif_set_mtu(f->unit, MIN(mtu, mru));
+ #endif /* PPP_WITH_MULTILINK */
+-	ppp_set_mtu(f->unit, MIN(MIN(mtu, mru), ao->mru));
++	ppp_set_mtu(f->unit, MIN(mtu, mru));
      ppp_send_config(f->unit, mtu,
  		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
  		    ho->neg_pcompression, ho->neg_accompression);
diff --git a/package/network/services/ppp/patches/208-fix_status_code.patch b/package/network/services/ppp/patches/208-fix_status_code.patch
index 54e6c45e..10cd9453 100644
--- a/package/network/services/ppp/patches/208-fix_status_code.patch
+++ b/package/network/services/ppp/patches/208-fix_status_code.patch
@@ -12,13 +12,13 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
 --- a/pppd/main.c
 +++ b/pppd/main.c
-@@ -1034,7 +1034,8 @@ get_input(void)
+@@ -1152,7 +1152,8 @@ get_input(void)
  	}
  	notice("Modem hangup");
  	hungup = 1;
--	status = EXIT_HANGUP;
-+	if (status == EXIT_OK)
-+		status = EXIT_HANGUP;
+-	code = EXIT_HANGUP;
++	if (code == EXIT_OK)
++		code = EXIT_HANGUP;
  	lcp_lowerdown(0);	/* serial link is no longer available */
  	link_terminated(0);
  	return;
diff --git a/package/network/services/ppp/patches/300-filter-pcap-includes-lib.patch b/package/network/services/ppp/patches/300-filter-pcap-includes-lib.patch
deleted file mode 100644
index 87e340b3..00000000
--- a/package/network/services/ppp/patches/300-filter-pcap-includes-lib.patch
+++ /dev/null
@@ -1,20 +0,0 @@
-build: Add required CFLAGS for libpcap
-
-This patch adds some flags to required to properly link libpcap within the
-OpenWrt environment.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/pppd/Makefile.linux
-+++ b/pppd/Makefile.linux
-@@ -210,8 +210,8 @@ LIBS	+= -ldl
- endif
- 
- ifdef FILTER
--LIBS    += -lpcap
--CFLAGS  += -DPPP_FILTER
-+LIBS    += -lpcap -L$(STAGING_DIR)/usr/lib
-+CFLAGS  += -DPPP_FILTER -I$(STAGING_DIR)/usr/include
- endif
- 
- ifdef HAVE_INET6
diff --git a/package/network/services/ppp/patches/310-precompile_filter.patch b/package/network/services/ppp/patches/310-precompile_filter.patch
index ca91d153..ad0dd03d 100644
--- a/package/network/services/ppp/patches/310-precompile_filter.patch
+++ b/package/network/services/ppp/patches/310-precompile_filter.patch
@@ -11,62 +11,70 @@ packets which are treated as active.
 
 Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
---- a/pppd/Makefile.linux
-+++ b/pppd/Makefile.linux
-@@ -51,6 +51,9 @@ MPPE=y
- # and that the kernel driver support PPP packet filtering.
- #FILTER=y
+--- a/configure.ac
++++ b/configure.ac
+@@ -306,6 +306,9 @@ AM_CONDITIONAL(PPP_WITH_PAM, test "x${wi
+ # With libpcap support, activate pppd on network activity
+ AX_CHECK_PCAP
  
-+# Support for precompiled filters
-+PRECOMPILED_FILTER=y
++# internal statically linked pcap
++AM_CONDITIONAL(PPP_WITH_PRECOMPILED_FILTER, test "x${with_static_pcap}" = "xyes")
 +
- # Uncomment the next line to enable multilink PPP (enabled by default)
- # Linux distributions: Please leave multilink ENABLED in your builds
- # of pppd!
-@@ -214,6 +217,14 @@ LIBS    += -lpcap -L$(STAGING_DIR)/usr/l
- CFLAGS  += -DPPP_FILTER -I$(STAGING_DIR)/usr/include
+ #
+ # SunOS provides a version of libpcap that would work, but SunOS has no support for activity filter
+ AM_CONDITIONAL([PPP_WITH_FILTER], [ test "x${with_pcap}" = "xyes" && test "x${build_sunos}" != "xyes" ])
+@@ -359,6 +362,7 @@ $PACKAGE_NAME version $PACKAGE_VERSION
+     With libatm..........: ${with_atm:-no}
+     With libpam..........: ${with_pam:-no}
+     With libpcap.........: ${with_pcap:-no}
++    With static libpcap..: ${with_static_pcap:-no}
+     With libsrp..........: ${with_srp:-no}
+     C Compiler...........: $CC $CFLAGS
+     Linker...............: $LD $LDFLAGS $LIBS
+--- a/pppd/Makefile.am
++++ b/pppd/Makefile.am
+@@ -138,6 +138,12 @@ pppd_LDFLAGS += $(PCAP_LDFLAGS)
+ pppd_LIBS += $(PCAP_LIBS)
  endif
  
-+ifdef PRECOMPILED_FILTER
-+PPPDSRCS += pcap_pcc.c
-+HEADERS  += pcap_pcc.h
-+PPPDOBJS += pcap_pcc.o
-+LIBS	+= $(STAGING_DIR)/usr/lib/libpcap.a
-+CFLAGS	+= -DPPP_FILTER -DPPP_PRECOMPILED_FILTER -I$(STAGING_DIR)/usr/include
++if PPP_WITH_PRECOMPILED_FILTER
++pppd_SOURCES += pcap_pcc.c
++pppd_include_HEADERS += pcap_pcc.h
++pppd_LIBS += $(STAGING_DIR)/usr/lib/libpcap.a
 +endif
 +
- ifdef HAVE_INET6
-      PPPDSRCS += ipv6cp.c eui64.c
-      HEADERS  += ipv6cp.h eui64.h
+ if PPP_WITH_PLUGINS
+ pppd_CPPFLAGS += -DPPPD_PLUGIN_DIR='"@PPPD_PLUGIN_DIR@"'
+ pppd_LIBS += -ldl
 --- a/pppd/options.c
 +++ b/pppd/options.c
-@@ -56,6 +56,7 @@
+@@ -62,6 +62,7 @@
  
- #ifdef PPP_FILTER
+ #ifdef PPP_WITH_FILTER
  #include <pcap.h>
 +#include <pcap-bpf.h>
  /*
   * There have been 3 or 4 different names for this in libpcap CVS, but
   * this seems to be what they have settled on...
-@@ -168,6 +169,13 @@ static int setlogfile(char **);
+@@ -182,6 +183,13 @@ static int setlogfile(char **);
  static int loadplugin(char **);
  #endif
  
-+#ifdef PPP_PRECOMPILED_FILTER
++#ifdef PPP_WITH_PRECOMPILED_FILTER
 +#include "pcap_pcc.h"
 +static int setprecompiledpassfilter(char **);
 +static int setprecompiledactivefilter(char **);
-+#undef PPP_FILTER
++#undef PPP_WITH_FILTER
 +#endif
 +
- #ifdef PPP_FILTER
+ #ifdef PPP_WITH_FILTER
  static int setpassfilter(char **);
  static int setactivefilter(char **);
-@@ -360,6 +368,14 @@ option_t general_options[] = {
+@@ -391,6 +399,14 @@ struct option general_options[] = {
        "set filter for active pkts", OPT_PRIO },
  #endif
  
-+#ifdef PPP_PRECOMPILED_FILTER
++#ifdef PPP_WITH_PRECOMPILED_FILTER
 +    { "precompiled-pass-filter", 1, setprecompiledpassfilter,
 +      "set precompiled filter for packets to pass", OPT_PRIO },
 +
@@ -74,14 +82,14 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 +      "set precompiled filter for active pkts", OPT_PRIO },
 +#endif
 +
- #ifdef MAXOCTETS
      { "maxoctets", o_int, &maxoctets,
        "Set connection traffic limit",
-@@ -1468,6 +1484,27 @@ callfile(char **argv)
+       OPT_PRIO | OPT_LLIMIT | OPT_NOINCR | OPT_ZEROINF },
+@@ -1666,6 +1682,27 @@ callfile(char **argv)
      return ok;
  }
  
-+#ifdef PPP_PRECOMPILED_FILTER
++#ifdef PPP_WITH_PRECOMPILED_FILTER
 +/*
 + * setprecompiledpassfilter - Set the pass filter for packets using a
 + * precompiled expression
@@ -102,18 +110,19 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 +}
 +#endif
 +
- #ifdef PPP_FILTER
+ #ifdef PPP_WITH_FILTER
  /*
   * setpassfilter - Set the pass filter for packets
 --- /dev/null
 +++ b/pppd/pcap_pcc.c
-@@ -0,0 +1,74 @@
+@@ -0,0 +1,75 @@
 +#include <pcap.h>
 +#include <pcap-bpf.h>
 +#include <stdio.h>
 +#include <stdlib.h>
 +#include <string.h>
 +#include <errno.h>
++#include "options.h"
 +#include "pppd.h"
 +
 +int pcap_pre_compiled (char * fname, struct bpf_program *p)
@@ -123,7 +132,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 +    FILE *f = fopen (fname, "r");
 +    if (!f)
 +    {
-+       option_error("error opening precompiled active-filter '%s': %s",
++       ppp_option_error("error opening precompiled active-filter '%s': %s",
 +                    fname, strerror (errno));
 +       return 0;
 +    }
@@ -167,18 +176,18 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 +    } 
 +    if (size != index)
 +    {
-+       option_error("error in precompiled active-filter,"
-+                    " expected %d expressions, got %dn",
-+                    size, index);
++       ppp_option_error("error in precompiled active-filter,"
++                        " expected %d expressions, got %dn",
++                        size, index);
 +       ret = 0;
 +    }
 +    fclose(f);
 +    return ret;
 +
 +err:
-+  option_error("error in precompiled active-filter"
-+              " expression line %s:%d (wrong size)\n", 
-+              fname, line);
++  ppp_option_error("error in precompiled active-filter"
++                   " expression line %s:%d (wrong size)\n",
++                   fname, line);
 +  fclose (f);
 +  return 0;
 +}
diff --git a/package/network/services/ppp/patches/321-multilink_support_custom_iface_names.patch b/package/network/services/ppp/patches/321-multilink_support_custom_iface_names.patch
index 0c4d7ea9..a761ca65 100644
--- a/package/network/services/ppp/patches/321-multilink_support_custom_iface_names.patch
+++ b/package/network/services/ppp/patches/321-multilink_support_custom_iface_names.patch
@@ -8,15 +8,15 @@ Signed-off-by: George Kashperko <george@znau.edu.ua>
  2 files changed, 53 insertions(+), 14 deletions(-)
 --- a/pppd/multilink.c
 +++ b/pppd/multilink.c
-@@ -35,6 +35,7 @@
+@@ -40,6 +40,7 @@
  #include <signal.h>
  #include <netinet/in.h>
  #include <unistd.h>
 +#include <net/if.h>
  
- #include "pppd.h"
+ #include "pppd-private.h"
  #include "fsm.h"
-@@ -56,7 +57,8 @@ static void iterate_bundle_links(void (*
+@@ -62,7 +63,8 @@ static void iterate_bundle_links(void (*
  
  static int get_default_epdisc(struct epdisc *);
  static int parse_num(char *str, const char *key, int *valp);
@@ -26,7 +26,7 @@ Signed-off-by: George Kashperko <george@znau.edu.ua>
  
  #define set_ip_epdisc(ep, addr) do {	\
  	ep->length = 4;			\
-@@ -197,35 +199,38 @@ mp_join_bundle(void)
+@@ -215,35 +217,38 @@ mp_join_bundle(void)
  	key.dptr = bundle_id;
  	key.dsize = p - bundle_id;
  	pid = tdb_fetch(pppdb, key);
@@ -61,7 +61,7 @@ Signed-off-by: George Kashperko <george@znau.edu.ua>
 -		if (bundle_attach(unit)) {
 +		if (unit >= 0 && bundle_attach(unit)) {
  			set_ifunit(0);
- 			script_setenv("BUNDLE", bundle_id + 7, 0);
+ 			ppp_script_setenv("BUNDLE", bundle_id + 7, 0);
  			make_bundle_links(1);
  			unlock_db();
 -			info("Link attached to %s", ifname);
@@ -73,7 +73,7 @@ Signed-off-by: George Kashperko <george@znau.edu.ua>
  	}
  
  	/* we have to make a new bundle */
-@@ -405,20 +410,39 @@ parse_num(char *str, const char *key, in
+@@ -423,20 +428,39 @@ parse_num(char *str, const char *key, in
  	return 0;
  }
  
@@ -119,7 +119,7 @@ Signed-off-by: George Kashperko <george@znau.edu.ua>
  			&& memcmp(vd.dptr, key.dptr, vd.dsize) == 0;
 --- a/pppd/sys-linux.c
 +++ b/pppd/sys-linux.c
-@@ -706,6 +706,16 @@ void cfg_bundle(int mrru, int mtru, int
+@@ -984,6 +984,16 @@ void cfg_bundle(int mrru, int mtru, int
  	add_fd(ppp_dev_fd);
  }
  
@@ -129,14 +129,14 @@ Signed-off-by: George Kashperko <george@znau.edu.ua>
 +#ifdef USE_TDB
 +	char tmp[11];
 +	slprintf(tmp, sizeof(tmp), "%d", ifunit);
-+	script_setenv("IFUNIT", tmp, 0);
++	ppp_script_setenv("IFUNIT", tmp, 0);
 +#endif
 +}
 +
  /*
   * make_new_bundle - create a new PPP unit (i.e. a bundle)
   * and connect our channel to it.  This should only get called
-@@ -724,6 +734,8 @@ void make_new_bundle(int mrru, int mtru,
+@@ -1002,6 +1012,8 @@ void make_new_bundle(int mrru, int mtru,
  
  	/* set the mrru and flags */
  	cfg_bundle(mrru, mtru, rssn, tssn);
diff --git a/package/network/services/ppp/patches/330-retain_foreign_default_routes.patch b/package/network/services/ppp/patches/330-retain_foreign_default_routes.patch
deleted file mode 100644
index 6ccc4507..00000000
--- a/package/network/services/ppp/patches/330-retain_foreign_default_routes.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-pppd: Retain foreign default routes on Linux
-
-On Linux, when pppd attempts to delete its default route it does not fill
-the rt_dev field of the struct rtentry used to match the system default route.
-As a consequence, pppd happily deletes any default route even if it belongs
-to another interface.
-
-This patch makes pppd fill out the rt_dev field so that only own default
-routes are ever matched.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/pppd/sys-linux.c
-+++ b/pppd/sys-linux.c
-@@ -1770,6 +1770,7 @@ int cifdefaultroute (int unit, u_int32_t
- 	SIN_ADDR(rt.rt_genmask) = 0L;
-     }
- 
-+    rt.rt_dev = ifname;
-     rt.rt_flags = RTF_UP;
-     if (ioctl(sock_fd, SIOCDELRT, &rt) < 0 && errno != ESRCH) {
- 	if (still_ppp()) {
diff --git a/package/network/services/ppp/patches/340-populate_default_gateway.patch b/package/network/services/ppp/patches/340-populate_default_gateway.patch
index 0f965c70..f3279713 100644
--- a/package/network/services/ppp/patches/340-populate_default_gateway.patch
+++ b/package/network/services/ppp/patches/340-populate_default_gateway.patch
@@ -13,7 +13,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
 --- a/pppd/sys-linux.c
 +++ b/pppd/sys-linux.c
-@@ -1720,6 +1720,9 @@ int sifdefaultroute (int unit, u_int32_t
+@@ -2251,6 +2251,9 @@ int sifdefaultroute (int unit, u_int32_t
      memset (&rt, 0, sizeof (rt));
      SET_SA_FAMILY (rt.rt_dst, AF_INET);
  
@@ -23,7 +23,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      rt.rt_dev = ifname;
      rt.rt_metric = dfl_route_metric + 1; /* +1 for binary compatibility */
  
-@@ -1728,7 +1731,7 @@ int sifdefaultroute (int unit, u_int32_t
+@@ -2259,7 +2262,7 @@ int sifdefaultroute (int unit, u_int32_t
  	SIN_ADDR(rt.rt_genmask) = 0L;
      }
  
diff --git a/package/network/services/ppp/patches/400-simplify_kernel_checks.patch b/package/network/services/ppp/patches/400-simplify_kernel_checks.patch
index 3c720483..311bb875 100644
--- a/package/network/services/ppp/patches/400-simplify_kernel_checks.patch
+++ b/package/network/services/ppp/patches/400-simplify_kernel_checks.patch
@@ -10,7 +10,14 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
 --- a/pppd/sys-linux.c
 +++ b/pppd/sys-linux.c
-@@ -206,7 +206,7 @@ static int driver_is_old       = 0;
+@@ -224,14 +224,10 @@ static fd_set in_fds;		/* set of fds tha
+ static int max_in_fd;		/* highest fd set in in_fds */
+ 
+ static int has_proxy_arp       = 0;
+-static int driver_version      = 0;
+-static int driver_modification = 0;
+-static int driver_patch        = 0;
+-static int driver_is_old       = 0;
  static int restore_term        = 0;	/* 1 => we've munged the terminal */
  static struct termios inittermios;	/* Initial TTY termios */
  
@@ -19,17 +26,18 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
  
  static char loop_name[20];
  static unsigned char inbuf[512]; /* buffer for chars read from loopback */
-@@ -225,8 +225,8 @@ static int	looped;			/* 1 if using loop
+@@ -249,9 +245,8 @@ static int	dynaddr_set;		/* 1 if ip_dyna
+ static int	looped;			/* 1 if using loop */
  static int	link_mtu;		/* mtu for the link (not bundle) */
  
- static struct utsname utsname;	/* for the kernel version */
+-static struct utsname utsname;	/* for the kernel version */
 -static int kernel_version;
  #define KVERSION(j,n,p)	((j)*1000000 + (n)*1000 + (p))
-+static const int kernel_version = KVERSION(2,6,37);
++static const int kernel_version = KVERSION(4,9,0);
  
  #define MAX_IFS		100
  
-@@ -1455,11 +1455,12 @@ int ccp_fatal_error (int unit)
+@@ -1970,11 +1965,12 @@ int ccp_fatal_error (int unit)
   *
   * path_to_procfs - find the path to the proc file system mount point
   */
@@ -44,7 +52,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      struct mntent *mntent;
      FILE *fp;
  
-@@ -1481,6 +1482,7 @@ static char *path_to_procfs(const char *
+@@ -1996,6 +1992,7 @@ static char *path_to_procfs(const char *
  	    fclose (fp);
  	}
      }
@@ -52,35 +60,24 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
  
      strlcpy(proc_path + proc_path_len, tail,
  	    sizeof(proc_path) - proc_path_len);
-@@ -2365,15 +2367,19 @@ int ppp_available(void)
-     int    my_version, my_modification, my_patch;
-     int osmaj, osmin, ospatch;
+@@ -2889,6 +2886,8 @@ ppp_registered(void)
  
+ int ppp_check_kernel_support(void)
+ {
++    return 1; /* OpenWrt support ppp device "/dev/ppp" by default */
 +#if 0
-     /* get the kernel version now, since we are called before sys_init */
-     uname(&utsname);
-     osmaj = osmin = ospatch = 0;
-     sscanf(utsname.release, "%d.%d.%d", &osmaj, &osmin, &ospatch);
-     kernel_version = KVERSION(osmaj, osmin, ospatch);
-+#endif
- 
-     fd = open("/dev/ppp", O_RDWR);
-     if (fd >= 0) {
-+#if 0
- 	new_style_driver = 1;
+     int s, ok, fd;
+     struct ifreq ifr;
+     int    size;
+@@ -3016,6 +3015,7 @@ int ppp_check_kernel_support(void)
+     }
+     close(s);
+     return ok;
 +#endif
+ }
  
- 	/* XXX should get from driver */
- 	driver_version = 2;
-@@ -2433,6 +2439,7 @@ int ppp_available(void)
- 
-     if (ok && ((ifr.ifr_hwaddr.sa_family & ~0xFF) != ARPHRD_PPP))
- 	ok = 0;
-+	return ok;
- 
- /*
-  *  This is the PPP device. Validate the version of the driver at this
-@@ -3106,6 +3113,7 @@ get_pty(int *master_fdp, int *slave_fdp,
+ #ifndef HAVE_LOGWTMP
+@@ -3577,6 +3577,7 @@ get_pty(int *master_fdp, int *slave_fdp,
      }
  #endif /* TIOCGPTN */
  
@@ -88,7 +85,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      if (sfd < 0) {
  	/* the old way - scan through the pty name space */
  	for (i = 0; i < 64; ++i) {
-@@ -3124,6 +3132,7 @@ get_pty(int *master_fdp, int *slave_fdp,
+@@ -3601,6 +3602,7 @@ get_pty(int *master_fdp, int *slave_fdp,
  	    }
  	}
      }
@@ -96,28 +93,40 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
  
      if (sfd < 0)
  	return 0;
+@@ -3716,6 +3718,7 @@ get_host_seed(void)
+ int
+ sys_check_options(void)
+ {
++#if 0
+     if (demand && driver_is_old) {
+ 	ppp_option_error("demand dialling is not supported by kernel driver "
+ 		     "version %d.%d.%d", driver_version, driver_modification,
+@@ -3726,6 +3729,7 @@ sys_check_options(void)
+ 	warn("Warning: multilink is not supported by the kernel driver");
+ 	multilink = 0;
+     }
++#endif
+     return 1;
+ }
+ 
 --- a/pppd/plugins/pppoatm/pppoatm.c
 +++ b/pppd/plugins/pppoatm/pppoatm.c
-@@ -171,14 +171,6 @@ static void disconnect_pppoatm(void)
- 
+@@ -180,10 +180,6 @@ static void disconnect_pppoatm(void)
  void plugin_init(void)
  {
--#ifdef linux
+ #ifdef linux
 -	extern int new_style_driver;	/* From sys-linux.c */
--	if (!ppp_available() && !new_style_driver)
+-	if (!ppp_check_kernel_support() && !new_style_driver)
 -		fatal("Kernel doesn't support ppp_generic - "
 -		    "needed for PPPoATM");
--#else
--	fatal("No PPPoATM support on this OS");
--#endif
- 	add_options(pppoa_options);
- }
- 
+ #else
+ 	fatal("No PPPoATM support on this OS");
+ #endif
 --- a/pppd/plugins/pppoe/plugin.c
 +++ b/pppd/plugins/pppoe/plugin.c
-@@ -58,9 +58,6 @@ static char const RCSID[] =
+@@ -57,9 +57,6 @@ static char const RCSID[] =
  
- char pppd_version[] = VERSION;
+ char pppd_version[] = PPPD_VERSION;
  
 -/* From sys-linux.c in pppd -- MUST FIX THIS! */
 -extern int new_style_driver;
@@ -125,30 +134,27 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
  char *pppd_pppoe_service = NULL;
  static char *acName = NULL;
  static char *existingSession = NULL;
-@@ -407,10 +404,6 @@ PPPoEDevnameHook(char *cmd, char **argv,
+@@ -421,10 +418,6 @@ PPPoEDevnameHook(char *cmd, char **argv,
  void
  plugin_init(void)
  {
--    if (!ppp_available() && !new_style_driver) {
+-    if (!ppp_check_kernel_support() && !new_style_driver) {
 -	fatal("Linux kernel does not support PPPoE -- are you running 2.4.x?");
 -    }
 -
-     add_options(Options);
+     ppp_add_options(Options);
  
-     info("PPPoE plugin from pppd %s", VERSION);
+     info("PPPoE plugin from pppd %s", PPPD_VERSION);
 --- a/pppd/plugins/pppol2tp/pppol2tp.c
 +++ b/pppd/plugins/pppol2tp/pppol2tp.c
-@@ -490,12 +490,7 @@ static void pppol2tp_cleanup(void)
- 
+@@ -501,10 +501,6 @@ static void pppol2tp_cleanup(void)
  void plugin_init(void)
  {
--#if defined(__linux__)
+ #if defined(__linux__)
 -	extern int new_style_driver;	/* From sys-linux.c */
--	if (!ppp_available() && !new_style_driver)
+-	if (!ppp_check_kernel_support() && !new_style_driver)
 -		fatal("Kernel doesn't support ppp_generic - "
 -		    "needed for PPPoL2TP");
--#else
-+#if !defined(__linux__)
+ #else
  	fatal("No PPPoL2TP support on this OS");
  #endif
- 	add_options(pppol2tp_options);
diff --git a/package/network/services/ppp/patches/401-no_record_file.patch b/package/network/services/ppp/patches/401-no_record_file.patch
index 78442606..5ef1a178 100644
--- a/package/network/services/ppp/patches/401-no_record_file.patch
+++ b/package/network/services/ppp/patches/401-no_record_file.patch
@@ -5,19 +5,19 @@ information to the permanent storage, therfore remove this option.
 
 Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
---- a/pppd/pppd.h
-+++ b/pppd/pppd.h
-@@ -317,7 +317,6 @@ extern int	holdoff;	/* Dead time before
+--- a/pppd/pppd-private.h
++++ b/pppd/pppd-private.h
+@@ -187,7 +187,6 @@ extern int	holdoff;	/* Dead time before
  extern bool	holdoff_specified; /* true if user gave a holdoff value */
  extern bool	notty;		/* Stdin/out is not a tty */
  extern char	*pty_socket;	/* Socket to connect to pty */
 -extern char	*record_file;	/* File to record chars sent/received */
- extern bool	sync_serial;	/* Device is synchronous serial device */
  extern int	maxfail;	/* Max # of unsuccessful connection attempts */
- extern char	linkname[MAXPATHLEN]; /* logical name for link */
+ extern char	linkname[];	/* logical name for link */
+ extern bool	tune_kernel;	/* May alter kernel settings as necessary */
 --- a/pppd/tty.c
 +++ b/pppd/tty.c
-@@ -143,7 +143,7 @@ char	*disconnect_script = NULL; /* Scrip
+@@ -150,7 +150,7 @@ char	*disconnect_script = NULL; /* Scrip
  char	*welcomer = NULL;	/* Script to run after phys link estab. */
  char	*ptycommand = NULL;	/* Command to run on other side of pty */
  bool	notty = 0;		/* Stdin/out is not a tty */
@@ -26,7 +26,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
  int	max_data_rate;		/* max bytes/sec through charshunt */
  bool	sync_serial = 0;	/* Device is synchronous serial device */
  char	*pty_socket = NULL;	/* Socket to connect to pty */
-@@ -199,8 +199,10 @@ option_t tty_options[] = {
+@@ -206,8 +206,10 @@ static struct option tty_options[] = {
        "Send and receive over socket, arg is host:port",
        OPT_PRIO | OPT_DEVNAM },
  
diff --git a/package/network/services/ppp/patches/403-no_wtmp.patch b/package/network/services/ppp/patches/403-no_wtmp.patch
deleted file mode 100644
index 772620ed..00000000
--- a/package/network/services/ppp/patches/403-no_wtmp.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-pppd: Disable wtmp support
-
-Many uClibc based environments lack wtmp and utmp support, therfore remove
-the code updating the wtmp information.
-
-Signed-off-by: Jo-Philipp Wich <jo@mein.io>
-
---- a/pppd/sys-linux.c
-+++ b/pppd/sys-linux.c
-@@ -2503,6 +2503,7 @@ int ppp_available(void)
- 
- void logwtmp (const char *line, const char *name, const char *host)
- {
-+#if 0
-     struct utmp ut, *utp;
-     pid_t  mypid = getpid();
- #if __GLIBC__ < 2
-@@ -2568,6 +2569,7 @@ void logwtmp (const char *line, const ch
- 	close (wtmp);
-     }
- #endif
-+#endif
- }
- #endif /* HAVE_LOGWTMP */
- 
diff --git a/package/network/services/ppp/patches/404-remove_obsolete_protocol_names.patch b/package/network/services/ppp/patches/404-remove_obsolete_protocol_names.patch
index b9b6f0e5..6b2d15ed 100644
--- a/package/network/services/ppp/patches/404-remove_obsolete_protocol_names.patch
+++ b/package/network/services/ppp/patches/404-remove_obsolete_protocol_names.patch
@@ -7,7 +7,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
 --- a/pppd/main.c
 +++ b/pppd/main.c
-@@ -866,14 +866,17 @@ struct protocol_list {
+@@ -984,14 +984,17 @@ struct protocol_list {
      const char	*name;
  } protocol_list[] = {
      { 0x21,	"IP" },
@@ -25,7 +25,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      { 0x33,	"Stream Protocol ST-II" },
      { 0x35,	"Banyan Vines" },
      { 0x39,	"AppleTalk EDDP" },
-@@ -887,8 +890,11 @@ struct protocol_list {
+@@ -1005,8 +1008,11 @@ struct protocol_list {
      { 0x49,	"Serial Data Transport Protocol (PPP-SDTP)" },
      { 0x4b,	"SNA over 802.2" },
      { 0x4d,	"SNA" },
@@ -37,7 +37,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      { 0x53,	"Encryption" },
      { 0x55,	"Individual Link Encryption" },
      { 0x57,	"IPv6" },
-@@ -899,12 +905,15 @@ struct protocol_list {
+@@ -1017,12 +1023,15 @@ struct protocol_list {
      { 0x65,	"RTP IPHC Compressed non-TCP" },
      { 0x67,	"RTP IPHC Compressed UDP 8" },
      { 0x69,	"RTP IPHC Compressed RTP 8" },
@@ -53,7 +53,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      { 0x0203,	"IBM Source Routing BPDU" },
      { 0x0205,	"DEC LANBridge100 Spanning Tree" },
      { 0x0207,	"Cisco Discovery Protocol" },
-@@ -916,15 +925,19 @@ struct protocol_list {
+@@ -1034,15 +1043,19 @@ struct protocol_list {
      { 0x0231,	"Luxcom" },
      { 0x0233,	"Sigma Network Systems" },
      { 0x0235,	"Apple Client Server Protocol" },
@@ -73,7 +73,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      { 0x4001,	"Cray Communications Control Protocol" },
      { 0x4003,	"CDPD Mobile Network Registration Protocol" },
      { 0x4005,	"Expand accelerator protocol" },
-@@ -935,8 +948,10 @@ struct protocol_list {
+@@ -1053,8 +1066,10 @@ struct protocol_list {
      { 0x4023,	"RefTek Protocol" },
      { 0x4025,	"Fibre Channel" },
      { 0x4027,	"EMIT Protocols" },
@@ -84,7 +84,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      { 0x8023,	"OSI Network Layer Control Protocol" },
      { 0x8025,	"Xerox NS IDP Control Protocol" },
      { 0x8027,	"DECnet Phase IV Control Protocol" },
-@@ -945,7 +960,9 @@ struct protocol_list {
+@@ -1063,7 +1078,9 @@ struct protocol_list {
      { 0x8031,	"Bridging NCP" },
      { 0x8033,	"Stream Protocol Control Protocol" },
      { 0x8035,	"Banyan Vines Control Protocol" },
@@ -94,7 +94,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      { 0x803f,	"NETBIOS Framing Control Protocol" },
      { 0x8041,	"Cisco Systems Control Protocol" },
      { 0x8043,	"Ascom Timeplex" },
-@@ -954,18 +971,24 @@ struct protocol_list {
+@@ -1072,18 +1089,24 @@ struct protocol_list {
      { 0x8049,	"Serial Data Control Protocol (PPP-SDCP)" },
      { 0x804b,	"SNA over 802.2 Control Protocol" },
      { 0x804d,	"SNA Control Protocol" },
@@ -119,7 +119,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
      { 0x8207,	"Cisco Discovery Protocol Control" },
      { 0x8209,	"Netcs Twin Routing" },
      { 0x820b,	"STP - Control Protocol" },
-@@ -974,24 +997,29 @@ struct protocol_list {
+@@ -1092,24 +1115,29 @@ struct protocol_list {
      { 0x8281,	"MPLSCP" },
      { 0x8285,	"IEEE p1284.4 standard - Protocol Control" },
      { 0x8287,	"ETSI TETRA TNP1 Control Protocol" },
diff --git a/package/network/services/ppp/patches/405-no_multilink_option.patch b/package/network/services/ppp/patches/405-no_multilink_option.patch
index a34ec57b..654bebd5 100644
--- a/package/network/services/ppp/patches/405-no_multilink_option.patch
+++ b/package/network/services/ppp/patches/405-no_multilink_option.patch
@@ -9,7 +9,7 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
 
 --- a/pppd/options.c
 +++ b/pppd/options.c
-@@ -348,13 +348,14 @@ option_t general_options[] = {
+@@ -379,13 +379,14 @@ struct option general_options[] = {
        "Enable multilink operation", OPT_PRIOSUB | OPT_ALIAS | 1 },
      { "nomultilink", o_bool, &multilink,
        "Disable multilink operation", OPT_PRIOSUB | 0 },
@@ -18,11 +18,11 @@ Signed-off-by: Jo-Philipp Wich <jo@mein.io>
  
      { "bundle", o_string, &bundle_name,
        "Bundle name for multilink", OPT_PRIO },
- #endif /* HAVE_MULTILINK */
+ #endif /* PPP_WITH_MULTILINK */
  
 +    { "nomp", o_bool, &multilink,
 +      "Disable multilink operation", OPT_PRIOSUB | OPT_ALIAS | 0 },
 +
- #ifdef PLUGIN
+ #ifdef PPP_WITH_PLUGINS
      { "plugin", o_special, (void *)loadplugin,
        "Load a plug-in module into pppd", OPT_PRIV | OPT_A2LIST },
diff --git a/package/network/services/ppp/patches/500-add-pptp-plugin.patch b/package/network/services/ppp/patches/500-add-pptp-plugin.patch
index 96f4bcaf..4b66cd21 100644
--- a/package/network/services/ppp/patches/500-add-pptp-plugin.patch
+++ b/package/network/services/ppp/patches/500-add-pptp-plugin.patch
@@ -1,59 +1,43 @@
---- a/configure
-+++ b/configure
-@@ -133,7 +133,7 @@ if [ -d "$ksrc" ]; then
-     mkmkf $ksrc/Makedefs$compiletype Makedefs.com
-     for dir in pppd pppstats chat pppdump pppd/plugins pppd/plugins/pppoe \
- 	       pppd/plugins/radius pppd/plugins/pppoatm \
--	       pppd/plugins/pppol2tp; do
-+	       pppd/plugins/pppol2tp pppd/plugins/pptp ; do
- 	mkmkf $dir/Makefile.$makext $dir/Makefile
-     done
-     if [ -f $ksrc/Makefile.$makext$archvariant ]; then
---- a/pppd/plugins/Makefile.linux
-+++ b/pppd/plugins/Makefile.linux
-@@ -14,7 +14,7 @@ INSTALL	= install
- # EAP-TLS
- CFLAGS += -DUSE_EAPTLS=1
+--- a/configure.ac
++++ b/configure.ac
+@@ -344,6 +344,7 @@ AC_CONFIG_FILES([
+     pppd/plugins/pppoatm/Makefile
+     pppd/plugins/pppol2tp/Makefile
+     pppd/plugins/radius/Makefile
++    pppd/plugins/pptp/Makefile
+     pppdump/Makefile
+     pppstats/Makefile
+     scripts/Makefile
+--- a/pppd/plugins/Makefile.am
++++ b/pppd/plugins/Makefile.am
+@@ -21,5 +21,5 @@ winbind_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+ winbind_la_SOURCES = winbind.c
  
--SUBDIRS := pppoe pppoatm pppol2tp
-+SUBDIRS := pppoe pppoatm pppol2tp pptp
- # Uncomment the next line to include the radius authentication plugin
- SUBDIRS += radius
- PLUGINS := minconn.so passprompt.so passwordfd.so winbind.so
+ if !SUNOS
+-SUBDIRS = pppoe pppoatm pppol2tp radius
++SUBDIRS = pppoe pppoatm pppol2tp radius pptp
+ endif
 --- /dev/null
-+++ b/pppd/plugins/pptp/Makefile.linux
-@@ -0,0 +1,31 @@
-+#
-+# This program may be distributed according to the terms of the GNU
-+# General Public License, version 2 or (at your option) any later version.
-+#
-+# $Id: Makefile.linux,v 1.9 2012/05/04 21:48:00 dgolle Exp $
-+#***********************************************************************
-+
-+DESTDIR = $(INSTROOT)@DESTDIR@
-+LIBDIR = $(DESTDIR)/lib/pppd/$(PPPDVERSION)
-+
-+PPPDVERSION = $(shell awk -F '"' '/VERSION/ { print $$2; }' ../../patchlevel.h)
-+
-+INSTALL	= install
-+
-+COPTS=-O2 -g
-+CFLAGS  = $(COPTS) -I. -I../.. -I../../../include -fPIC -DPPPD_VERSION=\"$(PPPDVERSION)\"
-+all: pptp.so
-+
-+%.o: %.c
-+	$(CC) $(CFLAGS) -c -o $@ $<
-+
-+pptp.so: dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
-+	$(CC) -o pptp.so -shared dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
-+
-+install: all
-+	$(INSTALL) -d -m 755 $(LIBDIR)
-+	$(INSTALL) -c -m 4550 pptp.so $(LIBDIR)
-+
-+clean:
-+	rm -f *.o *.so
-+
++++ b/pppd/plugins/pptp/Makefile.am
+@@ -0,0 +1,18 @@
++pppd_plugin_LTLIBRARIES = pptp.la
++pppd_plugindir = $(PPPD_PLUGIN_DIR)
++
++noinst_HEADERS = \
++    dirutil.h \
++    orckit_quirks.h \
++    pptp_callmgr.h \
++    pptp_ctrl.h \
++    pptp_msg.h \
++    pptp_options.h \
++    pptp_quirks.h \
++    util.h \
++    vector.h
++
++pptp_la_CPPFLAGS = -I${top_srcdir} -DSYSCONFDIR=\"${sysconfdir}\" -DPLUGIN
++pptp_la_LDFLAGS = -fPIC -module -avoid-version
++pptp_la_SOURCES = dirutil.c orckit_quirks.c pptp.c pptp_callmgr.c pptp_ctrl.c \
++    pptp_quirks.c util.c vector.c
 --- /dev/null
 +++ b/pppd/plugins/pptp/dirutil.c
 @@ -0,0 +1,68 @@
@@ -334,7 +318,7 @@
 +xeb xeb@mail.ru
 --- /dev/null
 +++ b/pppd/plugins/pptp/pptp.c
-@@ -0,0 +1,323 @@
+@@ -0,0 +1,325 @@
 +/***************************************************************************
 + *   Copyright (C) 2006 by Kozlov D. <xeb@mail.ru>                         *
 + *   some cleanup done (C) 2012 by Daniel Golle <dgolle@allnet.de>         *
@@ -377,6 +361,8 @@
 +#include <sys/ioctl.h>
 +
 +#include "pppd.h"
++#include "pppd-private.h"
++#include "options.h"
 +#include "fsm.h"
 +#include "lcp.h"
 +#include "ipcp.h"
@@ -385,7 +371,7 @@
 +
 +#include "pptp_callmgr.h"
 +#include <net/if.h>
-+#include <net/ethernet.h>
++#include <linux/if_ether.h>
 +#include <linux/if_pppox.h>
 +
 +#include <stdio.h>
@@ -437,8 +423,8 @@
 +    check_options: NULL,
 +    connect: &pptp_connect,
 +    disconnect: &pptp_disconnect,
-+    establish_ppp: &generic_establish_ppp,
-+    disestablish_ppp: &generic_disestablish_ppp,
++    establish_ppp: &ppp_generic_establish,
++    disestablish_ppp: &ppp_generic_disestablish,
 +    close: NULL,
 +    cleanup: NULL
 +};
@@ -446,7 +432,7 @@
 +static int pptp_start_server(void)
 +{
 +	pptp_fd=pptp_sock;
-+	sprintf(ppp_devnam,"pptp (%s)",pptp_client);
++	sprintf(ppp_devname,"pptp (%s)",pptp_client);
 +
 +	return pptp_fd;
 +}
@@ -527,7 +513,7 @@
 +		return -1;
 +	}
 +
-+	sprintf(ppp_devnam,"pptp (%s)",pptp_server);
++	sprintf(ppp_devname,"pptp (%s)",pptp_server);
 +
 +	return pptp_fd;
 +}
@@ -651,7 +637,7 @@
 +
 +void plugin_init(void)
 +{
-+    add_options(Options);
++    ppp_add_options(Options);
 +
 +    info("PPTP plugin version %s", PPTP_VERSION);
 +
diff --git a/package/network/services/ppp/patches/510-pptp_compile_fix.patch b/package/network/services/ppp/patches/510-pptp_compile_fix.patch
deleted file mode 100644
index 04bb620e..00000000
--- a/package/network/services/ppp/patches/510-pptp_compile_fix.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/pppd/plugins/pptp/pptp.c
-+++ b/pppd/plugins/pptp/pptp.c
-@@ -48,7 +48,7 @@
- 
- #include "pptp_callmgr.h"
- #include <net/if.h>
--#include <net/ethernet.h>
-+#include <linux/if_ether.h>
- #include <linux/if_pppox.h>
- 
- #include <stdio.h>
diff --git a/package/network/services/ppp/patches/511-pptp_cflags.patch b/package/network/services/ppp/patches/511-pptp_cflags.patch
deleted file mode 100644
index 548bf41c..00000000
--- a/package/network/services/ppp/patches/511-pptp_cflags.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/pppd/plugins/pptp/Makefile.linux
-+++ b/pppd/plugins/pptp/Makefile.linux
-@@ -20,7 +20,7 @@ all: pptp.so
- 	$(CC) $(CFLAGS) -c -o $@ $<
- 
- pptp.so: dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
--	$(CC) -o pptp.so -shared dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
-+	$(CC) -fPIC -o pptp.so -shared dirutil.o orckit_quirks.o pptp.o pptp_callmgr.o pptp_ctrl.o pptp_quirks.o util.o vector.o
- 
- install: all
- 	$(INSTALL) -d -m 755 $(LIBDIR)
diff --git a/package/network/services/ppp/patches/512-syncppp.patch b/package/network/services/ppp/patches/512-syncppp.patch
deleted file mode 100644
index 39ff5200..00000000
--- a/package/network/services/ppp/patches/512-syncppp.patch
+++ /dev/null
@@ -1,204 +0,0 @@
---- a/pppd/chap-new.c
-+++ b/pppd/chap-new.c
-@@ -37,6 +37,8 @@
- #include "chap-new.h"
- #include "chap-md5.h"
- 
-+#include "syncppp.h"
-+
- #ifdef CHAPMS
- #include "chap_ms.h"
- #define MDTYPE_ALL (MDTYPE_MICROSOFT_V2 | MDTYPE_MICROSOFT | MDTYPE_MD5)
-@@ -523,6 +525,18 @@ chap_respond(struct chap_client_state *cs, int id,
- 	p[2] = len >> 8;
- 	p[3] = len;
- 
-+	if (npppd > 1) {
-+		if (syncppp(npppd) < 0) {
-+			error("syncppp sync fail");
-+			sem_unlink(SEM_COUNT_NAME);
-+			sem_unlink(SEM_BLOCK_NAME);
-+		} else {
-+			info("syncppp sync succeeded");
-+		}
-+	} else {
-+		info("syncppp not active");
-+	}
-+
- 	output(0, response, PPP_HDRLEN + len);
- }
- 
---- a/pppd/Makefile.linux
-+++ b/pppd/Makefile.linux
-@@ -17,16 +17,16 @@ TARGETS = pppd
- 
- PPPDSRCS = main.c magic.c fsm.c lcp.c ipcp.c upap.c chap-new.c md5.c ccp.c \
- 	   ecp.c ipxcp.c auth.c options.c sys-linux.c md4.c chap_ms.c \
--	   demand.c utils.c tty.c eap.c chap-md5.c session.c
-+	   demand.c utils.c tty.c eap.c chap-md5.c session.c syncppp.c
- 
- HEADERS = ccp.h session.h chap-new.h ecp.h fsm.h ipcp.h \
- 	ipxcp.h lcp.h magic.h md5.h patchlevel.h pathnames.h pppd.h \
--	upap.h eap.h
-+	upap.h eap.h syncppp.h
- 
- MANPAGES = pppd.8
- PPPDOBJS = main.o magic.o fsm.o lcp.o ipcp.o upap.o chap-new.o md5.o ccp.o \
- 	   ecp.o auth.o options.o demand.o utils.o sys-linux.o ipxcp.o tty.o \
--	   eap.o chap-md5.o session.o
-+	   eap.o chap-md5.o session.o syncppp.o
- 
- #
- # include dependencies if present
-@@ -34,7 +34,7 @@ ifeq (.depend,$(wildcard .depend))
- include .depend
- endif
- 
--LIBS = -lrt
-+LIBS = -lpthread
- 
- # Uncomment the next line to include support for Microsoft's
- # MS-CHAP authentication protocol.  Also, edit plugins/radius/Makefile.linux.
---- a/pppd/options.c
-+++ b/pppd/options.c
-@@ -127,6 +127,7 @@ bool	dump_options;		/* print out option values */
- bool	dryrun;			/* print out option values and exit */
- char	*domain;		/* domain name set by domain option */
- int	child_wait = 5;		/* # seconds to wait for children at exit */
-+int	npppd = 0;		/* synchronize between multiple pppd */
- struct userenv *userenv_list;	/* user environment variables */
- int	dfl_route_metric = -1;	/* metric of the default route to set over the PPP link */
- 
-@@ -323,6 +324,9 @@ option_t general_options[] = {
-       "Unset user environment variable",
-       OPT_A2PRINTER | OPT_NOPRINT, (void *)user_unsetprint },
- 
-+    { "syncppp", o_int, &npppd,
-+      "sync among multiple pppd when sending chap/pap respond", OPT_PRIO },
-+
-     { "defaultroute-metric", o_int, &dfl_route_metric,
-       "Metric to use for the default route (Linux only; -1 for default behavior)",
-       OPT_PRIV|OPT_LLIMIT|OPT_INITONLY, NULL, 0, -1 },
---- a/pppd/pppd.h
-+++ b/pppd/pppd.h
-@@ -335,6 +335,7 @@ extern char	*bundle_name;	/* bundle name for multilink */
- extern bool	dump_options;	/* print out option values */
- extern bool	dryrun;		/* check everything, print options, exit */
- extern int	child_wait;	/* # seconds to wait for children at end */
-+extern int	npppd;		/* synchronize between multiple pppd */
- 
- #ifdef USE_EAPTLS
- extern char	*crl_dir;
---- /dev/null
-+++ b/pppd/syncppp.c
-@@ -0,0 +1,75 @@
-+#include<stdio.h>
-+#include<semaphore.h>
-+#include<fcntl.h>
-+#include<stdlib.h>
-+#include<time.h>
-+#include<errno.h>
-+#include "pppd.h"
-+#include "syncppp.h"
-+
-+int syncppp(int nproc)
-+{
-+    int flags;
-+    int value;
-+    sem_t *block; 
-+    sem_t *count;
-+    struct timespec ts;
-+
-+    if (nproc <= 1) {
-+        error("syncppp: number of pppd should be larger than 1");
-+        return -1;
-+    }
-+
-+    if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {
-+        error("clock_gettime error");
-+        return -1;
-+    }
-+    ts.tv_sec += SYNCPPP_TIMEOUT;
-+
-+
-+    flags = O_RDWR | O_CREAT;
-+    block = sem_open(SEM_BLOCK_NAME, flags, 0644, 0);
-+    count = sem_open(SEM_COUNT_NAME, flags, 0644, 0);
-+    if (block == SEM_FAILED || count == SEM_FAILED) {
-+        error("syncppp: sem_open failed");
-+        return -1;
-+    }
-+
-+    if (sem_post(count) < 0) {
-+        error("syncppp: sem_post failed");
-+        return -1;
-+    }
-+    if (sem_getvalue(count, &value) < 0) {
-+        error("syncppp: sem_getvalue failed");
-+        return -1;
-+    }
-+    info("%d pppd have arrived, waiting for the left %d", value, nproc-value);
-+    if (value >= nproc) {
-+        while (nproc-1 > 0) {
-+            if (sem_post(block) < 0) {
-+                error("syncppp: sem_post failed");
-+                return -1;
-+            }
-+            nproc--;
-+        }
-+    } else {
-+        if (sem_timedwait(block, &ts) < 0) {
-+            if (errno == ETIMEDOUT) {
-+                error("syncppp: sem_timewait time out");
-+            } else {
-+                error("syncppp: sem_timewait error");
-+            }
-+            return -1;
-+        }
-+
-+    }
-+
-+    sem_close(count);
-+    sem_close(block);
-+
-+    sem_unlink(SEM_COUNT_NAME);
-+    sem_unlink(SEM_BLOCK_NAME);
-+
-+    return 0;
-+}
-+
---- /dev/null
-+++ b/pppd/syncppp.h
-@@ -0,0 +1,3 @@
-+#define SEM_BLOCK_NAME  "block"
-+#define SEM_COUNT_NAME  "count"
-+#define SYNCPPP_TIMEOUT 5
---- a/pppd/upap.c
-+++ b/pppd/upap.c
-@@ -50,6 +50,7 @@
- #include "pppd.h"
- #include "upap.h"
- 
-+#include "syncppp.h"
- 
- static bool hide_password = 1;
- 
-@@ -540,6 +541,18 @@ upap_sauthreq(upap_state *u)
-     PUTCHAR(u->us_passwdlen, outp);
-     BCOPY(u->us_passwd, outp, u->us_passwdlen);
- 
-+    if (npppd > 1) {
-+        if (syncppp(npppd) < 0) {
-+            error("syncppp sync fail");
-+            sem_unlink(SEM_COUNT_NAME);
-+            sem_unlink(SEM_BLOCK_NAME);
-+        } else {
-+            info("syncppp sync succeeded");
-+        }
-+    } else {
-+        info("syncppp not active");
-+    }
-+
-     output(u->us_unit, outpacket_buf, outlen + PPP_HDRLEN);
- 
-     TIMEOUT(upap_timeout, u, u->us_timeouttime);
diff --git a/package/network/services/ppp/patches/600-Revert-pppd-Use-openssl-for-the-DES-instead-of-the-l.patch b/package/network/services/ppp/patches/600-Revert-pppd-Use-openssl-for-the-DES-instead-of-the-l.patch
deleted file mode 100644
index a3042af5..00000000
--- a/package/network/services/ppp/patches/600-Revert-pppd-Use-openssl-for-the-DES-instead-of-the-l.patch
+++ /dev/null
@@ -1,89 +0,0 @@
-From 831dca008699d485f2c8e91749657ef2d0b06166 Mon Sep 17 00:00:00 2001
-From: Martin Schiller <ms@dev.tdt.de>
-Date: Thu, 6 Dec 2018 08:43:17 +0100
-Subject: [PATCH] Revert "pppd: Use openssl for the DES instead of the libcrypt
- / glibc"
-
-For musl and glibc2.27 we can keep linking to crypt; however if we
-switch to glibc 2.28 we will have to link to one of the SSL libraries.
-
-This reverts commit 3c7b86229f7bd2600d74db14b1fe5b3896be3875.
----
- pppd/Makefile.linux |  7 +++----
- pppd/pppcrypt.c     | 18 +++++++++---------
- 2 files changed, 12 insertions(+), 13 deletions(-)
-
---- a/pppd/Makefile.linux
-+++ b/pppd/Makefile.linux
-@@ -36,10 +36,10 @@ endif
- 
- LIBS = -lpthread
- 
--# Uncomment the next line to include support for Microsoft's
-+# Uncomment the next 2 lines to include support for Microsoft's
- # MS-CHAP authentication protocol.  Also, edit plugins/radius/Makefile.linux.
- CHAPMS=y
--#USE_CRYPT=y
-+USE_CRYPT=y
- # Don't use MSLANMAN unless you really know what you're doing.
- #MSLANMAN=y
- # Uncomment the next line to include support for MPPE.  CHAPMS (above) must
-@@ -158,8 +158,7 @@ endif
- 
- ifdef NEEDDES
- ifndef USE_CRYPT
--CFLAGS   += -I$(shell $(CC) --print-sysroot)/usr/include/openssl
--NEEDCRYPTOLIB = y
-+LIBS     += -ldes $(LIBS)
- else
- CFLAGS   += -DUSE_CRYPT=1
- endif
---- a/pppd/pppcrypt.c
-+++ b/pppd/pppcrypt.c
-@@ -62,7 +62,7 @@ MakeKey(u_char *key, u_char *des_key)
- 	des_key[7] = Get7Bits(key, 49);
- 
- #ifndef USE_CRYPT
--	DES_set_odd_parity((DES_cblock *)des_key);
-+	des_set_odd_parity((des_cblock *)des_key);
- #endif
- }
- 
-@@ -147,30 +147,30 @@ DesDecrypt(u_char *cipher, u_char *clear
- }
- 
- #else /* USE_CRYPT */
--static DES_key_schedule	key_schedule;
-+static des_key_schedule	key_schedule;
- 
- bool
- DesSetkey(u_char *key)
- {
--	DES_cblock des_key;
-+	des_cblock des_key;
- 	MakeKey(key, des_key);
--	DES_set_key(&des_key, &key_schedule);
-+	des_set_key(&des_key, key_schedule);
- 	return (1);
- }
- 
- bool
- DesEncrypt(u_char *clear, u_char *cipher)
- {
--	DES_ecb_encrypt((DES_cblock *)clear, (DES_cblock *)cipher,
--	    &key_schedule, 1);
-+	des_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher,
-+	    key_schedule, 1);
- 	return (1);
- }
- 
- bool
- DesDecrypt(u_char *cipher, u_char *clear)
- {
--	DES_ecb_encrypt((DES_cblock *)cipher, (DES_cblock *)clear,
--	    &key_schedule, 0);
-+	des_ecb_encrypt((des_cblock *)cipher, (des_cblock *)clear,
-+	    key_schedule, 0);
- 	return (1);
- }
- 
diff --git a/package/network/services/ppp/patches/610-pppd_compile_fix.patch b/package/network/services/ppp/patches/610-pppd_compile_fix.patch
deleted file mode 100644
index 4f66e5d7..00000000
--- a/package/network/services/ppp/patches/610-pppd_compile_fix.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/pppd/Makefile.linux
-+++ b/pppd/Makefile.linux
-@@ -49,7 +49,8 @@ MPPE=y
- # Uncomment the next line to include support for PPP packet filtering.
- # This requires that the libpcap library and headers be installed
- # and that the kernel driver support PPP packet filtering.
--#FILTER=y
-+# libpcap statically linked in OpenWRT, hence disabled here.
-+FILTER=
- 
- # Support for precompiled filters
- PRECOMPILED_FILTER=y
diff --git a/package/network/utils/iproute2/Makefile b/package/network/utils/iproute2/Makefile
index 302d57bf..04a4df24 100644
--- a/package/network/utils/iproute2/Makefile
+++ b/package/network/utils/iproute2/Makefile
@@ -8,17 +8,19 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=iproute2
-PKG_VERSION:=6.2.0
+PKG_VERSION:=6.11.0
 PKG_RELEASE:=1
 
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.xz
 PKG_SOURCE_URL:=@KERNEL/linux/utils/net/iproute2
-PKG_HASH:=4d72730200ec5b2aabaa1a2f20553c6748292f065d9a154c7d5e22559df9fd62
+PKG_HASH:=1f795398a04aeaacd06a8f6ace2cfd913c33fa5953ca99daae83bb5c534611c3
 PKG_BUILD_PARALLEL:=1
 PKG_BUILD_DEPENDS:=iptables
 PKG_LICENSE:=GPL-2.0
 PKG_CPE_ID:=cpe:/a:iproute2_project:iproute2
 
+PKG_BUILD_FLAGS:=gc-sections lto
+
 include $(INCLUDE_DIR)/kernel.mk
 include $(INCLUDE_DIR)/package.mk
 include $(INCLUDE_DIR)/nls.mk
@@ -75,14 +77,7 @@ $(call Package/iproute2/Default)
   VARIANT:=tcfull
   PROVIDES:=tc
   ALTERNATIVES:=400:/sbin/tc:/usr/libexec/tc-full
-  DEPENDS:=+kmod-sched-core +(PACKAGE_devlink||PACKAGE_rdma):libmnl +libbpf +libxtables +tc-mod-iptables
-endef
-
-define Package/tc-mod-iptables
-$(call Package/iproute2/Default)
-  TITLE:=Traffic control module - iptables action
-  VARIANT:=tcfull
-  DEPENDS:=+libxtables +libbpf
+  DEPENDS:=+kmod-sched-core +(PACKAGE_devlink||PACKAGE_rdma):libmnl +libbpf +libxtables
 endef
 
 define Package/genl
@@ -100,7 +95,7 @@ endef
 define Package/ss
 $(call Package/iproute2/Default)
   TITLE:=Socket statistics utility
-  DEPENDS:=+libnl-tiny +(PACKAGE_devlink||PACKAGE_rdma):libmnl +kmod-netlink-diag
+  DEPENDS:=+libnl-tiny +(PACKAGE_devlink||PACKAGE_rdma):libmnl +libbpf +kmod-netlink-diag
 endef
 
 define Package/nstat
@@ -171,8 +166,7 @@ define Build/Configure
 		> $(PKG_BUILD_DIR)/include/SNAPSHOT.h
 endef
 
-TARGET_CFLAGS += -ffunction-sections -fdata-sections -flto
-TARGET_LDFLAGS += -Wl,--gc-sections -Wl,--as-needed
+TARGET_LDFLAGS += -Wl,--as-needed
 TARGET_CPPFLAGS += -I$(STAGING_DIR)/usr/include/libnl-tiny
 
 MAKE_FLAGS += \
@@ -231,11 +225,6 @@ define Package/tc-full/install
 	$(INSTALL_BIN) $(PKG_BUILD_DIR)/tc/tc $(1)/usr/libexec/tc-full
 endef
 
-define Package/tc-mod-iptables/install
-	$(INSTALL_DIR) $(1)/usr/lib/tc
-	$(CP) $(PKG_BUILD_DIR)/tc/m_xt.so $(1)/usr/lib/tc
-endef
-
 define Package/genl/install
 	$(INSTALL_DIR) $(1)/usr/sbin
 	$(INSTALL_BIN) $(PKG_BUILD_DIR)/genl/genl $(1)/usr/sbin/
@@ -268,9 +257,6 @@ endef
 
 $(eval $(call BuildPackage,ip-tiny))
 $(eval $(call BuildPackage,ip-full))
-# build tc-mod-iptables before its dependents, to avoid
-# spurious rebuilds when building multiple variants.
-$(eval $(call BuildPackage,tc-mod-iptables))
 $(eval $(call BuildPackage,tc-tiny))
 $(eval $(call BuildPackage,tc-bpf))
 $(eval $(call BuildPackage,tc-full))
diff --git a/package/network/utils/iproute2/patches/100-configure.patch b/package/network/utils/iproute2/patches/100-configure.patch
deleted file mode 100644
index 2d4fb7b9..00000000
--- a/package/network/utils/iproute2/patches/100-configure.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/configure
-+++ b/configure
-@@ -36,7 +36,8 @@ int main(int argc, char **argv) {
- }
- EOF
- 
--    if $CC -I$INCLUDE -o $TMPDIR/atmtest $TMPDIR/atmtest.c -latm >/dev/null 2>&1; then
-+# OpenWrt: disable ATM support even if present on host system
-+    if [ 1 -eq 0 ]; then
- 	echo "TC_CONFIG_ATM:=y" >>$CONFIG
- 	echo yes
-     else
diff --git a/package/network/utils/iproute2/patches/105-ipstats-Define-MIN-function-to-fix-undefined-referen.patch b/package/network/utils/iproute2/patches/105-ipstats-Define-MIN-function-to-fix-undefined-referen.patch
deleted file mode 100644
index 7bf55dd5..00000000
--- a/package/network/utils/iproute2/patches/105-ipstats-Define-MIN-function-to-fix-undefined-referen.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From c69e8e474936795a2cd7638b11ce3e99ff4d5ae7 Mon Sep 17 00:00:00 2001
-From: Nick Hainke <vincent@systemli.org>
-Date: Sat, 6 Aug 2022 10:00:20 +0200
-Subject: [PATCH] ipstats: Define MIN function to fix undefined references
-
-Fixes errors in the form of:
- in function `ipstats_show_64':
- <artificial>:(.text+0x4e30): undefined reference to `MIN'
-
-Signed-off-by: Nick Hainke <vincent@systemli.org>
----
- ip/ipstats.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/ip/ipstats.c
-+++ b/ip/ipstats.c
-@@ -6,6 +6,10 @@
- #include "utils.h"
- #include "ip_common.h"
- 
-+#ifndef MIN
-+#define MIN(a, b) ((a) < (b) ? (a) : (b))
-+#endif
-+
- struct ipstats_stat_dump_filters {
- 	/* mask[0] filters outer attributes. Then individual nests have their
- 	 * filtering mask at the index of the nested attribute.
diff --git a/package/network/utils/iproute2/patches/115-add-config-xtlibdir.patch b/package/network/utils/iproute2/patches/115-add-config-xtlibdir.patch
index 03df7809..38448e6c 100644
--- a/package/network/utils/iproute2/patches/115-add-config-xtlibdir.patch
+++ b/package/network/utils/iproute2/patches/115-add-config-xtlibdir.patch
@@ -1,6 +1,6 @@
 --- a/tc/Makefile
 +++ b/tc/Makefile
-@@ -127,6 +127,9 @@ CFLAGS += -DCONFIG_GACT -DCONFIG_GACT_PR
+@@ -107,6 +107,9 @@ CFLAGS += -DCONFIG_GACT -DCONFIG_GACT_PR
  ifneq ($(IPT_LIB_DIR),)
  	CFLAGS += -DIPT_LIB_DIR=\"$(IPT_LIB_DIR)\"
  endif
diff --git a/package/network/utils/iproute2/patches/130-no_netem_tipc_dcb_man_vdpa.patch b/package/network/utils/iproute2/patches/130-no_netem_tipc_dcb_man_vdpa.patch
index 2a3f9eb9..7f946070 100644
--- a/package/network/utils/iproute2/patches/130-no_netem_tipc_dcb_man_vdpa.patch
+++ b/package/network/utils/iproute2/patches/130-no_netem_tipc_dcb_man_vdpa.patch
@@ -1,6 +1,6 @@
 --- a/Makefile
 +++ b/Makefile
-@@ -65,9 +65,9 @@ WFLAGS += -Wmissing-declarations -Wold-s
+@@ -69,9 +69,9 @@ WFLAGS += -Wmissing-declarations -Wold-s
  CFLAGS := $(WFLAGS) $(CCOPTS) -I../include -I../include/uapi $(DEFINES) $(CFLAGS)
  YACCFLAGS = -d -t -v
  
diff --git a/package/network/utils/iproute2/patches/140-keep_libmnl_optional.patch b/package/network/utils/iproute2/patches/140-keep_libmnl_optional.patch
index a8cdd103..48a4ae75 100644
--- a/package/network/utils/iproute2/patches/140-keep_libmnl_optional.patch
+++ b/package/network/utils/iproute2/patches/140-keep_libmnl_optional.patch
@@ -1,6 +1,6 @@
 --- a/configure
 +++ b/configure
-@@ -411,7 +411,7 @@ check_tirpc()
+@@ -368,7 +368,7 @@ check_tirpc()
  
  check_mnl()
  {
diff --git a/package/network/utils/iproute2/patches/145-keep_libelf_optional.patch b/package/network/utils/iproute2/patches/145-keep_libelf_optional.patch
index 0c5c3f59..99b9d326 100644
--- a/package/network/utils/iproute2/patches/145-keep_libelf_optional.patch
+++ b/package/network/utils/iproute2/patches/145-keep_libelf_optional.patch
@@ -1,6 +1,6 @@
 --- a/configure
 +++ b/configure
-@@ -266,7 +266,7 @@ EOF
+@@ -217,7 +217,7 @@ EOF
  
  check_elf()
  {
diff --git a/package/network/utils/iproute2/patches/150-keep_libcap_optional.patch b/package/network/utils/iproute2/patches/150-keep_libcap_optional.patch
index 4cce2c3c..49873f87 100644
--- a/package/network/utils/iproute2/patches/150-keep_libcap_optional.patch
+++ b/package/network/utils/iproute2/patches/150-keep_libcap_optional.patch
@@ -1,6 +1,6 @@
 --- a/configure
 +++ b/configure
-@@ -469,7 +469,7 @@ EOF
+@@ -427,7 +427,7 @@ EOF
  
  check_cap()
  {
diff --git a/package/network/utils/iproute2/patches/155-keep_tirpc_optional.patch b/package/network/utils/iproute2/patches/155-keep_tirpc_optional.patch
index 28ba7e52..9e5e4330 100644
--- a/package/network/utils/iproute2/patches/155-keep_tirpc_optional.patch
+++ b/package/network/utils/iproute2/patches/155-keep_tirpc_optional.patch
@@ -1,6 +1,6 @@
 --- a/configure
 +++ b/configure
-@@ -398,7 +398,7 @@ check_selinux()
+@@ -355,7 +355,7 @@ check_selinux()
  
  check_tirpc()
  {
diff --git a/package/network/utils/iproute2/patches/170-ip_tiny.patch b/package/network/utils/iproute2/patches/170-ip_tiny.patch
index 71081c36..149bcd2a 100644
--- a/package/network/utils/iproute2/patches/170-ip_tiny.patch
+++ b/package/network/utils/iproute2/patches/170-ip_tiny.patch
@@ -30,15 +30,15 @@
  		"Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }\n"
  		"       ip [ -force ] -batch filename\n"
 +#ifndef IPROUTE2_TINY
- 		"where  OBJECT := { address | addrlabel | amt | fou | help | ila | ioam | l2tp |\n"
- 		"                   link | macsec | maddress | monitor | mptcp | mroute | mrule |\n"
+ 		"where  OBJECT := { address | addrlabel | fou | help | ila | ioam | l2tp | link |\n"
+ 		"                   macsec | maddress | monitor | mptcp | mroute | mrule |\n"
  		"                   neighbor | neighbour | netconf | netns | nexthop | ntable |\n"
- 		"                   ntbl | route | rule | sr | tap | tcpmetrics |\n"
+ 		"                   ntbl | route | rule | sr | stats | tap | tcpmetrics |\n"
  		"                   token | tunnel | tuntap | vrf | xfrm }\n"
 +#else
-+		"where  OBJECT := { address | link | maddress | monitor |\n"
++		"where  OBJECT := { address | help | link | maddress | monitor |\n"
 +		"                   neighbor | neighbour | netns | route |\n"
-+		"                   rule | token | tunnel }\n"
++		"                   rule | stats | token | tunnel }\n"
 +#endif
  		"       OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |\n"
  		"                    -h[uman-readable] | -iec | -j[son] | -p[retty] |\n"
diff --git a/package/network/utils/iproute2/patches/175-reduce-dynamic-syms.patch b/package/network/utils/iproute2/patches/175-reduce-dynamic-syms.patch
deleted file mode 100644
index d0914848..00000000
--- a/package/network/utils/iproute2/patches/175-reduce-dynamic-syms.patch
+++ /dev/null
@@ -1,45 +0,0 @@
---- a/tc/Makefile
-+++ b/tc/Makefile
-@@ -113,7 +113,7 @@ LDLIBS += -L. -lm
- 
- ifeq ($(SHARED_LIBS),y)
- LDLIBS += -ldl
--LDFLAGS += -Wl,-export-dynamic
-+LDFLAGS += -Wl,--dynamic-list=dynsyms.list
- endif
- 
- TCLIB := tc_core.o
-@@ -143,7 +143,7 @@ MODDESTDIR := $(DESTDIR)$(LIBDIR)/tc
- all: tc $(TCSO)
- 
- tc: $(TCOBJ) $(LIBNETLINK) libtc.a
--	$(QUIET_LINK)$(CC) $^ $(LDFLAGS) $(LDLIBS) -o $@
-+	$(QUIET_LINK)$(CC) $(filter-out dynsyms.list, $^) $(LDFLAGS) $(LDLIBS) -o $@
- 
- libtc.a: $(TCLIB)
- 	$(QUIET_AR)$(AR) rcs $@ $^
-@@ -165,6 +165,7 @@ install: all
- clean:
- 	rm -f $(TCOBJ) $(TCLIB) libtc.a tc *.so emp_ematch.tab.h; \
- 	rm -f emp_ematch.tab.*
-+	rm -f dynsyms.list
- 
- q_atm.so: q_atm.c
- 	$(QUIET_CC)$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -shared -fpic -o q_atm.so q_atm.c -latm
-@@ -204,4 +205,16 @@ static-syms.h: $(wildcard *.c)
- 		sed -n '/'$$s'[^ ]* =/{s:.* \([^ ]*'$$s'[^ ]*\) .*:extern char \1[] __attribute__((weak)); if (!strcmp(sym, "\1")) return \1;:;p}' $$files ; \
- 	done > $@
- 
-+else
-+
-+tc: dynsyms.list
-+m_xt.so: dynsyms.list
-+dynsyms.list: $(wildcard *.c)
-+	files="$(filter-out $(patsubst %.so,%.c,$(TCSO)), $^)" ; \
-+	echo "{" > $@ ; \
-+	for s in `grep -B 3 '\<dlsym' $$files | sed -n '/snprintf/{s:.*"\([^"]*\)".*:\1:;s:%s::;p}'` ; do \
-+		sed -n '/'$$s'[^ ]* =/{s:.* \([^ ]*'$$s'[^ ]*\) .*:\1;:;p}' $$files ; \
-+	done >> $@ ; \
-+	echo "show_stats; print_nl; print_tm; parse_rtattr; parse_rtattr_flags; get_u32; matches; addattr_l; addattr_nest; addattr_nest_end; };" >> $@
-+
- endif
diff --git a/package/network/utils/iproute2/patches/190-fix-nls-rpath-link.patch b/package/network/utils/iproute2/patches/190-fix-nls-rpath-link.patch
index c7fceb2e..545075fd 100644
--- a/package/network/utils/iproute2/patches/190-fix-nls-rpath-link.patch
+++ b/package/network/utils/iproute2/patches/190-fix-nls-rpath-link.patch
@@ -1,6 +1,6 @@
 --- a/configure
 +++ b/configure
-@@ -290,7 +290,7 @@ int main(int argc, char **argv) {
+@@ -241,7 +241,7 @@ int main(int argc, char **argv) {
  }
  EOF
  
@@ -9,7 +9,7 @@
      local ret=$?
  
      rm -f $TMPDIR/libbpf_test.c $TMPDIR/libbpf_test
-@@ -308,7 +308,7 @@ int main(int argc, char **argv) {
+@@ -259,7 +259,7 @@ int main(int argc, char **argv) {
  }
  EOF
  
diff --git a/package/network/utils/iproute2/patches/195-build_variant_ip_tc.patch b/package/network/utils/iproute2/patches/195-build_variant_ip_tc.patch
index 14176346..6ecf5568 100644
--- a/package/network/utils/iproute2/patches/195-build_variant_ip_tc.patch
+++ b/package/network/utils/iproute2/patches/195-build_variant_ip_tc.patch
@@ -11,7 +11,7 @@
  
 --- a/tc/Makefile
 +++ b/tc/Makefile
-@@ -140,7 +140,7 @@ MODDESTDIR := $(DESTDIR)$(LIBDIR)/tc
+@@ -120,7 +120,7 @@ MODDESTDIR := $(DESTDIR)$(LIBDIR)/tc
  	$(QUIET_CC)$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -shared -fpic $< -o $@
  
  
@@ -19,4 +19,4 @@
 +all: $(findstring tc,$(BUILD_VARIANT)) $(TCSO)
  
  tc: $(TCOBJ) $(LIBNETLINK) libtc.a
- 	$(QUIET_LINK)$(CC) $(filter-out dynsyms.list, $^) $(LDFLAGS) $(LDLIBS) -o $@
+ 	$(QUIET_LINK)$(CC) $^ $(LDFLAGS) $(LDLIBS) -o $@
diff --git a/package/network/utils/iproute2/patches/200-drop_libbsd_dependency.patch b/package/network/utils/iproute2/patches/200-drop_libbsd_dependency.patch
index d1948860..38193be1 100644
--- a/package/network/utils/iproute2/patches/200-drop_libbsd_dependency.patch
+++ b/package/network/utils/iproute2/patches/200-drop_libbsd_dependency.patch
@@ -1,12 +1,12 @@
 --- a/configure
 +++ b/configure
-@@ -455,14 +455,8 @@ EOF
+@@ -413,14 +413,8 @@ EOF
      if $CC -I$INCLUDE -o $TMPDIR/strtest $TMPDIR/strtest.c >/dev/null 2>&1; then
  	echo "no"
      else
 -	if ${PKG_CONFIG} libbsd --exists; then
--		echo 'CFLAGS += -DHAVE_LIBBSD' `${PKG_CONFIG} libbsd --cflags` >>$CONFIG
--		echo 'LDLIBS +=' `${PKG_CONFIG} libbsd --libs` >> $CONFIG
+-		echo 'CFLAGS += -DHAVE_LIBBSD' "$(${PKG_CONFIG} libbsd --cflags)" >>$CONFIG
+-		echo 'LDLIBS +=' "$(${PKG_CONFIG} libbsd --libs)" >> $CONFIG
 -		echo "no"
 -	else
 -		echo 'CFLAGS += -DNEED_STRLCPY' >>$CONFIG
diff --git a/package/network/utils/iproute2/patches/300-selinux-configurable.patch b/package/network/utils/iproute2/patches/300-selinux-configurable.patch
index 817abf7d..9f07d317 100644
--- a/package/network/utils/iproute2/patches/300-selinux-configurable.patch
+++ b/package/network/utils/iproute2/patches/300-selinux-configurable.patch
@@ -1,6 +1,6 @@
 --- a/configure
 +++ b/configure
-@@ -385,7 +385,7 @@ check_libbpf()
+@@ -342,7 +342,7 @@ check_libbpf()
  check_selinux()
  # SELinux is a compile time option in the ss utility
  {
diff --git a/package/network/utils/iproute2/patches/400-add-nss-qdisc.patch b/package/network/utils/iproute2/patches/400-add-nss-qdisc.patch
deleted file mode 100644
index b6e969bd..00000000
--- a/package/network/utils/iproute2/patches/400-add-nss-qdisc.patch
+++ /dev/null
@@ -1,2094 +0,0 @@
---- a/include/uapi/linux/pkt_sched.h
-+++ b/include/uapi/linux/pkt_sched.h
-@@ -119,6 +119,251 @@ enum {
- 
- #define TCA_STAB_MAX (__TCA_STAB_MAX - 1)
- 
-+enum {
-+	TCA_NSS_ACCEL_MODE_NSS_FW,
-+	TCA_NSS_ACCEL_MODE_PPE,
-+	TCA_NSS_ACCEL_MODE_MAX
-+};
-+
-+/* NSSFIFO section */
-+
-+enum {
-+	TCA_NSSFIFO_UNSPEC,
-+	TCA_NSSFIFO_PARMS,
-+	__TCA_NSSFIFO_MAX
-+};
-+
-+#define TCA_NSSFIFO_MAX	(__TCA_NSSFIFO_MAX - 1)
-+
-+struct tc_nssfifo_qopt {
-+	__u32	limit;		/* Queue length: bytes for bfifo, packets for pfifo */
-+	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSWRED section */
-+
-+enum {
-+	TCA_NSSWRED_UNSPEC,
-+	TCA_NSSWRED_PARMS,
-+	__TCA_NSSWRED_MAX
-+};
-+
-+#define TCA_NSSWRED_MAX (__TCA_NSSWRED_MAX - 1)
-+#define NSSWRED_CLASS_MAX 6
-+struct tc_red_alg_parameter {
-+	__u32	min;	/* qlen_avg < min: pkts are all enqueued */
-+	__u32	max;	/* qlen_avg > max: pkts are all dropped */
-+	__u32	probability;/* Drop probability at qlen_avg = max */
-+	__u32	exp_weight_factor;/* exp_weight_factor for calculate qlen_avg */
-+};
-+
-+struct tc_nsswred_traffic_class {
-+	__u32 limit;			/* Queue length */
-+	__u32 weight_mode_value;	/* Weight mode value */
-+	struct tc_red_alg_parameter rap;/* Parameters for RED alg */
-+};
-+
-+/*
-+ * Weight modes for WRED
-+ */
-+enum tc_nsswred_weight_modes {
-+	TC_NSSWRED_WEIGHT_MODE_DSCP = 0,/* Weight mode is DSCP */
-+	TC_NSSWRED_WEIGHT_MODES,	/* Must be last */
-+};
-+typedef enum tc_nsswred_weight_modes tc_nsswred_weight_mode_t;
-+
-+struct tc_nsswred_qopt {
-+	__u32	limit;			/* Queue length */
-+	enum tc_nsswred_weight_modes weight_mode;
-+					/* Weight mode */
-+	__u32	traffic_classes;	/* How many traffic classes: DPs */
-+	__u32	def_traffic_class;	/* Default traffic if no match: def_DP */
-+	__u32	traffic_id;		/* The traffic id to be configured: DP */
-+	__u32	weight_mode_value;	/* Weight mode value */
-+	struct tc_red_alg_parameter rap;/* RED algorithm parameters */
-+	struct tc_nsswred_traffic_class tntc[NSSWRED_CLASS_MAX];
-+					/* Traffic settings for dumpping */
-+	__u8	ecn;			/* Setting ECN bit or dropping */
-+	__u8	set_default;		/* Sets qdisc to be the default for enqueue */
-+	__u8	accel_mode;		/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSCODEL section */
-+
-+enum {
-+	TCA_NSSCODEL_UNSPEC,
-+	TCA_NSSCODEL_PARMS,
-+	__TCA_NSSCODEL_MAX
-+};
-+
-+#define TCA_NSSCODEL_MAX	(__TCA_NSSCODEL_MAX - 1)
-+
-+struct tc_nsscodel_qopt {
-+	__u32	target;		/* Acceptable queueing delay */
-+	__u32	limit;		/* Max number of packets that can be held in the queue */
-+	__u32	interval;	/* Monitoring interval */
-+	__u32	flows;		/* Number of flow buckets */
-+	__u32	quantum;	/* Weight (in bytes) used for DRR of flow buckets */
-+	__u8	ecn;		/* 0 - disable ECN, 1 - enable ECN */
-+	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+struct tc_nsscodel_xstats {
-+	__u32 peak_queue_delay;	/* Peak delay experienced by a dequeued packet */
-+	__u32 peak_drop_delay;	/* Peak delay experienced by a dropped packet */
-+};
-+
-+/* NSSFQ_CODEL section */
-+
-+struct tc_nssfq_codel_xstats {
-+	__u32 new_flow_count;	/* Total number of new flows seen */
-+	__u32 new_flows_len;	/* Current number of new flows */
-+	__u32 old_flows_len;	/* Current number of old flows */
-+	__u32 ecn_mark;		/* Number of packets marked with ECN */
-+	__u32 drop_overlimit;	/* Number of packets dropped due to overlimit */
-+	__u32 maxpacket;	/* The largest packet seen so far in the queue */
-+};
-+
-+/* NSSTBL section */
-+
-+enum {
-+	TCA_NSSTBL_UNSPEC,
-+	TCA_NSSTBL_PARMS,
-+	__TCA_NSSTBL_MAX
-+};
-+
-+#define TCA_NSSTBL_MAX	(__TCA_NSSTBL_MAX - 1)
-+
-+struct tc_nsstbl_qopt {
-+	__u32	burst;		/* Maximum burst size */
-+	__u32	rate;		/* Limiting rate of TBF */
-+	__u32	peakrate;	/* Maximum rate at which TBF is allowed to send */
-+	__u32	mtu;		/* Max size of packet, or minumim burst size */
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSPRIO section */
-+
-+#define TCA_NSSPRIO_MAX_BANDS 256
-+
-+enum {
-+	TCA_NSSPRIO_UNSPEC,
-+	TCA_NSSPRIO_PARMS,
-+	__TCA_NSSPRIO_MAX
-+};
-+
-+#define TCA_NSSPRIO_MAX	(__TCA_NSSPRIO_MAX - 1)
-+
-+struct tc_nssprio_qopt {
-+	__u32	bands;		/* Number of bands */
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSBF section */
-+
-+enum {
-+	TCA_NSSBF_UNSPEC,
-+	TCA_NSSBF_CLASS_PARMS,
-+	TCA_NSSBF_QDISC_PARMS,
-+	__TCA_NSSBF_MAX
-+};
-+
-+#define TCA_NSSBF_MAX	(__TCA_NSSBF_MAX - 1)
-+
-+struct tc_nssbf_class_qopt {
-+	__u32	burst;		/* Maximum burst size */
-+	__u32	rate;		/* Allowed bandwidth for this class */
-+	__u32	mtu;		/* MTU of the associated interface */
-+	__u32	quantum;	/* Quantum allocation for DRR */
-+};
-+
-+struct tc_nssbf_qopt {
-+	__u16	defcls;		/* Default class value */
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSWRR section */
-+
-+enum {
-+	TCA_NSSWRR_UNSPEC,
-+	TCA_NSSWRR_CLASS_PARMS,
-+	TCA_NSSWRR_QDISC_PARMS,
-+	__TCA_NSSWRR_MAX
-+};
-+
-+#define TCA_NSSWRR_MAX	(__TCA_NSSWRR_MAX - 1)
-+
-+struct tc_nsswrr_class_qopt {
-+	__u32	quantum;	/* Weight associated to this class */
-+};
-+
-+struct tc_nsswrr_qopt {
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSWFQ section */
-+
-+enum {
-+	TCA_NSSWFQ_UNSPEC,
-+	TCA_NSSWFQ_CLASS_PARMS,
-+	TCA_NSSWFQ_QDISC_PARMS,
-+	__TCA_NSSWFQ_MAX
-+};
-+
-+#define TCA_NSSWFQ_MAX	(__TCA_NSSWFQ_MAX - 1)
-+
-+struct tc_nsswfq_class_qopt {
-+	__u32	quantum;	/* Weight associated to this class */
-+};
-+
-+struct tc_nsswfq_qopt {
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSHTB section */
-+
-+enum {
-+	TCA_NSSHTB_UNSPEC,
-+	TCA_NSSHTB_CLASS_PARMS,
-+	TCA_NSSHTB_QDISC_PARMS,
-+	__TCA_NSSHTB_MAX
-+};
-+
-+#define TCA_NSSHTB_MAX	(__TCA_NSSHTB_MAX - 1)
-+
-+struct tc_nsshtb_class_qopt {
-+	__u32	burst;		/* Allowed burst size */
-+	__u32	rate;		/* Allowed bandwidth for this class */
-+	__u32	cburst;		/* Maximum burst size */
-+	__u32	crate;		/* Maximum bandwidth for this class */
-+	__u32	quantum;	/* Quantum allocation for DRR */
-+	__u32	priority;	/* Priority value associated with this class */
-+	__u32	overhead;	/* Overhead in bytes per packet */
-+};
-+
-+struct tc_nsshtb_qopt {
-+	__u32	r2q;		/* Rate to quantum ratio */
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+/* NSSBLACKHOLE section */
-+
-+enum {
-+	TCA_NSSBLACKHOLE_UNSPEC,
-+	TCA_NSSBLACKHOLE_PARMS,
-+	__TCA_NSSBLACKHOLE_MAX
-+};
-+
-+#define TCA_NSSBLACKHOLE_MAX	(__TCA_NSSBLACKHOLE_MAX - 1)
-+
-+struct tc_nssblackhole_qopt {
-+	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
-+	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
-+};
-+
-+
- /* FIFO section */
- 
- struct tc_fifo_qopt {
---- a/tc/Makefile
-+++ b/tc/Makefile
-@@ -82,6 +82,7 @@ TCMODULES += q_etf.o
- TCMODULES += q_taprio.o
- TCMODULES += q_plug.o
- TCMODULES += q_ets.o
-+TCMODULES += q_nss.o
- 
- TCSO :=
- ifeq ($(TC_CONFIG_ATM),y)
---- /dev/null
-+++ b/tc/q_nss.c
-@@ -0,0 +1,1826 @@
-+/*
-+ **************************************************************************
-+ * Copyright (c) 2015, 2018 The Linux Foundation. All rights reserved.
-+ * Permission to use, copy, modify, and/or distribute this software for
-+ * any purpose with or without fee is hereby granted, provided that the
-+ * above copyright notice and this permission notice appear in all copies.
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
-+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ **************************************************************************
-+ */
-+
-+#include <stdio.h>
-+#include <stdlib.h>
-+#include <unistd.h>
-+#include <syslog.h>
-+#include <fcntl.h>
-+#include <sys/socket.h>
-+#include <netinet/in.h>
-+#include <arpa/inet.h>
-+#include <string.h>
-+#include <math.h>
-+
-+#include "utils.h"
-+#include "tc_util.h"
-+#include "tc_red.h"
-+
-+/* ======================== NSSWRED =======================*/
-+
-+static void nssred_explain(void)
-+{
-+	fprintf(stderr, "Usage: ...  nssred limit BYTES avpkt BYTES [ min BYTES ] [ max BYTES ] [ probability VALUE ]\n");
-+	fprintf(stderr, "                   [ burst PACKETS ] [ecn] [ set_default ] [ accel_mode ]\n");
-+}
-+
-+static void nsswred_explain(void)
-+{
-+	fprintf(stderr, "Usage: ...  nsswred setup DPs NUMBER dp_default NUMBER [ weight_mode dscp ] [ecn] [ set_default ] [ accel_mode ]\n");
-+	fprintf(stderr, "            nsswred limit BYTES DP NUMBER min BYTES max BYTES avpkt BYTES dscp NUMBER [ probability VALUE ] [ burst PACKETS ]\n");
-+}
-+
-+static int nsswred_setup(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct rtattr *tail;
-+	struct tc_nsswred_qopt opt;
-+
-+	memset(&opt, 0, sizeof(opt));
-+	unsigned int dps = 0;
-+	unsigned int def_dp = 0;
-+	bool accel_mode = false;
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "DPs") == 0) {
-+			NEXT_ARG();
-+			if (get_unsigned(&dps, *argv, 0) || dps > NSSWRED_CLASS_MAX) {
-+
-+				fprintf(stderr, "DPs should be between 1 - %d\n", NSSWRED_CLASS_MAX);
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "weight_mode") == 0) {
-+			NEXT_ARG();
-+			if (strcmp(*argv, "dscp") == 0) {
-+				opt.weight_mode = TC_NSSWRED_WEIGHT_MODE_DSCP;
-+			} else {
-+				fprintf(stderr, "Illegal \"weight_mode\", we only support dscp at this moment\n");
-+			}
-+		} else if (strcmp(*argv, "ecn") == 0) {
-+			opt.ecn = 1;
-+		} else if (strcmp(*argv, "dp_default") == 0) {
-+			NEXT_ARG();
-+			if (get_unsigned(&def_dp, *argv, 0) || def_dp > dps) {
-+				fprintf(stderr, "Illegal dp_default value\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nsswred_explain();
-+			return -1;
-+		} else if (strcmp(*argv, "set_default") == 0) {
-+			opt.set_default = 1;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nsswred_explain();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
-+	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
-+		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
-+		return -1;
-+	}
-+
-+	if (!dps || !def_dp) {
-+		fprintf(stderr, "Illegal nsswred setup parameters\n");
-+		return -1;
-+	}
-+	opt.traffic_classes = dps;
-+	opt.def_traffic_class = def_dp;
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSWRED_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsswred_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct rtattr *tail;
-+	struct tc_nsswred_qopt opt;
-+
-+	int total_args = argc;
-+	unsigned burst = 0;
-+	unsigned avpkt = 0;
-+	double probability = 0.0;
-+	unsigned char weighted = (strcmp(qu->id, "nsswred") == 0);
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "limit") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.limit, *argv)) {
-+				fprintf(stderr, "Illegal \"limit\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "set_default") == 0) {
-+			opt.set_default = 1;
-+		} else if (strcmp(*argv, "min") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.rap.min, *argv)) {
-+				fprintf(stderr, "Illegal \"min\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "max") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.rap.max, *argv)) {
-+				fprintf(stderr, "Illegal \"max\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "burst") == 0) {
-+			NEXT_ARG();
-+			if (get_unsigned(&burst, *argv, 0)) {
-+				fprintf(stderr, "Illegal \"burst\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "avpkt") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&avpkt, *argv)) {
-+				fprintf(stderr, "Illegal \"avpkt\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "probability") == 0) {
-+			NEXT_ARG();
-+			if (sscanf(*argv, "%lg", &probability) != 1) {
-+				fprintf(stderr, "Illegal \"probability\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "ecn") == 0) {
-+			opt.ecn = 1;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			if (weighted) {
-+				nsswred_explain();
-+			} else {
-+				nssred_explain();
-+			}
-+			return -1;
-+		} else if (weighted) {
-+			if (strcmp(*argv, "setup") == 0) {
-+				if (argc != total_args) {
-+					fprintf(stderr, "Setup command must be the first parameter\n");
-+					return -1;
-+				}
-+				return nsswred_setup(qu, argc-1, argv+1, n);
-+			} else if (strcmp(*argv, "DP") == 0) {
-+				NEXT_ARG();
-+				if (get_unsigned(&opt.traffic_id, *argv, 0)) {
-+					fprintf(stderr, "Illegal \"DP\"");
-+					return -1;
-+				}
-+			} else if (strcmp(*argv, "dscp") == 0) {
-+				NEXT_ARG();
-+				if (get_unsigned(&opt.weight_mode_value, *argv, 0)) {
-+					fprintf(stderr, "Illegal \"dscp\" value\n");
-+					return -1;
-+				}
-+			}
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			if (weighted) {
-+				nsswred_explain();
-+			} else {
-+				nssred_explain();
-+			}
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+		fprintf(stderr, "Accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+		return -1;
-+	}
-+
-+	if (weighted) {
-+		if (!opt.limit || !opt.rap.min || !opt.rap.max || !opt.traffic_id || !avpkt || !opt.weight_mode_value) {
-+			fprintf(stderr, "Require limit, min, max, avpkt, DP, weight_mode_value\n");
-+			return -1;
-+		}
-+	} else {
-+		if (!opt.limit || !avpkt) {
-+			fprintf(stderr, "Require limit, avpkt");
-+			return -1;
-+		}
-+	}
-+
-+	/*
-+	 * Compute default min/max thresholds based on
-+	 * Sally Floyd's recommendations:
-+	 * http://www.icir.org/floyd/REDparameters.txt
-+	 */
-+	if (!opt.rap.max)
-+		opt.rap.max = opt.rap.min ? opt.rap.min * 3 : opt.limit / 4;
-+	if (!opt.rap.min)
-+		opt.rap.min = opt.rap.max / 3;
-+	if (!burst)
-+		burst = (2 * opt.rap.min + opt.rap.max) / (3 * avpkt);
-+	if ((opt.rap.exp_weight_factor = tc_red_eval_ewma(opt.rap.min, burst, avpkt)) < 0) {
-+		fprintf(stderr, "Failed to calculate EWMA constant.\n");
-+		return -1;
-+	}
-+
-+	/*
-+	 * project [0.0-1.0] to [0-255] to avoid floating point calculation
-+	 */
-+	opt.rap.probability = probability * (pow(2, 8)-1);
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSWRED_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsswred_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSWRED_MAX + 1];
-+	struct tc_nsswred_qopt *qopt;
-+	int i;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSWRED_MAX, opt);
-+
-+	if (tb[TCA_NSSWRED_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSWRED_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSWRED_PARMS]);
-+
-+	if (strcmp(qu->id, "nsswred") == 0) {
-+		fprintf(f, "DPs %d def_DP %d weight mode: " , qopt->traffic_classes, qopt->def_traffic_class);
-+		if (qopt->weight_mode == TC_NSSWRED_WEIGHT_MODE_DSCP)
-+			fprintf(f, "DSCP\n");
-+		else
-+			fprintf(f, "Unknown\n");
-+		for (i = 0;i < qopt->traffic_classes; i ++) {
-+			if (qopt->tntc[i].rap.exp_weight_factor) {
-+				double prob = (double)qopt->tntc[i].rap.probability;
-+				fprintf(f, "DP %d: limit %d, weight mode value: %d min: %d max: %d exp_weight_factor: %d probability %.2f\n",
-+						i + 1, qopt->tntc[i].limit, qopt->tntc[i].weight_mode_value
-+						, qopt->tntc[i].rap.min,qopt->tntc[i].rap.max,qopt->tntc[i].rap.exp_weight_factor,prob/255);
-+			}
-+		}
-+	} else {
-+		double prob = (double)qopt->rap.probability;
-+		fprintf(f, "limit %d, min: %d max: %d exp_weight_factor: %d probability %.2f\n",
-+				qopt->limit, qopt->rap.min,qopt->rap.max,qopt->rap.exp_weight_factor,prob/255);
-+	}
-+
-+	if (qopt->ecn)
-+		fprintf(f, "ECN enabled ");
-+        if (qopt->set_default)
-+                fprintf(f, "set_default ");
-+
-+	fprintf(f, "accel_mode: %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nssred_qdisc_util = {
-+	.id		= "nssred",
-+	.parse_qopt	= nsswred_parse_opt,
-+	.print_qopt	= nsswred_print_opt,
-+};
-+
-+struct qdisc_util nsswred_qdisc_util = {
-+	.id		= "nsswred",
-+	.parse_qopt	= nsswred_parse_opt,
-+	.print_qopt	= nsswred_print_opt,
-+};
-+
-+/* ======================== NSSFIFO =======================*/
-+
-+static void nssfifo_explain(void)
-+{
-+	fprintf(stderr, "Usage: ...  nsspfifo [ limit PACKETS ] [ set_default ] [ accel_mode ]\n");
-+}
-+
-+static int nssfifo_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct rtattr *tail;
-+	struct tc_nssfifo_qopt opt;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "limit") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.limit, *argv) || opt.limit == 0) {
-+				fprintf(stderr, "Illegal \"limit\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "set_default") == 0) {
-+			opt.set_default = 1;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nssfifo_explain();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nssfifo_explain();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSFIFO_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nssfifo_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSFIFO_MAX + 1];
-+	struct tc_nssfifo_qopt *qopt;
-+	SPRINT_BUF(b1);
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSFIFO_MAX, opt);
-+
-+	if (tb[TCA_NSSFIFO_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSFIFO_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSFIFO_PARMS]);
-+
-+	if (strcmp(qu->id, "nssbfifo") == 0)
-+		fprintf(f, "limit %s ", sprint_size(qopt->limit, b1));
-+	else
-+		fprintf(f, "limit %up ", qopt->limit);
-+
-+	if (qopt->set_default)
-+		fprintf(f, "set_default ");
-+
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nsspfifo_qdisc_util = {
-+	.id		= "nsspfifo",
-+	.parse_qopt	= nssfifo_parse_opt,
-+	.print_qopt	= nssfifo_print_opt,
-+};
-+
-+struct qdisc_util nssbfifo_qdisc_util = {
-+	.id		= "nssbfifo",
-+	.parse_qopt	= nssfifo_parse_opt,
-+	.print_qopt	= nssfifo_print_opt,
-+};
-+
-+/* ======================== NSSFQ_CODEL =======================*/
-+
-+static void nssfq_codel_explain(void)
-+{
-+	fprintf(stderr, "Usage: ... nssfq_codel target TIME interval TIME [ flows NUMBER ] [ quantum BYTES ]"
-+				"[ limit PACKETS ] [ set_default ] [ accel_mode ]\n");
-+}
-+
-+static void nssfq_codel_explain_err1(void)
-+{
-+	fprintf(stderr, "Value of target and interval should be greater than 1ms\n");
-+}
-+
-+static int nssfq_codel_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct rtattr *tail;
-+	struct tc_nsscodel_qopt opt;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "target") == 0) {
-+			NEXT_ARG();
-+			if (get_time(&opt.target, *argv)) {
-+				fprintf(stderr, "Illegal \"target\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "limit") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.limit, *argv) || opt.limit == 0) {
-+				fprintf(stderr, "Illegal \"limit\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "flows") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.flows, *argv) || opt.flows == 0) {
-+				fprintf(stderr, "Illegal \"flows\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "quantum") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.quantum, *argv) || opt.quantum == 0) {
-+				fprintf(stderr, "Illegal \"quantum\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "interval") == 0) {
-+			NEXT_ARG();
-+			if (get_time(&opt.interval, *argv)) {
-+				fprintf(stderr, "Illegal \"interval\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "ecn") == 0) {
-+			fprintf(stderr, "Illegal, ECN not supported\n");
-+			nssfq_codel_explain();
-+			return -1;
-+		} else if (strcmp(*argv, "set_default") == 0) {
-+			opt.set_default = 1;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nssfq_codel_explain();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nssfq_codel_explain();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
-+	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
-+		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
-+		return -1;
-+	}
-+
-+	if (!opt.target || !opt.interval) {
-+		nssfq_codel_explain();
-+		return -1;
-+	}
-+
-+	if (opt.target < 1000 || opt.interval < 1000) {
-+		nssfq_codel_explain_err1();
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSCODEL_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nssfq_codel_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSCODEL_MAX + 1];
-+	struct tc_nsscodel_qopt *qopt;
-+	SPRINT_BUF(b1);
-+	SPRINT_BUF(b2);
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSCODEL_MAX, opt);
-+
-+	if (tb[TCA_NSSCODEL_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSCODEL_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSCODEL_PARMS]);
-+
-+	fprintf(f, "target %s limit %up interval %s flows %u quantum %u ",
-+		sprint_time(qopt->target, b1),
-+		qopt->limit,
-+		sprint_time(qopt->interval, b2),
-+		qopt->flows,
-+		qopt->quantum);
-+
-+	if (qopt->ecn)
-+		fprintf(f, "ecn ");
-+
-+	if (qopt->set_default)
-+		fprintf(f, "set_default ");
-+
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+static int nssfq_codel_print_xstats(struct qdisc_util *qu, FILE *f, struct rtattr *xstats)
-+{
-+	struct tc_nssfq_codel_xstats *st;
-+
-+	if (xstats == NULL)
-+		return 0;
-+
-+	if (RTA_PAYLOAD(xstats) < sizeof(*st))
-+		return -1;
-+
-+	st = RTA_DATA(xstats);
-+	fprintf(f, " maxpacket %u drop_overlimit %u new_flow_count %u ecn_mark %u\n",
-+			st->maxpacket, st->drop_overlimit, st->new_flow_count, st->ecn_mark);
-+	fprintf(f, " new_flows_len %u old_flows_len %u", st->new_flows_len, st->old_flows_len);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nssfq_codel_qdisc_util = {
-+	.id		= "nssfq_codel",
-+	.parse_qopt	= nssfq_codel_parse_opt,
-+	.print_qopt	= nssfq_codel_print_opt,
-+	.print_xstats	= nssfq_codel_print_xstats,
-+};
-+
-+/* ======================== NSSCODEL =======================*/
-+
-+static void nsscodel_explain(void)
-+{
-+	fprintf(stderr, "Usage: ... nsscodel target TIME interval TIME [ limit PACKETS ] [ set_default ] [ accel_mode ]\n");
-+}
-+
-+static void nsscodel_explain_err1(void)
-+{
-+	fprintf(stderr, "Value of target and interval should be greater than 1ms\n");
-+}
-+
-+static int nsscodel_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct rtattr *tail;
-+	struct tc_nsscodel_qopt opt;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "target") == 0) {
-+			NEXT_ARG();
-+			if (get_time(&opt.target, *argv)) {
-+				fprintf(stderr, "Illegal \"target\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "limit") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.limit, *argv) || opt.limit == 0) {
-+				fprintf(stderr, "Illegal \"limit\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "interval") == 0) {
-+			NEXT_ARG();
-+			if (get_time(&opt.interval, *argv)) {
-+				fprintf(stderr, "Illegal \"interval\"\n");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "set_default") == 0) {
-+			opt.set_default = 1;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nsscodel_explain();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nsscodel_explain();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
-+	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
-+		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
-+		return -1;
-+	}
-+
-+	if (!opt.target || !opt.interval) {
-+		nsscodel_explain();
-+		return -1;
-+	}
-+
-+	if (opt.target < 1000 || opt.interval < 1000) {
-+		nsscodel_explain_err1();
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSCODEL_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsscodel_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSCODEL_MAX + 1];
-+	struct tc_nsscodel_qopt *qopt;
-+	SPRINT_BUF(b1);
-+	SPRINT_BUF(b2);
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSCODEL_MAX, opt);
-+
-+	if (tb[TCA_NSSCODEL_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSCODEL_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSCODEL_PARMS]);
-+
-+	fprintf(f, "target %s limit %up interval %s ",
-+		sprint_time(qopt->target, b1),
-+		qopt->limit,
-+		sprint_time(qopt->interval, b2));
-+
-+	if (qopt->set_default)
-+		fprintf(f, "set_default ");
-+
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+static int nsscodel_print_xstats(struct qdisc_util *qu, FILE *f, struct rtattr *xstats)
-+{
-+	struct tc_nsscodel_xstats *st;
-+
-+	if (xstats == NULL)
-+		return 0;
-+
-+	if (RTA_PAYLOAD(xstats) < sizeof(*st))
-+		return -1;
-+
-+	st = RTA_DATA(xstats);
-+	fprintf(f, " peak queue delay %ums peak drop delay %ums",
-+			st->peak_queue_delay, st->peak_drop_delay);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nsscodel_qdisc_util = {
-+	.id		= "nsscodel",
-+	.parse_qopt	= nsscodel_parse_opt,
-+	.print_qopt	= nsscodel_print_opt,
-+	.print_xstats	= nsscodel_print_xstats,
-+};
-+
-+/* ======================== NSSTBL =======================*/
-+
-+static void nsstbl_explain(void)
-+{
-+	fprintf(stderr, "Usage: ... nsstbl burst BYTES rate BPS [ mtu BYTES ] [ accel_mode ]\n");
-+}
-+
-+static int nsstbl_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	int ok = 0;
-+	struct rtattr *tail;
-+	struct tc_nsstbl_qopt opt;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "burst") == 0 ||
-+			   strcmp(*argv, "buffer") == 0 ||
-+			   strcmp(*argv, "maxburst") == 0) {
-+			NEXT_ARG();
-+			if (opt.burst) {
-+				fprintf(stderr, "Double \"buffer/burst\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.burst, *argv)) {
-+				fprintf(stderr, "Illegal \"burst\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "mtu") == 0 ||
-+			   strcmp(*argv, "minburst") == 0) {
-+			NEXT_ARG();
-+			if (opt.mtu) {
-+				fprintf(stderr, "Double \"mtu/minburst\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.mtu, *argv)) {
-+				fprintf(stderr, "Illegal \"mtu\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "rate") == 0) {
-+			NEXT_ARG();
-+			if (opt.rate) {
-+				fprintf(stderr, "Double \"rate\" spec\n");
-+				return -1;
-+			}
-+			if (get_rate(&opt.rate, *argv)) {
-+				fprintf(stderr, "Illegal \"rate\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nsstbl_explain();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nsstbl_explain();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!ok) {
-+		nsstbl_explain();
-+		return -1;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+		return -1;
-+	}
-+
-+	if (!opt.rate || !opt.burst) {
-+		fprintf(stderr, "Both \"rate\" and \"burst\" are required.\n");
-+		return -1;
-+	}
-+
-+	/*
-+	 * Peakrate is currently not supported, but we keep the infrastructure
-+	 * for future use. However, we have disabled taking input for this.
-+	 */
-+	if (opt.peakrate) {
-+		if (!opt.mtu) {
-+			fprintf(stderr, "\"mtu\" is required, if \"peakrate\" is requested.\n");
-+			return -1;
-+		}
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSTBL_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsstbl_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSTBL_MAX + 1];
-+	struct tc_nsstbl_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSTBL_MAX, opt);
-+
-+	if (tb[TCA_NSSTBL_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSTBL_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSTBL_PARMS]);
-+
-+	print_size(PRINT_FP, NULL, "buffer/maxburst %s ", qopt->burst);
-+	tc_print_rate(PRINT_FP, NULL, "rate %s ", qopt->rate);
-+	print_size(PRINT_FP, NULL, "mtu %s ", qopt->mtu);
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nsstbl_qdisc_util = {
-+	.id		= "nsstbl",
-+	.parse_qopt	= nsstbl_parse_opt,
-+	.print_qopt	= nsstbl_print_opt,
-+};
-+
-+/* ======================== NSSPRIO =======================*/
-+
-+static void nssprio_explain(void)
-+{
-+	fprintf(stderr, "Usage: ... nssprio [ bands NUMBER (default 256) ] [ accel_mode ]\n");
-+}
-+
-+static int nssprio_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	int ok = 0;
-+	struct rtattr *tail;
-+	struct tc_nssprio_qopt opt;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "bands") == 0) {
-+			NEXT_ARG();
-+			if (get_unsigned(&opt.bands, *argv, 0)) {
-+				fprintf(stderr, "Illegal \"limit\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nssprio_explain();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nssprio_explain();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!ok) {
-+		opt.bands = TCA_NSSPRIO_MAX_BANDS;
-+	} else if (opt.bands > TCA_NSSPRIO_MAX_BANDS) {
-+		nssprio_explain();
-+		return -1;
-+	}
-+
-+        if (!accel_mode) {
-+                opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+        } else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+                fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+                return -1;
-+        }
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSPRIO_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nssprio_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSPRIO_MAX + 1];
-+	struct tc_nssprio_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSPRIO_MAX, opt);
-+
-+	if (tb[TCA_NSSPRIO_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSPRIO_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSPRIO_PARMS]);
-+
-+	fprintf(f, "bands %u ", qopt->bands);
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nssprio_qdisc_util = {
-+	.id		= "nssprio",
-+	.parse_qopt	= nssprio_parse_opt,
-+	.print_qopt	= nssprio_print_opt,
-+};
-+
-+/* ======================== NSSBF =======================*/
-+
-+static void nssbf_explain_qdisc(void)
-+{
-+	fprintf(stderr,
-+		"Usage: ... nssbf [ accel_mode ]\n"
-+	);
-+}
-+
-+static void nssbf_explain_class(void)
-+{
-+	fprintf(stderr, "Usage: ... nssbf rate BPS burst BYTES [ mtu BYTES ]\n");
-+	fprintf(stderr, "                 [ quantum BYTES ]\n");
-+}
-+
-+static void nssbf_explain1(char *arg)
-+{
-+	fprintf(stderr, "NSSBF: Illegal \"%s\"\n", arg);
-+}
-+
-+static int nssbf_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct tc_nssbf_qopt opt;
-+	struct rtattr *tail;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (matches(*argv, "default") == 0) {
-+			NEXT_ARG();
-+			if (opt.defcls != 0) {
-+				fprintf(stderr, "NSSBF: Double \"default\"\n");
-+				return -1;
-+			}
-+			if (get_u16(&opt.defcls, *argv, 16) < 0) {
-+				nssbf_explain1("default");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (matches(*argv, "help") == 0) {
-+			nssbf_explain_qdisc();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "NSSBF: What is \"%s\" ?\n", *argv);
-+			nssbf_explain_qdisc();
-+			return -1;
-+		}
-+		argc--, argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
-+	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
-+		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSBF_QDISC_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nssbf_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSBF_MAX + 1];
-+	struct tc_nssbf_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSBF_MAX, opt);
-+
-+	if (tb[TCA_NSSBF_QDISC_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSBF_QDISC_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSBF_QDISC_PARMS]);
-+
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+static int nssbf_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	int ok = 0;
-+	struct rtattr *tail;
-+	struct tc_nssbf_class_qopt opt;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "burst") == 0 ||
-+			   strcmp(*argv, "buffer") == 0 ||
-+			   strcmp(*argv, "maxburst") == 0) {
-+			NEXT_ARG();
-+			if (opt.burst) {
-+				fprintf(stderr, "Double \"buffer/burst\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.burst, *argv)) {
-+				fprintf(stderr, "Illegal \"burst\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "mtu") == 0) {
-+			NEXT_ARG();
-+			if (opt.mtu) {
-+				fprintf(stderr, "Double \"mtu\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.mtu, *argv)) {
-+				fprintf(stderr, "Illegal \"mtu\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "quantum") == 0) {
-+			NEXT_ARG();
-+			if (opt.quantum) {
-+				fprintf(stderr, "Double \"quantum\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.quantum, *argv)) {
-+				fprintf(stderr, "Illegal \"quantum\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "rate") == 0) {
-+			NEXT_ARG();
-+			if (opt.rate) {
-+				fprintf(stderr, "Double \"rate\" spec\n");
-+				return -1;
-+			}
-+			if (get_rate(&opt.rate, *argv)) {
-+				fprintf(stderr, "Illegal \"rate\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nssbf_explain_class();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nssbf_explain_class();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!ok) {
-+		nssbf_explain_class();
-+		return -1;
-+	}
-+
-+	if (!opt.rate || !opt.burst) {
-+		fprintf(stderr, "Both \"rate\" and \"burst\" are required.\n");
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSBF_CLASS_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nssbf_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSBF_MAX + 1];
-+	struct tc_nssbf_class_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSBF_MAX, opt);
-+
-+	if (tb[TCA_NSSBF_CLASS_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSBF_CLASS_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSBF_CLASS_PARMS]);
-+
-+	print_size(PRINT_FP, NULL, "burst %s ", qopt->burst);
-+	tc_print_rate(PRINT_FP, NULL, "rate %s ", qopt->rate);
-+	print_size(PRINT_FP, NULL, "quantum %s ", qopt->quantum);
-+	print_size(PRINT_FP, NULL, "mtu %s ", qopt->mtu);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nssbf_qdisc_util = {
-+	.id		= "nssbf",
-+	.parse_qopt	= nssbf_parse_opt,
-+	.print_qopt	= nssbf_print_opt,
-+	.parse_copt	= nssbf_parse_class_opt,
-+	.print_copt	= nssbf_print_class_opt,
-+};
-+
-+/* ======================== NSSWRR =======================*/
-+
-+static void nsswrr_explain_qdisc(void)
-+{
-+	fprintf(stderr,	"Usage (qdisc): ... nsswrr [ accel_mode ]\n");
-+}
-+
-+static void nsswrr_explain_class(void)
-+{
-+	fprintf(stderr, "Usage (class): ... nsswrr quantum PACKETS ]\n");
-+}
-+
-+static int nsswrr_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct tc_nsswrr_qopt opt;
-+	bool accel_mode = false;
-+	struct rtattr *tail;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (matches(*argv, "help") == 0) {
-+			nsswrr_explain_qdisc();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\" ?\n", *argv);
-+			nsswrr_explain_qdisc();
-+			return -1;
-+		}
-+		argc--, argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSWRR_QDISC_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsswrr_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSWRR_MAX + 1];
-+	struct tc_nsswrr_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSWRR_MAX, opt);
-+
-+	if (tb[TCA_NSSWRR_QDISC_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSWRR_QDISC_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSWRR_QDISC_PARMS]);
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+static int nsswrr_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	int ok = 0;
-+	struct rtattr *tail;
-+	struct tc_nsswrr_class_qopt opt;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "quantum") == 0) {
-+			NEXT_ARG();
-+			if (get_u32(&opt.quantum, *argv, 10)) {
-+				fprintf(stderr, "Illegal \"quantum\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nsswrr_explain_class();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nsswrr_explain_class();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!ok) {
-+		nsswrr_explain_class();
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSWRR_CLASS_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsswrr_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSWRR_MAX + 1];
-+	struct tc_nsswrr_class_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSWRR_MAX, opt);
-+
-+	if (tb[TCA_NSSWRR_CLASS_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSWRR_CLASS_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSWRR_CLASS_PARMS]);
-+
-+	fprintf(f, "quantum %up ", qopt->quantum);
-+	return 0;
-+}
-+
-+struct qdisc_util nsswrr_qdisc_util = {
-+	.id		= "nsswrr",
-+	.parse_qopt	= nsswrr_parse_opt,
-+	.print_qopt	= nsswrr_print_opt,
-+	.parse_copt	= nsswrr_parse_class_opt,
-+	.print_copt	= nsswrr_print_class_opt,
-+};
-+
-+/* ======================== NSSWFQ =======================*/
-+
-+static void nsswfq_explain_qdisc(void)
-+{
-+	fprintf(stderr, "Usage (qdisc): ... nsswfq [ accel_mode ]\n");
-+}
-+
-+static void nsswfq_explain_class(void)
-+{
-+	fprintf(stderr, "Usage (class): ... nsswfq quantum BYTES ]\n");
-+}
-+
-+static int nsswfq_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct tc_nsswfq_qopt opt;
-+	bool accel_mode = false;
-+	struct rtattr *tail;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (matches(*argv, "help") == 0) {
-+			nsswfq_explain_qdisc();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "NSSWFQ: What is \"%s\" ?\n", *argv);
-+			nsswfq_explain_qdisc();
-+			return -1;
-+		}
-+		argc--, argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSWFQ_QDISC_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsswfq_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSWFQ_MAX + 1];
-+	struct tc_nsswfq_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSWFQ_MAX, opt);
-+
-+	if (tb[TCA_NSSWFQ_QDISC_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSWFQ_QDISC_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSWFQ_QDISC_PARMS]);
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+static int nsswfq_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	int ok = 0;
-+	struct rtattr *tail;
-+	struct tc_nsswfq_class_qopt opt;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "quantum") == 0) {
-+			NEXT_ARG();
-+			if (get_size(&opt.quantum, *argv)) {
-+				fprintf(stderr, "Illegal \"quantum\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nsswfq_explain_class();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nsswfq_explain_class();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!ok) {
-+		nsswfq_explain_class();
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSWFQ_CLASS_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsswfq_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSWFQ_MAX + 1];
-+	struct tc_nsswfq_class_qopt *qopt;
-+	SPRINT_BUF(b1);
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSWFQ_MAX, opt);
-+
-+	if (tb[TCA_NSSWFQ_CLASS_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSWFQ_CLASS_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSWFQ_CLASS_PARMS]);
-+
-+	fprintf(f, "quantum %s ", sprint_size(qopt->quantum, b1));
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nsswfq_qdisc_util = {
-+	.id		= "nsswfq",
-+	.parse_qopt	= nsswfq_parse_opt,
-+	.print_qopt	= nsswfq_print_opt,
-+	.parse_copt	= nsswfq_parse_class_opt,
-+	.print_copt	= nsswfq_print_class_opt,
-+};
-+
-+/* ======================== NSSHTB =======================*/
-+
-+static void nsshtb_explain_qdisc(void)
-+{
-+	fprintf(stderr,
-+		"Usage: ... nsshtb [ r2q ] [ accel_mode ]\n"
-+	);
-+}
-+
-+static void nsshtb_explain_class(void)
-+{
-+	fprintf(stderr, "Usage: ... nsshtb priority 0-3 [ quantum BYTES ] [ rate BPS ] [ burst BYTES ] [crate BPS ] [ cburst BYTES ]\n");
-+	fprintf(stderr, "                 [ overhead BYTES ] \n");
-+}
-+
-+static void nsshtb_explain1(char *arg)
-+{
-+	fprintf(stderr, "NSSHTB: Illegal \"%s\"\n", arg);
-+}
-+
-+static int nsshtb_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct tc_nsshtb_qopt opt;
-+	struct rtattr *tail;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "r2q") == 0) {
-+			NEXT_ARG();
-+			if (opt.r2q != 0) {
-+				fprintf(stderr, "NSSHTB: Double \"r2q\"\n");
-+				return -1;
-+			}
-+			if (get_u32(&opt.r2q, *argv, 10) < 0) {
-+				nsshtb_explain1("r2q");
-+				return -1;
-+			}
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nsshtb_explain_qdisc();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "NSSHTB: What is \"%s\" ?\n", *argv);
-+			nsshtb_explain_qdisc();
-+			return -1;
-+		}
-+		argc--, argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSHTB_QDISC_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsshtb_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSHTB_MAX + 1];
-+	struct tc_nsshtb_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSHTB_MAX, opt);
-+
-+	if (tb[TCA_NSSHTB_QDISC_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSHTB_QDISC_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSHTB_QDISC_PARMS]);
-+
-+	if (qopt->r2q != 0)
-+		fprintf(f, "r2q %u ", qopt->r2q);
-+
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+static int nsshtb_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	int ok = 0;
-+	struct rtattr *tail;
-+	struct tc_nsshtb_class_qopt opt;
-+	int crate = 0;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "burst") == 0) {
-+			NEXT_ARG();
-+			if (opt.burst) {
-+				fprintf(stderr, "Double \"burst\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.burst, *argv)) {
-+				fprintf(stderr, "Illegal \"burst\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "rate") == 0) {
-+			NEXT_ARG();
-+			if (opt.rate) {
-+				fprintf(stderr, "Double \"rate\" spec\n");
-+				return -1;
-+			}
-+			if (get_rate(&opt.rate, *argv)) {
-+				fprintf(stderr, "Illegal \"rate\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "cburst") == 0) {
-+			NEXT_ARG();
-+			if (opt.cburst) {
-+				fprintf(stderr, "Double \"cburst\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.cburst, *argv)) {
-+				fprintf(stderr, "Illegal \"cburst\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "crate") == 0) {
-+			NEXT_ARG();
-+			if (opt.crate) {
-+				fprintf(stderr, "Double \"crate\" spec\n");
-+				return -1;
-+			}
-+			if (get_rate(&opt.crate, *argv)) {
-+				fprintf(stderr, "Illegal \"crate\"\n");
-+				return -1;
-+			}
-+			crate++;
-+			ok++;
-+		} else if (strcmp(*argv, "priority") == 0) {
-+			NEXT_ARG();
-+			if (opt.priority) {
-+				fprintf(stderr, "Double \"priority\" spec\n");
-+				return -1;
-+			}
-+			if (get_u32(&opt.priority, *argv, 10) < 0) {
-+				fprintf(stderr, "Illegal \"priority\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "quantum") == 0) {
-+			NEXT_ARG();
-+			if (opt.quantum) {
-+				fprintf(stderr, "Double \"quantum\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.quantum, *argv)) {
-+				fprintf(stderr, "Illegal \"quantum\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "overhead") == 0) {
-+			NEXT_ARG();
-+			if (opt.overhead) {
-+				fprintf(stderr, "Double \"overhead\" spec\n");
-+				return -1;
-+			}
-+			if (get_size(&opt.overhead, *argv)) {
-+				fprintf(stderr, "Illegal \"overhead\"\n");
-+				return -1;
-+			}
-+			ok++;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nsshtb_explain_class();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nsshtb_explain_class();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!ok) {
-+		nsshtb_explain_class();
-+		return -1;
-+	}
-+
-+	if (opt.rate && !opt.burst) {
-+		fprintf(stderr, "\"burst\" required if \"rate\" is specified.\n");
-+		return -1;
-+	}
-+
-+	if (!crate) {
-+		fprintf(stderr, "\"crate\" is required.\n");
-+		return -1;
-+	}
-+
-+	if (opt.crate && !opt.cburst) {
-+		fprintf(stderr, "\"cburst\" required if \"crate\" is non-zero.\n");
-+		return -1;
-+	}
-+
-+	if (opt.priority > 3) {
-+		fprintf(stderr, "\"priority\" should be an integer between 0 and 3.\n");
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSHTB_CLASS_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nsshtb_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSHTB_MAX + 1];
-+	struct tc_nsshtb_class_qopt *qopt;
-+	SPRINT_BUF(b1);
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSHTB_MAX, opt);
-+
-+	if (tb[TCA_NSSHTB_CLASS_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSHTB_CLASS_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSHTB_CLASS_PARMS]);
-+
-+	print_size(PRINT_FP, NULL, "burst %s ", qopt->burst);
-+	tc_print_rate(PRINT_FP, NULL, "rate %s ", qopt->rate);
-+	print_size(PRINT_FP, NULL, "cburst %s ", qopt->cburst);
-+	tc_print_rate(PRINT_FP, NULL, "crate %s ", qopt->crate);
-+	fprintf(f, "priority %u ", qopt->priority);
-+	print_size(PRINT_FP, NULL, "quantum %s ", qopt->quantum);
-+	print_size(PRINT_FP, NULL, "overhead %s ", qopt->overhead);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nsshtb_qdisc_util = {
-+	.id		= "nsshtb",
-+	.parse_qopt	= nsshtb_parse_opt,
-+	.print_qopt	= nsshtb_print_opt,
-+	.parse_copt	= nsshtb_parse_class_opt,
-+	.print_copt	= nsshtb_print_class_opt,
-+};
-+
-+/* ======================== NSSBLACKHOLE ======================= */
-+
-+static void nssblackhole_explain(void)
-+{
-+	fprintf(stderr, "Usage: ...  nssblackhole [ set_default ] [ accel_mode ]\n");
-+}
-+
-+static int nssblackhole_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
-+{
-+	struct rtattr *tail;
-+	struct tc_nssblackhole_qopt opt;
-+	bool accel_mode = false;
-+
-+	memset(&opt, 0, sizeof(opt));
-+
-+	while (argc > 0) {
-+		if (strcmp(*argv, "set_default") == 0) {
-+			opt.set_default = 1;
-+		} else if (strcmp(*argv, "accel_mode") == 0) {
-+			NEXT_ARG();
-+			if (get_u8(&opt.accel_mode, *argv, 0)) {
-+				fprintf(stderr, "Illegal accel_mode value\n");
-+				return -1;
-+			}
-+			accel_mode = true;
-+		} else if (strcmp(*argv, "help") == 0) {
-+			nssblackhole_explain();
-+			return -1;
-+		} else {
-+			fprintf(stderr, "What is \"%s\"?\n", *argv);
-+			nssblackhole_explain();
-+			return -1;
-+		}
-+		argc--; argv++;
-+	}
-+
-+	if (!accel_mode) {
-+		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
-+	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
-+		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
-+		return -1;
-+	}
-+
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
-+	addattr_l(n, 1024, TCA_NSSBLACKHOLE_PARMS, &opt, sizeof(opt));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+
-+	return 0;
-+}
-+
-+static int nssblackhole_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
-+{
-+	struct rtattr *tb[TCA_NSSBLACKHOLE_MAX + 1];
-+	struct tc_nssblackhole_qopt *qopt;
-+
-+	if (opt == NULL)
-+		return 0;
-+
-+	parse_rtattr_nested(tb, TCA_NSSBLACKHOLE_MAX, opt);
-+
-+	if (tb[TCA_NSSBLACKHOLE_PARMS] == NULL)
-+		return -1;
-+
-+	if (RTA_PAYLOAD(tb[TCA_NSSBLACKHOLE_PARMS]) < sizeof(*qopt))
-+		return -1;
-+
-+	qopt = RTA_DATA(tb[TCA_NSSBLACKHOLE_PARMS]);
-+
-+	if (qopt->set_default)
-+		fprintf(f, "set_default ");
-+
-+	fprintf(f, "accel_mode %d ", qopt->accel_mode);
-+
-+	return 0;
-+}
-+
-+struct qdisc_util nssblackhole_qdisc_util = {
-+	.id		= "nssblackhole",
-+	.parse_qopt	= nssblackhole_parse_opt,
-+	.print_qopt	= nssblackhole_print_opt,
-+};
-
diff --git a/package/network/utils/iproute2/patches/500-add-nssmirred.patch b/package/network/utils/iproute2/patches/500-add-nssmirred.patch
deleted file mode 100644
index e48058e6..00000000
--- a/package/network/utils/iproute2/patches/500-add-nssmirred.patch
+++ /dev/null
@@ -1,243 +0,0 @@
---- a/tc/Makefile	2019-04-08 12:48:15.425854828 +0530
-+++ b/tc/Makefile	2019-04-08 13:03:17.204741000 +0530
-@@ -54,6 +54,7 @@ TCMODULES += m_bpf.o
- TCMODULES += m_sample.o
- TCMODULES += m_ct.o
- TCMODULES += m_gate.o
-+TCMODULES += m_nssmirred.o
- TCMODULES += p_ip.o
- TCMODULES += p_ip6.o
- TCMODULES += p_icmp.o
---- /dev/null	1970-01-01 05:30:00.000000000 +0530
-+++ b/tc/m_nssmirred.c	2019-06-19 14:25:51.369793000 +0530
-@@ -0,0 +1,183 @@
-+/*
-+ **************************************************************************
-+ * Copyright (c) 2019 The Linux Foundation. All rights reserved.
-+ * Permission to use, copy, modify, and/or distribute this software for
-+ * any purpose with or without fee is hereby granted, provided that the
-+ * above copyright notice and this permission notice appear in all copies.
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
-+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ **************************************************************************
-+ */
-+
-+#include <stdio.h>
-+#include <stdlib.h>
-+#include <unistd.h>
-+#include <syslog.h>
-+#include <fcntl.h>
-+#include <sys/socket.h>
-+#include <netinet/in.h>
-+#include <arpa/inet.h>
-+#include <string.h>
-+#include "utils.h"
-+#include "tc_util.h"
-+#include "tc_common.h"
-+#include <linux/tc_act/tc_nssmirred.h>
-+
-+/*
-+ * explain()
-+ *	API to print the explaination of nssmirred action statement's
-+ *	elements.
-+ */
-+static void explain(void)
-+{
-+	fprintf(stderr, "Usage: nssmirred redirect <dev TO_DEVICENAME fromdev FROM_DEVICENAME> \n");
-+	fprintf(stderr, "where: \n");
-+	fprintf(stderr, "\tTO_DEVICENAME is the devicename to redirect to\n");
-+	fprintf(stderr, "\tFROM_DEVICENAME is the devicename to redirect from\n");
-+}
-+
-+/*
-+ * usage()
-+ *	API to show the usage of the nssmirred action.
-+ */
-+static void usage(void)
-+{
-+	explain();
-+	exit(-1);
-+}
-+
-+/*
-+ * parse_nss_mirred()
-+ *	Parse and validate the nssmirred action statement.
-+ */
-+static int parse_nss_mirred(struct action_util *a, int *argc_p, char ***argv_p,
-+	     int tca_id, struct nlmsghdr *n)
-+{
-+	int idx, argc = *argc_p;
-+	char **argv = *argv_p;
-+	struct tc_nss_mirred p;
-+	struct rtattr *tail;
-+
-+	if (argc < 0) {
-+		fprintf(stderr, "nssmirred bad argument count %d. Try option \"help\"\n", argc);
-+		goto error;
-+	}
-+
-+	if (matches(*argv, "nssmirred")) {
-+		fprintf(stderr, "nssmirred bad argument %s. Try option \"help\"\n", *argv);
-+		goto error;
-+	}
-+
-+	NEXT_ARG();
-+	if (!matches(*argv, "help")) {
-+		usage();
-+	}
-+
-+	if (matches(*argv, "redirect")) {
-+		fprintf(stderr, "nssmirred bad argument %s. Try option \"help\"\n", *argv);
-+		goto error;
-+	}
-+
-+	NEXT_ARG();
-+	if (matches(*argv, "dev")) {
-+		fprintf(stderr, "nssmirred: bad value %s. Try option \"help\"\n", *argv);
-+		goto error;
-+	}
-+
-+	NEXT_ARG();
-+	memset(&p, 0, sizeof(struct tc_nss_mirred));
-+	if ((idx = ll_name_to_index(*argv)) == 0) {
-+		fprintf(stderr, "Cannot find to device \"%s\"\n", *argv);
-+		goto error;
-+	}
-+
-+	p.to_ifindex = idx;
-+	NEXT_ARG();
-+	if (matches(*argv, "fromdev")) {
-+		fprintf(stderr, "nssmirred: bad value %s. Try option \"help\"\n", *argv);
-+		goto error;
-+	}
-+
-+	NEXT_ARG();
-+	if ((idx = ll_name_to_index(*argv)) == 0) {
-+		fprintf(stderr, "Cannot find from device \"%s\"\n", *argv);
-+		goto error;
-+	}
-+
-+	p.from_ifindex = idx;
-+	p.action = TC_ACT_STOLEN;
-+	tail = NLMSG_TAIL(n);
-+	addattr_l(n, MAX_MSG, tca_id, NULL, 0);
-+	addattr_l(n, MAX_MSG, TCA_NSS_MIRRED_PARMS, &p, sizeof (p));
-+	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
-+	argc--;
-+	argv++;
-+	*argc_p = argc;
-+	*argv_p = argv;
-+	return 0;
-+
-+error:
-+	return -1;
-+}
-+
-+/*
-+ * print_nss_mirred()
-+ *	Print information related to nssmirred action.
-+ */
-+static int print_nss_mirred(struct action_util *au, FILE * f, struct rtattr *arg)
-+{
-+	struct tc_nss_mirred *p;
-+	struct rtattr *tb[TCA_NSS_MIRRED_MAX + 1];
-+	const char *from_dev, *to_dev;
-+
-+	if (arg == NULL) {
-+		return -1;
-+	}
-+
-+	parse_rtattr_nested(tb, TCA_NSS_MIRRED_MAX, arg);
-+
-+	if (tb[TCA_NSS_MIRRED_PARMS] == NULL) {
-+		fprintf(f, "[NULL nssmirred parameters]");
-+		goto error;
-+	}
-+
-+	p = RTA_DATA(tb[TCA_NSS_MIRRED_PARMS]);
-+	if ((from_dev = ll_index_to_name(p->from_ifindex)) == 0) {
-+		fprintf(stderr, "Invalid interface (index: %d)\n", p->from_ifindex);
-+		goto error;
-+	}
-+
-+	if ((to_dev = ll_index_to_name(p->to_ifindex)) == 0) {
-+		fprintf(stderr, "Invalid interface (index: %d)\n", p->to_ifindex);
-+		goto error;
-+	}
-+
-+	fprintf(f, "nssmirred (%s to device %s) stolen\n", from_dev, to_dev);
-+	fprintf(f, "\tindex %d ref %d bind %d\n",p->index,p->refcnt,p->bindcnt);
-+
-+	if (show_stats) {
-+		if (tb[TCA_NSS_MIRRED_TM]) {
-+			struct tcf_t *tm = RTA_DATA(tb[TCA_NSS_MIRRED_TM]);
-+			print_tm(f,tm);
-+		}
-+	}
-+	return 0;
-+
-+error:
-+	return -1;
-+}
-+
-+/*
-+ * nssmirred_action_util
-+ *	nssmirred action utility structure.
-+ */
-+struct action_util nssmirred_action_util = {
-+	.id = "nssmirred",
-+	.parse_aopt = parse_nss_mirred,
-+	.print_aopt = print_nss_mirred,
-+};
---- /dev/null	1970-01-01 05:30:00.000000000 +0530
-+++ a/include/linux/tc_act/tc_nssmirred.h	2019-06-19 14:25:40.787768000 +0530
-@@ -0,0 +1,44 @@
-+/*
-+ **************************************************************************
-+ * Copyright (c) 2019 The Linux Foundation. All rights reserved.
-+ * Permission to use, copy, modify, and/or distribute this software for
-+ * any purpose with or without fee is hereby granted, provided that the
-+ * above copyright notice and this permission notice appear in all copies.
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
-+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ **************************************************************************
-+ */
-+
-+#ifndef __LINUX_TC_NSS_MIR_H
-+#define __LINUX_TC_NSS_MIR_H
-+
-+#include <linux/types.h>
-+#include <linux/pkt_cls.h>
-+
-+/*
-+ * tc_nss_mirred
-+ *	Structure for nssmirred action.
-+ */
-+struct tc_nss_mirred {
-+	tc_gen;
-+	__u32                   from_ifindex;  /* ifindex of the port to be redirected from */
-+	__u32                   to_ifindex;  /* ifindex of the port to be redirected to */
-+};
-+
-+/*
-+ * Types of nssmirred action parameters.
-+ */
-+enum {
-+	TCA_NSS_MIRRED_UNSPEC,
-+	TCA_NSS_MIRRED_TM,
-+	TCA_NSS_MIRRED_PARMS,
-+	__TCA_NSS_MIRRED_MAX
-+};
-+#define TCA_NSS_MIRRED_MAX (__TCA_NSS_MIRRED_MAX - 1)
-+
-+#endif	/* __LINUX_TC_NSS_MIR_H */
diff --git a/package/network/utils/linux-atm/Makefile b/package/network/utils/linux-atm/Makefile
index c74febcb..c48309da 100644
--- a/package/network/utils/linux-atm/Makefile
+++ b/package/network/utils/linux-atm/Makefile
@@ -10,7 +10,7 @@ include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=linux-atm
 PKG_VERSION:=2.5.2
-PKG_RELEASE:=7
+PKG_RELEASE:=8
 
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
 PKG_SOURCE_URL:=@SF/$(PKG_NAME)
@@ -21,6 +21,7 @@ PKG_BUILD_PARALLEL:=1
 PKG_LICENSE:=GPL-2.0+
 PKG_CPE_ID:=cpe:/a:linux-atm:linux-atm
 PKG_FIXUP:=autoreconf
+PKG_FLAGS:=nonshared
 
 include $(INCLUDE_DIR)/package.mk
 
@@ -98,6 +99,8 @@ endef
 
 $(foreach t,$(ATM_DEBUG_TOOLS),$(eval $(call GenAtmPlugin,atm-$(t),$(t))))
 
+TARGET_CFLAGS += -I$(LINUX_DIR)/user_headers/include
+
 define Build/Configure
 	$(call Build/Configure/Default)
 	# prevent autoheader invocation
diff --git a/package/network/utils/linux-atm/patches/000-debian_16.patch b/package/network/utils/linux-atm/patches/000-debian_16.patch
deleted file mode 100644
index 4abaac07..00000000
--- a/package/network/utils/linux-atm/patches/000-debian_16.patch
+++ /dev/null
@@ -1,270 +0,0 @@
---- a/src/arpd/io.c
-+++ b/src/arpd/io.c
-@@ -277,7 +277,8 @@ static void accept_new(void)
-     struct atm_qos qos;
-     ENTRY *entry;
-     VCC *vcc;
--    int fd,len,size,error;
-+    int fd,error;
-+    socklen_t len,size;
- 
-     len = sizeof(addr);
-     if ((fd = accept(incoming,(struct sockaddr *) &addr,&len)) < 0) {
-@@ -614,7 +615,8 @@ int ip_itf_info(int number,uint32_t *ip,
- 
- int get_local(int fd,struct sockaddr_atmsvc *addr)
- {
--    int length,result;
-+    int result;
-+    size_t length;
- 
-     length = sizeof(struct sockaddr_atmsvc);
-     result = getsockname(fd,(struct sockaddr *) addr,&length);
---- a/src/arpd/table.c
-+++ b/src/arpd/table.c
-@@ -101,7 +101,8 @@ static void dump_vcc(VCC *vcc)
-     char addr_buf[MAX_ATM_ADDR_LEN+1];
-     char qos_buf[MAX_ATM_QOS_LEN+1];
-     struct atm_qos qos;
--    int size,sndbuf;
-+    int sndbuf;
-+    socklen_t size;
- 
-     size = sizeof(addr);
-     if (getpeername(vcc->fd,(struct sockaddr *) &addr,&size) < 0) {
---- a/src/ilmid/asn1/asn_int.c
-+++ b/src/ilmid/asn1/asn_int.c
-@@ -185,7 +185,7 @@ FILE* f _AND_
- AsnInt* v _AND_
- unsigned short int indent)
- {
--    fprintf(f,"%d", *v);
-+    fprintf(f,"%ld", *v);
- } 
- 
- 
-@@ -370,5 +370,5 @@ FILE* f _AND_
- UAsnInt* v _AND_
- unsigned short int indent)
- {
--    fprintf(f,"%u", *v);
-+    fprintf(f,"%lu", *v);
- } 
---- a/src/ilmid/asn1/asn_oid.c
-+++ b/src/ilmid/asn1/asn_oid.c
-@@ -127,7 +127,7 @@ unsigned short int indent)
-     if (firstArcNum > 2)
-         firstArcNum = 2;
- 
--    fprintf(f,"%u %u", firstArcNum, arcNum - (firstArcNum * 40));
-+    fprintf(f,"%d %lu", firstArcNum, arcNum - (firstArcNum * 40));
- 
-     for (; i < v->octetLen ; )
-     {
-@@ -136,7 +136,7 @@ unsigned short int indent)
- 
-         arcNum = (arcNum << 7) + (v->octs[i] & 0x7f);
-         i++;
--        fprintf(f," %u", arcNum);
-+        fprintf(f," %lu", arcNum);
-     }
-     fprintf(f,"}");
- 
---- a/src/lane/connect.c
-+++ b/src/lane/connect.c
-@@ -258,7 +258,8 @@ static int
- data_handler(const Event_t *event, void *funcdata)
- {
-   Conn_t *tmp, *newconn;
--  int fd, nbytes;
-+  int fd;
-+  socklen_t nbytes;
-   static char buffer[BUFSIZE];
-   LaneControl_t *ctmp;
-   struct sockaddr_atmsvc addr;
---- a/src/lane/connect_bus.c
-+++ b/src/lane/connect_bus.c
-@@ -170,7 +170,8 @@ static int
- data_handler(const Event_t *event, void *funcdata)
- {
-   Conn_t *tmp, *newconn;
--  int fd, nbytes;
-+  int fd;
-+  socklen_t nbytes;
-   static char buffer[BUFSIZE];
-   struct sockaddr_atmsvc addr;
- 
---- a/src/lane/lane_atm.c
-+++ b/src/lane/lane_atm.c
-@@ -138,7 +138,7 @@ atm_connect_back(const AtmAddr_t *our_ad
-   struct atm_blli blli;
-   struct atm_qos qos;
-   int fd, ret;
--  int len = sizeof(address);
-+  socklen_t len = sizeof(address);
-   
-   fd = socket(PF_ATMSVC, SOCK_DGRAM, 0);
-   if (fd <0) {
---- a/src/lane/lecs.c
-+++ b/src/lane/lecs.c
-@@ -119,7 +119,7 @@ int main(int argc, char **argv)
-   int just_dump=0;
-   fd_set fds;
-   struct sockaddr_atmsvc client;
--  int len;
-+  socklen_t len;
-   unsigned char buffer[P_SIZE];
- 
-   while(i!=-1) {
---- a/src/lib/ans.c
-+++ b/src/lib/ans.c
-@@ -41,7 +41,7 @@
- static int ans(const char *text,int wanted,void *result,int res_len)
- {
-     unsigned char answer[MAX_ANSWER];
--    unsigned char name[MAX_NAME];
-+    char name[MAX_NAME];
-     unsigned char *pos,*data,*found;
-     int answer_len,name_len,data_len,found_len;
-     int questions,answers;
---- a/src/lib/sdu2cell.c
-+++ b/src/lib/sdu2cell.c
-@@ -15,7 +15,8 @@ int sdu2cell(int s,int sizes,const int *
- {
-     struct atm_qos qos;
-     int trailer,total,cells;
--    int size,i;
-+    int i;
-+    socklen_t size;
- 
-     size = sizeof(qos);
-     if (getsockopt(s,SOL_AAL,SO_ATMQOS,&qos,&size) < 0) return -1;
---- a/src/lib/unix.c
-+++ b/src/lib/unix.c
-@@ -63,8 +63,8 @@ int un_attach(const char *path)
- int un_recv_connect(int s,void *buf,int size)
- {
-     struct sockaddr_un addr;
--    int addr_size;
-     int len;
-+    socklen_t addr_size;
- 
-     addr_size = sizeof(addr);
-     len = recvfrom(s,buf,size,0,(struct sockaddr *) &addr,&addr_size);
---- a/src/maint/atmtcp.c
-+++ b/src/maint/atmtcp.c
-@@ -817,7 +817,8 @@ int main(int argc,char **argv)
- 	}
- 	else if (!strcmp(ARG,"listen") ||
- 	  (do_background = !strcmp(ARG,"listen-bg"))) {
--	    int fd,port,addr_len;
-+	    int fd,port;
-+	    socklen_t addr_len;
- 	    int *fd2 = alloc_t(int);
- 
- 	    if ((fd = socket(PF_INET,SOCK_STREAM,0)) < 0) {
---- a/src/maint/hediag.c
-+++ b/src/maint/hediag.c
-@@ -1,6 +1,7 @@
- #include <stdio.h>
- #include <stdlib.h>
- #include <unistd.h>
-+#include <string.h>
- #include <sys/ioctl.h>
- #include <sys/types.h>
- #include <sys/socket.h>
---- a/src/mpoad/io.c
-+++ b/src/mpoad/io.c
-@@ -521,7 +521,8 @@ static int msg_from_mps(int slot)
- static int accept_conn(int slot)
- {
-         struct sockaddr_atmsvc sa;
--        int i, new_fd, sa_len;
-+        int i, new_fd;
-+        socklen_t sa_len;
- 
-         sa_len = sizeof(sa);
-         new_fd = accept(fds[slot].fd, (struct sockaddr *)&sa, &sa_len);
---- a/src/sigd/io.c
-+++ b/src/sigd/io.c
-@@ -355,7 +355,7 @@ int get_pvc(int itf,int *vci)
-     error = 0;
-     if (bind(s,(struct sockaddr *) &addr,sizeof(addr)) < 0) error = errno;
-     else {
--	int size;
-+	socklen_t size;
- 
- 	size = sizeof(addr);
- 	if (getsockname(s,(struct sockaddr *) &addr,&size) < 0)
---- a/src/test/ttcp.c
-+++ b/src/test/ttcp.c
-@@ -92,7 +92,8 @@ struct sockaddr_in frominet;
- struct sockaddr_atmsvc satm;
- struct atm_qos qos;
- 
--int domain, fromlen;
-+int domain;
-+socklen_t fromlen;
- int fd;				/* fd of network socket */
- 
- int buflen = 8 * 1024;		/* length of buffer */
-@@ -466,7 +467,7 @@ int no_check = 0;
- 	    
- 	    {
- 		struct sockaddr_atmsvc peer;
--		int peerlen = sizeof(peer);
-+		socklen_t peerlen = sizeof(peer);
- 		if (getpeername(fd, (struct sockaddr *) &peer, 
- 				&peerlen) < 0) {
- 		    err("getpeername");
-@@ -498,7 +499,7 @@ int no_check = 0;
-     /* set socket buffer size */
- #if defined(SO_SNDBUF) || defined(SO_RCVBUF)
-     if (sockbufsize) {
--	int len;
-+	socklen_t len;
- 
- 	if (trans) {
- 	    /* set send socket buffer if we are transmitting */    
---- a/src/mpoad/mpcd.8
-+++ b/src/mpoad/mpcd.8
-@@ -28,7 +28,7 @@ mpcd \- ATM MPOA (Multi\-Protocol Over A
- .B ]]
- .SH DESCRIPTION
- MPOA client
--.SM(MPC) is responsible for creating and receiving
-+.SM (MPC) is responsible for creating and receiving
- internetwork layer shortcuts. Using these shortcuts MPCs forward
- unicast internetwork layer packets effectively over ATM without need
- for routing protocols.
-@@ -43,7 +43,7 @@ accepts shortcuts and packets arriving o
- shortcuts is done with the help of
- .SM MPOA
- server
--.SM(MPS).
-+.SM (MPS).
- .PP
- Just as the Linux
- .SM LAN
---- a/src/led/zeppelin.8
-+++ b/src/led/zeppelin.8
-@@ -99,7 +99,7 @@ Ring and ATM parts of the ELAN, so using
- recommended. Token Ring support has received less testing than its
- Ethernet counterpart.
- .SH FILES
--.IP \fI/var/run/lec[interface number].pid\fP
-+.IP \fI/var/run/lec[interface\ number].pid\fP
- The file containing the process id of zeppelin.
- .SH BUGS
- John Bonham died 1980 and Led Zeppelin broke.
---- a/src/sigd/atmsigd.conf.4
-+++ b/src/sigd/atmsigd.conf.4
-@@ -125,7 +125,7 @@ a comment. The `#' character cannot be e
- .P
- If an option is specified in \fBatmsigd.conf\fP and on the command
- line, the command line has priority.
--.COMPATIBILITY
-+.SH COMPATIBILITY
- Certain options used by past versions of \fBatmsigd\fP but no longer documented
- on the man page are still recognized and supported, but they also yield a
- warning message. Future versions of \fBatmsigd\fP will not recognize those
diff --git a/package/network/utils/linux-atm/patches/510-remove-LINUX_NETDEVICE-hack.patch b/package/network/utils/linux-atm/patches/510-remove-LINUX_NETDEVICE-hack.patch
index d76ec1ea..c16df18a 100644
--- a/package/network/utils/linux-atm/patches/510-remove-LINUX_NETDEVICE-hack.patch
+++ b/package/network/utils/linux-atm/patches/510-remove-LINUX_NETDEVICE-hack.patch
@@ -28,8 +28,8 @@ in Linux 4.20.
  #include <sys/socket.h>
 -#define _LINUX_NETDEVICE_H /* glibc2 */
  #include <linux/types.h>
+ #include <linux/if.h>
  #include <linux/if_arp.h>
- 
 --- a/src/arpd/io.c
 +++ b/src/arpd/io.c
 @@ -21,7 +21,6 @@
@@ -48,5 +48,5 @@ in Linux 4.20.
  #include <netinet/in.h> /* for ntohs, etc. */
 -#define _LINUX_NETDEVICE_H /* very crude hack for glibc2 */
  #include <linux/types.h>
+ #include <linux/if.h>
  #include <linux/if_arp.h>
- #include <linux/if_ether.h>
diff --git a/package/network/utils/linux-atm/patches/600-fix-format-errors.patch b/package/network/utils/linux-atm/patches/600-fix-format-errors.patch
deleted file mode 100644
index ef484f2f..00000000
--- a/package/network/utils/linux-atm/patches/600-fix-format-errors.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/src/test/ttcp.c
-+++ b/src/test/ttcp.c
-@@ -664,7 +664,7 @@ int no_check = 0;
-     exit(0);
- 
-   usage:
--    fprintf(stderr, Usage);
-+    fprintf(stderr, "%s", Usage);
-     exit(1);
- }
- 
diff --git a/package/network/utils/linux-atm/patches/700-musl-include.patch b/package/network/utils/linux-atm/patches/700-musl-include.patch
deleted file mode 100644
index 2b2268d8..00000000
--- a/package/network/utils/linux-atm/patches/700-musl-include.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/src/include/atmd.h
-+++ b/src/include/atmd.h
-@@ -10,6 +10,7 @@
- 
- #include <stdint.h>
- #include <stdio.h>
-+#include <string.h>
- #include <sys/types.h>
- #include <sys/time.h>
- 
---- a/src/lib/unix.c
-+++ b/src/lib/unix.c
-@@ -8,6 +8,7 @@
- 
- #include <stdlib.h>
- #include <stdio.h>
-+#include <string.h>
- #include <unistd.h>
- #include <errno.h>
- #include <sys/types.h>
---- a/src/sigd/kernel.c
-+++ b/src/sigd/kernel.c
-@@ -8,6 +8,7 @@
- 
- #include <stdlib.h>
- #include <stdio.h>
-+#include <string.h>
- #include <errno.h>
- #include <assert.h>
- 
diff --git a/package/network/utils/linux-atm/patches/800-include_sockios.patch b/package/network/utils/linux-atm/patches/800-include_sockios.patch
deleted file mode 100644
index edb385ca..00000000
--- a/package/network/utils/linux-atm/patches/800-include_sockios.patch
+++ /dev/null
@@ -1,21 +0,0 @@
---- a/src/maint/saaldump.c	2020-03-29 22:58:01.089711789 +0200
-+++ b/src/maint/saaldump.c	2020-03-29 22:59:17.564639387 +0200
-@@ -6,6 +6,7 @@
- #include <config.h>
- #endif
-
-+#include <linux/sockios.h>
- #include <stdlib.h>
- #include <stdarg.h>
- #include <stdio.h>
---- a/src/maint/atmdump.c	2020-03-29 22:58:18.573694469 +0200
-+++ b/src/maint/atmdump.c	2020-03-29 22:58:49.956729365 +0200
-@@ -6,6 +6,7 @@
- #include <config.h>
- #endif
-
-+#include <linux/sockios.h>
- #include <stdlib.h>
- #include <stdio.h>
- #include <unistd.h>
-
diff --git a/package/network/utils/linux-atm/patches/900-add_5.19_support.patch b/package/network/utils/linux-atm/patches/900-add_5.19_support.patch
deleted file mode 100644
index 0dc26dc4..00000000
--- a/package/network/utils/linux-atm/patches/900-add_5.19_support.patch
+++ /dev/null
@@ -1,17 +0,0 @@
---- a/src/maint/Makefile.am
-+++ b/src/maint/Makefile.am
-@@ -1,5 +1,5 @@
- BOOTPGMS=atmaddr esi
--SYSPGMS=atmloop atmtcp enitune zntune hediag # nstune
-+SYSPGMS=atmloop atmtcp enitune hediag # nstune
- USRPGMS=atmdiag atmdump sonetdiag saaldump
- 
- INCLUDES=-I$(srcdir)/../q2931 -I$(srcdir)/../saal -I.
-@@ -14,7 +14,6 @@ esi_SOURCES = esi.c
- atmloop_SOURCES = atmloop.c
- atmtcp_SOURCES = atmtcp.c
- enitune_SOURCES = enitune.c
--zntune_SOURCES = zntune.c
- #nstune_SOURCES = nstune.c
- 
- atmdiag_SOURCES = atmdiag.c
diff --git a/package/system/ubus/Makefile b/package/system/ubus/Makefile
index 40dafd68..9a807852 100644
--- a/package/system/ubus/Makefile
+++ b/package/system/ubus/Makefile
@@ -5,9 +5,9 @@ PKG_RELEASE:=1
 
 PKG_SOURCE_PROTO:=git
 PKG_SOURCE_URL=$(PROJECT_GIT)/project/ubus.git
-PKG_SOURCE_DATE:=2024-10-20
-PKG_SOURCE_VERSION:=252a9b0c1774790fb9c25735d5a09c27dba895db
-PKG_MIRROR_HASH:=475d96cc267370eb2e6ec808fc88285267cece1c5956d3966a060932d8b95175
+PKG_SOURCE_DATE:=2025-01-02
+PKG_SOURCE_VERSION:=afa57cce0aff82f4a7a0e509d4387ebc23dd3be7
+PKG_MIRROR_HASH:=a0b3c1961f5f49d31c34a44576ce44538c3ee97bfce97f86f732d7ecc1df9798
 PKG_ABI_VERSION:=$(call abi_version_str,$(PKG_SOURCE_DATE))
 CMAKE_INSTALL:=1
 
diff --git a/package/utils/util-linux/Makefile b/package/utils/util-linux/Makefile
index 44bf22f7..83f3a8c8 100644
--- a/package/utils/util-linux/Makefile
+++ b/package/utils/util-linux/Makefile
@@ -8,12 +8,12 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=util-linux
-PKG_VERSION:=2.38.1
+PKG_VERSION:=2.40.2
 PKG_RELEASE:=1
 
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.xz
-PKG_SOURCE_URL:=@KERNEL/linux/utils/$(PKG_NAME)/v2.38
-PKG_HASH:=60492a19b44e6cf9a3ddff68325b333b8b52b6c59ce3ebd6a0ecaa4c5117e84f
+PKG_SOURCE_URL:=@KERNEL/linux/utils/$(PKG_NAME)/v2.40
+PKG_HASH:=d78b37a66f5922d70edf3bdfb01a6b33d34ed3c3cafd6628203b2a2b67c8e8b3
 PKG_CPE_ID:=cpe:/a:kernel:util-linux
 
 PKG_LICENSE:=GPL-2.0-only
@@ -25,14 +25,10 @@ PKG_LICENSE_FILES:=	COPYING					\
 			libuuid/COPYING				\
 			Documentation/licenses/COPYING.BSD-3
 
-PKG_BUILD_PARALLEL:=1
-
-PKG_FIXUP:=autoreconf
 PKG_INSTALL:=1
 
-DISABLE_NLS:=--disable-nls
-
 include $(INCLUDE_DIR)/package.mk
+include $(INCLUDE_DIR)/meson.mk
 
 define Package/util-linux/Default
   SECTION:=utils
@@ -178,6 +174,17 @@ define Package/cfdisk/description
  cfdisk is a curses-based program for partitioning any hard disk drive
 endef
 
+define Package/colrm
+$(call Package/util-linux/Default)
+  TITLE:=colrm removes selected columns from a file
+  DEPENDS:=
+endef
+
+define Package/colrm/description
+ colrm removes selected columns from a file. Input is taken from
+ standard input. Output is sent to standard output.
+endef
+
 define Package/dmesg
 $(call Package/util-linux/Default)
   TITLE:=print or control the kernel ring buffer
@@ -311,7 +318,7 @@ endef
 define Package/lsblk
 $(call Package/util-linux/Default)
   TITLE:=list block devices
-  DEPENDS:= +libblkid +libmount +libsmartcols
+  DEPENDS:= +libblkid +libmount +libsmartcols +libncurses
   SUBMENU=Disc
 endef
 
@@ -419,6 +426,17 @@ define Package/rename/description
  expression in their name by replacement
 endef
 
+define Package/rev
+$(call Package/util-linux/Default)
+  TITLE:=Reverse lines characterwise
+endef
+
+define Package/rev/description
+ rev utility copies the specified files to the standard output, reversing the
+ order of characters in every line. If no files are specified, the standard
+ input is read.
+endef
+
 define Package/partx-utils
 $(call Package/util-linux/Default)
   TITLE:=inform kernel about the presence and numbering of on-disk partitions
@@ -478,6 +496,7 @@ endef
 define Package/taskset
 $(call Package/util-linux/Default)
   TITLE:=set or retrieve a process's CPU affinity
+  ALTERNATIVES:=200:/usr/bin/taskset:/usr/bin/util-linux-taskset
 endef
 
 define Package/taskset/description
@@ -552,44 +571,70 @@ define Package/wipefs/description
  libblkid.
 endef
 
-CONFIGURE_ARGS += \
-	--disable-use-tty-group		\
-	--disable-rpath			\
-	--disable-tls			\
-	--disable-su			\
-	--disable-sulogin		\
-	--disable-makeinstall-chown	\
-	--disable-login 		\
-	--disable-nologin		\
-	--disable-lslogins		\
-	--disable-runuser		\
-	--disable-chfn-chsh		\
-	--disable-raw			\
-	--without-python		\
-	--without-udev			\
-	--without-readline		\
-	--without-libmagic		\
-	--with-ncursesw
-
-TARGET_CFLAGS += $(FPIC) -std=gnu99
+MESON_ARGS += \
+	-Dsystemd=disabled \
+	-Dtinfo=disabled \
+	-Dcryptsetup=disabled \
+	-Dlibutil=disabled \
+	-Dlibutempter=disabled \
+	-Dlibpcre2-posix=disabled \
+	-Dlibuser=disabled \
+	-Duse-tty-group=false \
+	-Duse-tls=false \
+	-Dbuild-python=disabled \
+	-Dbuild-zramctl=disabled \
+	-Dbuild-fsck=disabled \
+	-Dbuild-wipefs=disabled \
+	-Dbuild-fallocate=disabled \
+	-Dbuild-setpriv=disabled \
+	-Dbuild-hardlink=disabled \
+	-Dbuild-cramfs=disabled \
+	-Dbuild-bfs=disabled \
+	-Dbuild-minix=disabled \
+	-Dbuild-fdformat=disabled \
+	-Dbuild-lslogins=disabled \
+	-Dbuild-wdctl=disabled \
+	-Dbuild-cal=disabled \
+	-Dbuild-switch_root=disabled \
+	-Dbuild-pivot_root=disabled \
+	-Dbuild-lsmem=disabled \
+	-Dbuild-lsirq=disabled \
+	-Dbuild-irqtop=disabled \
+	-Dbuild-chmem=disabled \
+	-Dbuild-ipcrm=disabled \
+	-Dbuild-rfkill=disabled \
+	-Dbuild-tunelp=disabled \
+	-Dbuild-kill=disabled \
+	-Dbuild-last=disabled \
+	-Dbuild-utmpdump=disabled \
+	-Dbuild-line=disabled \
+	-Dbuild-mesg=disabled \
+	-Dbuild-raw=disabled \
+	-Dbuild-vipw=disabled \
+	-Dbuild-newgrp=disabled \
+	-Dbuild-chfn-chsh=disabled \
+	-Dbuild-login=disabled \
+	-Dbuild-nologin=disabled \
+	-Dbuild-sulogin=disabled \
+	-Dbuild-su=disabled \
+	-Dbuild-runuser=disabled \
+	-Dbuild-ul=disabled \
+	-Dbuild-pg=disabled \
+	-Dbuild-write=disabled \
+	-Dbuild-bash-completion=disabled \
+	-Dbuild-pylibmount=disabled \
+	-Dbuild-liblastlog2=disabled \
+	-Dreadline=disabled \
+	-Dmagic=disabled \
+	-Dncursesw=enabled
 
 define Build/InstallDev
 	$(INSTALL_DIR) $(1)/usr/lib/pkgconfig
 	$(CP) $(PKG_INSTALL_DIR)/usr/lib/pkgconfig/blkid.pc $(1)/usr/lib/pkgconfig
-	$(SED) 's,/usr/include,$$$${prefix}/include,g' $(1)/usr/lib/pkgconfig/blkid.pc
-	$(SED) 's,/usr/lib,$$$${exec_prefix}/lib,g' $(1)/usr/lib/pkgconfig/blkid.pc
 	$(CP) $(PKG_INSTALL_DIR)/usr/lib/pkgconfig/fdisk.pc $(1)/usr/lib/pkgconfig
-	$(SED) 's,/usr/include,$$$${prefix}/include,g' $(1)/usr/lib/pkgconfig/fdisk.pc
-	$(SED) 's,/usr/lib,$$$${exec_prefix}/lib,g' $(1)/usr/lib/pkgconfig/fdisk.pc
 	$(CP) $(PKG_INSTALL_DIR)/usr/lib/pkgconfig/mount.pc $(1)/usr/lib/pkgconfig
-	$(SED) 's,/usr/include,$$$${prefix}/include,g' $(1)/usr/lib/pkgconfig/mount.pc
-	$(SED) 's,/usr/lib,$$$${exec_prefix}/lib,g' $(1)/usr/lib/pkgconfig/mount.pc
 	$(CP) $(PKG_INSTALL_DIR)/usr/lib/pkgconfig/smartcols.pc $(1)/usr/lib/pkgconfig
-	$(SED) 's,/usr/include,$$$${prefix}/include,g' $(1)/usr/lib/pkgconfig/smartcols.pc
-	$(SED) 's,/usr/lib,$$$${exec_prefix}/lib,g' $(1)/usr/lib/pkgconfig/smartcols.pc
 	$(CP) $(PKG_INSTALL_DIR)/usr/lib/pkgconfig/uuid.pc $(1)/usr/lib/pkgconfig
-	$(SED) 's,/usr/include,$$$${prefix}/include,g' $(1)/usr/lib/pkgconfig/uuid.pc
-	$(SED) 's,/usr/lib,$$$${exec_prefix}/lib,g' $(1)/usr/lib/pkgconfig/uuid.pc
 
 	$(INSTALL_DIR) $(1)/usr/include/blkid
 	$(CP) $(PKG_INSTALL_DIR)/usr/include/blkid/blkid.h $(1)/usr/include/blkid
@@ -603,43 +648,37 @@ define Build/InstallDev
 	$(CP) $(PKG_INSTALL_DIR)/usr/include/libsmartcols/libsmartcols.h $(1)/usr/include/libsmartcols
 
 	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libblkid.so* $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libfdisk.so* $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libmount.so* $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libuuid.so* $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libsmartcols.so* $(1)/usr/lib
-
-	$(LN) libblkid.so.1 $(1)/usr/lib/libblkid.so
-	$(LN) libfdisk.so.1 $(1)/usr/lib/libfdisk.so
-	$(LN) libmount.so.1 $(1)/usr/lib/libmount.so
-	$(LN) libuuid.so.1 $(1)/usr/lib/libuuid.so
-	$(LN) libsmartcols.so.1 $(1)/usr/lib/libsmartcols.so
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libblkid.so* $(1)/usr/lib
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libfdisk.so* $(1)/usr/lib
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libmount.so* $(1)/usr/lib
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libuuid.so* $(1)/usr/lib
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libsmartcols.so* $(1)/usr/lib
 endef
 
 
 define Package/libfdisk/install
 	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libfdisk.so.* $(1)/usr/lib/
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libfdisk.so.* $(1)/usr/lib/
 endef
 
 define Package/libblkid/install
 	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libblkid.so.* $(1)/usr/lib/
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libblkid.so.* $(1)/usr/lib/
 endef
 
 define Package/libmount/install
 	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libmount.so.* $(1)/usr/lib/
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libmount.so.* $(1)/usr/lib/
 endef
 
 define Package/libsmartcols/install
 	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libsmartcols.so.* $(1)/usr/lib/
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libsmartcols.so.* $(1)/usr/lib/
 endef
 
 define Package/libuuid/install
 	$(INSTALL_DIR) $(1)/usr/lib
-	$(CP) $(PKG_INSTALL_DIR)/lib/libuuid.so.* $(1)/usr/lib/
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libuuid.so.* $(1)/usr/lib/
 endef
 
 define Package/agetty/install
@@ -672,6 +711,11 @@ define Package/cfdisk/install
 	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/cfdisk $(1)/usr/sbin/
 endef
 
+define Package/colrm/install
+	$(INSTALL_DIR) $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/colrm $(1)/usr/bin/
+endef
+
 define Package/dmesg/install
 	$(INSTALL_DIR) $(1)/usr/bin
 	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/dmesg $(1)/usr/bin/
@@ -789,6 +833,11 @@ define Package/rename/install
 	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/rename $(1)/usr/bin/
 endef
 
+define Package/rev/install
+	$(INSTALL_DIR) $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/rev $(1)/usr/bin/
+endef
+
 define Package/partx-utils/install
 	$(INSTALL_DIR) $(1)/usr/sbin
 	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/partx $(1)/usr/sbin/
@@ -820,7 +869,7 @@ endef
 
 define Package/taskset/install
 	$(INSTALL_DIR) $(1)/usr/bin
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/taskset $(1)/usr/bin/
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/taskset $(1)/usr/bin/util-linux-taskset
 endef
 
 define Package/unshare/install
@@ -866,6 +915,7 @@ $(eval $(call BuildPackage,blkid))
 $(eval $(call BuildPackage,blockdev))
 $(eval $(call BuildPackage,cal))
 $(eval $(call BuildPackage,cfdisk))
+$(eval $(call BuildPackage,colrm))
 $(eval $(call BuildPackage,dmesg))
 $(eval $(call BuildPackage,eject))
 $(eval $(call BuildPackage,fdisk))
@@ -889,6 +939,7 @@ $(eval $(call BuildPackage,namei))
 $(eval $(call BuildPackage,nsenter))
 $(eval $(call BuildPackage,prlimit))
 $(eval $(call BuildPackage,rename))
+$(eval $(call BuildPackage,rev))
 $(eval $(call BuildPackage,partx-utils))
 $(eval $(call BuildPackage,script-utils))
 $(eval $(call BuildPackage,setterm))
diff --git a/package/utils/util-linux/patches/100-use_urandom.patch b/package/utils/util-linux/patches/100-use_urandom.patch
deleted file mode 100644
index 58172098..00000000
--- a/package/utils/util-linux/patches/100-use_urandom.patch
+++ /dev/null
@@ -1,14 +0,0 @@
---- a/lib/randutils.c
-+++ b/lib/randutils.c
-@@ -26,6 +26,11 @@
- #define THREAD_LOCAL static
- #endif
- 
-+/* force /dev/urandom to avoid hanging on early boot */
-+#undef HAVE_GETRANDOM
-+#undef SYS_getrandom
-+#undef __NR_getrandom
-+
- #ifdef HAVE_GETRANDOM
- # include <sys/random.h>
- #elif defined (__linux__)
diff --git a/toolchain/binutils/Config.in b/toolchain/binutils/Config.in
index 3ec4fe47..e2721b1e 100644
--- a/toolchain/binutils/Config.in
+++ b/toolchain/binutils/Config.in
@@ -2,29 +2,21 @@
 
 choice
 	prompt "Binutils Version" if TOOLCHAINOPTS
-	default BINUTILS_USE_VERSION_2_40
+	default BINUTILS_USE_VERSION_2_42
 	help
 	  Select the version of binutils you wish to use.
 
-	config BINUTILS_USE_VERSION_2_37
-		bool "Binutils 2.37"
-		select BINUTILS_VERSION_2_37
-
-	config BINUTILS_USE_VERSION_2_38
-		bool "Binutils 2.38"
-		select BINUTILS_VERSION_2_38
-
-	config BINUTILS_USE_VERSION_2_39
-		bool "Binutils 2.39"
-		select BINUTILS_VERSION_2_39
-
 	config BINUTILS_USE_VERSION_2_40
 		bool "Binutils 2.40"
 		select BINUTILS_VERSION_2_40
 
-	config BINUTILS_USE_VERSION_2_41
-		bool "Binutils 2.41"
-		select BINUTILS_VERSION_2_41
+	config BINUTILS_USE_VERSION_2_42
+		bool "Binutils 2.42"
+		select BINUTILS_VERSION_2_42
+
+	config BINUTILS_USE_VERSION_2_43
+		bool "Binutils 2.43.1"
+		select BINUTILS_VERSION_2_43
 endchoice
 
 config EXTRA_BINUTILS_CONFIG_OPTIONS
diff --git a/toolchain/binutils/Config.version b/toolchain/binutils/Config.version
index acb764bb..f616cddc 100644
--- a/toolchain/binutils/Config.version
+++ b/toolchain/binutils/Config.version
@@ -1,24 +1,16 @@
 
-config BINUTILS_VERSION_2_37
-	bool
-
-config BINUTILS_VERSION_2_38
-	bool
-
-config BINUTILS_VERSION_2_39
+config BINUTILS_VERSION_2_40
 	bool
 
-config BINUTILS_VERSION_2_40
+config BINUTILS_VERSION_2_42
 	default y if !TOOLCHAINOPTS
 	bool
 
-config BINUTILS_VERSION_2_41
+config BINUTILS_VERSION_2_43
 	bool
 
 config BINUTILS_VERSION
 	string
-	default "2.37"			if BINUTILS_VERSION_2_37
-	default "2.38"			if BINUTILS_VERSION_2_38
-	default "2.39"			if BINUTILS_VERSION_2_39
 	default "2.40"			if BINUTILS_VERSION_2_40
-	default "2.41"			if BINUTILS_VERSION_2_41
+	default "2.42"			if BINUTILS_VERSION_2_42
+	default "2.43.1"		if BINUTILS_VERSION_2_43
diff --git a/toolchain/binutils/Makefile b/toolchain/binutils/Makefile
index b2831f8c..63f0e07c 100644
--- a/toolchain/binutils/Makefile
+++ b/toolchain/binutils/Makefile
@@ -16,24 +16,16 @@ PKG_CPE_ID:=cpe:/a:gnu:binutils
 
 TAR_OPTIONS += --exclude='*.rej'
 
-ifeq ($(PKG_VERSION),2.37)
-  PKG_HASH:=820d9724f020a3e69cb337893a0b63c2db161dadcb0e06fc11dc29eb1e84a32c
-endif
-
-ifeq ($(PKG_VERSION),2.38)
-  PKG_HASH:=e316477a914f567eccc34d5d29785b8b0f5a10208d36bbacedcc39048ecfe024
-endif
-
-ifeq ($(PKG_VERSION),2.39)
-  PKG_HASH:=645c25f563b8adc0a81dbd6a41cffbf4d37083a382e02d5d3df4f65c09516d00
-endif
-
 ifeq ($(PKG_VERSION),2.40)
   PKG_HASH:=0f8a4c272d7f17f369ded10a4aca28b8e304828e95526da482b0ccc4dfc9d8e1
 endif
 
-ifeq ($(PKG_VERSION),2.41)
-  PKG_HASH:=ae9a5789e23459e59606e6714723f2d3ffc31c03174191ef0d015bdf06007450
+ifeq ($(PKG_VERSION),2.42)
+  PKG_HASH:=f6e4d41fd5fc778b06b7891457b3620da5ecea1006c6a4a41ae998109f85a800
+endif
+
+ifeq ($(PKG_VERSION),2.43.1)
+  PKG_HASH:=13f74202a3c4c51118b797a39ea4200d3f6cfbe224da6d1d95bb938480132dfd
 endif
 
 HOST_BUILD_PARALLEL:=1
@@ -55,7 +47,7 @@ HOST_CONFIGURE_ARGS = \
 	--target=$(REAL_GNU_TARGET_NAME) \
 	--with-sysroot=$(TOOLCHAIN_DIR) \
 	--with-system-zlib \
-	--without-zstd \
+	--with-zstd \
 	--enable-deterministic-archives \
 	--enable-plugins \
 	--enable-lto \
diff --git a/toolchain/binutils/patches/2.37/300-001_ld_makefile_patch.patch b/toolchain/binutils/patches/2.37/300-001_ld_makefile_patch.patch
deleted file mode 100644
index f1cbb819..00000000
--- a/toolchain/binutils/patches/2.37/300-001_ld_makefile_patch.patch
+++ /dev/null
@@ -1,22 +0,0 @@
---- a/ld/Makefile.am
-+++ b/ld/Makefile.am
-@@ -50,7 +50,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- 
- EMUL = @EMUL@
- EMULATION_OFILES = @EMULATION_OFILES@
---- a/ld/Makefile.in
-+++ b/ld/Makefile.in
-@@ -561,7 +561,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- BASEDIR = $(srcdir)/..
- BFDDIR = $(BASEDIR)/bfd
- INCDIR = $(BASEDIR)/include
diff --git a/toolchain/binutils/patches/2.37/400-mips_no_dynamic_linking_sym.patch b/toolchain/binutils/patches/2.37/400-mips_no_dynamic_linking_sym.patch
deleted file mode 100644
index 070247ec..00000000
--- a/toolchain/binutils/patches/2.37/400-mips_no_dynamic_linking_sym.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/bfd/elfxx-mips.c
-+++ b/bfd/elfxx-mips.c
-@@ -8057,6 +8057,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
-       bh = NULL;
-+      if (0) {
-       if (!(_bfd_generic_link_add_one_symbol
- 	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
- 	     NULL, false, get_elf_backend_data (abfd)->collect, &bh)))
-@@ -8069,6 +8070,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       if (! bfd_elf_link_record_dynamic_symbol (info, h))
- 	return false;
-+      }
- 
-       if (! mips_elf_hash_table (info)->use_rld_obj_head)
- 	{
diff --git a/toolchain/binutils/patches/2.37/500-Change-default-emulation-for-mips64-linux.patch b/toolchain/binutils/patches/2.37/500-Change-default-emulation-for-mips64-linux.patch
deleted file mode 100644
index c5984376..00000000
--- a/toolchain/binutils/patches/2.37/500-Change-default-emulation-for-mips64-linux.patch
+++ /dev/null
@@ -1,38 +0,0 @@
---- a/bfd/config.bfd
-+++ b/bfd/config.bfd
-@@ -891,12 +891,12 @@ case "${targ}" in
-     targ_selvecs="mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
-     ;;
-   mips64*el-*-linux*)
--    targ_defvec=mips_elf32_ntrad_le_vec
--    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_le_vec mips_elf64_trad_be_vec"
-+    targ_defvec=mips_elf64_trad_le_vec
-+    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_be_vec"
-     ;;
-   mips64*-*-linux*)
--    targ_defvec=mips_elf32_ntrad_be_vec
--    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
-+    targ_defvec=mips_elf64_trad_be_vec
-+    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_le_vec"
-     ;;
-   mips*el-*-linux*)
-     targ_defvec=mips_elf32_trad_le_vec
---- a/ld/configure.tgt
-+++ b/ld/configure.tgt
-@@ -530,12 +530,12 @@ mips*-*-vxworks*)	targ_emul=elf32ebmipvx
- 			;;
- mips*-*-windiss)	targ_emul=elf32mipswindiss
- 			;;
--mips64*el-*-linux-*)	targ_emul=elf32ltsmipn32
--			targ_extra_emuls="elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip"
-+mips64*el-*-linux-*)	targ_emul=elf64ltsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32ltsmip elf32btsmip elf64btsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
--mips64*-*-linux-*)	targ_emul=elf32btsmipn32
--			targ_extra_emuls="elf32ltsmipn32 elf32btsmip elf32ltsmip elf64btsmip elf64ltsmip"
-+mips64*-*-linux-*)	targ_emul=elf64btsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32btsmip elf32ltsmip elf64ltsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
- mips*el-*-linux-*)	targ_emul=elf32ltsmip
diff --git a/toolchain/binutils/patches/2.37/600-Close_the_file_descriptor.patch b/toolchain/binutils/patches/2.37/600-Close_the_file_descriptor.patch
deleted file mode 100644
index fef86a9c..00000000
--- a/toolchain/binutils/patches/2.37/600-Close_the_file_descriptor.patch
+++ /dev/null
@@ -1,184 +0,0 @@
-From: H.J. Lu <hjl.tools@gmail.com>
-Date: Mon, 26 Jul 2021 12:59:55 +0000 (-0700)
-Subject: bfd: Close the file descriptor if there is no archive fd
-X-Git-Url: https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff_plain;h=1c611b40e6bfc8029bff7696814330b5bc0ee5c0
-
-bfd: Close the file descriptor if there is no archive fd
-
-Close the file descriptor if there is no archive plugin file descriptor
-to avoid running out of file descriptors on thin archives with many
-archive members.
-
-bfd/
-
-	PR ld/28138
-	* plugin.c (bfd_plugin_close_file_descriptor): Close the file
-	descriptor there is no archive plugin file descriptor.
-
-ld/
-
-	PR ld/28138
-	* testsuite/ld-plugin/lto.exp: Run tmpdir/pr28138 only for
-	native build.
-
-	PR ld/28138
-	* testsuite/ld-plugin/lto.exp: Run ld/28138 tests.
-	* testsuite/ld-plugin/pr28138.c: New file.
-	* testsuite/ld-plugin/pr28138-1.c: Likewise.
-	* testsuite/ld-plugin/pr28138-2.c: Likewise.
-	* testsuite/ld-plugin/pr28138-3.c: Likewise.
-	* testsuite/ld-plugin/pr28138-4.c: Likewise.
-	* testsuite/ld-plugin/pr28138-5.c: Likewise.
-	* testsuite/ld-plugin/pr28138-6.c: Likewise.
-	* testsuite/ld-plugin/pr28138-7.c: Likewise.
-
-(cherry picked from commit 5a98fb7513b559e20dfebdbaa2a471afda3b4742)
-(cherry picked from commit 7dc37e1e1209c80e0bab784df6b6bac335e836f2)
----
-
---- a/bfd/plugin.c
-+++ b/bfd/plugin.c
-@@ -291,6 +291,14 @@ bfd_plugin_close_file_descriptor (bfd *a
- 	     && !bfd_is_thin_archive (abfd->my_archive))
- 	abfd = abfd->my_archive;
- 
-+      /* Close the file descriptor if there is no archive plugin file
-+	 descriptor.  */
-+      if (abfd->archive_plugin_fd == -1)
-+	{
-+	  close (fd);
-+	  return;
-+	}
-+
-       abfd->archive_plugin_fd_open_count--;
-       /* Dup the archive plugin file descriptor for later use, which
- 	 will be closed by _bfd_archive_close_and_cleanup.  */
---- a/ld/testsuite/ld-plugin/lto.exp
-+++ b/ld/testsuite/ld-plugin/lto.exp
-@@ -687,6 +687,40 @@ if { [is_elf_format] && [check_lto_share
-     }
- }
- 
-+run_cc_link_tests [list \
-+    [list \
-+	"Build pr28138.a" \
-+	"-T" "" \
-+	{pr28138-1.c pr28138-2.c pr28138-3.c pr28138-4.c pr28138-5.c \
-+	 pr28138-6.c pr28138-7.c} {} "pr28138.a" \
-+    ] \
-+    [list \
-+	"Build pr28138.o" \
-+	"" "" \
-+	{pr28138.c} {} \
-+    ] \
-+]
-+
-+set exec_output [run_host_cmd "sh" \
-+			      "-c \"ulimit -n 20; \
-+			      $CC -Btmpdir/ld -o tmpdir/pr28138 \
-+			      tmpdir/pr28138.o tmpdir/pr28138.a\""]
-+set exec_output [prune_warnings $exec_output]
-+if [string match "" $exec_output] then {
-+    if { [isnative] } {
-+	set exec_output [run_host_cmd "tmpdir/pr28138" ""]
-+	if [string match "PASS" $exec_output] then {
-+	    pass "PR ld/28138"
-+	} else {
-+	    fail "PR ld/28138"
-+	}
-+    } else {
-+	pass "PR ld/28138"
-+    }
-+} else {
-+    fail "PR ld/28138"
-+}
-+
- set testname "Build liblto-11.a"
- remote_file host delete "tmpdir/liblto-11.a"
- set catch_output [run_host_cmd "$ar" "rc $plug_opt tmpdir/liblto-11.a tmpdir/lto-11a.o tmpdir/lto-11b.o tmpdir/lto-11c.o"]
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138-1.c
-@@ -0,0 +1,6 @@
-+extern int a0(void);
-+int
-+a1(void)
-+{
-+  return 1 + a0();
-+}
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138-2.c
-@@ -0,0 +1,6 @@
-+extern int a1(void);
-+int
-+a2(void)
-+{
-+  return 1 + a1();
-+}
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138-3.c
-@@ -0,0 +1,6 @@
-+extern int a2(void);
-+int
-+a3(void)
-+{
-+  return 1 + a2();
-+}
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138-4.c
-@@ -0,0 +1,6 @@
-+extern int a3(void);
-+int
-+a4(void)
-+{
-+  return 1 + a3();
-+}
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138-5.c
-@@ -0,0 +1,6 @@
-+extern int a4(void);
-+int
-+a5(void)
-+{
-+  return 1 + a4();
-+}
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138-6.c
-@@ -0,0 +1,6 @@
-+extern int a5(void);
-+int
-+a6(void)
-+{
-+  return 1 + a5();
-+}
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138-7.c
-@@ -0,0 +1,6 @@
-+extern int a6(void);
-+int
-+a7(void)
-+{
-+  return 1 + a6();
-+}
---- /dev/null
-+++ b/ld/testsuite/ld-plugin/pr28138.c
-@@ -0,0 +1,20 @@
-+#include <stdio.h>
-+
-+extern int a7(void);
-+
-+int
-+a0(void)
-+{
-+  return 0;
-+}
-+
-+int
-+main()
-+{
-+  if (a7() == 7)
-+    {
-+      printf ("PASS\n");
-+      return 0;
-+    }
-+  return 1;
-+}
diff --git a/toolchain/binutils/patches/2.38/300-001_ld_makefile_patch.patch b/toolchain/binutils/patches/2.38/300-001_ld_makefile_patch.patch
deleted file mode 100644
index ecc9dd64..00000000
--- a/toolchain/binutils/patches/2.38/300-001_ld_makefile_patch.patch
+++ /dev/null
@@ -1,22 +0,0 @@
---- a/ld/Makefile.am
-+++ b/ld/Makefile.am
-@@ -50,7 +50,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- 
- EMUL = @EMUL@
- EMULATION_OFILES = @EMULATION_OFILES@
---- a/ld/Makefile.in
-+++ b/ld/Makefile.in
-@@ -563,7 +563,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- BASEDIR = $(srcdir)/..
- BFDDIR = $(BASEDIR)/bfd
- INCDIR = $(BASEDIR)/include
diff --git a/toolchain/binutils/patches/2.38/400-mips_no_dynamic_linking_sym.patch b/toolchain/binutils/patches/2.38/400-mips_no_dynamic_linking_sym.patch
deleted file mode 100644
index 070247ec..00000000
--- a/toolchain/binutils/patches/2.38/400-mips_no_dynamic_linking_sym.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/bfd/elfxx-mips.c
-+++ b/bfd/elfxx-mips.c
-@@ -8057,6 +8057,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
-       bh = NULL;
-+      if (0) {
-       if (!(_bfd_generic_link_add_one_symbol
- 	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
- 	     NULL, false, get_elf_backend_data (abfd)->collect, &bh)))
-@@ -8069,6 +8070,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       if (! bfd_elf_link_record_dynamic_symbol (info, h))
- 	return false;
-+      }
- 
-       if (! mips_elf_hash_table (info)->use_rld_obj_head)
- 	{
diff --git a/toolchain/binutils/patches/2.38/500-Change-default-emulation-for-mips64-linux.patch b/toolchain/binutils/patches/2.38/500-Change-default-emulation-for-mips64-linux.patch
deleted file mode 100644
index 0797f4df..00000000
--- a/toolchain/binutils/patches/2.38/500-Change-default-emulation-for-mips64-linux.patch
+++ /dev/null
@@ -1,38 +0,0 @@
---- a/bfd/config.bfd
-+++ b/bfd/config.bfd
-@@ -928,12 +928,12 @@ case "${targ}" in
-     targ_selvecs="mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
-     ;;
-   mips64*el-*-linux*)
--    targ_defvec=mips_elf32_ntrad_le_vec
--    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_le_vec mips_elf64_trad_be_vec"
-+    targ_defvec=mips_elf64_trad_le_vec
-+    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_be_vec"
-     ;;
-   mips64*-*-linux*)
--    targ_defvec=mips_elf32_ntrad_be_vec
--    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
-+    targ_defvec=mips_elf64_trad_be_vec
-+    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_le_vec"
-     ;;
-   mips*el-*-linux*)
-     targ_defvec=mips_elf32_trad_le_vec
---- a/ld/configure.tgt
-+++ b/ld/configure.tgt
-@@ -543,12 +543,12 @@ mips*-*-vxworks*)	targ_emul=elf32ebmipvx
- 			;;
- mips*-*-windiss)	targ_emul=elf32mipswindiss
- 			;;
--mips64*el-*-linux-*)	targ_emul=elf32ltsmipn32
--			targ_extra_emuls="elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip"
-+mips64*el-*-linux-*)	targ_emul=elf64ltsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32ltsmip elf32btsmip elf64btsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
--mips64*-*-linux-*)	targ_emul=elf32btsmipn32
--			targ_extra_emuls="elf32ltsmipn32 elf32btsmip elf32ltsmip elf64btsmip elf64ltsmip"
-+mips64*-*-linux-*)	targ_emul=elf64btsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32btsmip elf32ltsmip elf64ltsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
- mips*el-*-linux-*)	targ_emul=elf32ltsmip
diff --git a/toolchain/binutils/patches/2.39/005-ld-fix-NEWS-typos.patch b/toolchain/binutils/patches/2.39/005-ld-fix-NEWS-typos.patch
deleted file mode 100644
index 39c61d93..00000000
--- a/toolchain/binutils/patches/2.39/005-ld-fix-NEWS-typos.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 9284b63ea39cecbfc1522d9e143ecb7727d77eb5 Mon Sep 17 00:00:00 2001
-From: Martin Liska <mliska@suse.cz>
-Date: Mon, 8 Aug 2022 13:22:26 +0200
-Subject: [PATCH 005/160] ld: fix NEWS typos
-
-ld/ChangeLog:
-
-	* NEWS: Fix 2 typos.
----
- ld/NEWS | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/ld/NEWS
-+++ b/ld/NEWS
-@@ -27,10 +27,10 @@ Changes in 2.39:
-   --enable-warn-rwx-segments=no
-      will make --no-warn-rwx-segments enabled by default.
-      
--  --enable-defaul-execstack=no
-+  --enable-default-execstack=no
-      will stop the creation of an executable stack simply because an input file
-      is missing a .note.GNU-stack section, even on architectures where this
--     ehaviour is the default.
-+     behaviour is the default.
- 
- * TYPE=<type> is now supported in an output section description to set the
-   section type value.
diff --git a/toolchain/binutils/patches/2.39/008-gas-Dwarf-properly-skip-zero-size-functions.patch b/toolchain/binutils/patches/2.39/008-gas-Dwarf-properly-skip-zero-size-functions.patch
deleted file mode 100644
index 055da841..00000000
--- a/toolchain/binutils/patches/2.39/008-gas-Dwarf-properly-skip-zero-size-functions.patch
+++ /dev/null
@@ -1,90 +0,0 @@
-From e8cf73215187b0c08679d726a5cc7c019fa3ea2e Mon Sep 17 00:00:00 2001
-From: Jan Beulich <jbeulich@suse.com>
-Date: Wed, 10 Aug 2022 10:34:22 +0200
-Subject: [PATCH 008/160] gas/Dwarf: properly skip zero-size functions
-
-PR gas/29451
-
-While out_debug_abbrev() properly skips such functions, out_debug_info()
-mistakenly didn't. It needs to calculate the high_pc expression ahead of
-time, in order to skip emitting any data for the function if the value
-is zero.
-
-The one case which would still leave a zero-size entry is when
-symbol_get_obj(symp)->size ends up evaluating to zero. I hope we can
-expect that to not be the case, otherwise we'd need to have a way to
-post-process .debug_info contents between resolving expressions and
-actually writing the data out to the file. Even then it wouldn't be
-entirely obvious in which way to alter the data.
-
-(cherry picked from commit d7abcbcea5ddd40a3bf28758b62f35933c59f996)
----
- gas/dwarf2dbg.c | 39 ++++++++++++++++++++-------------------
- 1 file changed, 20 insertions(+), 19 deletions(-)
-
---- a/gas/dwarf2dbg.c
-+++ b/gas/dwarf2dbg.c
-@@ -2882,6 +2882,7 @@ out_debug_info (segT info_seg, segT abbr
- 	{
- 	  const char *name;
- 	  size_t len;
-+	  expressionS size = { .X_op = O_constant };
- 
- 	  /* Skip warning constructs (see above).  */
- 	  if (symbol_get_bfdsym (symp)->flags & BSF_WARNING)
-@@ -2895,6 +2896,18 @@ out_debug_info (segT info_seg, segT abbr
- 	  if (!S_IS_DEFINED (symp) || !S_IS_FUNCTION (symp))
- 	    continue;
- 
-+#if defined (OBJ_ELF) /* || defined (OBJ_MAYBE_ELF) */
-+	  size.X_add_number = S_GET_SIZE (symp);
-+	  if (size.X_add_number == 0 && IS_ELF
-+	      && symbol_get_obj (symp)->size != NULL)
-+	    {
-+	      size.X_op = O_add;
-+	      size.X_op_symbol = make_expr_symbol (symbol_get_obj (symp)->size);
-+	    }
-+#endif
-+	  if (size.X_op == O_constant && size.X_add_number == 0)
-+	    continue;
-+
- 	  subseg_set (str_seg, 0);
- 	  name_sym = symbol_temp_new_now_octets ();
- 	  name = S_GET_NAME (symp);
-@@ -2920,29 +2933,17 @@ out_debug_info (segT info_seg, segT abbr
- 	  emit_expr (&exp, sizeof_address);
- 
- 	  /* DW_AT_high_pc */
--	  exp.X_op = O_constant;
--#if defined (OBJ_ELF) /* || defined (OBJ_MAYBE_ELF) */
--	  exp.X_add_number = S_GET_SIZE (symp);
--	  if (exp.X_add_number == 0 && IS_ELF
--	      && symbol_get_obj (symp)->size != NULL)
--	    {
--	      exp.X_op = O_add;
--	      exp.X_op_symbol = make_expr_symbol (symbol_get_obj (symp)->size);
--	    }
--#else
--	  exp.X_add_number = 0;
--#endif
- 	  if (DWARF2_VERSION < 4)
- 	    {
--	      if (exp.X_op == O_constant)
--		exp.X_op = O_symbol;
--	      exp.X_add_symbol = symp;
--	      emit_expr (&exp, sizeof_address);
-+	      if (size.X_op == O_constant)
-+		size.X_op = O_symbol;
-+	      size.X_add_symbol = symp;
-+	      emit_expr (&size, sizeof_address);
- 	    }
--	  else if (exp.X_op == O_constant)
--	    out_uleb128 (exp.X_add_number);
-+	  else if (size.X_op == O_constant)
-+	    out_uleb128 (size.X_add_number);
- 	  else
--	    emit_leb128_expr (symbol_get_value_expression (exp.X_op_symbol), 0);
-+	    emit_leb128_expr (symbol_get_value_expression (size.X_op_symbol), 0);
- 	}
- 
-       /* End of children.  */
diff --git a/toolchain/binutils/patches/2.39/009-PR29462-internal-error-in-relocate-at-powerpc.cc-107.patch b/toolchain/binutils/patches/2.39/009-PR29462-internal-error-in-relocate-at-powerpc.cc-107.patch
deleted file mode 100644
index e325d3bc..00000000
--- a/toolchain/binutils/patches/2.39/009-PR29462-internal-error-in-relocate-at-powerpc.cc-107.patch
+++ /dev/null
@@ -1,270 +0,0 @@
-From e3b5d935247084dca057dea72be61b063fe2357a Mon Sep 17 00:00:00 2001
-From: Alan Modra <amodra@gmail.com>
-Date: Wed, 10 Aug 2022 10:38:52 +0930
-Subject: [PATCH 009/160] PR29462, internal error in relocate, at
- powerpc.cc:10796
-
-Prior to the inline plt call support (commit 08be322439), the only
-local syms with plt entries were local ifunc symbols.  There shouldn't
-be stubs for other local symbols so don't look for them.  The patch
-also fixes minor bugs in get_reference_flags; Many relocs are valid
-only for ppc64 and a couple only for ppc32.
-
-	PR 29462
-	* powerpc.cc (Target_powerpc::Relocate::relocate): Rename
-	use_plt_offset to pltcal_to_direct, invert logic.  For relocs
-	not used with inline plt sequences against local symbols, only
-	look for stubs when the symbol is an ifunc.
-	(Target_powerpc::Scan::get_reference_flags): Correct reloc
-	handling for relocs not valid for both 32-bit and 64-bit.
-
-(cherry picked from commit 6158b25f77db11712b84e6a4609898f2615ac749)
----
- gold/powerpc.cc | 129 ++++++++++++++++++++++++++++--------------------
- 1 file changed, 75 insertions(+), 54 deletions(-)
-
---- a/gold/powerpc.cc
-+++ b/gold/powerpc.cc
-@@ -7675,22 +7675,18 @@ Target_powerpc<size, big_endian>::Scan::
- 
-   switch (r_type)
-     {
-+    case elfcpp::R_PPC64_TOC:
-+      if (size != 64)
-+	break;
-+      // Fall through.
-     case elfcpp::R_POWERPC_NONE:
-     case elfcpp::R_POWERPC_GNU_VTINHERIT:
-     case elfcpp::R_POWERPC_GNU_VTENTRY:
--    case elfcpp::R_PPC64_TOC:
-       // No symbol reference.
-       break;
- 
-     case elfcpp::R_PPC64_ADDR64:
-     case elfcpp::R_PPC64_UADDR64:
--    case elfcpp::R_POWERPC_ADDR32:
--    case elfcpp::R_POWERPC_UADDR32:
--    case elfcpp::R_POWERPC_ADDR16:
--    case elfcpp::R_POWERPC_UADDR16:
--    case elfcpp::R_POWERPC_ADDR16_LO:
--    case elfcpp::R_POWERPC_ADDR16_HI:
--    case elfcpp::R_POWERPC_ADDR16_HA:
-     case elfcpp::R_PPC64_ADDR16_HIGHER34:
-     case elfcpp::R_PPC64_ADDR16_HIGHERA34:
-     case elfcpp::R_PPC64_ADDR16_HIGHEST34:
-@@ -7700,6 +7696,16 @@ Target_powerpc<size, big_endian>::Scan::
-     case elfcpp::R_PPC64_D34_HI30:
-     case elfcpp::R_PPC64_D34_HA30:
-     case elfcpp::R_PPC64_D28:
-+      if (size != 64)
-+	break;
-+      // Fall through.
-+    case elfcpp::R_POWERPC_ADDR32:
-+    case elfcpp::R_POWERPC_UADDR32:
-+    case elfcpp::R_POWERPC_ADDR16:
-+    case elfcpp::R_POWERPC_UADDR16:
-+    case elfcpp::R_POWERPC_ADDR16_LO:
-+    case elfcpp::R_POWERPC_ADDR16_HI:
-+    case elfcpp::R_POWERPC_ADDR16_HA:
-       ref = Symbol::ABSOLUTE_REF;
-       break;
- 
-@@ -7710,13 +7716,14 @@ Target_powerpc<size, big_endian>::Scan::
-       ref = Symbol::FUNCTION_CALL | Symbol::ABSOLUTE_REF;
-       break;
- 
--    case elfcpp::R_PPC64_REL64:
--    case elfcpp::R_POWERPC_REL32:
-     case elfcpp::R_PPC_LOCAL24PC:
--    case elfcpp::R_POWERPC_REL16:
--    case elfcpp::R_POWERPC_REL16_LO:
--    case elfcpp::R_POWERPC_REL16_HI:
--    case elfcpp::R_POWERPC_REL16_HA:
-+      if (size != 32)
-+	break;
-+      // Fall through.
-+      ref = Symbol::RELATIVE_REF;
-+      break;
-+
-+    case elfcpp::R_PPC64_REL64:
-     case elfcpp::R_PPC64_REL16_HIGH:
-     case elfcpp::R_PPC64_REL16_HIGHA:
-     case elfcpp::R_PPC64_REL16_HIGHER:
-@@ -7729,36 +7736,45 @@ Target_powerpc<size, big_endian>::Scan::
-     case elfcpp::R_PPC64_REL16_HIGHEST34:
-     case elfcpp::R_PPC64_REL16_HIGHESTA34:
-     case elfcpp::R_PPC64_PCREL28:
-+      if (size != 64)
-+	break;
-+      // Fall through.
-+    case elfcpp::R_POWERPC_REL32:
-+    case elfcpp::R_POWERPC_REL16:
-+    case elfcpp::R_POWERPC_REL16_LO:
-+    case elfcpp::R_POWERPC_REL16_HI:
-+    case elfcpp::R_POWERPC_REL16_HA:
-       ref = Symbol::RELATIVE_REF;
-       break;
- 
-+    case elfcpp::R_PPC_PLTREL24:
-+      if (size != 32)
-+	break;
-+      ref = Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;
-+      break;
-+
-     case elfcpp::R_PPC64_REL24_NOTOC:
--      if (size == 32)
-+    case elfcpp::R_PPC64_REL24_P9NOTOC:
-+    case elfcpp::R_PPC64_PLT16_LO_DS:
-+    case elfcpp::R_PPC64_PLTSEQ_NOTOC:
-+    case elfcpp::R_PPC64_PLTCALL_NOTOC:
-+    case elfcpp::R_PPC64_PLT_PCREL34:
-+    case elfcpp::R_PPC64_PLT_PCREL34_NOTOC:
-+      if (size != 64)
- 	break;
-       // Fall through.
--    case elfcpp::R_PPC64_REL24_P9NOTOC:
-     case elfcpp::R_POWERPC_REL24:
--    case elfcpp::R_PPC_PLTREL24:
-     case elfcpp::R_POWERPC_REL14:
-     case elfcpp::R_POWERPC_REL14_BRTAKEN:
-     case elfcpp::R_POWERPC_REL14_BRNTAKEN:
-     case elfcpp::R_POWERPC_PLT16_LO:
-     case elfcpp::R_POWERPC_PLT16_HI:
-     case elfcpp::R_POWERPC_PLT16_HA:
--    case elfcpp::R_PPC64_PLT16_LO_DS:
-     case elfcpp::R_POWERPC_PLTSEQ:
--    case elfcpp::R_PPC64_PLTSEQ_NOTOC:
-     case elfcpp::R_POWERPC_PLTCALL:
--    case elfcpp::R_PPC64_PLTCALL_NOTOC:
--    case elfcpp::R_PPC64_PLT_PCREL34:
--    case elfcpp::R_PPC64_PLT_PCREL34_NOTOC:
-       ref = Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;
-       break;
- 
--    case elfcpp::R_POWERPC_GOT16:
--    case elfcpp::R_POWERPC_GOT16_LO:
--    case elfcpp::R_POWERPC_GOT16_HI:
--    case elfcpp::R_POWERPC_GOT16_HA:
-     case elfcpp::R_PPC64_GOT16_DS:
-     case elfcpp::R_PPC64_GOT16_LO_DS:
-     case elfcpp::R_PPC64_GOT_PCREL34:
-@@ -7768,11 +7784,16 @@ Target_powerpc<size, big_endian>::Scan::
-     case elfcpp::R_PPC64_TOC16_HA:
-     case elfcpp::R_PPC64_TOC16_DS:
-     case elfcpp::R_PPC64_TOC16_LO_DS:
-+      if (size != 64)
-+	break;
-+      // Fall through.
-+    case elfcpp::R_POWERPC_GOT16:
-+    case elfcpp::R_POWERPC_GOT16_LO:
-+    case elfcpp::R_POWERPC_GOT16_HI:
-+    case elfcpp::R_POWERPC_GOT16_HA:
-       ref = Symbol::RELATIVE_REF;
-       break;
- 
--    case elfcpp::R_POWERPC_GOT_TPREL16:
--    case elfcpp::R_POWERPC_TLS:
-     case elfcpp::R_PPC64_TLSGD:
-     case elfcpp::R_PPC64_TLSLD:
-     case elfcpp::R_PPC64_TPREL34:
-@@ -7781,6 +7802,11 @@ Target_powerpc<size, big_endian>::Scan::
-     case elfcpp::R_PPC64_GOT_TLSLD_PCREL34:
-     case elfcpp::R_PPC64_GOT_TPREL_PCREL34:
-     case elfcpp::R_PPC64_GOT_DTPREL_PCREL34:
-+      if (size != 64)
-+	break;
-+      // Fall through.
-+    case elfcpp::R_POWERPC_GOT_TPREL16:
-+    case elfcpp::R_POWERPC_TLS:
-       ref = Symbol::TLS_REF;
-       break;
- 
-@@ -10671,10 +10697,8 @@ Target_powerpc<size, big_endian>::Reloca
-   bool has_stub_value = false;
-   bool localentry0 = false;
-   unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());
--  bool use_plt_offset
--    = (gsym != NULL
--       ? gsym->use_plt_offset(Scan::get_reference_flags(r_type, target))
--       : object->local_has_plt_offset(r_sym));
-+  bool pltcall_to_direct = false;
-+
-   if (is_plt16_reloc<size>(r_type)
-       || r_type == elfcpp::R_PPC64_PLT_PCREL34
-       || r_type == elfcpp::R_PPC64_PLT_PCREL34_NOTOC
-@@ -10688,21 +10712,18 @@ Target_powerpc<size, big_endian>::Reloca
-       // that the decision depends on the PLTCALL reloc, and we don't
-       // know the address of that instruction when processing others
-       // in the sequence.  So the decision needs to be made in
--      // do_relax().  For now, don't optimise inline plt calls.
--      if (gsym)
--	use_plt_offset = gsym->has_plt_offset();
--    }
--  if (use_plt_offset
--      && !is_got_reloc(r_type)
--      && !is_plt16_reloc<size>(r_type)
--      && r_type != elfcpp::R_PPC64_PLT_PCREL34
--      && r_type != elfcpp::R_PPC64_PLT_PCREL34_NOTOC
--      && r_type != elfcpp::R_POWERPC_PLTSEQ
--      && r_type != elfcpp::R_POWERPC_PLTCALL
--      && r_type != elfcpp::R_PPC64_PLTSEQ_NOTOC
--      && r_type != elfcpp::R_PPC64_PLTCALL_NOTOC
--      && (!psymval->is_ifunc_symbol()
--	  || Scan::reloc_needs_plt_for_ifunc(target, object, r_type, false)))
-+      // do_relax().
-+      pltcall_to_direct = !(gsym != NULL
-+			    ? gsym->has_plt_offset()
-+			    : object->local_has_plt_offset(r_sym));
-+    }
-+  else if ((gsym != NULL
-+	    ? gsym->use_plt_offset(Scan::get_reference_flags(r_type, target))
-+	    : psymval->is_ifunc_symbol() && object->local_has_plt_offset(r_sym))
-+	   && !is_got_reloc(r_type)
-+	   && (!psymval->is_ifunc_symbol()
-+	       || Scan::reloc_needs_plt_for_ifunc(target, object, r_type,
-+						  false)))
-     {
-       if (size == 64
- 	  && gsym != NULL
-@@ -10796,9 +10817,9 @@ Target_powerpc<size, big_endian>::Reloca
-       gold_assert(has_stub_value || !(os->flags() & elfcpp::SHF_ALLOC));
-     }
- 
--  if (use_plt_offset && (is_plt16_reloc<size>(r_type)
--			 || r_type == elfcpp::R_PPC64_PLT_PCREL34
--			 || r_type == elfcpp::R_PPC64_PLT_PCREL34_NOTOC))
-+  if (!pltcall_to_direct && (is_plt16_reloc<size>(r_type)
-+			     || r_type == elfcpp::R_PPC64_PLT_PCREL34
-+			     || r_type == elfcpp::R_PPC64_PLT_PCREL34_NOTOC))
-     {
-       const Output_data_plt_powerpc<size, big_endian>* plt;
-       if (gsym)
-@@ -10826,7 +10847,7 @@ Target_powerpc<size, big_endian>::Reloca
- 	    value -= target->toc_pointer();
- 	}
-     }
--  else if (!use_plt_offset
-+  else if (pltcall_to_direct
- 	   && (is_plt16_reloc<size>(r_type)
- 	       || r_type == elfcpp::R_POWERPC_PLTSEQ
- 	       || r_type == elfcpp::R_PPC64_PLTSEQ_NOTOC))
-@@ -10835,7 +10856,7 @@ Target_powerpc<size, big_endian>::Reloca
-       elfcpp::Swap<32, big_endian>::writeval(iview, nop);
-       r_type = elfcpp::R_POWERPC_NONE;
-     }
--  else if (!use_plt_offset
-+  else if (pltcall_to_direct
- 	   && (r_type == elfcpp::R_PPC64_PLT_PCREL34
- 	       || r_type == elfcpp::R_PPC64_PLT_PCREL34_NOTOC))
-     {
-@@ -11316,8 +11337,8 @@ Target_powerpc<size, big_endian>::Reloca
-     }
-   else if (!has_stub_value)
-     {
--      if (!use_plt_offset && (r_type == elfcpp::R_POWERPC_PLTCALL
--			      || r_type == elfcpp::R_PPC64_PLTCALL_NOTOC))
-+      if (pltcall_to_direct && (r_type == elfcpp::R_POWERPC_PLTCALL
-+				|| r_type == elfcpp::R_PPC64_PLTCALL_NOTOC))
- 	{
- 	  // PLTCALL without plt entry => convert to direct call
- 	  Insn* iview = reinterpret_cast<Insn*>(view);
diff --git a/toolchain/binutils/patches/2.39/011-PR29466-APP-NO_APP-with-.linefile.patch b/toolchain/binutils/patches/2.39/011-PR29466-APP-NO_APP-with-.linefile.patch
deleted file mode 100644
index f7b58199..00000000
--- a/toolchain/binutils/patches/2.39/011-PR29466-APP-NO_APP-with-.linefile.patch
+++ /dev/null
@@ -1,167 +0,0 @@
-From 9e855cffa1fda44629e7f9b76dfa3e5a51a440e9 Mon Sep 17 00:00:00 2001
-From: Alan Modra <amodra@gmail.com>
-Date: Thu, 11 Aug 2022 09:51:03 +0930
-Subject: [PATCH 011/160] PR29466, APP/NO_APP with .linefile
-
-Commit 53f2b36a54b9 exposed a bug in sb_scrub_and_add_sb that could
-result in losing input.  If scrubbing results in expansion past the
-holding capacity of do_scrub_chars output buffer, then do_scrub_chars
-stashes the extra input for the next call.  That call never came
-because sb_scrub_and_add_sb wrongly decided it was done.  Fix that by
-allowing sb_scrub_and_add_sb to see whether there is pending input.
-Also allow a little extra space so that in most cases we won't need
-to resize the output buffer.
-
-sb_scrub_and_add_sb also limited output to the size of the input,
-rather than the actual output buffer size.  Fixing that resulted in a
-fail of gas/testsuite/macros/dot with an extra warning: "end of file
-not at end of a line; newline inserted".  OK, so the macro in dot.s
-really does finish without end-of-line.  Apparently the macro
-expansion code relied on do_scrub_chars returning early.  So fix that
-too by adding a newline if needed in macro_expand_body.
-
-	PR 29466
-	* app.c (do_scrub_pending): New function.
-	* as.h: Declare it.
-	* input-scrub.c (input_scrub_include_sb): Add extra space for
-	two .linefile directives.
-	* sb.c (sb_scrub_and_add_sb): Take into account pending input.
-	Allow output to max.
-	* macro.c (macro_expand_body): Add terminating newline.
-	* testsuite/config/default.exp (SIZE, SIZEFLAGS): Define.
-	* testsuite/gas/macros/app5.d,
-	* testsuite/gas/macros/app5.s: New test.
-	* testsuite/gas/macros/macros.exp: Run it.
-
-(cherry picked from commit 4d74aab7aa562fe79d4669cdad0c32610531cbc0)
----
- gas/app.c                           | 13 +++++++++++++
- gas/as.h                            |  1 +
- gas/input-scrub.c                   |  6 ++++--
- gas/macro.c                         |  2 ++
- gas/sb.c                            |  5 +++--
- gas/testsuite/config/default.exp    |  8 ++++++++
- gas/testsuite/gas/macros/app5.d     |  6 ++++++
- gas/testsuite/gas/macros/app5.s     |  5 +++++
- gas/testsuite/gas/macros/macros.exp |  1 +
- 9 files changed, 43 insertions(+), 4 deletions(-)
- create mode 100644 gas/testsuite/gas/macros/app5.d
- create mode 100644 gas/testsuite/gas/macros/app5.s
-
---- a/gas/app.c
-+++ b/gas/app.c
-@@ -1537,3 +1537,16 @@ do_scrub_chars (size_t (*get) (char *, s
-     last_char = to[-1];
-   return to - tostart;
- }
-+
-+/* Return amount of pending input.  */
-+
-+size_t
-+do_scrub_pending (void)
-+{
-+  size_t len = 0;
-+  if (saved_input)
-+    len += saved_input_len;
-+  if (state == -1)
-+    len += strlen (out_string);
-+  return len;
-+}
---- a/gas/as.h
-+++ b/gas/as.h
-@@ -460,6 +460,7 @@ void   input_scrub_insert_file (char *);
- char * input_scrub_new_file (const char *);
- char * input_scrub_next_buffer (char **bufp);
- size_t do_scrub_chars (size_t (*get) (char *, size_t), char *, size_t);
-+size_t do_scrub_pending (void);
- bool   scan_for_multibyte_characters (const unsigned char *, const unsigned char *, bool);
- int    gen_to_words (LITTLENUM_TYPE *, int, long);
- int    had_err (void);
---- a/gas/input-scrub.c
-+++ b/gas/input-scrub.c
-@@ -278,9 +278,11 @@ input_scrub_include_sb (sb *from, char *
- 
-   next_saved_file = input_scrub_push (position);
- 
--  /* Allocate sufficient space: from->len + optional newline.  */
-+  /* Allocate sufficient space: from->len plus optional newline
-+     plus two ".linefile " directives, plus a little more for other
-+     expansion.  */
-   newline = from->len >= 1 && from->ptr[0] != '\n';
--  sb_build (&from_sb, from->len + newline);
-+  sb_build (&from_sb, from->len + newline + 2 * sizeof (".linefile") + 30);
-   if (expansion == expanding_repeat && from_sb_expansion >= expanding_macro)
-     expansion = expanding_nested;
-   from_sb_expansion = expansion;
---- a/gas/macro.c
-+++ b/gas/macro.c
-@@ -1056,6 +1056,8 @@ macro_expand_body (sb *in, sb *out, form
-       loclist = f;
-     }
- 
-+  if (!err && (out->len == 0 || out->ptr[out->len - 1] != '\n'))
-+    sb_add_char (out, '\n');
-   return err;
- }
- 
---- a/gas/sb.c
-+++ b/gas/sb.c
-@@ -119,11 +119,12 @@ sb_scrub_and_add_sb (sb *ptr, sb *s)
-      So we loop until the input S is consumed.  */
-   while (1)
-     {
--      size_t copy = s->len - (scrub_position - s->ptr);
-+      size_t copy = s->len - (scrub_position - s->ptr) + do_scrub_pending ();
-       if (copy == 0)
- 	break;
-       sb_check (ptr, copy);
--      ptr->len += do_scrub_chars (scrub_from_sb, ptr->ptr + ptr->len, copy);
-+      ptr->len += do_scrub_chars (scrub_from_sb, ptr->ptr + ptr->len,
-+				  ptr->max - ptr->len);
-     }
- 
-   sb_to_scrub = 0;
---- a/gas/testsuite/config/default.exp
-+++ b/gas/testsuite/config/default.exp
-@@ -52,6 +52,14 @@ if ![info exists NMFLAGS] then {
-     set NMFLAGS {}
- }
- 
-+if ![info exists SIZE] then {
-+    set SIZE [findfile $base_dir/size]
-+}
-+
-+if ![info exists SIZEFLAGS] then {
-+    set SIZEFLAGS ""
-+}
-+
- if ![info exists OBJCOPY] then {
-     set OBJCOPY [findfile $base_dir/../../binutils/objcopy]
- }
---- /dev/null
-+++ b/gas/testsuite/gas/macros/app5.d
-@@ -0,0 +1,6 @@
-+#name: APP with linefile
-+#xfail: tic30-*-*
-+#size: -G
-+# pr29466 just check that the test assembles
-+
-+#pass
---- /dev/null
-+++ b/gas/testsuite/gas/macros/app5.s
-@@ -0,0 +1,5 @@
-+#NO_APP
-+#APP
-+# 5 "foo.c" 1
-+# 0 "" 2
-+#NO_APP
---- a/gas/testsuite/gas/macros/macros.exp
-+++ b/gas/testsuite/gas/macros/macros.exp
-@@ -70,6 +70,7 @@ run_dump_test app2
- run_dump_test app3
- remote_download host "$srcdir/$subdir/app4b.s"
- run_dump_test app4
-+run_dump_test app5
- 
- run_list_test badarg ""
- 
diff --git a/toolchain/binutils/patches/2.39/039-LoongArch-ld-Fix-relocation-error-of-pcrel.patch b/toolchain/binutils/patches/2.39/039-LoongArch-ld-Fix-relocation-error-of-pcrel.patch
deleted file mode 100644
index 67e499de..00000000
--- a/toolchain/binutils/patches/2.39/039-LoongArch-ld-Fix-relocation-error-of-pcrel.patch
+++ /dev/null
@@ -1,128 +0,0 @@
-From 509a2ec6ad3ea7eb3f4cf59538cf636a2126e4c3 Mon Sep 17 00:00:00 2001
-From: liuzhensong <liuzhensong@loongson.cn>
-Date: Fri, 2 Sep 2022 16:29:14 +0800
-Subject: [PATCH 039/160] LoongArch:ld: Fix relocation error of pcrel.
-
-  Patch for branch 2.39.
-  Need to reduce the address of pc when using
-  reloction R_LARCH_SOP_PUSH_PCREL.
-
-  bfd/
-    * elfnn-loongarch.c
----
- bfd/elfnn-loongarch.c                         |  3 +-
- ld/testsuite/ld-loongarch-elf/pcrel-const.d   | 14 +++++++
- ld/testsuite/ld-loongarch-elf/pcrel-const.lds | 14 +++++++
- ld/testsuite/ld-loongarch-elf/pcrel-const.s   | 12 ++++++
- ld/testsuite/ld-loongarch-elf/pr.exp          | 39 +++++++++++++++++++
- 5 files changed, 81 insertions(+), 1 deletion(-)
- create mode 100644 ld/testsuite/ld-loongarch-elf/pcrel-const.d
- create mode 100644 ld/testsuite/ld-loongarch-elf/pcrel-const.lds
- create mode 100644 ld/testsuite/ld-loongarch-elf/pcrel-const.s
- create mode 100644 ld/testsuite/ld-loongarch-elf/pr.exp
-
---- a/bfd/elfnn-loongarch.c
-+++ b/bfd/elfnn-loongarch.c
-@@ -2341,9 +2341,10 @@ loongarch_elf_relocate_section (bfd *out
- 	case R_LARCH_SOP_PUSH_PLT_PCREL:
- 	  unresolved_reloc = false;
- 
--	  if (resolved_to_const)
-+	  if (!is_undefweak && resolved_to_const)
- 	    {
- 	      relocation += rel->r_addend;
-+	      relocation -= pc;
- 	      break;
- 	    }
- 	  else if (is_undefweak)
---- /dev/null
-+++ b/ld/testsuite/ld-loongarch-elf/pcrel-const.d
-@@ -0,0 +1,14 @@
-+#as: -mla-global-with-pcrel
-+#objdump: -Drsz
-+
-+.*:[    ]+file format .*
-+
-+
-+Disassembly of section .text:
-+
-+.* <foo>:
-+#...
-+[ 	]+8:[ 	]+02c04084[ 	]+addi.d[ 	]+\$a0,[ 	]+\$a0,[ 	]+16\(0x10\)
-+#...
-+0+14 <__sec_end>:
-+#pass
---- /dev/null
-+++ b/ld/testsuite/ld-loongarch-elf/pcrel-const.lds
-@@ -0,0 +1,14 @@
-+ENTRY(foo);
-+SECTIONS
-+{
-+	.text : {
-+		*(.text*)
-+	}
-+
-+	.data : {
-+		__sec_start = .;
-+		*(.gzdata)
-+		__sec_end = .;
-+	}
-+}
-+PROVIDE(__sec_size = __sec_end);
---- /dev/null
-+++ b/ld/testsuite/ld-loongarch-elf/pcrel-const.s
-@@ -0,0 +1,12 @@
-+	.text
-+	.align	2
-+	.globl	foo
-+	.type	foo, @function
-+foo:
-+	nop
-+	la.global	$r4,__sec_size
-+	ldptr.w	$r4,$r4,0
-+	jr	$r1
-+	.size	foo, .-foo
-+	.data
-+	.word 1
---- /dev/null
-+++ b/ld/testsuite/ld-loongarch-elf/pr.exp
-@@ -0,0 +1,39 @@
-+# Expect script for LoongArch ELF linker tests
-+#   Copyright (C) 2022 Free Software Foundation, Inc.
-+#
-+# This file is part of the GNU Binutils.
-+#
-+# This program is free software; you can redistribute it and/or modify
-+# it under the terms of the GNU General Public License as published by
-+# the Free Software Foundation; either version 3 of the License, or
-+# (at your option) any later version.
-+#
-+# This program is distributed in the hope that it will be useful,
-+# but WITHOUT ANY WARRANTY; without even the implied warranty of
-+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+# GNU General Public License for more details.
-+#
-+# You should have received a copy of the GNU General Public License
-+# along with this program; if not, write to the Free Software
-+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-+# MA 02110-1301, USA.
-+#
-+
-+if ![istarget loongarch64-*-*] {
-+  return
-+}
-+
-+set link_tests [list \
-+  [list \
-+    "pcrel const" \
-+    "-T pcrel-const.lds" "" \
-+    "-mla-global-with-pcrel" \
-+    { pcrel-const.s } \
-+    [list \
-+      [list objdump -D pcrel-const.d] \
-+    ] \
-+    "pcrel-const" \
-+  ] \
-+]
-+
-+run_ld_link_tests $link_tests
diff --git a/toolchain/binutils/patches/2.39/043-Re-PR29466-APP-NO_APP-with-linefile.patch b/toolchain/binutils/patches/2.39/043-Re-PR29466-APP-NO_APP-with-linefile.patch
deleted file mode 100644
index 1de501a1..00000000
--- a/toolchain/binutils/patches/2.39/043-Re-PR29466-APP-NO_APP-with-linefile.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 4233be14a34d754a70b8b6f6fa42d21f35c6e030 Mon Sep 17 00:00:00 2001
-From: Alan Modra <amodra@gmail.com>
-Date: Sat, 10 Sep 2022 07:30:57 +0930
-Subject: [PATCH 043/160] Re: PR29466, APP/NO_APP with linefile
-
-It looks like I copied the SIZE init across from
-binutils/testsuite/config/default.exp without some necessary editing.
-
-	PR 29466
-	* testsuite/config/default.exp (SIZE): Adjust relative path.
-
-(cherry picked from commit 1180f540d5f2f7751b5309bdd6c38d69fcf699e7)
----
- gas/testsuite/config/default.exp | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/gas/testsuite/config/default.exp
-+++ b/gas/testsuite/config/default.exp
-@@ -53,7 +53,7 @@ if ![info exists NMFLAGS] then {
- }
- 
- if ![info exists SIZE] then {
--    set SIZE [findfile $base_dir/size]
-+    set SIZE [findfile $base_dir/../../binutils/size]
- }
- 
- if ![info exists SIZEFLAGS] then {
diff --git a/toolchain/binutils/patches/2.39/050-PowerPC64-pcrel-got-relocs-against-local-symbols.patch b/toolchain/binutils/patches/2.39/050-PowerPC64-pcrel-got-relocs-against-local-symbols.patch
deleted file mode 100644
index 5c89f680..00000000
--- a/toolchain/binutils/patches/2.39/050-PowerPC64-pcrel-got-relocs-against-local-symbols.patch
+++ /dev/null
@@ -1,38 +0,0 @@
-From 4d7bba23a39fba18d6d13a2941a3c232011a7064 Mon Sep 17 00:00:00 2001
-From: Alan Modra <amodra@gmail.com>
-Date: Fri, 16 Sep 2022 18:08:44 +0930
-Subject: [PATCH 050/160] PowerPC64 pcrel got relocs against local symbols
-
-Not that anyone would want to indirect via the GOT when an address can
-be loaded directly with pla, the following:
-
- pld 3,x@got@pcrel
-x:
-
-leads to "Internal error in md_apply_fix", because the generic parts
-of assembler fixup handling convert the fx_pcrel fixup to one without
-a symbol.  Stop that happening.
-
-	* config/tc-ppc.c (ppc_force_relocation): Add PLT_PCREL34 and
-	assorted GOT_PCREL34 relocs.
-
-(cherry picked from commit 49c3ed081fed6b8e2b48fdc48f805f11e4589514)
----
- gas/config/tc-ppc.c | 6 ++++++
- 1 file changed, 6 insertions(+)
-
---- a/gas/config/tc-ppc.c
-+++ b/gas/config/tc-ppc.c
-@@ -6676,6 +6676,12 @@ ppc_force_relocation (fixS *fix)
-     case BFD_RELOC_PPC_BA16_BRNTAKEN:
-     case BFD_RELOC_24_PLT_PCREL:
-     case BFD_RELOC_PPC64_TOC:
-+    case BFD_RELOC_PPC64_PLT_PCREL34:
-+    case BFD_RELOC_PPC64_GOT_PCREL34:
-+    case BFD_RELOC_PPC64_GOT_TLSGD_PCREL34:
-+    case BFD_RELOC_PPC64_GOT_TLSLD_PCREL34:
-+    case BFD_RELOC_PPC64_GOT_TPREL_PCREL34:
-+    case BFD_RELOC_PPC64_GOT_DTPREL_PCREL34:
-       return 1;
-     case BFD_RELOC_PPC_B26:
-     case BFD_RELOC_PPC_BA26:
diff --git a/toolchain/binutils/patches/2.39/055-Re-PowerPC64-pcrel-got-relocs-against-local-symbols.patch b/toolchain/binutils/patches/2.39/055-Re-PowerPC64-pcrel-got-relocs-against-local-symbols.patch
deleted file mode 100644
index 19b80c34..00000000
--- a/toolchain/binutils/patches/2.39/055-Re-PowerPC64-pcrel-got-relocs-against-local-symbols.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From 010db38b54b589ca3e95b498aba2831064970171 Mon Sep 17 00:00:00 2001
-From: Alan Modra <amodra@gmail.com>
-Date: Wed, 21 Sep 2022 09:06:29 +0930
-Subject: [PATCH 055/160] Re: PowerPC64 pcrel got relocs against local symbols
-
-The last patch wasn't all that shiny.  There are rather a lot more
-relocations that can hit the assertion in md_apply_fix if the symbol
-is local or absolute.  Fix them all.
-
-	* config/tc-ppc.c (ppc_force_relocation): Add all relocs that
-	expect a symbol in md_apply_fix.  Remove tls pcrel relocs
-	already covered in general tls match range.
-
-(cherry picked from commit 8b168f1a1e09e337d2a970f204a0230c091bbe58)
----
- gas/config/tc-ppc.c | 58 ++++++++++++++++++++++++++++++++++++++++-----
- 1 file changed, 52 insertions(+), 6 deletions(-)
-
---- a/gas/config/tc-ppc.c
-+++ b/gas/config/tc-ppc.c
-@@ -6666,8 +6666,6 @@ ppc_force_relocation (fixS *fix)
- int
- ppc_force_relocation (fixS *fix)
- {
--  /* Branch prediction relocations must force a relocation, as must
--     the vtable description relocs.  */
-   switch (fix->fx_r_type)
-     {
-     case BFD_RELOC_PPC_B16_BRTAKEN:
-@@ -6676,12 +6674,60 @@ ppc_force_relocation (fixS *fix)
-     case BFD_RELOC_PPC_BA16_BRNTAKEN:
-     case BFD_RELOC_24_PLT_PCREL:
-     case BFD_RELOC_PPC64_TOC:
-+    case BFD_RELOC_16_GOTOFF:
-+    case BFD_RELOC_LO16_GOTOFF:
-+    case BFD_RELOC_HI16_GOTOFF:
-+    case BFD_RELOC_HI16_S_GOTOFF:
-+    case BFD_RELOC_LO16_PLTOFF:
-+    case BFD_RELOC_HI16_PLTOFF:
-+    case BFD_RELOC_HI16_S_PLTOFF:
-+    case BFD_RELOC_GPREL16:
-+    case BFD_RELOC_16_BASEREL:
-+    case BFD_RELOC_LO16_BASEREL:
-+    case BFD_RELOC_HI16_BASEREL:
-+    case BFD_RELOC_HI16_S_BASEREL:
-+    case BFD_RELOC_PPC_TOC16:
-+    case BFD_RELOC_PPC64_TOC16_LO:
-+    case BFD_RELOC_PPC64_TOC16_HI:
-+    case BFD_RELOC_PPC64_TOC16_HA:
-+    case BFD_RELOC_PPC64_PLTGOT16:
-+    case BFD_RELOC_PPC64_PLTGOT16_LO:
-+    case BFD_RELOC_PPC64_PLTGOT16_HI:
-+    case BFD_RELOC_PPC64_PLTGOT16_HA:
-+    case BFD_RELOC_PPC64_GOT16_DS:
-+    case BFD_RELOC_PPC64_GOT16_LO_DS:
-+    case BFD_RELOC_PPC64_PLT16_LO_DS:
-+    case BFD_RELOC_PPC64_SECTOFF_DS:
-+    case BFD_RELOC_PPC64_SECTOFF_LO_DS:
-+    case BFD_RELOC_PPC64_TOC16_DS:
-+    case BFD_RELOC_PPC64_TOC16_LO_DS:
-+    case BFD_RELOC_PPC64_PLTGOT16_DS:
-+    case BFD_RELOC_PPC64_PLTGOT16_LO_DS:
-+    case BFD_RELOC_PPC_EMB_NADDR16:
-+    case BFD_RELOC_PPC_EMB_NADDR16_LO:
-+    case BFD_RELOC_PPC_EMB_NADDR16_HI:
-+    case BFD_RELOC_PPC_EMB_NADDR16_HA:
-+    case BFD_RELOC_PPC_EMB_SDAI16:
-+    case BFD_RELOC_PPC_EMB_SDA2I16:
-+    case BFD_RELOC_PPC_EMB_SDA2REL:
-+    case BFD_RELOC_PPC_EMB_SDA21:
-+    case BFD_RELOC_PPC_EMB_MRKREF:
-+    case BFD_RELOC_PPC_EMB_RELSEC16:
-+    case BFD_RELOC_PPC_EMB_RELST_LO:
-+    case BFD_RELOC_PPC_EMB_RELST_HI:
-+    case BFD_RELOC_PPC_EMB_RELST_HA:
-+    case BFD_RELOC_PPC_EMB_BIT_FLD:
-+    case BFD_RELOC_PPC_EMB_RELSDA:
-+    case BFD_RELOC_PPC_VLE_SDA21:
-+    case BFD_RELOC_PPC_VLE_SDA21_LO:
-+    case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
-+    case BFD_RELOC_PPC_VLE_SDAREL_LO16D:
-+    case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
-+    case BFD_RELOC_PPC_VLE_SDAREL_HI16D:
-+    case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
-+    case BFD_RELOC_PPC_VLE_SDAREL_HA16D:
-     case BFD_RELOC_PPC64_PLT_PCREL34:
-     case BFD_RELOC_PPC64_GOT_PCREL34:
--    case BFD_RELOC_PPC64_GOT_TLSGD_PCREL34:
--    case BFD_RELOC_PPC64_GOT_TLSLD_PCREL34:
--    case BFD_RELOC_PPC64_GOT_TPREL_PCREL34:
--    case BFD_RELOC_PPC64_GOT_DTPREL_PCREL34:
-       return 1;
-     case BFD_RELOC_PPC_B26:
-     case BFD_RELOC_PPC_BA26:
diff --git a/toolchain/binutils/patches/2.39/058-elf-Reset-alignment-for-each-PT_LOAD-segment.patch b/toolchain/binutils/patches/2.39/058-elf-Reset-alignment-for-each-PT_LOAD-segment.patch
deleted file mode 100644
index aaf7a1b0..00000000
--- a/toolchain/binutils/patches/2.39/058-elf-Reset-alignment-for-each-PT_LOAD-segment.patch
+++ /dev/null
@@ -1,89 +0,0 @@
-From a98316d5cf970cbc99689797d84c2ea832bcdcbb Mon Sep 17 00:00:00 2001
-From: "H.J. Lu" <hjl.tools@gmail.com>
-Date: Mon, 1 Aug 2022 16:02:39 -0700
-Subject: [PATCH 058/160] elf: Reset alignment for each PT_LOAD segment
-
-Reset alignment for each PT_LOAD segment to avoid using alignment from
-the previous PT_LOAD segment.
-
-bfd/
-
-	PR ld/29435
-	* elf.c (assign_file_positions_for_load_sections): Reset
-	alignment for each PT_LOAD segment.
-
-ld/
-
-	PR ld/29435
-	* testsuite/ld-elf/pr29435.d: New file.
-	* testsuite/ld-elf/pr29435.s: Likewise.
-
-(cherry picked from commit 59f214544c50ec7ebbca285ff2b4949f48671690)
----
- bfd/elf.c                     |  7 ++++---
- ld/testsuite/ld-elf/pr29435.d | 11 +++++++++++
- ld/testsuite/ld-elf/pr29435.s |  6 ++++++
- 3 files changed, 21 insertions(+), 3 deletions(-)
- create mode 100644 ld/testsuite/ld-elf/pr29435.d
- create mode 100644 ld/testsuite/ld-elf/pr29435.s
-
---- a/bfd/elf.c
-+++ b/bfd/elf.c
-@@ -5438,8 +5438,6 @@ assign_file_positions_for_load_sections
-   Elf_Internal_Phdr *p;
-   file_ptr off;  /* Octets.  */
-   bfd_size_type maxpagesize;
--  bfd_size_type p_align;
--  bool p_align_p = false;
-   unsigned int alloc, actual;
-   unsigned int i, j;
-   struct elf_segment_map **sorted_seg_map;
-@@ -5524,7 +5522,6 @@ assign_file_positions_for_load_sections
-     qsort (sorted_seg_map, alloc, sizeof (*sorted_seg_map),
- 	   elf_sort_segments);
- 
--  p_align = bed->p_align;
-   maxpagesize = 1;
-   if ((abfd->flags & D_PAGED) != 0)
-     {
-@@ -5559,6 +5556,8 @@ assign_file_positions_for_load_sections
-       asection **secpp;
-       bfd_vma off_adjust;  /* Octets.  */
-       bool no_contents;
-+      bfd_size_type p_align;
-+      bool p_align_p;
- 
-       /* An ELF segment (described by Elf_Internal_Phdr) may contain a
- 	 number of sections with contents contributing to both p_filesz
-@@ -5569,6 +5568,8 @@ assign_file_positions_for_load_sections
-       p = phdrs + m->idx;
-       p->p_type = m->p_type;
-       p->p_flags = m->p_flags;
-+      p_align = bed->p_align;
-+      p_align_p = false;
- 
-       if (m->count == 0)
- 	p->p_vaddr = m->p_vaddr_offset * opb;
---- /dev/null
-+++ b/ld/testsuite/ld-elf/pr29435.d
-@@ -0,0 +1,11 @@
-+#ld: -shared -z separate-code -z relro
-+#xfail: ![check_shared_lib_support]
-+#xfail: ![check_relro_support]
-+#readelf: -Wl
-+
-+#failif
-+#...
-+ +LOAD +0x[0-9a-f]+ 0x[0-9a-f]+ 0x[0-9a-f]+ 0x[0-9a-f]+ 0x[0-9a-f]+ .* 0x8000
-+#...
-+ +LOAD +0x[0-9a-f]+ 0x[0-9a-f]+ 0x[0-9a-f]+ 0x[0-9a-f]+ 0x[0-9a-f]+ .* 0x8000
-+#...
---- /dev/null
-+++ b/ld/testsuite/ld-elf/pr29435.s
-@@ -0,0 +1,6 @@
-+        .text
-+	.balign 0x8000
-+	.globl	foo
-+	.type	foo, %function
-+foo:
-+	.byte 0
diff --git a/toolchain/binutils/patches/2.39/063-PR29542-PowerPC-gold-internal-error-in-get_output_vi.patch b/toolchain/binutils/patches/2.39/063-PR29542-PowerPC-gold-internal-error-in-get_output_vi.patch
deleted file mode 100644
index 0d66b775..00000000
--- a/toolchain/binutils/patches/2.39/063-PR29542-PowerPC-gold-internal-error-in-get_output_vi.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From 041c22e35de06d22566f4c71e4425c3351215e66 Mon Sep 17 00:00:00 2001
-From: Alan Modra <amodra@gmail.com>
-Date: Sun, 25 Sep 2022 12:07:36 +0930
-Subject: [PATCH 063/160] PR29542, PowerPC gold internal error in
- get_output_view,
-
-We were attempting to set a BSS style section contents.
-
-	PR 29542
-	* powerpc.cc (Output_data_plt_powerpc::do_write): Don't set .plt,
-	.iplt or .lplt section contents when position independent.
-
-(cherry picked from commit c21736aed1d4877e090df60362413669dbdc391d)
----
- gold/powerpc.cc | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/gold/powerpc.cc
-+++ b/gold/powerpc.cc
-@@ -4338,7 +4338,8 @@ template<int size, bool big_endian>
- void
- Output_data_plt_powerpc<size, big_endian>::do_write(Output_file* of)
- {
--  if (!this->sym_ents_.empty())
-+  if (!this->sym_ents_.empty()
-+      && !parameters->options().output_is_position_independent())
-     {
-       const section_size_type offset = this->offset();
-       const section_size_type oview_size
diff --git a/toolchain/binutils/patches/2.39/116-arm-Use-DWARF-numbering-convention-for-pseudo-regist.patch b/toolchain/binutils/patches/2.39/116-arm-Use-DWARF-numbering-convention-for-pseudo-regist.patch
deleted file mode 100644
index 82a015ee..00000000
--- a/toolchain/binutils/patches/2.39/116-arm-Use-DWARF-numbering-convention-for-pseudo-regist.patch
+++ /dev/null
@@ -1,301 +0,0 @@
-From 88ac930a725b8aac8284a2738f03b843f4343dd0 Mon Sep 17 00:00:00 2001
-From: Victor Do Nascimento <Victor.DoNascimento@arm.com>
-Date: Thu, 17 Nov 2022 14:48:37 +0000
-Subject: [PATCH 116/160] arm: Use DWARF numbering convention for
- pseudo-register representation
-
-The patch, initially submitted to trunk in
-https://sourceware.org/pipermail/binutils/2022-July/122092.html ensures correct
-support for handling .save directives for mixed-register type lists involving
-the ra_auth_code pseudo-register, whereby the support first introduced in 2.39
-(https://sourceware.org/pipermail/binutils/2022-May/120672.html) led to the
-generation of unwinder code popping registers in reversed order.
-
-gas/Changelog:
-
-  * config/tc-arm.c (REG_RA_AUTH_CODE): New.
-  (parse_dot_save): Likewise.
-  (parse_reg_list): Remove obsolete code.
-  (reg_names): Set ra_auth_code to 143.
-  (s_arm_unwind_save): Handle core and pseudo-register lists via
-  parse_dot_save.
-  (s_arm_unwind_save_mixed): Deleted.
-  (s_arm_unwind_save_pseudo): Handle one register at a time.
-  * testsuite/gas/arm/unwind-pacbti-m-readelf.d: Fix test.
-  * testsuite/gas/arm/unwind-pacbti-m.d: Likewise.
-
-(cherry picked from commit 3a368c4c248f6e9f4bda3a5369befa17a4560293)
----
- gas/config/tc-arm.c                           | 159 ++++++++++--------
- .../gas/arm/unwind-pacbti-m-readelf.d         |   4 +-
- gas/testsuite/gas/arm/unwind-pacbti-m.d       |   2 +-
- 3 files changed, 95 insertions(+), 70 deletions(-)
-
---- a/gas/config/tc-arm.c
-+++ b/gas/config/tc-arm.c
-@@ -742,6 +742,7 @@ const char * const reg_expected_msgs[] =
- #define REG_SP	13
- #define REG_LR	14
- #define REG_PC	15
-+#define REG_RA_AUTH_CODE 143
- 
- /* ARM instructions take 4bytes in the object file, Thumb instructions
-    take 2:  */
-@@ -1943,21 +1944,6 @@ parse_reg_list (char ** strp, enum reg_l
- 
- 	      reg = arm_reg_parse (&str, rt);
- 
--	      /* Skip over allowed registers of alternative types in mixed-type
--	         register lists.  */
--	      if (reg == FAIL && rt == REG_TYPE_PSEUDO
--		  && ((reg = arm_reg_parse (&str, REG_TYPE_RN)) != FAIL))
--		{
--		  cur_reg = reg;
--		  continue;
--		}
--	      else if (reg == FAIL && rt == REG_TYPE_RN
--		       && ((reg = arm_reg_parse (&str, REG_TYPE_PSEUDO)) != FAIL))
--		{
--		  cur_reg = reg;
--		  continue;
--		}
--
- 	      if (etype == REGLIST_CLRM)
- 		{
- 		  if (reg == REG_SP || reg == REG_PC)
-@@ -4139,7 +4125,6 @@ s_arm_unwind_fnstart (int ignored ATTRIB
-   unwind.sp_restored = 0;
- }
- 
--
- /* Parse a handlerdata directive.  Creates the exception handling table entry
-    for the function.  */
- 
-@@ -4297,15 +4282,19 @@ s_arm_unwind_personality (int ignored AT
- /* Parse a directive saving pseudo registers.  */
- 
- static void
--s_arm_unwind_save_pseudo (long range)
-+s_arm_unwind_save_pseudo (int regno)
- {
-   valueT op;
- 
--  if (range & (1 << 12))
-+  switch (regno)
-     {
-+    case REG_RA_AUTH_CODE:
-       /* Opcode for restoring RA_AUTH_CODE.  */
-       op = 0xb4;
-       add_unwind_opcode (op, 1);
-+      break;
-+    default:
-+      as_bad (_("Unknown register %d encountered\n"), regno);
-     }
- }
- 
-@@ -4375,6 +4364,80 @@ s_arm_unwind_save_core (long range)
-     }
- }
- 
-+/* Implement correct handling of .save lists enabling the split into
-+sublists where necessary, while preserving correct sublist ordering.  */
-+
-+static void
-+parse_dot_save (char **str_p, int prev_reg)
-+{
-+  long core_regs = 0;
-+  int reg;
-+  int in_range = 0;
-+
-+  if (**str_p == ',')
-+    *str_p += 1;
-+  if (**str_p == '}')
-+    {
-+      *str_p += 1;
-+      return;
-+    }
-+
-+  while ((reg = arm_reg_parse (str_p, REG_TYPE_RN)) != FAIL)
-+    {
-+      if (!in_range)
-+	{
-+	  if (core_regs & (1 << reg))
-+	    as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
-+		       reg);
-+	  else if (reg <= prev_reg)
-+	    as_tsktsk (_("Warning: register list not in ascending order"));
-+
-+	  core_regs |= (1 << reg);
-+	  prev_reg = reg;
-+	  if (skip_past_char(str_p, '-') != FAIL)
-+	    in_range = 1;
-+	  else if (skip_past_comma(str_p) == FAIL)
-+	    first_error (_("bad register list"));
-+	}
-+      else
-+	{
-+	  int i;
-+	  if (reg <= prev_reg)
-+	    first_error (_("bad range in register list"));
-+	  for (i = prev_reg + 1; i <= reg; i++)
-+	    {
-+	      if (core_regs & (1 << i))
-+		as_tsktsk (_("Warning: duplicated register (r%d) in register list"),
-+			   i);
-+	      else
-+		core_regs |= 1 << i;
-+	    }
-+	  in_range = 0;
-+	}
-+    }
-+  if (core_regs)
-+    {
-+      /* Higher register numbers go in higher memory addresses.  When splitting a list,
-+	 right-most sublist should therefore be .saved first.  Use recursion for this.  */
-+      parse_dot_save (str_p, reg);
-+      /* We're back from recursion, so emit .save insn for sublist.  */
-+      s_arm_unwind_save_core (core_regs);
-+      return;
-+    }
-+  /* Handle pseudo-regs, under assumption these are emitted singly.  */
-+  else if ((reg = arm_reg_parse (str_p, REG_TYPE_PSEUDO)) != FAIL)
-+    {
-+      /* Recurse for remainder of input.  Note: No assumption is made regarding which
-+	 register in core register set holds pseudo-register.  It's not considered in
-+	 ordering check beyond ensuring it's not sandwiched between 2 consecutive
-+	 registers.  */
-+      parse_dot_save (str_p, prev_reg + 1);
-+      s_arm_unwind_save_pseudo (reg);
-+      return;
-+    }
-+  else
-+    as_bad (BAD_SYNTAX);
-+}
- 
- /* Parse a directive saving FPA registers.  */
- 
-@@ -4716,39 +4779,13 @@ s_arm_unwind_save_mmxwcg (void)
-   ignore_rest_of_line ();
- }
- 
--/* Convert range and mask_range into a sequence of s_arm_unwind_core
--   and s_arm_unwind_pseudo operations.  We assume that mask_range will
--   not have consecutive bits set, or that one operation per bit is
--   acceptable.  */
--
--static void
--s_arm_unwind_save_mixed (long range, long mask_range)
--{
--  while (mask_range)
--    {
--      long mask_bit = mask_range & -mask_range;
--      long subrange = range & (mask_bit - 1);
--
--      if (subrange)
--	s_arm_unwind_save_core (subrange);
--
--      s_arm_unwind_save_pseudo (mask_bit);
--      range &= ~subrange;
--      mask_range &= ~mask_bit;
--    }
--
--  if (range)
--    s_arm_unwind_save_core (range);
--}
--
- /* Parse an unwind_save directive.
-    If the argument is non-zero, this is a .vsave directive.  */
- 
- static void
- s_arm_unwind_save (int arch_v6)
- {
--  char *peek, *mask_peek;
--  long range, mask_range;
-+  char *peek;
-   struct reg_entry *reg;
-   bool had_brace = false;
- 
-@@ -4756,7 +4793,7 @@ s_arm_unwind_save (int arch_v6)
-     as_bad (MISSING_FNSTART);
- 
-   /* Figure out what sort of save we have.  */
--  peek = mask_peek = input_line_pointer;
-+  peek = input_line_pointer;
- 
-   if (*peek == '{')
-     {
-@@ -4788,20 +4825,13 @@ s_arm_unwind_save (int arch_v6)
- 
-     case REG_TYPE_PSEUDO:
-     case REG_TYPE_RN:
--      mask_range = parse_reg_list (&mask_peek, REGLIST_PSEUDO);
--      range = parse_reg_list (&input_line_pointer, REGLIST_RN);
--
--      if (range == FAIL || mask_range == FAIL)
--	{
--	  as_bad (_("expected register list"));
--	  ignore_rest_of_line ();
--	  return;
--	}
--
--      demand_empty_rest_of_line ();
--
--      s_arm_unwind_save_mixed (range, mask_range);
--      return;
-+      {
-+	if (had_brace)
-+	  input_line_pointer++;
-+	parse_dot_save (&input_line_pointer, -1);
-+	demand_empty_rest_of_line ();
-+	return;
-+      }
- 
-     case REG_TYPE_VFD:
-       if (arch_v6)
-@@ -23993,12 +24023,8 @@ static const struct reg_entry reg_names[
-   /* XScale accumulator registers.  */
-   REGNUM(acc,0,XSCALE), REGNUM(ACC,0,XSCALE),
- 
--  /* DWARF ABI defines RA_AUTH_CODE to 143. It also reserves 134-142 for future
--     expansion.  RA_AUTH_CODE here is given the value 143 % 134 to make it easy
--     for tc_arm_regname_to_dw2regnum to translate to DWARF reg number using
--     134 + reg_number should the range 134 to 142 be used for more pseudo regs
--     in the future.  This also helps fit RA_AUTH_CODE into a bitmask.  */
--  REGDEF(ra_auth_code,12,PSEUDO),
-+  /* AADWARF32 defines RA_AUTH_CODE to 143.  */
-+  REGDEF(ra_auth_code,143,PSEUDO),
- };
- #undef REGDEF
- #undef REGNUM
-@@ -27905,7 +27931,6 @@ create_unwind_entry (int have_data)
-   return 0;
- }
- 
--
- /* Initialize the DWARF-2 unwind information for this procedure.  */
- 
- void
---- a/gas/testsuite/gas/arm/unwind-pacbti-m-readelf.d
-+++ b/gas/testsuite/gas/arm/unwind-pacbti-m-readelf.d
-@@ -10,11 +10,11 @@ Unwind section '.ARM.exidx' at offset 0x
- 
- 0x0 <foo>: @0x0
-   Compact model index: 1
--  0x84 0x00 pop {r14}
-   0xb4      pop {ra_auth_code}
-   0x84 0x00 pop {r14}
--  0xb4      pop {ra_auth_code}
-   0xa3      pop {r4, r5, r6, r7}
-   0xb4      pop {ra_auth_code}
-+  0x84 0x00 pop {r14}
-+  0xb4      pop {ra_auth_code}
-   0xa8      pop {r4, r14}
-   0xb0      finish
---- a/gas/testsuite/gas/arm/unwind-pacbti-m.d
-+++ b/gas/testsuite/gas/arm/unwind-pacbti-m.d
-@@ -8,4 +8,4 @@
- .*:     file format.*
- 
- Contents of section .ARM.extab:
-- 0000 (00840281 b40084b4 b0a8b4a3|81028400 b48400b4 a3b4a8b0) 00000000  .*
-+ 0000 (84b40281 84b4a300 b0a8b400|8102b484 00a3b484 00b4a8b0) 00000000  .*
diff --git a/toolchain/binutils/patches/2.39/300-001_ld_makefile_patch.patch b/toolchain/binutils/patches/2.39/300-001_ld_makefile_patch.patch
deleted file mode 100644
index ac80bf42..00000000
--- a/toolchain/binutils/patches/2.39/300-001_ld_makefile_patch.patch
+++ /dev/null
@@ -1,22 +0,0 @@
---- a/ld/Makefile.am
-+++ b/ld/Makefile.am
-@@ -50,7 +50,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- 
- EMUL = @EMUL@
- EMULATION_OFILES = @EMULATION_OFILES@
---- a/ld/Makefile.in
-+++ b/ld/Makefile.in
-@@ -569,7 +569,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- BASEDIR = $(srcdir)/..
- BFDDIR = $(BASEDIR)/bfd
- INCDIR = $(BASEDIR)/include
diff --git a/toolchain/binutils/patches/2.39/400-mips_no_dynamic_linking_sym.patch b/toolchain/binutils/patches/2.39/400-mips_no_dynamic_linking_sym.patch
deleted file mode 100644
index f499dfdc..00000000
--- a/toolchain/binutils/patches/2.39/400-mips_no_dynamic_linking_sym.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/bfd/elfxx-mips.c
-+++ b/bfd/elfxx-mips.c
-@@ -8066,6 +8066,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
-       bh = NULL;
-+      if (0) {
-       if (!(_bfd_generic_link_add_one_symbol
- 	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
- 	     NULL, false, get_elf_backend_data (abfd)->collect, &bh)))
-@@ -8078,6 +8079,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       if (! bfd_elf_link_record_dynamic_symbol (info, h))
- 	return false;
-+      }
- 
-       if (! mips_elf_hash_table (info)->use_rld_obj_head)
- 	{
diff --git a/toolchain/binutils/patches/2.39/500-Change-default-emulation-for-mips64-linux.patch b/toolchain/binutils/patches/2.39/500-Change-default-emulation-for-mips64-linux.patch
deleted file mode 100644
index 8a43563d..00000000
--- a/toolchain/binutils/patches/2.39/500-Change-default-emulation-for-mips64-linux.patch
+++ /dev/null
@@ -1,38 +0,0 @@
---- a/bfd/config.bfd
-+++ b/bfd/config.bfd
-@@ -928,12 +928,12 @@ case "${targ}" in
-     targ_selvecs="mips_elf32_le_vec mips_elf64_be_vec mips_elf64_le_vec mips_ecoff_be_vec mips_ecoff_le_vec"
-     ;;
-   mips64*el-*-linux*)
--    targ_defvec=mips_elf32_ntrad_le_vec
--    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_le_vec mips_elf64_trad_be_vec"
-+    targ_defvec=mips_elf64_trad_le_vec
-+    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_be_vec"
-     ;;
-   mips64*-*-linux*)
--    targ_defvec=mips_elf32_ntrad_be_vec
--    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
-+    targ_defvec=mips_elf64_trad_be_vec
-+    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_le_vec"
-     ;;
-   mips*el-*-linux*)
-     targ_defvec=mips_elf32_trad_le_vec
---- a/ld/configure.tgt
-+++ b/ld/configure.tgt
-@@ -580,12 +580,12 @@ mips*-*-vxworks*)	targ_emul=elf32ebmipvx
- 			;;
- mips*-*-windiss)	targ_emul=elf32mipswindiss
- 			;;
--mips64*el-*-linux-*)	targ_emul=elf32ltsmipn32
--			targ_extra_emuls="elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip"
-+mips64*el-*-linux-*)	targ_emul=elf64ltsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32ltsmip elf32btsmip elf64btsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
--mips64*-*-linux-*)	targ_emul=elf32btsmipn32
--			targ_extra_emuls="elf32ltsmipn32 elf32btsmip elf32ltsmip elf64btsmip elf64ltsmip"
-+mips64*-*-linux-*)	targ_emul=elf64btsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32btsmip elf32ltsmip elf64ltsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
- mips*el-*-linux-*)	targ_emul=elf32ltsmip
diff --git a/toolchain/binutils/patches/2.41/300-001_ld_makefile_patch.patch b/toolchain/binutils/patches/2.41/300-001_ld_makefile_patch.patch
deleted file mode 100644
index 2dafd92a..00000000
--- a/toolchain/binutils/patches/2.41/300-001_ld_makefile_patch.patch
+++ /dev/null
@@ -1,22 +0,0 @@
---- a/ld/Makefile.am
-+++ b/ld/Makefile.am
-@@ -50,7 +50,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- 
- EMUL = @EMUL@
- EMULATION_OFILES = @EMULATION_OFILES@
---- a/ld/Makefile.in
-+++ b/ld/Makefile.in
-@@ -573,7 +573,7 @@ AM_CFLAGS = $(WARN_CFLAGS) $(ELF_CLFAGS)
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- BASEDIR = $(srcdir)/..
- BFDDIR = $(BASEDIR)/bfd
- INCDIR = $(BASEDIR)/include
diff --git a/toolchain/binutils/patches/2.41/400-mips_no_dynamic_linking_sym.patch b/toolchain/binutils/patches/2.41/400-mips_no_dynamic_linking_sym.patch
deleted file mode 100644
index c50a988d..00000000
--- a/toolchain/binutils/patches/2.41/400-mips_no_dynamic_linking_sym.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/bfd/elfxx-mips.c
-+++ b/bfd/elfxx-mips.c
-@@ -8144,6 +8144,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       name = SGI_COMPAT (abfd) ? "_DYNAMIC_LINK" : "_DYNAMIC_LINKING";
-       bh = NULL;
-+      if (0) {
-       if (!(_bfd_generic_link_add_one_symbol
- 	    (info, abfd, name, BSF_GLOBAL, bfd_abs_section_ptr, 0,
- 	     NULL, false, get_elf_backend_data (abfd)->collect, &bh)))
-@@ -8156,6 +8157,7 @@ _bfd_mips_elf_create_dynamic_sections (b
- 
-       if (! bfd_elf_link_record_dynamic_symbol (info, h))
- 	return false;
-+      }
- 
-       if (! mips_elf_hash_table (info)->use_rld_obj_head)
- 	{
diff --git a/toolchain/binutils/patches/2.41/500-Change-default-emulation-for-mips64-linux.patch b/toolchain/binutils/patches/2.41/500-Change-default-emulation-for-mips64-linux.patch
deleted file mode 100644
index 60676bbe..00000000
--- a/toolchain/binutils/patches/2.41/500-Change-default-emulation-for-mips64-linux.patch
+++ /dev/null
@@ -1,48 +0,0 @@
---- a/bfd/config.bfd
-+++ b/bfd/config.bfd
-@@ -947,8 +947,8 @@ case "${targ}" in
-     want64=true
-     ;;
-   mips64*el-*-linux*)
--    targ_defvec=mips_elf32_ntrad_le_vec
--    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_le_vec mips_elf64_trad_be_vec"
-+    targ_defvec=mips_elf64_trad_le_vec
-+    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_ntrad_be_vec mips_elf32_trad_le_vec mips_elf32_trad_be_vec mips_elf64_trad_be_vec"
-     ;;
-   mips64*-*-linux*-gnuabi64)
-     targ_defvec=mips_elf64_trad_be_vec
-@@ -956,8 +956,8 @@ case "${targ}" in
-     want64=true
-     ;;
-   mips64*-*-linux*)
--    targ_defvec=mips_elf32_ntrad_be_vec
--    targ_selvecs="mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_be_vec mips_elf64_trad_le_vec"
-+    targ_defvec=mips_elf64_trad_be_vec
-+    targ_selvecs="mips_elf32_ntrad_be_vec mips_elf32_ntrad_le_vec mips_elf32_trad_be_vec mips_elf32_trad_le_vec mips_elf64_trad_le_vec"
-     ;;
-   mips*el-*-linux*)
-     targ_defvec=mips_elf32_trad_le_vec
---- a/ld/configure.tgt
-+++ b/ld/configure.tgt
-@@ -585,8 +585,8 @@ mips64*el-*-linux-gnuabi64)
- 			targ_extra_emuls="elf64btsmip elf32ltsmipn32 elf32btsmipn32 elf32ltsmip elf32btsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
--mips64*el-*-linux-*)	targ_emul=elf32ltsmipn32
--			targ_extra_emuls="elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip"
-+mips64*el-*-linux-*)	targ_emul=elf64ltsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32ltsmip elf32btsmip elf64btsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
- mips64*-*-linux-gnuabi64)
-@@ -594,8 +594,8 @@ mips64*-*-linux-gnuabi64)
- 			targ_extra_emuls="elf64ltsmip elf32btsmipn32 elf32ltsmipn32 elf32btsmip elf32ltsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
--mips64*-*-linux-*)	targ_emul=elf32btsmipn32
--			targ_extra_emuls="elf32ltsmipn32 elf32btsmip elf32ltsmip elf64btsmip elf64ltsmip"
-+mips64*-*-linux-*)	targ_emul=elf64btsmip
-+			targ_extra_emuls="elf32btsmipn32 elf32ltsmipn32 elf32btsmip elf32ltsmip elf64ltsmip"
- 			targ_extra_libpath=$targ_extra_emuls
- 			;;
- mips*el-*-linux-*)	targ_emul=elf32ltsmip
diff --git a/toolchain/gcc/Config.in b/toolchain/gcc/Config.in
index 714620db..b306040f 100644
--- a/toolchain/gcc/Config.in
+++ b/toolchain/gcc/Config.in
@@ -2,22 +2,21 @@
 
 choice
 	prompt "GCC compiler Version" if TOOLCHAINOPTS
-	default GCC_USE_VERSION_8 if mips || mipsel || mips64 || mips64el
 	default GCC_USE_VERSION_13
 	help
 	  Select the version of gcc you wish to use.
 
-	config GCC_USE_VERSION_8
-		bool "gcc 8.x"
-
 	config GCC_USE_VERSION_11
 		bool "gcc 11.x"
 
 	config GCC_USE_VERSION_12
 		bool "gcc 12.x"
-		
+
 	config GCC_USE_VERSION_13
-		bool "gcc 13.x"	
+		bool "gcc 13.x"
+
+	config GCC_USE_VERSION_14
+		bool "gcc 14.x"
 endchoice
 
 config GCC_USE_GRAPHITE
@@ -34,21 +33,18 @@ config EXTRA_GCC_CONFIG_OPTIONS
 config GCC_DEFAULT_PIE
 	bool
 	prompt "Build executable with PIE enabled by default" if TOOLCHAINOPTS
-	default n
 	help
 	    Use gcc configure option --enable-default-pie to turn on -fPIE and -pie by default.
 
 config GCC_DEFAULT_SSP
 	bool
 	prompt "Build executable with Stack-Smashing Protection enabled by default" if TOOLCHAINOPTS
-	default n
 	help
 	    Use gcc configure option --enable-default-ssp to turn on -fstack-protector-strong by default.
 
 config SJLJ_EXCEPTIONS
 	bool
 	prompt "Use setjump()/longjump() exceptions" if TOOLCHAINOPTS
-	default n
 	help
 	    Use old setjump()/longjump() exceptions instead of the newer
 	    frame unwinding exceptions handling routines.  Warning: increases
@@ -57,7 +53,6 @@ config SJLJ_EXCEPTIONS
 config INSTALL_GFORTRAN
 	bool
 	prompt "Build/install fortran compiler?" if TOOLCHAINOPTS
-	default n
 	help
 	    Build/install GNU fortran compiler ?
 
@@ -65,6 +60,5 @@ config INSTALL_GCCGO
 	bool
 	prompt "Build/install Go compiler?" if TOOLCHAINOPTS
 	depends on USE_GLIBC || BROKEN
-	default n
 	help
 	    Build/install GNU gccgo compiler ?
diff --git a/toolchain/gcc/Config.version b/toolchain/gcc/Config.version
index 83d07717..49bb3686 100644
--- a/toolchain/gcc/Config.version
+++ b/toolchain/gcc/Config.version
@@ -1,8 +1,3 @@
-config GCC_VERSION_8
-	default y if GCC_USE_VERSION_8
-	default y if mips || mipsel || mips64 || mips64el
-	bool
-
 config GCC_VERSION_11
 	default y if GCC_USE_VERSION_11
 	bool
@@ -11,9 +6,19 @@ config GCC_VERSION_12
 	default y if GCC_USE_VERSION_12
 	bool
 
+config GCC_VERSION_14
+	default y if GCC_USE_VERSION_14
+	bool
+
 config GCC_VERSION
 	string
-	default "8.4.0"		if GCC_VERSION_8
+	default EXTERNAL_GCC_VERSION	if EXTERNAL_TOOLCHAIN && !NATIVE_TOOLCHAIN
 	default "11.3.0"	if GCC_VERSION_11
-	default "12.2.0"	if GCC_VERSION_12
+	default "12.3.0"	if GCC_VERSION_12
+	default "14.2.0"	if GCC_VERSION_14
 	default "13.3.0"
+
+config GCC_USE_DEFAULT_VERSION
+	bool
+	default y if !TOOLCHAINOPTS || GCC_USE_VERSION_13
+	imply KERNEL_WERROR
diff --git a/toolchain/gcc/common.mk b/toolchain/gcc/common.mk
index 55be6228..0ccf55bd 100644
--- a/toolchain/gcc/common.mk
+++ b/toolchain/gcc/common.mk
@@ -28,23 +28,24 @@ GCC_DIR:=$(PKG_NAME)-$(PKG_VERSION)
 
 PKG_SOURCE_URL:=@GNU/gcc/gcc-$(PKG_VERSION)
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.xz
-
-ifeq ($(PKG_VERSION),8.4.0)
-  PKG_HASH:=e30a6e52d10e1f27ed55104ad233c30bd1e99cfb5ff98ab022dc941edd1b2dd4
-endif
+PKG_CPE_ID:=cpe:/a:gnu:gcc
 
 ifeq ($(PKG_VERSION),11.3.0)
   PKG_HASH:=b47cf2818691f5b1e21df2bb38c795fac2cfbd640ede2d0a5e1c89e338a3ac39
 endif
 
-ifeq ($(PKG_VERSION),12.2.0)
-  PKG_HASH:=e549cf9cf3594a00e27b6589d4322d70e0720cdd213f39beb4181e06926230ff
+ifeq ($(PKG_VERSION),12.3.0)
+  PKG_HASH:=949a5d4f99e786421a93b532b22ffab5578de7321369975b91aec97adfda8c3b
 endif
 
 ifeq ($(PKG_VERSION),13.3.0)
   PKG_HASH:=0845e9621c9543a13f484e94584a49ffc0129970e9914624235fc1d061a0c083
 endif
 
+ifeq ($(PKG_VERSION),14.2.0)
+  PKG_HASH:=a7b39bc69cbf9e25826c5a60ab26477001f7c08d85cec04bc0e29cabed6f3cc9
+endif
+
 PATCH_DIR=../patches-$(GCC_MAJOR_VERSION).x
 
 BUGURL=http://bugs.openwrt.org/
@@ -74,6 +75,9 @@ TAR_OPTIONS += \
 	--exclude-from='$(CURDIR)/../exclude-testsuite' --exclude=gcc/ada/*.ad* \
 	--exclude=libjava
 
+# this needs to be without -L/-lzstd flags or other parts fail to build
+# use an absolute path to ensure it really picks up our version
+export ac_cv_search_ZSTD_compress=$(STAGING_DIR_HOST)/lib/libzstd.a -pthread
 export libgcc_cv_fixed_point=no
 ifdef CONFIG_INSTALL_GCCGO
   export libgo_cv_c_split_stack_supported=no
@@ -87,10 +91,6 @@ endif
 
 GCC_CONFIGURE:= \
 	SHELL="$(BASH)" \
-	$(if $(shell gcc --version 2>&1 | grep -E "Apple.(LLVM|clang)"), \
-		CFLAGS="-O2 -fbracket-depth=512 -pipe" \
-		CXXFLAGS="-O2 -fbracket-depth=512 -pipe" \
-	) \
 	$(HOST_SOURCE_DIR)/configure \
 		--with-bugurl=$(BUGURL) \
 		--with-pkgversion="$(PKGVERSION)" \
@@ -114,6 +114,8 @@ GCC_CONFIGURE:= \
 			--with-abi=$(call qstrip,$(CONFIG_MIPS64_ABI))) \
 		$(if $(CONFIG_arc),--with-cpu=$(CONFIG_CPU_TYPE)) \
 		$(if $(CONFIG_powerpc64), $(if $(CONFIG_USE_MUSL),--with-abi=elfv2)) \
+		--with-system-zlib=$(STAGING_DIR_HOST) \
+		--with-zstd=$(STAGING_DIR_HOST) \
 		--with-gmp=$(STAGING_DIR_HOST) \
 		--with-mpfr=$(STAGING_DIR_HOST) \
 		--with-mpc=$(STAGING_DIR_HOST) \
@@ -172,29 +174,34 @@ ifeq ($(CONFIG_TARGET_x86)$(CONFIG_USE_GLIBC)$(CONFIG_INSTALL_GCCGO),yyy)
   TARGET_CFLAGS+=-fno-split-stack
 endif
 
+CFLAGS:=$(HOST_CFLAGS) -pipe
+ifneq ($(shell gcc --version 2>&1 | grep -E "Apple.(LLVM|clang)"),)
+  CFLAGS+= -fbracket-depth=512
+endif
+
+GCC_CONFIGURE+= \
+	CFLAGS="$(CFLAGS)" \
+	CXXFLAGS="$(CFLAGS)" \
+	CFLAGS_FOR_TARGET="$(TARGET_CFLAGS)" \
+	CXXFLAGS_FOR_TARGET="$(TARGET_CFLAGS)" \
+	GOCFLAGS_FOR_TARGET="$(TARGET_CFLAGS)"
+
 GCC_MAKE:= \
 	export SHELL="$(BASH)"; \
-	$(MAKE) \
-		CFLAGS="$(HOST_CFLAGS)" \
-		CFLAGS_FOR_TARGET="$(TARGET_CFLAGS)" \
-		CXXFLAGS_FOR_TARGET="$(TARGET_CFLAGS)" \
-		GOCFLAGS_FOR_TARGET="$(TARGET_CFLAGS)"
+	$(MAKE)
 
 define Host/SetToolchainInfo
 	$(SED) 's,TARGET_CROSS=.*,TARGET_CROSS=$(REAL_GNU_TARGET_NAME)-,' $(TOOLCHAIN_DIR)/info.mk
 	$(SED) 's,GCC_VERSION=.*,GCC_VERSION=$(GCC_VERSION),' $(TOOLCHAIN_DIR)/info.mk
 endef
 
+
 ifeq ($(GCC_MAJOR_VERSION),11)
 	GCC_VERSION_FILE:=gcc/version.c
 else
 	GCC_VERSION_FILE:=gcc/genversion.cc
 endif
 
-ifeq ($(GCC_MAJOR_VERSION),8)
-	GCC_VERSION_FILE:=gcc/version.c
-endif
-
 ifneq ($(GCC_PREPARE),)
   define Host/Prepare
 	$(call Host/SetToolchainInfo)
diff --git a/toolchain/gcc/final/Makefile b/toolchain/gcc/final/Makefile
index 049ddf61..78a5576b 100644
--- a/toolchain/gcc/final/Makefile
+++ b/toolchain/gcc/final/Makefile
@@ -8,6 +8,7 @@ GCC_CONFIGURE += \
 	--enable-shared \
 	--enable-threads \
 	--with-slibdir=$(TOOLCHAIN_DIR)/lib \
+	--enable-plugins \
 	--enable-lto \
 	--with-libelf=$(STAGING_DIR_HOST)
 
diff --git a/toolchain/gcc/initial/Makefile b/toolchain/gcc/initial/Makefile
index c71b17dd..7cb4a73d 100644
--- a/toolchain/gcc/initial/Makefile
+++ b/toolchain/gcc/initial/Makefile
@@ -19,18 +19,10 @@ endef
 
 define Host/Install
 	+$(GCC_MAKE) $(HOST_JOBS) -C $(GCC_BUILD_DIR) \
-		prefix="$(TOOLCHAIN_DIR)/initial" \
 		install-gcc \
 		install-target-libgcc
 
-	# XXX: glibc insists on linking against libgcc_eh
-	( cd $(TOOLCHAIN_DIR)/initial/lib/gcc/$(REAL_GNU_TARGET_NAME)/$(PKG_VERSION) ; \
-		[ -e libgcc_eh.a ] || ln -sf libgcc.a libgcc_eh.a ; \
-		cp libgcc.a libgcc_initial.a; \
-	)
-
-	$(call FixupLibdir,$(TOOLCHAIN_DIR)/initial)
-	$$(call file_copy,$(TOOLCHAIN_DIR)/initial/.,$(TOOLCHAIN_DIR)/)
+	$(call FixupLibdir,$(TOOLCHAIN_DIR))
 endef
 
 $(eval $(call HostBuild))
diff --git a/toolchain/gcc/patches-11.x/910-mbsd_multi.patch b/toolchain/gcc/patches-11.x/910-mbsd_multi.patch
index 21f53204..2d1c3d1b 100644
--- a/toolchain/gcc/patches-11.x/910-mbsd_multi.patch
+++ b/toolchain/gcc/patches-11.x/910-mbsd_multi.patch
@@ -114,7 +114,7 @@ Date:   Tue Jul 31 00:52:27 2007 +0000
  ; On SVR4 targets, it also controls whether or not to emit a
 --- a/gcc/doc/invoke.texi
 +++ b/gcc/doc/invoke.texi
-@@ -9058,6 +9058,17 @@ This option is only supported for C and
+@@ -9059,6 +9059,17 @@ This option is only supported for C and
  @option{-Wall} and by @option{-Wpedantic}, which can be disabled with
  @option{-Wno-pointer-sign}.
  
diff --git a/toolchain/gcc/patches-11.x/980-libiberty-set_32 call.patch b/toolchain/gcc/patches-11.x/980-libiberty-set_32 call.patch
deleted file mode 100644
index 7489504c..00000000
--- a/toolchain/gcc/patches-11.x/980-libiberty-set_32 call.patch	
+++ /dev/null
@@ -1,33 +0,0 @@
-From 38757aa88735ab2e511bc428e2407a5a5e9fa0be Mon Sep 17 00:00:00 2001
-From: Iain Sandoe <iain@sandoe.co.uk>
-Date: Mon, 23 Aug 2021 17:34:43 +0100
-Subject: [PATCH] libiberty, Darwin: Fix a build warning.
-
-r12-3005-g220c410162ebece4f missed a cast for the set_32 call.
-Fixed thus.
-
-Signed-off-by: Iain Sandoe <iain@sandoe.co.uk>
-
-libiberty/ChangeLog:
-
-	* simple-object-mach-o.c (simple_object_mach_o_write_segment):
-	Cast the first argument to set_32 as needed.
----
- libiberty/simple-object-mach-o.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/libiberty/simple-object-mach-o.c b/libiberty/simple-object-mach-o.c
-index 72b69d19c216..a8869e7c6395 100644
---- a/libiberty/simple-object-mach-o.c
-+++ b/libiberty/simple-object-mach-o.c
-@@ -1228,7 +1228,7 @@ simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,
-       /* Swap the indices, if required.  */
- 
-       for (i = 0; i < (nsects_in * 4); ++i)
--	set_32 (&index[i], index[i]);
-+	set_32 ((unsigned char *) &index[i], index[i]);
- 
-       sechdr_offset += sechdrsize;
- 
--- 
-2.43.5
diff --git a/toolchain/gcc/patches-12.x/230-musl_libssp.patch b/toolchain/gcc/patches-12.x/230-musl_libssp.patch
index 3ce5e495..a909d638 100644
--- a/toolchain/gcc/patches-12.x/230-musl_libssp.patch
+++ b/toolchain/gcc/patches-12.x/230-musl_libssp.patch
@@ -1,6 +1,6 @@
 --- a/gcc/gcc.cc
 +++ b/gcc/gcc.cc
-@@ -985,7 +985,9 @@ proper position among the other output f
+@@ -987,7 +987,9 @@ proper position among the other output f
  #endif
  
  #ifndef LINK_SSP_SPEC
diff --git a/toolchain/gcc/patches-12.x/910-mbsd_multi.patch b/toolchain/gcc/patches-12.x/910-mbsd_multi.patch
index 4033c5b2..9233c6a1 100644
--- a/toolchain/gcc/patches-12.x/910-mbsd_multi.patch
+++ b/toolchain/gcc/patches-12.x/910-mbsd_multi.patch
@@ -114,7 +114,7 @@ Date:   Tue Jul 31 00:52:27 2007 +0000
  ; On SVR4 targets, it also controls whether or not to emit a
 --- a/gcc/doc/invoke.texi
 +++ b/gcc/doc/invoke.texi
-@@ -9596,6 +9596,17 @@ This option is only supported for C and
+@@ -9597,6 +9597,17 @@ This option is only supported for C and
  @option{-Wall} and by @option{-Wpedantic}, which can be disabled with
  @option{-Wno-pointer-sign}.
  
@@ -134,7 +134,7 @@ Date:   Tue Jul 31 00:52:27 2007 +0000
  @opindex Wno-stack-protector
 --- a/gcc/opts.cc
 +++ b/gcc/opts.cc
-@@ -2692,6 +2692,9 @@ common_handle_option (struct gcc_options
+@@ -2699,6 +2699,9 @@ common_handle_option (struct gcc_options
        add_comma_separated_to_vector (&opts->x_flag_ignored_attributes, arg);
        break;
  
diff --git a/toolchain/gcc/patches-12.x/920-specs_nonfatal_getenv.patch b/toolchain/gcc/patches-12.x/920-specs_nonfatal_getenv.patch
index 0f7d40b2..59bd3500 100644
--- a/toolchain/gcc/patches-12.x/920-specs_nonfatal_getenv.patch
+++ b/toolchain/gcc/patches-12.x/920-specs_nonfatal_getenv.patch
@@ -7,7 +7,7 @@ Date:   Sat Apr 21 03:02:39 2012 +0000
 
 --- a/gcc/gcc.cc
 +++ b/gcc/gcc.cc
-@@ -10213,8 +10213,10 @@ getenv_spec_function (int argc, const ch
+@@ -10186,8 +10186,10 @@ getenv_spec_function (int argc, const ch
      }
  
    if (!value)
diff --git a/toolchain/gcc/patches-12.x/970-macos_arm64-building-fix.patch b/toolchain/gcc/patches-12.x/970-macos_arm64-building-fix.patch
index 86fa68e1..89730449 100644
--- a/toolchain/gcc/patches-12.x/970-macos_arm64-building-fix.patch
+++ b/toolchain/gcc/patches-12.x/970-macos_arm64-building-fix.patch
@@ -17,7 +17,7 @@ Date:   Mon Aug 16 13:16:21 2021 +0100
 
 --- a/gcc/config/aarch64/aarch64.h
 +++ b/gcc/config/aarch64/aarch64.h
-@@ -1290,7 +1290,7 @@ extern const char *aarch64_rewrite_mcpu
+@@ -1293,7 +1293,7 @@ extern const char *aarch64_rewrite_mcpu
  #define MCPU_TO_MARCH_SPEC_FUNCTIONS \
    { "rewrite_mcpu", aarch64_rewrite_mcpu },
  
diff --git a/toolchain/gcc/patches-8.x/002-case_insensitive.patch b/toolchain/gcc/patches-8.x/002-case_insensitive.patch
deleted file mode 100644
index 3442076d..00000000
--- a/toolchain/gcc/patches-8.x/002-case_insensitive.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-commit 81cc26c706b2bc8c8c1eb1a322e5c5157900836e
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sun Oct 19 21:45:51 2014 +0000
-
-    gcc: do not assume that the Mac OS X filesystem is case insensitive
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-    
-    SVN-Revision: 42973
-
---- a/include/filenames.h
-+++ b/include/filenames.h
-@@ -43,11 +43,6 @@ extern "C" {
- #  define IS_DIR_SEPARATOR(c) IS_DOS_DIR_SEPARATOR (c)
- #  define IS_ABSOLUTE_PATH(f) IS_DOS_ABSOLUTE_PATH (f)
- #else /* not DOSish */
--#  if defined(__APPLE__)
--#    ifndef HAVE_CASE_INSENSITIVE_FILE_SYSTEM
--#      define HAVE_CASE_INSENSITIVE_FILE_SYSTEM 1
--#    endif
--#  endif /* __APPLE__ */
- #  define HAS_DRIVE_SPEC(f) (0)
- #  define IS_DIR_SEPARATOR(c) IS_UNIX_DIR_SEPARATOR (c)
- #  define IS_ABSOLUTE_PATH(f) IS_UNIX_ABSOLUTE_PATH (f)
diff --git a/toolchain/gcc/patches-8.x/010-documentation.patch b/toolchain/gcc/patches-8.x/010-documentation.patch
deleted file mode 100644
index c7e3d4ad..00000000
--- a/toolchain/gcc/patches-8.x/010-documentation.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-commit 098bd91f5eae625c7d2ee621e10930fc4434e5e2
-Author: Luka Perkov <luka@openwrt.org>
-Date:   Tue Feb 26 16:16:33 2013 +0000
-
-    gcc: don't build documentation
-    
-    This closes #13039.
-    
-    Signed-off-by: Luka Perkov <luka@openwrt.org>
-    
-    SVN-Revision: 35807
-
---- a/gcc/Makefile.in
-+++ b/gcc/Makefile.in
-@@ -3204,18 +3204,10 @@ doc/gcc.info: $(TEXI_GCC_FILES)
- doc/gccint.info: $(TEXI_GCCINT_FILES)
- doc/cppinternals.info: $(TEXI_CPPINT_FILES)
- 
--doc/%.info: %.texi
--	if [ x$(BUILD_INFO) = xinfo ]; then \
--		$(MAKEINFO) $(MAKEINFOFLAGS) -I . -I $(gcc_docdir) \
--			-I $(gcc_docdir)/include -o $@ $<; \
--	fi
-+doc/%.info:
- 
- # Duplicate entry to handle renaming of gccinstall.info
--doc/gccinstall.info: $(TEXI_GCCINSTALL_FILES)
--	if [ x$(BUILD_INFO) = xinfo ]; then \
--		$(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \
--			-I $(gcc_docdir)/include -o $@ $<; \
--	fi
-+doc/gccinstall.info:
- 
- doc/cpp.dvi: $(TEXI_CPP_FILES)
- doc/gcc.dvi: $(TEXI_GCC_FILES)
diff --git a/toolchain/gcc/patches-8.x/110-Fix-MIPS-PR-84790.patch b/toolchain/gcc/patches-8.x/110-Fix-MIPS-PR-84790.patch
deleted file mode 100644
index b89eca2f..00000000
--- a/toolchain/gcc/patches-8.x/110-Fix-MIPS-PR-84790.patch
+++ /dev/null
@@ -1,20 +0,0 @@
-Fix https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84790.
-MIPS16 functions have a static assembler prologue which clobbers
-registers v0 and v1. Add these register clobbers to function call
-instructions.
-
---- a/gcc/config/mips/mips.c
-+++ b/gcc/config/mips/mips.c
-@@ -3102,6 +3102,12 @@ mips_emit_call_insn (rtx pattern, rtx or
-       emit_insn (gen_update_got_version ());
-     }
- 
-+  if (TARGET_MIPS16 && TARGET_USE_GOT)
-+    {
-+      clobber_reg (&CALL_INSN_FUNCTION_USAGE (insn), MIPS16_PIC_TEMP);
-+      clobber_reg (&CALL_INSN_FUNCTION_USAGE (insn), MIPS_PROLOGUE_TEMP (word_mode));
-+    }
-+
-   if (TARGET_MIPS16
-       && TARGET_EXPLICIT_RELOCS
-       && TARGET_CALL_CLOBBERED_GP)
diff --git a/toolchain/gcc/patches-8.x/230-musl_libssp.patch b/toolchain/gcc/patches-8.x/230-musl_libssp.patch
deleted file mode 100644
index b3ab79ca..00000000
--- a/toolchain/gcc/patches-8.x/230-musl_libssp.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/gcc/gcc.c
-+++ b/gcc/gcc.c
-@@ -868,7 +868,9 @@ proper position among the other output f
- #endif
- 
- #ifndef LINK_SSP_SPEC
--#ifdef TARGET_LIBC_PROVIDES_SSP
-+#if DEFAULT_LIBC == LIBC_MUSL
-+#define LINK_SSP_SPEC "-lssp_nonshared"
-+#elif defined(TARGET_LIBC_PROVIDES_SSP)
- #define LINK_SSP_SPEC "%{fstack-protector|fstack-protector-all" \
- 		       "|fstack-protector-strong|fstack-protector-explicit:}"
- #else
diff --git a/toolchain/gcc/patches-8.x/300-mips_Os_cpu_rtx_cost_model.patch b/toolchain/gcc/patches-8.x/300-mips_Os_cpu_rtx_cost_model.patch
deleted file mode 100644
index 2e2c609e..00000000
--- a/toolchain/gcc/patches-8.x/300-mips_Os_cpu_rtx_cost_model.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-commit ecf7671b769fe96f7b5134be442089f8bdba55d2
-Author: Felix Fietkau <nbd@nbd.name>
-Date:   Thu Aug 4 20:29:45 2016 +0200
-
-gcc: add a patch to generate better code with Os on mips
-
-Also happens to reduce compressed code size a bit
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-
---- a/gcc/config/mips/mips.c
-+++ b/gcc/config/mips/mips.c
-@@ -19847,7 +19847,7 @@ mips_option_override (void)
-     flag_pcc_struct_return = 0;
- 
-   /* Decide which rtx_costs structure to use.  */
--  if (optimize_size)
-+  if (0 && optimize_size)
-     mips_cost = &mips_rtx_cost_optimize_size;
-   else
-     mips_cost = &mips_rtx_cost_data[mips_tune];
diff --git a/toolchain/gcc/patches-8.x/800-arm_v5te_no_ldrd_strd.patch b/toolchain/gcc/patches-8.x/800-arm_v5te_no_ldrd_strd.patch
deleted file mode 100644
index 172295f2..00000000
--- a/toolchain/gcc/patches-8.x/800-arm_v5te_no_ldrd_strd.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/gcc/config/arm/arm.h
-+++ b/gcc/config/arm/arm.h
-@@ -155,7 +155,7 @@ extern tree arm_fp16_type_node;
- /* Thumb-1 only.  */
- #define TARGET_THUMB1_ONLY		(TARGET_THUMB1 && !arm_arch_notm)
- 
--#define TARGET_LDRD			(arm_arch5e && ARM_DOUBLEWORD_ALIGN \
-+#define TARGET_LDRD			(arm_arch6 && ARM_DOUBLEWORD_ALIGN \
-                                          && !TARGET_THUMB1)
- 
- #define TARGET_CRC32			(arm_arch_crc)
diff --git a/toolchain/gcc/patches-8.x/810-arm-softfloat-libgcc.patch b/toolchain/gcc/patches-8.x/810-arm-softfloat-libgcc.patch
deleted file mode 100644
index 5c9d86ae..00000000
--- a/toolchain/gcc/patches-8.x/810-arm-softfloat-libgcc.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-commit 8570c4be394cff7282f332f97da2ff569a927ddb
-Author: Imre Kaloz <kaloz@openwrt.org>
-Date:   Wed Feb 2 20:06:12 2011 +0000
-
-    fixup arm soft-float symbols
-    
-    SVN-Revision: 25325
-
---- a/libgcc/config/arm/t-linux
-+++ b/libgcc/config/arm/t-linux
-@@ -1,6 +1,10 @@
- LIB1ASMSRC = arm/lib1funcs.S
- LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_lnx _clzsi2 _clzdi2 \
--	_ctzsi2 _arm_addsubdf3 _arm_addsubsf3
-+	_ctzsi2 _arm_addsubdf3 _arm_addsubsf3 \
-+	_arm_negdf2 _arm_muldivdf3 _arm_cmpdf2 _arm_unorddf2 \
-+	_arm_fixdfsi _arm_fixunsdfsi _arm_truncdfsf2 \
-+	_arm_negsf2 _arm_muldivsf3 _arm_cmpsf2 _arm_unordsf2 \
-+	_arm_fixsfsi _arm_fixunssfsi
- 
- # Just for these, we omit the frame pointer since it makes such a big
- # difference.
---- a/gcc/config/arm/linux-elf.h
-+++ b/gcc/config/arm/linux-elf.h
-@@ -58,8 +58,6 @@
-    %{shared:-lc} \
-    %{!shared:%{profile:-lc_p}%{!profile:-lc}}"
- 
--#define LIBGCC_SPEC "%{mfloat-abi=soft*:-lfloat} -lgcc"
--
- #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
- 
- #define LINUX_TARGET_LINK_SPEC  "%{h*} \
diff --git a/toolchain/gcc/patches-8.x/820-libgcc_pic.patch b/toolchain/gcc/patches-8.x/820-libgcc_pic.patch
deleted file mode 100644
index 1a9678d4..00000000
--- a/toolchain/gcc/patches-8.x/820-libgcc_pic.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-commit c96312958c0621e72c9b32da5bc224ffe2161384
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Mon Oct 19 23:26:09 2009 +0000
-
-    gcc: create a proper libgcc_pic.a static library for relinking (4.3.3+ for now, backport will follow)
-    
-    SVN-Revision: 18086
-
---- a/libgcc/Makefile.in
-+++ b/libgcc/Makefile.in
-@@ -923,11 +923,12 @@ $(libgcov-driver-objects): %$(objext): $
- 
- # Static libraries.
- libgcc.a: $(libgcc-objects)
-+libgcc_pic.a: $(libgcc-s-objects)
- libgcov.a: $(libgcov-objects)
- libunwind.a: $(libunwind-objects)
- libgcc_eh.a: $(libgcc-eh-objects)
- 
--libgcc.a libgcov.a libunwind.a libgcc_eh.a:
-+libgcc.a libgcov.a libunwind.a libgcc_eh.a libgcc_pic.a:
- 	-rm -f $@
- 
- 	objects="$(objects)";					\
-@@ -948,7 +949,7 @@ all: libunwind.a
- endif
- 
- ifeq ($(enable_shared),yes)
--all: libgcc_eh.a libgcc_s$(SHLIB_EXT)
-+all: libgcc_eh.a libgcc_pic.a libgcc_s$(SHLIB_EXT)
- ifneq ($(LIBUNWIND),)
- all: libunwind$(SHLIB_EXT)
- libgcc_s$(SHLIB_EXT): libunwind$(SHLIB_EXT)
-@@ -1154,6 +1155,10 @@ install-shared:
- 	chmod 644 $(DESTDIR)$(inst_libdir)/libgcc_eh.a
- 	$(RANLIB) $(DESTDIR)$(inst_libdir)/libgcc_eh.a
- 
-+	$(INSTALL_DATA) libgcc_pic.a $(mapfile) $(DESTDIR)$(inst_libdir)/
-+	chmod 644 $(DESTDIR)$(inst_libdir)/libgcc_pic.a
-+	$(RANLIB) $(DESTDIR)$(inst_libdir)/libgcc_pic.a
-+
- 	$(subst @multilib_dir@,$(MULTIDIR),$(subst \
- 		@shlib_base_name@,libgcc_s,$(subst \
- 		@shlib_slibdir_qual@,$(MULTIOSSUBDIR),$(SHLIB_INSTALL))))
diff --git a/toolchain/gcc/patches-8.x/840-armv4_pass_fix-v4bx_to_ld.patch b/toolchain/gcc/patches-8.x/840-armv4_pass_fix-v4bx_to_ld.patch
deleted file mode 100644
index b9c9b161..00000000
--- a/toolchain/gcc/patches-8.x/840-armv4_pass_fix-v4bx_to_ld.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-commit 7edc8ca5456d9743dd0075eb3cc5b04f4f24c8cc
-Author: Imre Kaloz <kaloz@openwrt.org>
-Date:   Wed Feb 2 19:34:36 2011 +0000
-
-    add armv4 fixup patches
-    
-    SVN-Revision: 25322
-
-
---- a/gcc/config/arm/linux-eabi.h
-+++ b/gcc/config/arm/linux-eabi.h
-@@ -88,10 +88,15 @@
- #define MUSL_DYNAMIC_LINKER \
-   "/lib/ld-musl-arm" MUSL_DYNAMIC_LINKER_E "%{mfloat-abi=hard:hf}.so.1"
- 
-+/* For armv4 we pass --fix-v4bx to linker to support EABI */
-+#undef TARGET_FIX_V4BX_SPEC
-+#define TARGET_FIX_V4BX_SPEC " %{mcpu=arm8|mcpu=arm810|mcpu=strongarm*"\
-+  "|march=armv4|mcpu=fa526|mcpu=fa626:--fix-v4bx}"
-+
- /* At this point, bpabi.h will have clobbered LINK_SPEC.  We want to
-    use the GNU/Linux version, not the generic BPABI version.  */
- #undef  LINK_SPEC
--#define LINK_SPEC EABI_LINK_SPEC					\
-+#define LINK_SPEC EABI_LINK_SPEC TARGET_FIX_V4BX_SPEC			\
-   LINUX_OR_ANDROID_LD (LINUX_TARGET_LINK_SPEC,				\
- 		       LINUX_TARGET_LINK_SPEC " " ANDROID_LINK_SPEC)
- 
diff --git a/toolchain/gcc/patches-8.x/850-use_shared_libgcc.patch b/toolchain/gcc/patches-8.x/850-use_shared_libgcc.patch
deleted file mode 100644
index f619f0e6..00000000
--- a/toolchain/gcc/patches-8.x/850-use_shared_libgcc.patch
+++ /dev/null
@@ -1,54 +0,0 @@
-commit dcfc40358b5a3cae7320c17f8d1cebd5ad5540cd
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sun Feb 12 20:25:47 2012 +0000
-
-    gcc 4.6: port over the missing patch 850-use_shared_libgcc.patch to prevent libgcc crap from leaking into every single binary
-    
-    SVN-Revision: 30486
---- a/gcc/config/arm/linux-eabi.h
-+++ b/gcc/config/arm/linux-eabi.h
-@@ -126,10 +126,6 @@
-   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} "	\
-   LINUX_OR_ANDROID_LD (GNU_USER_TARGET_ENDFILE_SPEC, ANDROID_ENDFILE_SPEC)
- 
--/* Use the default LIBGCC_SPEC, not the version in linux-elf.h, as we
--   do not use -lfloat.  */
--#undef LIBGCC_SPEC
--
- /* Clear the instruction cache from `beg' to `end'.  This is
-    implemented in lib1funcs.S, so ensure an error if this definition
-    is used.  */
---- a/gcc/config/linux.h
-+++ b/gcc/config/linux.h
-@@ -53,6 +53,10 @@ see the files COPYING3 and COPYING.RUNTI
- 	builtin_assert ("system=posix");			\
-     } while (0)
- 
-+#ifndef LIBGCC_SPEC
-+#define LIBGCC_SPEC "%{static|static-libgcc:-lgcc}%{!static:%{!static-libgcc:-lgcc_s}}"
-+#endif
-+
- /* Determine which dynamic linker to use depending on whether GLIBC or
-    uClibc or Bionic or musl is the default C library and whether
-    -muclibc or -mglibc or -mbionic or -mmusl has been passed to change
---- a/libgcc/mkmap-symver.awk
-+++ b/libgcc/mkmap-symver.awk
-@@ -136,5 +136,5 @@ function output(lib) {
-   else if (inherit[lib])
-     printf("} %s;\n", inherit[lib]);
-   else
--    printf ("\n  local:\n\t*;\n};\n");
-+    printf ("\n\t*;\n};\n");
- }
---- a/gcc/config/rs6000/linux.h
-+++ b/gcc/config/rs6000/linux.h
-@@ -60,6 +60,9 @@
- #undef	CPP_OS_DEFAULT_SPEC
- #define CPP_OS_DEFAULT_SPEC "%(cpp_os_linux)"
- 
-+#undef LIBGCC_SPEC
-+#define LIBGCC_SPEC "%{!static:%{!static-libgcc:-lgcc_s}} -lgcc"
-+
- #undef  LINK_SHLIB_SPEC
- #define LINK_SHLIB_SPEC "%{shared:-shared} %{!shared: %{static:-static}} \
-   %{static-pie:-static -pie --no-dynamic-linker -z text}"
diff --git a/toolchain/gcc/patches-8.x/851-libgcc_no_compat.patch b/toolchain/gcc/patches-8.x/851-libgcc_no_compat.patch
deleted file mode 100644
index d710e407..00000000
--- a/toolchain/gcc/patches-8.x/851-libgcc_no_compat.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-commit 64661de100da1ec1061ef3e5e400285dce115e6b
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sun May 10 13:16:35 2015 +0000
-
-    gcc: add some size optimization patches
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-    
-    SVN-Revision: 45664
-
---- a/libgcc/config/t-libunwind
-+++ b/libgcc/config/t-libunwind
-@@ -2,8 +2,7 @@
- 
- HOST_LIBGCC2_CFLAGS += -DUSE_GAS_SYMVER
- 
--LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c \
--  $(srcdir)/unwind-compat.c $(srcdir)/unwind-dw2-fde-compat.c
-+LIB2ADDEH = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
- LIB2ADDEHSTATIC = $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
- 
- # Override the default value from t-slibgcc-elf-ver and mention -lunwind
diff --git a/toolchain/gcc/patches-8.x/870-ppc_no_crtsavres.patch b/toolchain/gcc/patches-8.x/870-ppc_no_crtsavres.patch
deleted file mode 100644
index 51d11c3d..00000000
--- a/toolchain/gcc/patches-8.x/870-ppc_no_crtsavres.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/gcc/config/rs6000/rs6000.c
-+++ b/gcc/config/rs6000/rs6000.c
-@@ -24780,7 +24780,7 @@ rs6000_savres_strategy (rs6000_stack_t *
-   /* Define cutoff for using out-of-line functions to save registers.  */
-   if (DEFAULT_ABI == ABI_V4 || TARGET_ELF)
-     {
--      if (!optimize_size)
-+      if (1)
- 	{
- 	  strategy |= SAVE_INLINE_FPRS | REST_INLINE_FPRS;
- 	  strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;
diff --git a/toolchain/gcc/patches-8.x/881-no_tm_section.patch b/toolchain/gcc/patches-8.x/881-no_tm_section.patch
deleted file mode 100644
index fab5db3b..00000000
--- a/toolchain/gcc/patches-8.x/881-no_tm_section.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/libgcc/crtstuff.c
-+++ b/libgcc/crtstuff.c
-@@ -152,7 +152,7 @@ call_ ## FUNC (void)					\
- #endif
- 
- #if !defined(USE_TM_CLONE_REGISTRY) && defined(OBJECT_FORMAT_ELF)
--# define USE_TM_CLONE_REGISTRY 1
-+# define USE_TM_CLONE_REGISTRY 0
- #endif
- 
- /* We do not want to add the weak attribute to the declarations of these
diff --git a/toolchain/gcc/patches-8.x/900-bad-mips16-crt.patch b/toolchain/gcc/patches-8.x/900-bad-mips16-crt.patch
deleted file mode 100644
index dd6e9dc8..00000000
--- a/toolchain/gcc/patches-8.x/900-bad-mips16-crt.patch
+++ /dev/null
@@ -1,9 +0,0 @@
---- a/libgcc/config/mips/t-mips16
-+++ b/libgcc/config/mips/t-mips16
-@@ -43,3 +43,6 @@ SYNC_CFLAGS = -mno-mips16
- 
- # Version these symbols if building libgcc.so.
- SHLIB_MAPFILES += $(srcdir)/config/mips/libgcc-mips16.ver
-+
-+CRTSTUFF_T_CFLAGS += -mno-mips16
-+CRTSTUFF_T_CFLAGS_S += -mno-mips16
diff --git a/toolchain/gcc/patches-8.x/910-mbsd_multi.patch b/toolchain/gcc/patches-8.x/910-mbsd_multi.patch
deleted file mode 100644
index c566ea35..00000000
--- a/toolchain/gcc/patches-8.x/910-mbsd_multi.patch
+++ /dev/null
@@ -1,146 +0,0 @@
-commit 99368862e44740ff4fd33760893f04e14f9dbdf1
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Tue Jul 31 00:52:27 2007 +0000
-
-    Port the mbsd_multi patch from freewrt, which adds -fhonour-copts. This will emit warnings in packages that don't use our target cflags properly
-    
-    SVN-Revision: 8256
-
-	This patch brings over a feature from MirBSD:
-	* -fhonour-copts
-	  If this option is not given, it's warned (depending
-	  on environment variables). This is to catch errors
-	  of misbuilt packages which override CFLAGS themselves.
-
-	This patch was authored by Thorsten Glaser <tg at mirbsd.de>
-	with copyright assignment to the FSF in effect.
-
---- a/gcc/c-family/c-opts.c
-+++ b/gcc/c-family/c-opts.c
-@@ -107,6 +107,9 @@ static dump_flags_t original_dump_flags;
- /* Whether any standard preincluded header has been preincluded.  */
- static bool done_preinclude;
- 
-+/* Check if a port honours COPTS.  */
-+static int honour_copts = 0;
-+
- static void handle_OPT_d (const char *);
- static void set_std_cxx98 (int);
- static void set_std_cxx11 (int);
-@@ -459,6 +462,12 @@ c_common_handle_option (size_t scode, co
-       flag_no_builtin = !value;
-       break;
- 
-+    case OPT_fhonour_copts:
-+      if (c_language == clk_c) {
-+        honour_copts++;
-+      }
-+      break;
-+
-     case OPT_fconstant_string_class_:
-       constant_string_class_name = arg;
-       break;
-@@ -1125,6 +1134,47 @@ c_common_init (void)
-       return false;
-     }
- 
-+  if (c_language == clk_c) {
-+    char *ev = getenv ("GCC_HONOUR_COPTS");
-+    int evv;
-+    if (ev == NULL)
-+      evv = -1;
-+    else if ((*ev == '0') || (*ev == '\0'))
-+      evv = 0;
-+    else if (*ev == '1')
-+      evv = 1;
-+    else if (*ev == '2')
-+      evv = 2;
-+    else if (*ev == 's')
-+      evv = -1;
-+    else {
-+      warning (0, "unknown GCC_HONOUR_COPTS value, assuming 1");
-+      evv = 1; /* maybe depend this on something like MIRBSD_NATIVE?  */
-+    }
-+    if (evv == 1) {
-+      if (honour_copts == 0) {
-+        error ("someone does not honour COPTS at all in lenient mode");
-+        return false;
-+      } else if (honour_copts != 1) {
-+        warning (0, "someone does not honour COPTS correctly, passed %d times",
-+         honour_copts);
-+      }
-+    } else if (evv == 2) {
-+      if (honour_copts == 0) {
-+        error ("someone does not honour COPTS at all in strict mode");
-+        return false;
-+      } else if (honour_copts != 1) {
-+        error ("someone does not honour COPTS correctly, passed %d times",
-+         honour_copts);
-+        return false;
-+      }
-+    } else if (evv == 0) {
-+      if (honour_copts != 1)
-+        inform (UNKNOWN_LOCATION, "someone does not honour COPTS correctly, passed %d times",
-+         honour_copts);
-+    }
-+  }
-+
-   return true;
- }
- 
---- a/gcc/c-family/c.opt
-+++ b/gcc/c-family/c.opt
-@@ -1469,6 +1469,9 @@ C++ ObjC++ Optimization Alias(fexception
- fhonor-std
- C++ ObjC++ Ignore Warn(switch %qs is no longer supported)
- 
-+fhonour-copts
-+C ObjC C++ ObjC++ RejectNegative
-+
- fhosted
- C ObjC
- Assume normal C execution environment.
---- a/gcc/common.opt
-+++ b/gcc/common.opt
-@@ -1551,6 +1551,9 @@ fguess-branch-probability
- Common Report Var(flag_guess_branch_prob) Optimization
- Enable guessing of branch probabilities.
- 
-+fhonour-copts
-+Common RejectNegative
-+
- ; Nonzero means ignore `#ident' directives.  0 means handle them.
- ; Generate position-independent code for executables if possible
- ; On SVR4 targets, it also controls whether or not to emit a
---- a/gcc/opts.c
-+++ b/gcc/opts.c
-@@ -2073,6 +2073,9 @@ common_handle_option (struct gcc_options
- 			       opts, opts_set, loc, dc);
-       break;
- 
-+    case OPT_fhonour_copts:
-+      break;
-+
-     case OPT_Wlarger_than_:
-       opts->x_larger_than_size = value;
-       opts->x_warn_larger_than = value != -1;
---- a/gcc/doc/invoke.texi
-+++ b/gcc/doc/invoke.texi
-@@ -7013,6 +7013,17 @@ This option is only supported for C and
- @option{-Wall} and by @option{-Wpedantic}, which can be disabled with
- @option{-Wno-pointer-sign}.
- 
-+@item -fhonour-copts
-+@opindex fhonour-copts
-+If @env{GCC_HONOUR_COPTS} is set to 1, abort if this option is not
-+given at least once, and warn if it is given more than once.
-+If @env{GCC_HONOUR_COPTS} is set to 2, abort if this option is not
-+given exactly once.
-+If @env{GCC_HONOUR_COPTS} is set to 0 or unset, warn if this option
-+is not given exactly once.
-+The warning is quelled if @env{GCC_HONOUR_COPTS} is set to @samp{s}.
-+This flag and environment variable only affect the C language.
-+
- @item -Wstack-protector
- @opindex Wstack-protector
- @opindex Wno-stack-protector
diff --git a/toolchain/gcc/patches-8.x/920-specs_nonfatal_getenv.patch b/toolchain/gcc/patches-8.x/920-specs_nonfatal_getenv.patch
deleted file mode 100644
index c3836e63..00000000
--- a/toolchain/gcc/patches-8.x/920-specs_nonfatal_getenv.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-Author: Jo-Philipp Wich <jow@openwrt.org>
-Date:   Sat Apr 21 03:02:39 2012 +0000
-
-    gcc: add patch to make the getenv() spec function nonfatal if requested environment variable is unset
-    
-    SVN-Revision: 31390
-
---- a/gcc/gcc.c
-+++ b/gcc/gcc.c
-@@ -9347,8 +9347,10 @@ getenv_spec_function (int argc, const ch
-     value = varname;
- 
-   if (!value)
--    fatal_error (input_location,
--		 "environment variable %qs not defined", varname);
-+    {
-+      warning (input_location, "environment variable %qs not defined", varname);
-+      value = "";
-+    }
- 
-   /* We have to escape every character of the environment variable so
-      they are not interpreted as active spec characters.  A
diff --git a/toolchain/gcc/patches-8.x/930-fix-mips-noexecstack.patch b/toolchain/gcc/patches-8.x/930-fix-mips-noexecstack.patch
deleted file mode 100644
index ed8ada22..00000000
--- a/toolchain/gcc/patches-8.x/930-fix-mips-noexecstack.patch
+++ /dev/null
@@ -1,111 +0,0 @@
-From da45b3fde60095756f5f6030f6012c23a3d34429 Mon Sep 17 00:00:00 2001
-From: Andrew McDonnell <bugs@andrewmcdonnell.net>
-Date: Fri, 3 Oct 2014 19:09:00 +0930
-Subject: Add .note.GNU-stack section
-
-See http://lists.busybox.net/pipermail/uclibc/2014-October/048671.html
-Below copied from https://gcc.gnu.org/ml/gcc-patches/2014-09/msg02430.html
-
-Re: [Patch, MIPS] Add .note.GNU-stack section
-
-    From: Steve Ellcey <sellcey at mips dot com>
-
-On Wed, 2014-09-10 at 10:15 -0700, Eric Christopher wrote:
->
->
-> On Wed, Sep 10, 2014 at 9:27 AM, <pinskia@gmail.com> wrote:
-
->         This works except you did not update the assembly files in
->         libgcc or glibc. We (Cavium) have the same patch in our tree
->         for a few released versions.
-
-> Mind just checking yours in then Andrew?
-
-> Thanks!
-> -eric
-
-I talked to Andrew about what files he changed in GCC and created and
-tested this new patch.  Andrew also mentioned changing some assembly
-files in glibc but I don't see any use of '.section .note.GNU-stack' in
-any assembly files in glibc (for any platform) so I wasn't planning on
-creating a glibc to add them to mips glibc assembly language files.
-
-OK to check in this patch?
-
-Steve Ellcey
-sellcey@mips.com
-
-
-
-2014-09-26  Steve Ellcey  <sellcey@mips.com>
----
- gcc/config/mips/mips.c          | 3 +++
- libgcc/config/mips/crti.S       | 4 ++++
- libgcc/config/mips/crtn.S       | 3 +++
- libgcc/config/mips/mips16.S     | 4 ++++
- libgcc/config/mips/vr4120-div.S | 4 ++++
- 5 files changed, 18 insertions(+)
-
---- a/gcc/config/mips/mips.c
-+++ b/gcc/config/mips/mips.c
-@@ -22640,6 +22640,9 @@ mips_starting_frame_offset (void)
- #undef TARGET_STARTING_FRAME_OFFSET
- #define TARGET_STARTING_FRAME_OFFSET mips_starting_frame_offset
- 
-+#undef TARGET_ASM_FILE_END
-+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
-+
- struct gcc_target targetm = TARGET_INITIALIZER;
- 
- #include "gt-mips.h"
---- a/libgcc/config/mips/crti.S
-+++ b/libgcc/config/mips/crti.S
-@@ -21,6 +21,10 @@ a copy of the GCC Runtime Library Except
- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
- <http://www.gnu.org/licenses/>.  */
- 
-+
-+/* An executable stack is *not* required for these functions.  */
-+	.section .note.GNU-stack,"",%progbits
-+
- /* 4 slots for argument spill area.  1 for cpreturn, 1 for stack.
-    Return spill offset of 40 and 20.  Aligned to 16 bytes for n32.  */
- 
---- a/libgcc/config/mips/crtn.S
-+++ b/libgcc/config/mips/crtn.S
-@@ -21,6 +21,9 @@ a copy of the GCC Runtime Library Except
- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
- <http://www.gnu.org/licenses/>.  */
- 
-+/* An executable stack is *not* required for these functions.  */
-+	.section .note.GNU-stack,"",%progbits
-+
- /* 4 slots for argument spill area.  1 for cpreturn, 1 for stack.
-    Return spill offset of 40 and 20.  Aligned to 16 bytes for n32.  */
- 
---- a/libgcc/config/mips/mips16.S
-+++ b/libgcc/config/mips/mips16.S
-@@ -48,6 +48,10 @@ see the files COPYING3 and COPYING.RUNTI
-    values using the soft-float calling convention, but do the actual
-    operation using the hard floating point instructions.  */
- 
-+/* An executable stack is *not* required for these functions.  */
-+	.section .note.GNU-stack,"",%progbits
-+	.previous
-+
- #if defined _MIPS_SIM && (_MIPS_SIM == _ABIO32 || _MIPS_SIM == _ABIO64)
- 
- /* This file contains 32-bit assembly code.  */
---- a/libgcc/config/mips/vr4120-div.S
-+++ b/libgcc/config/mips/vr4120-div.S
-@@ -26,6 +26,10 @@ see the files COPYING3 and COPYING.RUNTI
-    -mfix-vr4120.  div and ddiv do not give the correct result when one
-    of the operands is negative.  */
- 
-+/* An executable stack is *not* required for these functions.  */
-+	.section .note.GNU-stack,"",%progbits
-+	.previous
-+
- 	.set	nomips16
- 
- #define DIV								\
diff --git a/toolchain/gcc/patches-8.x/931-libffi-fix-MIPS-softfloat-build-issue.patch b/toolchain/gcc/patches-8.x/931-libffi-fix-MIPS-softfloat-build-issue.patch
deleted file mode 100644
index fb4cb153..00000000
--- a/toolchain/gcc/patches-8.x/931-libffi-fix-MIPS-softfloat-build-issue.patch
+++ /dev/null
@@ -1,168 +0,0 @@
-From c0c62fa4256f805389f16ebfc4a60cf789129b50 Mon Sep 17 00:00:00 2001
-From: BangLang Huang <banglang.huang@foxmail.com>
-Date: Wed, 9 Nov 2016 10:36:49 +0800
-Subject: [PATCH] libffi: fix MIPS softfloat build issue
-
-Backported from github.com/libffi/libffi#272
-
-Signed-off-by: BangLang Huang <banglang.huang@foxmail.com>
-Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
----
- libffi/src/mips/n32.S | 17 +++++++++++++++++
- libffi/src/mips/o32.S | 17 +++++++++++++++++
- 2 files changed, 34 insertions(+)
-
---- a/libffi/src/mips/n32.S
-+++ b/libffi/src/mips/n32.S
-@@ -107,6 +107,16 @@ loadregs:
- 
- 	REG_L	t6, 3*FFI_SIZEOF_ARG($fp)  # load the flags word into t6.
- 
-+#ifdef __mips_soft_float
-+	REG_L	a0, 0*FFI_SIZEOF_ARG(t9)
-+	REG_L	a1, 1*FFI_SIZEOF_ARG(t9)
-+	REG_L	a2, 2*FFI_SIZEOF_ARG(t9)
-+	REG_L	a3, 3*FFI_SIZEOF_ARG(t9)
-+	REG_L	a4, 4*FFI_SIZEOF_ARG(t9)
-+	REG_L	a5, 5*FFI_SIZEOF_ARG(t9)
-+	REG_L	a6, 6*FFI_SIZEOF_ARG(t9)
-+	REG_L	a7, 7*FFI_SIZEOF_ARG(t9)
-+#else
- 	and	t4, t6, ((1<<FFI_FLAG_BITS)-1)
- 	REG_L	a0, 0*FFI_SIZEOF_ARG(t9)
- 	beqz	t4, arg1_next
-@@ -193,6 +203,7 @@ arg7_next:
- arg8_doublep:	
-  	l.d	$f19, 7*FFI_SIZEOF_ARG(t9)	
- arg8_next:	
-+#endif
- 
- callit:		
- 	# Load the function pointer
-@@ -214,6 +225,7 @@ retint:
- 	b	epilogue
- 
- retfloat:
-+#ifndef __mips_soft_float
- 	bne     t6, FFI_TYPE_FLOAT, retdouble
- 	jal	t9
- 	REG_L	t4, 4*FFI_SIZEOF_ARG($fp)
-@@ -272,6 +284,7 @@ retstruct_f_d:
- 	s.s	$f0, 0(t4)
- 	s.d	$f2, 8(t4)
- 	b	epilogue
-+#endif
- 
- retstruct_d_soft:
- 	bne	t6, FFI_TYPE_STRUCT_D_SOFT, retstruct_f_soft
-@@ -429,6 +442,7 @@ ffi_closure_N32:
- 	REG_S	a6, A6_OFF2($sp)
- 	REG_S	a7, A7_OFF2($sp)
- 
-+#ifndef __mips_soft_float
- 	# Store all possible float/double registers.
- 	s.d	$f12, F12_OFF2($sp)
- 	s.d	$f13, F13_OFF2($sp)
-@@ -438,6 +452,7 @@ ffi_closure_N32:
- 	s.d	$f17, F17_OFF2($sp)
- 	s.d	$f18, F18_OFF2($sp)
- 	s.d	$f19, F19_OFF2($sp)
-+#endif
- 
- 	# Call ffi_closure_mips_inner_N32 to do the real work.
- 	LA	t9, ffi_closure_mips_inner_N32
-@@ -458,6 +473,7 @@ cls_retint:
- 	b	cls_epilogue
- 
- cls_retfloat:
-+#ifndef __mips_soft_float
- 	bne     v0, FFI_TYPE_FLOAT, cls_retdouble
- 	l.s	$f0, V0_OFF2($sp)
- 	b	cls_epilogue
-@@ -500,6 +516,7 @@ cls_retstruct_f_d:
- 	l.s	$f0, V0_OFF2($sp)
- 	l.d	$f2, V1_OFF2($sp)
- 	b	cls_epilogue
-+#endif
- 	
- cls_retstruct_small2:	
- 	REG_L	v0, V0_OFF2($sp)
---- a/libffi/src/mips/o32.S
-+++ b/libffi/src/mips/o32.S
-@@ -82,13 +82,16 @@ sixteen:
- 		
- 	ADDU	$sp, 4 * FFI_SIZEOF_ARG		# adjust $sp to new args
- 
-+#ifndef __mips_soft_float
- 	bnez	t0, pass_d			# make it quick for int
-+#endif
- 	REG_L	a0, 0*FFI_SIZEOF_ARG($sp)	# just go ahead and load the
- 	REG_L	a1, 1*FFI_SIZEOF_ARG($sp)	# four regs.
- 	REG_L	a2, 2*FFI_SIZEOF_ARG($sp)
- 	REG_L	a3, 3*FFI_SIZEOF_ARG($sp)
- 	b	call_it
- 
-+#ifndef __mips_soft_float
- pass_d:
- 	bne	t0, FFI_ARGS_D, pass_f
- 	l.d	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
-@@ -130,6 +133,7 @@ pass_f_d:
-  #	bne	t0, FFI_ARGS_F_D, call_it
- 	l.s	$f12, 0*FFI_SIZEOF_ARG($sp)	# load $fp regs from args
- 	l.d	$f14, 2*FFI_SIZEOF_ARG($sp)	# passing double and float
-+#endif
- 
- call_it:	
- 	# Load the function pointer
-@@ -158,14 +162,23 @@ retfloat:
- 	bne     t2, FFI_TYPE_FLOAT, retdouble
- 	jalr	t9
- 	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
-+#ifndef __mips_soft_float
- 	s.s	$f0, 0(t0)
-+#else
-+	REG_S v0, 0(t0)
-+#endif
- 	b	epilogue
- 
- retdouble:	
- 	bne	t2, FFI_TYPE_DOUBLE, noretval
- 	jalr	t9
- 	REG_L	t0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)
-+#ifndef __mips_soft_float
- 	s.d	$f0, 0(t0)
-+#else
-+	REG_S v1, 4(t0)
-+	REG_S v0, 0(t0)
-+#endif
- 	b	epilogue
- 	
- noretval:	
-@@ -261,9 +274,11 @@ $LCFI7:
- 	li	$13, 1		# FFI_O32
- 	bne	$16, $13, 1f	# Skip fp save if FFI_O32_SOFT_FLOAT
- 	
-+#ifndef __mips_soft_float
- 	# Store all possible float/double registers.
- 	s.d	$f12, FA_0_0_OFF2($fp)
- 	s.d	$f14, FA_1_0_OFF2($fp)
-+#endif
- 1:	
- 	# Call ffi_closure_mips_inner_O32 to do the work.
- 	la	t9, ffi_closure_mips_inner_O32
-@@ -281,6 +296,7 @@ $LCFI7:
- 	li	$13, 1		# FFI_O32
- 	bne	$16, $13, 1f	# Skip fp restore if FFI_O32_SOFT_FLOAT
- 
-+#ifndef __mips_soft_float
- 	li	$9, FFI_TYPE_FLOAT
- 	l.s	$f0, V0_OFF2($fp)
- 	beq	$8, $9, closure_done
-@@ -288,6 +304,7 @@ $LCFI7:
- 	li	$9, FFI_TYPE_DOUBLE
- 	l.d	$f0, V0_OFF2($fp)
- 	beq	$8, $9, closure_done
-+#endif
- 1:	
- 	REG_L	$3, V1_OFF2($fp)
- 	REG_L	$2, V0_OFF2($fp)
diff --git a/toolchain/gcc/patches-8.x/960-gotools-fix-compilation-when-making-cross-compiler.patch b/toolchain/gcc/patches-8.x/960-gotools-fix-compilation-when-making-cross-compiler.patch
deleted file mode 100644
index 1dd05080..00000000
--- a/toolchain/gcc/patches-8.x/960-gotools-fix-compilation-when-making-cross-compiler.patch
+++ /dev/null
@@ -1,67 +0,0 @@
-From dda6b050cd74a352670787a294596a9c56c21327 Mon Sep 17 00:00:00 2001
-From: Yousong Zhou <yszhou4tech@gmail.com>
-Date: Fri, 4 May 2018 18:20:53 +0800
-Subject: [PATCH] gotools: fix compilation when making cross compiler
-
-libgo is "the runtime support library for the Go programming language.
-This library is intended for use with the Go frontend."
-
-gccgo will link target files with libgo.so which depends on libgcc_s.so.1, but
-the linker will complain that it cannot find it.  That's because shared libgcc
-is not present in the install directory yet.  libgo.so was made without problem
-because gcc will emit -lgcc_s when compiled with -shared option.  When gotools
-were being made, it was supplied with -static-libgcc thus no link option was
-provided.  Check LIBGO in gcc/go/gcc-spec.c for how gccgo make a builtin spec
-for linking with libgo.so
-
-- GccgoCrossCompilation, https://github.com/golang/go/wiki/GccgoCrossCompilation
-- Cross-building instructions, http://www.eglibc.org/archives/patches/msg00078.html
-
-When 3-pass GCC compilation is used, shared libgcc runtime libraries will be
-available after gcc pass2 completed and will meet the gotools link requirement
-at gcc pass3
----
- gotools/Makefile.am | 4 +++-
- gotools/Makefile.in | 4 +++-
- 2 files changed, 6 insertions(+), 2 deletions(-)
-
---- a/gotools/Makefile.am
-+++ b/gotools/Makefile.am
-@@ -26,6 +26,7 @@ PWD_COMMAND = $${PWDCMD-pwd}
- STAMP = echo timestamp >
- 
- libgodir = ../$(target_noncanonical)/libgo
-+libgccdir = ../$(target_noncanonical)/libgcc
- LIBGODEP = $(libgodir)/libgo.la
- 
- LIBGOTOOL = $(libgodir)/libgotool.a
-@@ -41,7 +42,8 @@ GOCFLAGS = $(CFLAGS_FOR_TARGET)
- GOCOMPILE = $(GOCOMPILER) $(GOCFLAGS)
- 
- AM_GOCFLAGS = -I $(libgodir)
--AM_LDFLAGS = -L $(libgodir) -L $(libgodir)/.libs
-+AM_LDFLAGS = -L $(libgodir) -L $(libgodir)/.libs \
-+	-L $(libgccdir) -L $(libgccdir)/.libs -lgcc_s
- GOLINK = $(GOCOMPILER) $(GOCFLAGS) $(AM_GOCFLAGS) $(LDFLAGS) $(AM_LDFLAGS) -o $@
- 
- libgosrcdir = $(srcdir)/../libgo/go
---- a/gotools/Makefile.in
-+++ b/gotools/Makefile.in
-@@ -263,6 +263,7 @@ mkinstalldirs = $(SHELL) $(toplevel_srcd
- PWD_COMMAND = $${PWDCMD-pwd}
- STAMP = echo timestamp >
- libgodir = ../$(target_noncanonical)/libgo
-+libgccdir = ../$(target_noncanonical)/libgcc
- LIBGODEP = $(libgodir)/libgo.la
- LIBGOTOOL = $(libgodir)/libgotool.a
- @NATIVE_FALSE@GOCOMPILER = $(GOC)
-@@ -271,7 +272,8 @@ LIBGOTOOL = $(libgodir)/libgotool.a
- @NATIVE_TRUE@GOCOMPILER = $(GOC_FOR_TARGET) $(XGCC_FLAGS_FOR_TARGET)
- GOCOMPILE = $(GOCOMPILER) $(GOCFLAGS)
- AM_GOCFLAGS = -I $(libgodir)
--AM_LDFLAGS = -L $(libgodir) -L $(libgodir)/.libs
-+AM_LDFLAGS = -L $(libgodir) -L $(libgodir)/.libs \
-+	-L $(libgccdir) -L $(libgccdir)/.libs -lgcc_s
- GOLINK = $(GOCOMPILER) $(GOCFLAGS) $(AM_GOCFLAGS) $(LDFLAGS) $(AM_LDFLAGS) -o $@
- libgosrcdir = $(srcdir)/../libgo/go
- cmdsrcdir = $(libgosrcdir)/cmd
diff --git a/toolchain/gcc/patches-8.x/999-fix-apple-silicon-support.patch b/toolchain/gcc/patches-8.x/999-fix-apple-silicon-support.patch
deleted file mode 100644
index 5e8d84f3..00000000
--- a/toolchain/gcc/patches-8.x/999-fix-apple-silicon-support.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-diff -ru a/gcc/config/host-darwin.c b/gcc/config/host-darwin.c
---- a/gcc/config/host-darwin.c	2021-05-14 10:42:08.000000000 +0200
-+++ b/gcc/config/host-darwin.c	2021-08-07 22:51:11.000000000 +0200
-@@ -22,6 +22,8 @@
- #include "coretypes.h"
- #include "diagnostic-core.h"
- #include "config/host-darwin.h"
-+#include "hosthooks.h"
-+#include "hosthooks-def.h"
- 
- /* Yes, this is really supposed to work.  */
- static char pch_address_space[1024*1024*1024] __attribute__((aligned (4096)));
-@@ -75,3 +77,5 @@
- 
-   return ret;
- }
-+
-+const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;
-diff -ru a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
---- a/gcc/config/aarch64/aarch64.h  2021-05-14 10:42:08.000000000 +0200
-+++ b/gcc/config/aarch64/aarch64.h  2021-08-10 00:54:13.000000000 +0200
-@@ -1013,7 +1013,7 @@
- #define MCPU_TO_MARCH_SPEC_FUNCTIONS \
-   { "rewrite_mcpu", aarch64_rewrite_mcpu },
- 
--#if defined(__aarch64__)
-+#if defined(__aarch64__) && ! defined(__APPLE__)
- extern const char *host_detect_local_cpu (int argc, const char **argv);
- #define HAVE_LOCAL_CPU_DETECT
- # define EXTRA_SPEC_FUNCTIONS                  \
\ No newline at end of file
diff --git a/tools/dwarves/Makefile b/tools/dwarves/Makefile
index bcb16dd3..53461267 100644
--- a/tools/dwarves/Makefile
+++ b/tools/dwarves/Makefile
@@ -3,12 +3,12 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=dwarves
-PKG_VERSION:=1.27
+PKG_VERSION:=1.28
 PKG_RELEASE:=1
 
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
 PKG_SOURCE_URL:=https://fedorapeople.org/~acme/dwarves/
-PKG_HASH:=ef7f21f1c6016896d03a01f05cab225151f9068e19cc8cddc6e754b2b5cbe279
+PKG_HASH:=826efc0fc9237d3c1e9c01553ea387a8cb46e8dc119ff863889043f4ed54b2ae
 
 PKG_MAINTAINER:=Tony Ambardar <itugrok@yahoo.com>
 PKG_LICENSE:=GPL-2.0-only
diff --git a/tools/dwarves/patches/100-reproducible-builds.patch b/tools/dwarves/patches/100-reproducible-builds.patch
index 15bddd56..d8cbd114 100644
--- a/tools/dwarves/patches/100-reproducible-builds.patch
+++ b/tools/dwarves/patches/100-reproducible-builds.patch
@@ -1,6 +1,6 @@
 --- a/pahole.c
 +++ b/pahole.c
-@@ -3723,6 +3723,9 @@ int main(int argc, char *argv[])
+@@ -3681,6 +3681,9 @@ int main(int argc, char *argv[])
  		goto out;
  	}
  
